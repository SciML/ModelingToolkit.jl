<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Code generation utilities · ModelingToolkit.jl</title><meta name="title" content="Code generation utilities · ModelingToolkit.jl"/><meta property="og:title" content="Code generation utilities · ModelingToolkit.jl"/><meta property="twitter:title" content="Code generation utilities · ModelingToolkit.jl"/><meta name="description" content="Documentation for ModelingToolkit.jl."/><meta property="og:description" content="Documentation for ModelingToolkit.jl."/><meta property="twitter:description" content="Documentation for ModelingToolkit.jl."/><meta property="og:url" content="https://docs.sciml.ai/ModelingToolkit/stable/API/codegen/"/><meta property="twitter:url" content="https://docs.sciml.ai/ModelingToolkit/stable/API/codegen/"/><link rel="canonical" href="https://docs.sciml.ai/ModelingToolkit/stable/API/codegen/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="ModelingToolkit.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">ModelingToolkit.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../tutorials/ode_modeling/">Getting Started with ModelingToolkit.jl</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/acausal_components/">Acausal Component-Based Modeling</a></li><li><a class="tocitem" href="../../tutorials/nonlinear/">Modeling Nonlinear Systems</a></li><li><a class="tocitem" href="../../tutorials/initialization/">Initialization of Systems</a></li><li><a class="tocitem" href="../../tutorials/optimization/">Modeling Optimization Problems</a></li><li><a class="tocitem" href="../../tutorials/modelingtoolkitize/">Modelingtoolkitize: Automatically Translating Numerical to Symbolic Code</a></li><li><a class="tocitem" href="../../tutorials/programmatically_generating/">Programmatically Generating and Scripting Systems</a></li><li><a class="tocitem" href="../../tutorials/stochastic_diffeq/">Modeling with Stochasticity</a></li><li><a class="tocitem" href="../../tutorials/dynamic_optimization/">Solving Dynamic Optimization Problems</a></li><li><a class="tocitem" href="../../tutorials/discrete_system/">(Experimental) Modeling Discrete Systems</a></li><li><a class="tocitem" href="../../tutorials/parameter_identifiability/">Parameter Identifiability in ODE Models</a></li><li><a class="tocitem" href="../../tutorials/change_independent_variable/">Changing the independent variable of ODEs</a></li><li><a class="tocitem" href="../../tutorials/bifurcation_diagram_computation/">Bifurcation Diagrams</a></li><li><a class="tocitem" href="../../tutorials/attractors/">Multi- and Nonlocal- Continuation</a></li><li><a class="tocitem" href="../../tutorials/SampledData/">Clocks and Sampled-Data Systems</a></li><li><a class="tocitem" href="../../tutorials/domain_connections/">Domains</a></li><li><a class="tocitem" href="../../tutorials/callable_params/">Callable parameters and interpolating data</a></li><li><a class="tocitem" href="../../tutorials/linear_analysis/">Linear Analysis</a></li><li><a class="tocitem" href="../../tutorials/disturbance_modeling/">Disturbance and input modeling modeling</a></li><li><a class="tocitem" href="../../tutorials/fmi/">Importing FMUs</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><input class="collapse-toggle" id="menuitem-4-1" type="checkbox"/><label class="tocitem" for="menuitem-4-1"><span class="docs-label">Basic Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/higher_order/">Automatic Transformation of Nth Order ODEs to 1st Order ODEs</a></li><li><a class="tocitem" href="../../examples/spring_mass/">Component-Based Modeling of a Spring-Mass System</a></li><li><a class="tocitem" href="../../examples/modelingtoolkitize_index_reduction/">Automated Index Reduction of DAEs</a></li><li><a class="tocitem" href="../../examples/remake/">Optimizing through an ODE solve and re-creating MTK Problems</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-2" type="checkbox"/><label class="tocitem" for="menuitem-4-2"><span class="docs-label">Advanced Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/tearing_parallelism/">Exposing More Parallelism By Tearing Algebraic Equations in Systems</a></li><li><a class="tocitem" href="../../examples/sparse_jacobians/">Automated Sparse Analytical Jacobians</a></li><li><a class="tocitem" href="../../examples/perturbation/">Symbolic-Numeric Perturbation Theory for ODEs</a></li></ul></li></ul></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../System/">The <code>System</code> type</a></li><li><a class="tocitem" href="../variables/">Symbolic variables and variable metadata</a></li><li><a class="tocitem" href="../model_building/">Model building reference</a></li><li><a class="tocitem" href="../problems/">Building and solving numerical problems</a></li><li><a class="tocitem" href="../dynamic_opt/">Dynamic Optimization Solvers</a></li><li class="is-active"><a class="tocitem" href>Code generation utilities</a></li><li><a class="tocitem" href="../PDESystem/">PDESystem</a></li></ul></li><li><span class="tocitem">Basics</span><ul><li><a class="tocitem" href="../../basics/Composition/">Composing Models and Building Reusable Components</a></li><li><a class="tocitem" href="../../basics/Events/">Event Handling and Callback Functions</a></li><li><a class="tocitem" href="../../basics/Linearization/">Linearization</a></li><li><a class="tocitem" href="../../basics/InputOutput/">Input output</a></li><li><a class="tocitem" href="../../basics/MTKLanguage/">ModelingToolkit Language: Modeling with <code>@mtkmodel</code>, <code>@connectors</code> and <code>@mtkcompile</code></a></li><li><a class="tocitem" href="../../basics/Validation/">Model Validation and Units</a></li><li><a class="tocitem" href="../../basics/Debugging/">Debugging</a></li><li><a class="tocitem" href="../../basics/DependencyGraphs/">Dependency Graphs</a></li><li><a class="tocitem" href="../../basics/Precompilation/">Working with Precompilation and Binary Building</a></li><li><a class="tocitem" href="../../basics/FAQ/">Frequently Asked Questions</a></li></ul></li><li><a class="tocitem" href="../../comparison/">Comparison of ModelingToolkit vs Equation-Based and Block Modeling Languages</a></li><li><a class="tocitem" href="../../internals/">Internal Details</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API</a></li><li class="is-active"><a href>Code generation utilities</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Code generation utilities</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SciML/ModelingToolkit.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SciML/ModelingToolkit.jl/blob/master/docs/src/API/codegen.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Code-generation-utilities"><a class="docs-heading-anchor" href="#Code-generation-utilities">Code generation utilities</a><a id="Code-generation-utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Code-generation-utilities" title="Permalink"></a></h1><p>These are lower-level functions that ModelingToolkit leverages to generate code for building numerical problems.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.generate_rhs" href="#ModelingToolkit.generate_rhs"><code>ModelingToolkit.generate_rhs</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">generate_rhs(
    sys::System;
    implicit_dae,
    scalar,
    expression,
    wrap_gfw,
    eval_expression,
    eval_module,
    override_discrete,
    kwargs...
) -&gt; Union{Expr, Tuple{Expr, Expr}}
</code></pre><p>Generate the RHS function for the <a href="../System/#ModelingToolkit.equations"><code>equations</code></a> of a <a href="../System/#ModelingToolkit.System"><code>System</code></a>.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>expression</code>: <code>Val{true}</code> if this should return an <code>Expr</code> (or tuple of <code>Expr</code>s) of the generated code. <code>Val{false}</code> otherwise.</li><li><code>wrap_gfw</code>: <code>Val{true}</code> if the returned functions should be wrapped in a callable struct to make them callable using the expected syntax. The callable struct itself is internal API. If <code>expression == Val{true}</code>, the returned expression will construct the callable struct. If this function returns a tuple of functions/expressions, both will be identical if <code>wrap_gfw == Val{true}</code>.</li><li><code>eval_expression</code>: Whether to compile any functions via <code>eval</code> or <code>RuntimeGeneratedFunctions</code>.</li><li><code>eval_module</code>: If <code>eval_expression == true</code>, the module to <code>eval</code> into. Otherwise, the module in which to generate the <code>RuntimeGeneratedFunction</code>.</li></ul><ul><li><code>implicit_dae</code>: Whether the generated function should be in the implicit form. Applicable only for ODEs/DAEs or discrete systems. Instead of <code>f(u, p, t)</code> (<code>f(du, u, p, t)</code> for the in-place form) the function is <code>f(du, u, p, t)</code> (respectively <code>f(resid, du, u, p, t)</code>).</li><li><code>override_discrete</code>: Whether to assume the system is discrete regardless of <code>is_discrete_system(sys)</code>.</li><li><code>scalar</code>: Whether to generate a single-out-of-place function that returns a scalar for the only equation in the system.</li></ul><p>All other keyword arguments are forwarded to <a href="@ref"><code>build_function_wrapper</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/0aad5b471cd3c9822fdad67a713907e0fd73ed87/src/systems/codegen.jl#L12-L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.generate_diffusion_function" href="#ModelingToolkit.generate_diffusion_function"><code>ModelingToolkit.generate_diffusion_function</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">generate_diffusion_function(
    sys::System;
    expression,
    wrap_gfw,
    eval_expression,
    eval_module,
    kwargs...
) -&gt; Any
</code></pre><p>Generate the diffusion function for the noise equations of a <a href="../System/#ModelingToolkit.System"><code>System</code></a>.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>expression</code>: <code>Val{true}</code> if this should return an <code>Expr</code> (or tuple of <code>Expr</code>s) of the generated code. <code>Val{false}</code> otherwise.</li><li><code>wrap_gfw</code>: <code>Val{true}</code> if the returned functions should be wrapped in a callable struct to make them callable using the expected syntax. The callable struct itself is internal API. If <code>expression == Val{true}</code>, the returned expression will construct the callable struct. If this function returns a tuple of functions/expressions, both will be identical if <code>wrap_gfw == Val{true}</code>.</li><li><code>eval_expression</code>: Whether to compile any functions via <code>eval</code> or <code>RuntimeGeneratedFunctions</code>.</li><li><code>eval_module</code>: If <code>eval_expression == true</code>, the module to <code>eval</code> into. Otherwise, the module in which to generate the <code>RuntimeGeneratedFunction</code>.</li></ul><p>All other keyword arguments are forwarded to <a href="@ref"><code>build_function_wrapper</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/0aad5b471cd3c9822fdad67a713907e0fd73ed87/src/systems/codegen.jl#L107-L117">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.generate_jacobian" href="#ModelingToolkit.generate_jacobian"><code>ModelingToolkit.generate_jacobian</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">generate_jacobian(
    sys::System;
    simplify,
    sparse,
    eval_expression,
    eval_module,
    expression,
    wrap_gfw,
    kwargs...
) -&gt; Union{Expr, Tuple{Expr, Expr}}
</code></pre><p>Generate the jacobian function for the equations of a <a href="../System/#ModelingToolkit.System"><code>System</code></a>.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>expression</code>: <code>Val{true}</code> if this should return an <code>Expr</code> (or tuple of <code>Expr</code>s) of the generated code. <code>Val{false}</code> otherwise.</li><li><code>wrap_gfw</code>: <code>Val{true}</code> if the returned functions should be wrapped in a callable struct to make them callable using the expected syntax. The callable struct itself is internal API. If <code>expression == Val{true}</code>, the returned expression will construct the callable struct. If this function returns a tuple of functions/expressions, both will be identical if <code>wrap_gfw == Val{true}</code>.</li><li><code>eval_expression</code>: Whether to compile any functions via <code>eval</code> or <code>RuntimeGeneratedFunctions</code>.</li><li><code>eval_module</code>: If <code>eval_expression == true</code>, the module to <code>eval</code> into. Otherwise, the module in which to generate the <code>RuntimeGeneratedFunction</code>.</li></ul><ul><li><code>simplify</code>, <code>sparse</code>: Forwarded to <a href="#ModelingToolkit.calculate_jacobian"><code>calculate_jacobian</code></a>.</li></ul><p>All other keyword arguments are forwarded to <a href="@ref"><code>build_function_wrapper</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/0aad5b471cd3c9822fdad67a713907e0fd73ed87/src/systems/codegen.jl#L201-L212">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.generate_tgrad" href="#ModelingToolkit.generate_tgrad"><code>ModelingToolkit.generate_tgrad</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">generate_tgrad(
    sys::System;
    simplify,
    eval_expression,
    eval_module,
    expression,
    wrap_gfw,
    kwargs...
) -&gt; Union{Expr, Tuple{Expr, Expr}}
</code></pre><p>Generate the tgrad function for the equations of a <a href="../System/#ModelingToolkit.System"><code>System</code></a>.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>expression</code>: <code>Val{true}</code> if this should return an <code>Expr</code> (or tuple of <code>Expr</code>s) of the generated code. <code>Val{false}</code> otherwise.</li><li><code>wrap_gfw</code>: <code>Val{true}</code> if the returned functions should be wrapped in a callable struct to make them callable using the expected syntax. The callable struct itself is internal API. If <code>expression == Val{true}</code>, the returned expression will construct the callable struct. If this function returns a tuple of functions/expressions, both will be identical if <code>wrap_gfw == Val{true}</code>.</li><li><code>eval_expression</code>: Whether to compile any functions via <code>eval</code> or <code>RuntimeGeneratedFunctions</code>.</li><li><code>eval_module</code>: If <code>eval_expression == true</code>, the module to <code>eval</code> into. Otherwise, the module in which to generate the <code>RuntimeGeneratedFunction</code>.</li></ul><ul><li><code>simplify</code>: Forwarded to <a href="#ModelingToolkit.calculate_tgrad"><code>calculate_tgrad</code></a>.</li></ul><p>All other keyword arguments are forwarded to <a href="@ref"><code>build_function_wrapper</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/0aad5b471cd3c9822fdad67a713907e0fd73ed87/src/systems/codegen.jl#L248-L259">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.generate_W" href="#ModelingToolkit.generate_W"><code>ModelingToolkit.generate_W</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">generate_W(
    sys::System;
    simplify,
    sparse,
    expression,
    wrap_gfw,
    eval_expression,
    eval_module,
    kwargs...
) -&gt; Union{Expr, Tuple{Expr, Expr}}
</code></pre><p>Generate the <code>W = γ * M + J</code> function for the equations of a <a href="../System/#ModelingToolkit.System"><code>System</code></a>.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>expression</code>: <code>Val{true}</code> if this should return an <code>Expr</code> (or tuple of <code>Expr</code>s) of the generated code. <code>Val{false}</code> otherwise.</li><li><code>wrap_gfw</code>: <code>Val{true}</code> if the returned functions should be wrapped in a callable struct to make them callable using the expected syntax. The callable struct itself is internal API. If <code>expression == Val{true}</code>, the returned expression will construct the callable struct. If this function returns a tuple of functions/expressions, both will be identical if <code>wrap_gfw == Val{true}</code>.</li><li><code>eval_expression</code>: Whether to compile any functions via <code>eval</code> or <code>RuntimeGeneratedFunctions</code>.</li><li><code>eval_module</code>: If <code>eval_expression == true</code>, the module to <code>eval</code> into. Otherwise, the module in which to generate the <code>RuntimeGeneratedFunction</code>.</li></ul><ul><li><code>simplify</code>, <code>sparse</code>: Forwarded to <a href="#ModelingToolkit.calculate_jacobian"><code>calculate_jacobian</code></a>.</li></ul><p>All other keyword arguments are forwarded to <a href="@ref"><code>build_function_wrapper</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/0aad5b471cd3c9822fdad67a713907e0fd73ed87/src/systems/codegen.jl#L316-L327">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.generate_dae_jacobian" href="#ModelingToolkit.generate_dae_jacobian"><code>ModelingToolkit.generate_dae_jacobian</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">generate_dae_jacobian(
    sys::System;
    simplify,
    sparse,
    expression,
    wrap_gfw,
    eval_expression,
    eval_module,
    kwargs...
) -&gt; Union{Expr, Tuple{Expr, Expr}}
</code></pre><p>Generate the DAE jacobian <code>γ * J′ + J</code> function for the equations of a <a href="../System/#ModelingToolkit.System"><code>System</code></a>. <code>J′</code> is the jacobian of the equations with respect to the <code>du</code> vector, and <code>J</code> is the standard jacobian.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>expression</code>: <code>Val{true}</code> if this should return an <code>Expr</code> (or tuple of <code>Expr</code>s) of the generated code. <code>Val{false}</code> otherwise.</li><li><code>wrap_gfw</code>: <code>Val{true}</code> if the returned functions should be wrapped in a callable struct to make them callable using the expected syntax. The callable struct itself is internal API. If <code>expression == Val{true}</code>, the returned expression will construct the callable struct. If this function returns a tuple of functions/expressions, both will be identical if <code>wrap_gfw == Val{true}</code>.</li><li><code>eval_expression</code>: Whether to compile any functions via <code>eval</code> or <code>RuntimeGeneratedFunctions</code>.</li><li><code>eval_module</code>: If <code>eval_expression == true</code>, the module to <code>eval</code> into. Otherwise, the module in which to generate the <code>RuntimeGeneratedFunction</code>.</li></ul><ul><li><code>simplify</code>, <code>sparse</code>: Forwarded to <a href="#ModelingToolkit.calculate_jacobian"><code>calculate_jacobian</code></a>.</li></ul><p>All other keyword arguments are forwarded to <a href="@ref"><code>build_function_wrapper</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/0aad5b471cd3c9822fdad67a713907e0fd73ed87/src/systems/codegen.jl#L351-L364">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.generate_history" href="#ModelingToolkit.generate_history"><code>ModelingToolkit.generate_history</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">generate_history(
    sys::System,
    u0;
    expression,
    wrap_gfw,
    eval_expression,
    eval_module,
    kwargs...
) -&gt; Union{Expr, Tuple{Expr, Expr}}
</code></pre><p>Generate the history function for a <a href="../System/#ModelingToolkit.System"><code>System</code></a>, given a symbolic representation of the <code>u0</code> vector prior to the initial time.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>expression</code>: <code>Val{true}</code> if this should return an <code>Expr</code> (or tuple of <code>Expr</code>s) of the generated code. <code>Val{false}</code> otherwise.</li><li><code>wrap_gfw</code>: <code>Val{true}</code> if the returned functions should be wrapped in a callable struct to make them callable using the expected syntax. The callable struct itself is internal API. If <code>expression == Val{true}</code>, the returned expression will construct the callable struct. If this function returns a tuple of functions/expressions, both will be identical if <code>wrap_gfw == Val{true}</code>.</li><li><code>eval_expression</code>: Whether to compile any functions via <code>eval</code> or <code>RuntimeGeneratedFunctions</code>.</li><li><code>eval_module</code>: If <code>eval_expression == true</code>, the module to <code>eval</code> into. Otherwise, the module in which to generate the <code>RuntimeGeneratedFunction</code>.</li></ul><p>All other keyword arguments are forwarded to <a href="@ref"><code>build_function_wrapper</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/0aad5b471cd3c9822fdad67a713907e0fd73ed87/src/systems/codegen.jl#L384-L395">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.generate_boundary_conditions" href="#ModelingToolkit.generate_boundary_conditions"><code>ModelingToolkit.generate_boundary_conditions</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">generate_boundary_conditions(
    sys::System,
    u0,
    u0_idxs,
    t0;
    expression,
    wrap_gfw,
    eval_expression,
    eval_module,
    kwargs...
) -&gt; Union{Expr, Tuple{Expr, Expr}}
</code></pre><p>Generate the boundary condition function for a <a href="../System/#ModelingToolkit.System"><code>System</code></a> given the state vector <code>u0</code>, the indexes of <code>u0</code> to consider as hard constraints <code>u0_idxs</code> and the initial time <code>t0</code>.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>expression</code>: <code>Val{true}</code> if this should return an <code>Expr</code> (or tuple of <code>Expr</code>s) of the generated code. <code>Val{false}</code> otherwise.</li><li><code>wrap_gfw</code>: <code>Val{true}</code> if the returned functions should be wrapped in a callable struct to make them callable using the expected syntax. The callable struct itself is internal API. If <code>expression == Val{true}</code>, the returned expression will construct the callable struct. If this function returns a tuple of functions/expressions, both will be identical if <code>wrap_gfw == Val{true}</code>.</li><li><code>eval_expression</code>: Whether to compile any functions via <code>eval</code> or <code>RuntimeGeneratedFunctions</code>.</li><li><code>eval_module</code>: If <code>eval_expression == true</code>, the module to <code>eval</code> into. Otherwise, the module in which to generate the <code>RuntimeGeneratedFunction</code>.</li></ul><p>All other keyword arguments are forwarded to <a href="@ref"><code>build_function_wrapper</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/0aad5b471cd3c9822fdad67a713907e0fd73ed87/src/systems/codegen.jl#L536-L547">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.generate_cost" href="#ModelingToolkit.generate_cost"><code>ModelingToolkit.generate_cost</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">generate_cost(
    sys::System;
    expression,
    wrap_gfw,
    eval_expression,
    eval_module,
    kwargs...
) -&gt; Any
</code></pre><p>Generate the cost function for a <a href="../System/#ModelingToolkit.System"><code>System</code></a>.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>expression</code>: <code>Val{true}</code> if this should return an <code>Expr</code> (or tuple of <code>Expr</code>s) of the generated code. <code>Val{false}</code> otherwise.</li><li><code>wrap_gfw</code>: <code>Val{true}</code> if the returned functions should be wrapped in a callable struct to make them callable using the expected syntax. The callable struct itself is internal API. If <code>expression == Val{true}</code>, the returned expression will construct the callable struct. If this function returns a tuple of functions/expressions, both will be identical if <code>wrap_gfw == Val{true}</code>.</li><li><code>eval_expression</code>: Whether to compile any functions via <code>eval</code> or <code>RuntimeGeneratedFunctions</code>.</li><li><code>eval_module</code>: If <code>eval_expression == true</code>, the module to <code>eval</code> into. Otherwise, the module in which to generate the <code>RuntimeGeneratedFunction</code>.</li></ul><p>All other keyword arguments are forwarded to <a href="@ref"><code>build_function_wrapper</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/0aad5b471cd3c9822fdad67a713907e0fd73ed87/src/systems/codegen.jl#L582-L592">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.generate_cost_gradient" href="#ModelingToolkit.generate_cost_gradient"><code>ModelingToolkit.generate_cost_gradient</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">generate_cost_gradient(
    sys::System;
    expression,
    wrap_gfw,
    eval_expression,
    eval_module,
    simplify,
    kwargs...
) -&gt; Union{Expr, Tuple{Expr, Expr}}
</code></pre><p>Generate the gradient of the cost function with respect to unknowns for a <a href="../System/#ModelingToolkit.System"><code>System</code></a>.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>expression</code>: <code>Val{true}</code> if this should return an <code>Expr</code> (or tuple of <code>Expr</code>s) of the generated code. <code>Val{false}</code> otherwise.</li><li><code>wrap_gfw</code>: <code>Val{true}</code> if the returned functions should be wrapped in a callable struct to make them callable using the expected syntax. The callable struct itself is internal API. If <code>expression == Val{true}</code>, the returned expression will construct the callable struct. If this function returns a tuple of functions/expressions, both will be identical if <code>wrap_gfw == Val{true}</code>.</li><li><code>eval_expression</code>: Whether to compile any functions via <code>eval</code> or <code>RuntimeGeneratedFunctions</code>.</li><li><code>eval_module</code>: If <code>eval_expression == true</code>, the module to <code>eval</code> into. Otherwise, the module in which to generate the <code>RuntimeGeneratedFunction</code>.</li></ul><ul><li><code>simplify</code>: Forwarded to <a href="#ModelingToolkit.calculate_cost_gradient"><code>calculate_cost_gradient</code></a>.</li></ul><p>All other keyword arguments are forwarded to <a href="@ref"><code>build_function_wrapper</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/0aad5b471cd3c9822fdad67a713907e0fd73ed87/src/systems/codegen.jl#L635-L646">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.generate_cost_hessian" href="#ModelingToolkit.generate_cost_hessian"><code>ModelingToolkit.generate_cost_hessian</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">generate_cost_hessian(
    sys::System;
    expression,
    wrap_gfw,
    eval_expression,
    eval_module,
    simplify,
    sparse,
    return_sparsity,
    kwargs...
) -&gt; Union{Tuple{Expr, Expr}, Tuple{Tuple{Expr, Expr}, Union{Nothing, SparseArrays.SparseMatrixCSC{Float64, Int64}, Matrix{Float64}}}}
</code></pre><p>Generate the hessian of the cost function for a <a href="../System/#ModelingToolkit.System"><code>System</code></a>.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>expression</code>: <code>Val{true}</code> if this should return an <code>Expr</code> (or tuple of <code>Expr</code>s) of the generated code. <code>Val{false}</code> otherwise.</li><li><code>wrap_gfw</code>: <code>Val{true}</code> if the returned functions should be wrapped in a callable struct to make them callable using the expected syntax. The callable struct itself is internal API. If <code>expression == Val{true}</code>, the returned expression will construct the callable struct. If this function returns a tuple of functions/expressions, both will be identical if <code>wrap_gfw == Val{true}</code>.</li><li><code>eval_expression</code>: Whether to compile any functions via <code>eval</code> or <code>RuntimeGeneratedFunctions</code>.</li><li><code>eval_module</code>: If <code>eval_expression == true</code>, the module to <code>eval</code> into. Otherwise, the module in which to generate the <code>RuntimeGeneratedFunction</code>.</li></ul><ul><li><code>simplify</code>, <code>sparse</code>: Forwarded to <a href="#ModelingToolkit.calculate_cost_hessian"><code>calculate_cost_hessian</code></a>.</li><li><code>return_sparsity</code>: Whether to also return the sparsity pattern of the hessian as the second return value.</li></ul><p>All other keyword arguments are forwarded to <a href="@ref"><code>build_function_wrapper</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/0aad5b471cd3c9822fdad67a713907e0fd73ed87/src/systems/codegen.jl#L686-L699">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.generate_cons" href="#ModelingToolkit.generate_cons"><code>ModelingToolkit.generate_cons</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">generate_cons(
    sys::System;
    expression,
    wrap_gfw,
    eval_expression,
    eval_module,
    kwargs...
) -&gt; Union{Expr, Tuple{Expr, Expr}}
</code></pre><p>Generate the constraint function for a <a href="../System/#ModelingToolkit.System"><code>System</code></a>.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>expression</code>: <code>Val{true}</code> if this should return an <code>Expr</code> (or tuple of <code>Expr</code>s) of the generated code. <code>Val{false}</code> otherwise.</li><li><code>wrap_gfw</code>: <code>Val{true}</code> if the returned functions should be wrapped in a callable struct to make them callable using the expected syntax. The callable struct itself is internal API. If <code>expression == Val{true}</code>, the returned expression will construct the callable struct. If this function returns a tuple of functions/expressions, both will be identical if <code>wrap_gfw == Val{true}</code>.</li><li><code>eval_expression</code>: Whether to compile any functions via <code>eval</code> or <code>RuntimeGeneratedFunctions</code>.</li><li><code>eval_module</code>: If <code>eval_expression == true</code>, the module to <code>eval</code> into. Otherwise, the module in which to generate the <code>RuntimeGeneratedFunction</code>.</li></ul><p>All other keyword arguments are forwarded to <a href="@ref"><code>build_function_wrapper</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/0aad5b471cd3c9822fdad67a713907e0fd73ed87/src/systems/codegen.jl#L725-L735">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.generate_constraint_jacobian" href="#ModelingToolkit.generate_constraint_jacobian"><code>ModelingToolkit.generate_constraint_jacobian</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">generate_constraint_jacobian(
    sys::System;
    expression,
    wrap_gfw,
    eval_expression,
    eval_module,
    return_sparsity,
    simplify,
    sparse,
    kwargs...
) -&gt; Union{Expr, Tuple{Union{Expr, Tuple{Expr, Expr}}, Any}}
</code></pre><p>Generate the jacobian of the constraint function for a <a href="../System/#ModelingToolkit.System"><code>System</code></a>.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>expression</code>: <code>Val{true}</code> if this should return an <code>Expr</code> (or tuple of <code>Expr</code>s) of the generated code. <code>Val{false}</code> otherwise.</li><li><code>wrap_gfw</code>: <code>Val{true}</code> if the returned functions should be wrapped in a callable struct to make them callable using the expected syntax. The callable struct itself is internal API. If <code>expression == Val{true}</code>, the returned expression will construct the callable struct. If this function returns a tuple of functions/expressions, both will be identical if <code>wrap_gfw == Val{true}</code>.</li><li><code>eval_expression</code>: Whether to compile any functions via <code>eval</code> or <code>RuntimeGeneratedFunctions</code>.</li><li><code>eval_module</code>: If <code>eval_expression == true</code>, the module to <code>eval</code> into. Otherwise, the module in which to generate the <code>RuntimeGeneratedFunction</code>.</li></ul><ul><li><code>simplify</code>, <code>sparse</code>: Forwarded to <a href="#ModelingToolkit.calculate_constraint_jacobian"><code>calculate_constraint_jacobian</code></a>.</li><li><code>return_sparsity</code>: Whether to also return the sparsity pattern of the jacobian as the second return value.</li></ul><p>All other keyword arguments are forwarded to <a href="@ref"><code>build_function_wrapper</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/0aad5b471cd3c9822fdad67a713907e0fd73ed87/src/systems/codegen.jl#L770-L783">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.generate_constraint_hessian" href="#ModelingToolkit.generate_constraint_hessian"><code>ModelingToolkit.generate_constraint_hessian</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">generate_constraint_hessian(
    sys::System;
    expression,
    wrap_gfw,
    eval_expression,
    eval_module,
    return_sparsity,
    simplify,
    sparse,
    kwargs...
) -&gt; Union{Expr, Tuple{Union{Expr, Tuple{Expr, Expr}}, Any}}
</code></pre><p>Generate the hessian of the constraint function for a <a href="../System/#ModelingToolkit.System"><code>System</code></a>.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>expression</code>: <code>Val{true}</code> if this should return an <code>Expr</code> (or tuple of <code>Expr</code>s) of the generated code. <code>Val{false}</code> otherwise.</li><li><code>wrap_gfw</code>: <code>Val{true}</code> if the returned functions should be wrapped in a callable struct to make them callable using the expected syntax. The callable struct itself is internal API. If <code>expression == Val{true}</code>, the returned expression will construct the callable struct. If this function returns a tuple of functions/expressions, both will be identical if <code>wrap_gfw == Val{true}</code>.</li><li><code>eval_expression</code>: Whether to compile any functions via <code>eval</code> or <code>RuntimeGeneratedFunctions</code>.</li><li><code>eval_module</code>: If <code>eval_expression == true</code>, the module to <code>eval</code> into. Otherwise, the module in which to generate the <code>RuntimeGeneratedFunction</code>.</li></ul><ul><li><code>simplify</code>, <code>sparse</code>: Forwarded to <a href="#ModelingToolkit.calculate_constraint_hessian"><code>calculate_constraint_hessian</code></a>.</li><li><code>return_sparsity</code>: Whether to also return the sparsity pattern of the hessian as the second return value.</li></ul><p>All other keyword arguments are forwarded to <a href="@ref"><code>build_function_wrapper</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/0aad5b471cd3c9822fdad67a713907e0fd73ed87/src/systems/codegen.jl#L825-L838">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.generate_control_jacobian" href="#ModelingToolkit.generate_control_jacobian"><code>ModelingToolkit.generate_control_jacobian</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">generate_control_jacobian(
    sys::ModelingToolkit.AbstractSystem;
    expression,
    wrap_gfw,
    eval_expression,
    eval_module,
    simplify,
    sparse,
    kwargs...
) -&gt; Union{Expr, Tuple{Expr, Expr}}
</code></pre><p>Generate the jacobian function of the equations of <code>sys</code> with respect to the inputs.</p><p><strong>Keyword arguments</strong></p><ul><li><code>expression</code>: <code>Val{true}</code> if this should return an <code>Expr</code> (or tuple of <code>Expr</code>s) of the generated code. <code>Val{false}</code> otherwise.</li><li><code>wrap_gfw</code>: <code>Val{true}</code> if the returned functions should be wrapped in a callable struct to make them callable using the expected syntax. The callable struct itself is internal API. If <code>expression == Val{true}</code>, the returned expression will construct the callable struct. If this function returns a tuple of functions/expressions, both will be identical if <code>wrap_gfw == Val{true}</code>.</li><li><code>eval_expression</code>: Whether to compile any functions via <code>eval</code> or <code>RuntimeGeneratedFunctions</code>.</li><li><code>eval_module</code>: If <code>eval_expression == true</code>, the module to <code>eval</code> into. Otherwise, the module in which to generate the <code>RuntimeGeneratedFunction</code>.</li></ul><ul><li><code>simplify</code>, <code>sparse</code>: Forwarded to <a href="#ModelingToolkit.calculate_constraint_hessian"><code>calculate_constraint_hessian</code></a>.</li></ul><p>All other keyword arguments are forwarded to <a href="@ref"><code>build_function_wrapper</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/0aad5b471cd3c9822fdad67a713907e0fd73ed87/src/systems/codegen.jl#L877-L888">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.build_explicit_observed_function" href="#ModelingToolkit.build_explicit_observed_function"><code>ModelingToolkit.build_explicit_observed_function</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">build_explicit_observed_function(sys, ts; kwargs...) -&gt; Function(s)</code></pre><p>Generates a function that computes the observed value(s) <code>ts</code> in the system <code>sys</code>, while making the assumption that there are no cycles in the equations.</p><p><strong>Arguments</strong></p><ul><li><code>sys</code>: The system for which to generate the function</li><li><code>ts</code>: The symbolic observed values whose value should be computed</li></ul><p><strong>Keywords</strong></p><ul><li><code>return_inplace = false</code>: If true and the observed value is a vector, then return both the in place and out of place methods.</li><li><code>expression = false</code>: Generates a Julia <code>Expr</code><code>computing the observed value if</code>expression` is true</li><li><code>eval_expression = false</code>: If true and <code>expression = false</code>, evaluates the returned function in the module <code>eval_module</code></li><li><code>output_type = Array</code> the type of the array generated by a out-of-place vector-valued function</li><li><code>param_only = false</code> if true, only allow the generated function to access system parameters</li><li><code>inputs = nothing</code> additinoal symbolic variables that should be provided to the generated function</li><li><code>checkbounds = true</code> checks bounds if true when destructuring parameters</li><li><code>op = Operator</code> sets the recursion terminator for the walk done by <code>vars</code> to identify the variables that appear in <code>ts</code>. See the documentation for <code>vars</code> for more detail.</li><li><code>throw = true</code> if true, throw an error when generating a function for <code>ts</code> that reference variables that do not exist.</li><li><code>mkarray</code>: only used if the output is an array (that is, <code>!isscalar(ts)</code>  and <code>ts</code> is not a tuple, in which case the result will always be a tuple). Called as <code>mkarray(ts, output_type)</code> where <code>ts</code> are the expressions to put in the array and <code>output_type</code> is the argument of the same name passed to build<em>explicit</em>observed_function.</li><li><code>cse = true</code>: Whether to use Common Subexpression Elimination (CSE) to generate a more efficient function.</li><li><code>wrap_delays = is_dde(sys)</code>: Whether to add an argument for the history function and use it to calculate all delayed variables.</li></ul><p><strong>Returns</strong></p><p>The return value will be either:</p><ul><li>a single function <code>f_oop</code> if the input is a scalar or if the input is a Vector but <code>return_inplace</code> is false</li><li>the out of place and in-place functions <code>(f_ip, f_oop)</code> if <code>return_inplace</code> is true and the input is a <code>Vector</code></li></ul><p>The function(s) <code>f_oop</code> (and potentially <code>f_ip</code>) will be:</p><ul><li><code>RuntimeGeneratedFunction</code>s by default,</li><li>A Julia <code>Expr</code> if <code>expression</code> is true,</li><li>A directly evaluated Julia function in the module <code>eval_module</code> if <code>eval_expression</code> is true and <code>expression</code> is false.</li></ul><p>The signatures will be of the form <code>g(...)</code> with arguments:</p><ul><li><code>output</code> for in-place functions</li><li><code>unknowns</code> if <code>param_only</code> is <code>false</code></li><li><code>inputs</code> if <code>inputs</code> is an array of symbolic inputs that should be available in <code>ts</code> </li><li><code>p...</code> unconditionally; note that in the case of <code>MTKParameters</code> more than one parameters argument may be present, so it must be splatted</li><li><code>t</code> if the system is time-dependent; for example systems of nonlinear equations will not have <code>t</code></li></ul><p>For example, a function <code>g(op, unknowns, p..., inputs, t)</code> will be the in-place function generated if <code>return_inplace</code> is true, <code>ts</code> is a vector,  an array of inputs <code>inputs</code> is given, and <code>param_only</code> is false for a time-dependent system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/0aad5b471cd3c9822fdad67a713907e0fd73ed87/src/systems/codegen.jl#L964-L1009">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.generate_control_function" href="#ModelingToolkit.generate_control_function"><code>ModelingToolkit.generate_control_function</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">generate_control_function(sys::ModelingToolkit.AbstractSystem, input_ap_name::Union{Symbol, Vector{Symbol}, AnalysisPoint, Vector{AnalysisPoint}}, dist_ap_name::Union{Symbol, Vector{Symbol}, AnalysisPoint, Vector{AnalysisPoint}}; system_modifier = identity, kwargs)</code></pre><p>When called with analysis points as input arguments, we assume that all analysis points corresponds to connections that should be opened (broken). The use case for this is to get rid of input signal blocks, such as <code>Step</code> or <code>Sine</code>, since these are useful for simulation but are not needed when using the plant model in a controller or state estimator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/0aad5b471cd3c9822fdad67a713907e0fd73ed87/src/systems/analysis_points.jl#L1067-L1071">source</a></section><section><div><pre><code class="language-julia hljs">(f_oop, f_ip), x_sym, p_sym, io_sys = generate_control_function(
        sys::System,
        inputs             = unbound_inputs(sys),
        disturbance_inputs = disturbances(sys);
        implicit_dae       = false,
        simplify           = false,
    )</code></pre><p>For a system <code>sys</code> with inputs (as determined by <a href="../System/#ModelingToolkit.unbound_inputs"><code>unbound_inputs</code></a> or user specified), generate functions with additional input argument <code>u</code></p><p>The returned functions are the out-of-place (<code>f_oop</code>) and in-place (<code>f_ip</code>) forms:</p><pre><code class="nohighlight hljs">f_oop : (x,u,p,t)      -&gt; rhs
f_ip  : (xout,x,u,p,t) -&gt; nothing</code></pre><p>The return values also include the chosen state-realization (the remaining unknowns) <code>x_sym</code> and parameters, in the order they appear as arguments to <code>f</code>.</p><p>If <code>disturbance_inputs</code> is an array of variables, the generated dynamics function will preserve any state and dynamics associated with disturbance inputs, but the disturbance inputs themselves will (by default) not be included as inputs to the generated function. The use case for this is to generate dynamics for state observers that estimate the influence of unmeasured disturbances, and thus require unknown variables for the disturbance model, but without disturbance inputs since the disturbances are not available for measurement. To add an input argument corresponding to the disturbance inputs, either include the disturbance inputs among the control inputs, or set <code>disturbance_argument=true</code>, in which case an additional input argument <code>w</code> is added to the generated function <code>(x,u,p,t,w)-&gt;rhs</code>.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">using ModelingToolkit: generate_control_function, varmap_to_vars, defaults
f, x_sym, ps = generate_control_function(sys, expression=Val{false}, simplify=false)
p = varmap_to_vars(defaults(sys), ps)
x = varmap_to_vars(defaults(sys), x_sym)
t = 0
f[1](x, inputs, p, t)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/0aad5b471cd3c9822fdad67a713907e0fd73ed87/src/inputoutput.jl#L162-L193">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.generate_update_A" href="#ModelingToolkit.generate_update_A"><code>ModelingToolkit.generate_update_A</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">generate_update_A(
    sys::System,
    A::AbstractMatrix;
    expression,
    wrap_gfw,
    eval_expression,
    eval_module,
    kwargs...
) -&gt; Union{Expr, Tuple{Expr, Expr}}
</code></pre><p>Given a system <code>sys</code> and the <code>A</code> from <a href="#ModelingToolkit.calculate_A_b"><code>calculate_A_b</code></a> generate the function that updates <code>A</code> given the parameter object.</p><p><strong>Keyword arguments</strong></p><ul><li><code>expression</code>: <code>Val{true}</code> if this should return an <code>Expr</code> (or tuple of <code>Expr</code>s) of the generated code. <code>Val{false}</code> otherwise.</li><li><code>wrap_gfw</code>: <code>Val{true}</code> if the returned functions should be wrapped in a callable struct to make them callable using the expected syntax. The callable struct itself is internal API. If <code>expression == Val{true}</code>, the returned expression will construct the callable struct. If this function returns a tuple of functions/expressions, both will be identical if <code>wrap_gfw == Val{true}</code>.</li><li><code>eval_expression</code>: Whether to compile any functions via <code>eval</code> or <code>RuntimeGeneratedFunctions</code>.</li><li><code>eval_module</code>: If <code>eval_expression == true</code>, the module to <code>eval</code> into. Otherwise, the module in which to generate the <code>RuntimeGeneratedFunction</code>.</li></ul><p>All other keyword arguments are forwarded to <a href="@ref"><code>build_function_wrapper</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/0aad5b471cd3c9822fdad67a713907e0fd73ed87/src/systems/codegen.jl#L1179-L1190">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.generate_update_b" href="#ModelingToolkit.generate_update_b"><code>ModelingToolkit.generate_update_b</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">generate_update_b(
    sys::System,
    b::AbstractVector;
    expression,
    wrap_gfw,
    eval_expression,
    eval_module,
    kwargs...
) -&gt; Union{Expr, Tuple{Expr, Expr}}
</code></pre><p>Given a system <code>sys</code> and the <code>b</code> from <a href="#ModelingToolkit.calculate_A_b"><code>calculate_A_b</code></a> generate the function that updates <code>b</code> given the parameter object.</p><p><strong>Keyword arguments</strong></p><ul><li><code>expression</code>: <code>Val{true}</code> if this should return an <code>Expr</code> (or tuple of <code>Expr</code>s) of the generated code. <code>Val{false}</code> otherwise.</li><li><code>wrap_gfw</code>: <code>Val{true}</code> if the returned functions should be wrapped in a callable struct to make them callable using the expected syntax. The callable struct itself is internal API. If <code>expression == Val{true}</code>, the returned expression will construct the callable struct. If this function returns a tuple of functions/expressions, both will be identical if <code>wrap_gfw == Val{true}</code>.</li><li><code>eval_expression</code>: Whether to compile any functions via <code>eval</code> or <code>RuntimeGeneratedFunctions</code>.</li><li><code>eval_module</code>: If <code>eval_expression == true</code>, the module to <code>eval</code> into. Otherwise, the module in which to generate the <code>RuntimeGeneratedFunction</code>.</li></ul><p>All other keyword arguments are forwarded to <a href="@ref"><code>build_function_wrapper</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/0aad5b471cd3c9822fdad67a713907e0fd73ed87/src/systems/codegen.jl#L1201-L1212">source</a></section></article><p>For functions such as jacobian calculation which require symbolic computation, there are <code>calculate_*</code> equivalents to obtain the symbolic result without building a function.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.calculate_tgrad" href="#ModelingToolkit.calculate_tgrad"><code>ModelingToolkit.calculate_tgrad</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">calculate_tgrad(sys::System; simplify) -&gt; Any
</code></pre><p>Calculate the gradient of the equations of <code>sys</code> with respect to the independent variable. <code>simplify</code> is forwarded to <code>Symbolics.expand_derivatives</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/0aad5b471cd3c9822fdad67a713907e0fd73ed87/src/systems/codegen.jl#L144-L149">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.calculate_jacobian" href="#ModelingToolkit.calculate_jacobian"><code>ModelingToolkit.calculate_jacobian</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">calculate_jacobian(
    sys::System;
    sparse,
    simplify,
    dvs
) -&gt; Any
</code></pre><p>Calculate the jacobian of the equations of <code>sys</code>.</p><p><strong>Keyword arguments</strong></p><ul><li><code>simplify</code>, <code>sparse</code>: Forwarded to <code>Symbolics.jacobian</code>.</li><li><code>dvs</code>: The variables with respect to which the jacobian should be computed.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/0aad5b471cd3c9822fdad67a713907e0fd73ed87/src/systems/codegen.jl#L165-L174">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Symbolics.jacobian_sparsity" href="#Symbolics.jacobian_sparsity"><code>Symbolics.jacobian_sparsity</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">jacobian_sparsity(
    sys::System
) -&gt; SparseArrays.SparseMatrixCSC{Bool, Int64}
</code></pre><p>Return the sparsity pattern of the jacobian of <code>sys</code> as a matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/0aad5b471cd3c9822fdad67a713907e0fd73ed87/src/systems/codegen.jl#L452-L456">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.jacobian_dae_sparsity" href="#ModelingToolkit.jacobian_dae_sparsity"><code>ModelingToolkit.jacobian_dae_sparsity</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">jacobian_dae_sparsity(
    sys::System
) -&gt; SparseArrays.SparseMatrixCSC{Int64, Int64}
</code></pre><p>Return the sparsity pattern of the DAE jacobian of <code>sys</code> as a matrix.</p><p>See also: <a href="#ModelingToolkit.generate_dae_jacobian"><code>generate_dae_jacobian</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/0aad5b471cd3c9822fdad67a713907e0fd73ed87/src/systems/codegen.jl#L465-L471">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.calculate_hessian" href="#ModelingToolkit.calculate_hessian"><code>ModelingToolkit.calculate_hessian</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">calculate_hessian(sys::System; simplify, sparse) -&gt; Any
</code></pre><p>Return an array of symbolic hessians corresponding to the equations of the system.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>sparse</code>: Controls whether the symbolic hessians are sparse matrices</li><li><code>simplify</code>: Forwarded to <code>Symbolics.hessian</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/0aad5b471cd3c9822fdad67a713907e0fd73ed87/src/systems/codegen.jl#L280-L289">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Symbolics.hessian_sparsity" href="#Symbolics.hessian_sparsity"><code>Symbolics.hessian_sparsity</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">hessian_sparsity(sys::System) -&gt; Any
</code></pre><p>Return the sparsity pattern of the hessian of the equations of <code>sys</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/0aad5b471cd3c9822fdad67a713907e0fd73ed87/src/systems/codegen.jl#L304-L308">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.calculate_massmatrix" href="#ModelingToolkit.calculate_massmatrix"><code>ModelingToolkit.calculate_massmatrix</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">calculate_massmatrix(sys::System; simplify) -&gt; Any
</code></pre><p>Calculate the mass matrix of <code>sys</code>. <code>simplify</code> controls whether <code>Symbolics.simplify</code> is applied to the symbolic mass matrix. Returns a <code>Diagonal</code> or <code>LinearAlgebra.I</code> wherever possible.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/0aad5b471cd3c9822fdad67a713907e0fd73ed87/src/systems/codegen.jl#L406-L412">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.W_sparsity" href="#ModelingToolkit.W_sparsity"><code>ModelingToolkit.W_sparsity</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">W_sparsity(sys::System) -&gt; Any
</code></pre><p>Return the sparsity pattern of the <code>W</code> matrix of <code>sys</code>.</p><p>See also: <a href="#ModelingToolkit.generate_W"><code>generate_W</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/0aad5b471cd3c9822fdad67a713907e0fd73ed87/src/systems/codegen.jl#L481-L487">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.calculate_W_prototype" href="#ModelingToolkit.calculate_W_prototype"><code>ModelingToolkit.calculate_W_prototype</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">calculate_W_prototype(W_sparsity; u0, sparse) -&gt; Any
</code></pre><p>Return the matrix to use as the jacobian prototype given the W-sparsity matrix of the system. This is not the same as the jacobian sparsity pattern.</p><p><strong>Keyword arguments</strong></p><ul><li><code>u0</code>: The <code>u0</code> vector for the problem.</li><li><code>sparse</code>: The prototype is <code>nothing</code> for non-sparse matrices.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/0aad5b471cd3c9822fdad67a713907e0fd73ed87/src/systems/codegen.jl#L497-L507">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.calculate_cost_gradient" href="#ModelingToolkit.calculate_cost_gradient"><code>ModelingToolkit.calculate_cost_gradient</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">calculate_cost_gradient(sys::System; simplify) -&gt; Any
</code></pre><p>Calculate the gradient of the consolidated cost of <code>sys</code> with respect to the unknowns. <code>simplify</code> is forwarded to <code>Symbolics.gradient</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/0aad5b471cd3c9822fdad67a713907e0fd73ed87/src/systems/codegen.jl#L623-L628">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.calculate_cost_hessian" href="#ModelingToolkit.calculate_cost_hessian"><code>ModelingToolkit.calculate_cost_hessian</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">calculate_cost_hessian(
    sys::System;
    sparse,
    simplify
) -&gt; Union{SparseArrays.SparseMatrixCSC{Float64, Int64}, Matrix{Num}}
</code></pre><p>Calculate the hessian of the consolidated cost of <code>sys</code> with respect to the unknowns. <code>simplify</code> is forwarded to <code>Symbolics.hessian</code>. <code>sparse</code> controls whether a sparse matrix is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/0aad5b471cd3c9822fdad67a713907e0fd73ed87/src/systems/codegen.jl#L659-L665">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.cost_hessian_sparsity" href="#ModelingToolkit.cost_hessian_sparsity"><code>ModelingToolkit.cost_hessian_sparsity</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cost_hessian_sparsity(
    sys::System
) -&gt; Union{SparseArrays.SparseMatrixCSC{Float64, Int64}, Matrix{Float64}}
</code></pre><p>Return the sparsity pattern for the hessian of the cost function of <code>sys</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/0aad5b471cd3c9822fdad67a713907e0fd73ed87/src/systems/codegen.jl#L677-L681">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.calculate_constraint_jacobian" href="#ModelingToolkit.calculate_constraint_jacobian"><code>ModelingToolkit.calculate_constraint_jacobian</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">calculate_constraint_jacobian(
    sys::System;
    simplify,
    sparse,
    return_sparsity
) -&gt; Any
</code></pre><p>Return the jacobian of the constraints of <code>sys</code> with respect to unknowns.</p><p><strong>Keyword arguments</strong></p><ul><li><code>simplify</code>, <code>sparse</code>: Forwarded to <code>Symbolics.jacobian</code>.</li><li><code>return_sparsity</code>: Whether to also return the sparsity pattern of the jacobian.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/0aad5b471cd3c9822fdad67a713907e0fd73ed87/src/systems/codegen.jl#L746-L755">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.calculate_constraint_hessian" href="#ModelingToolkit.calculate_constraint_hessian"><code>ModelingToolkit.calculate_constraint_hessian</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">calculate_constraint_hessian(
    sys::System;
    simplify,
    sparse,
    return_sparsity
) -&gt; Any
</code></pre><p>Return the hessian of the constraints of <code>sys</code> with respect to unknowns.</p><p><strong>Keyword arguments</strong></p><ul><li><code>simplify</code>, <code>sparse</code>: Forwarded to <code>Symbolics.hessian</code>.</li><li><code>return_sparsity</code>: Whether to also return the sparsity pattern of the hessian.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/0aad5b471cd3c9822fdad67a713907e0fd73ed87/src/systems/codegen.jl#L799-L808">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.calculate_control_jacobian" href="#ModelingToolkit.calculate_control_jacobian"><code>ModelingToolkit.calculate_control_jacobian</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">calculate_control_jacobian(
    sys::ModelingToolkit.AbstractSystem;
    sparse,
    simplify
) -&gt; Any
</code></pre><p>Calculate the jacobian of the equations of <code>sys</code> with respect to the inputs.</p><p><strong>Keyword arguments</strong></p><ul><li><code>simplify</code>, <code>sparse</code>: Forwarded to <code>Symbolics.jacobian</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/0aad5b471cd3c9822fdad67a713907e0fd73ed87/src/systems/codegen.jl#L854-L862">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.calculate_A_b" href="#ModelingToolkit.calculate_A_b"><code>ModelingToolkit.calculate_A_b</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">calculate_A_b(
    sys::System;
    sparse
) -&gt; Tuple{Union{SparseArrays.SparseMatrixCSC{Any, Int64}, Matrix{Any}}, Any}
</code></pre><p>Return matrix <code>A</code> and vector <code>b</code> such that the system <code>sys</code> can be represented as <code>A * x = b</code> where <code>x</code> is <code>unknowns(sys)</code>. Errors if the system is not affine.</p><p><strong>Keyword arguments</strong></p><ul><li><code>sparse</code>: return a sparse <code>A</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/0aad5b471cd3c9822fdad67a713907e0fd73ed87/src/systems/codegen.jl#L1136-L1145">source</a></section></article><p>All code generation eventually calls <code>build_function_wrapper</code>.</p><div class="admonition is-warning" id="Missing-docstring.-fae5db2da713e85c"><header class="admonition-header">Missing docstring.<a class="admonition-anchor" href="#Missing-docstring.-fae5db2da713e85c" title="Permalink"></a></header><div class="admonition-body"><p>Missing docstring for <code>build_function_wrapper</code>. Check Documenter&#39;s build log for details.</p></div></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../dynamic_opt/">« Dynamic Optimization Solvers</a><a class="docs-footer-nextpage" href="../PDESystem/">PDESystem »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Friday 18 July 2025 14:38">Friday 18 July 2025</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
