<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Disturbance and input modeling modeling · ModelingToolkit.jl</title><meta name="title" content="Disturbance and input modeling modeling · ModelingToolkit.jl"/><meta property="og:title" content="Disturbance and input modeling modeling · ModelingToolkit.jl"/><meta property="twitter:title" content="Disturbance and input modeling modeling · ModelingToolkit.jl"/><meta name="description" content="Documentation for ModelingToolkit.jl."/><meta property="og:description" content="Documentation for ModelingToolkit.jl."/><meta property="twitter:description" content="Documentation for ModelingToolkit.jl."/><meta property="og:url" content="https://docs.sciml.ai/ModelingToolkit/stable/tutorials/disturbance_modeling/"/><meta property="twitter:url" content="https://docs.sciml.ai/ModelingToolkit/stable/tutorials/disturbance_modeling/"/><link rel="canonical" href="https://docs.sciml.ai/ModelingToolkit/stable/tutorials/disturbance_modeling/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="ModelingToolkit.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">ModelingToolkit.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../ode_modeling/">Getting Started with ModelingToolkit.jl</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../acausal_components/">Acausal Component-Based Modeling</a></li><li><a class="tocitem" href="../nonlinear/">Modeling Nonlinear Systems</a></li><li><a class="tocitem" href="../initialization/">Initialization of ODESystems</a></li><li><a class="tocitem" href="../optimization/">Modeling Optimization Problems</a></li><li><a class="tocitem" href="../modelingtoolkitize/">Modelingtoolkitize: Automatically Translating Numerical to Symbolic Code</a></li><li><a class="tocitem" href="../programmatically_generating/">Programmatically Generating and Scripting ODESystems</a></li><li><a class="tocitem" href="../stochastic_diffeq/">Modeling with Stochasticity</a></li><li><a class="tocitem" href="../discrete_system/">(Experimental) Modeling Discrete Systems</a></li><li><a class="tocitem" href="../parameter_identifiability/">Parameter Identifiability in ODE Models</a></li><li><a class="tocitem" href="../change_independent_variable/">Changing the independent variable of ODEs</a></li><li><a class="tocitem" href="../bifurcation_diagram_computation/">Bifurcation Diagrams</a></li><li><a class="tocitem" href="../attractors/">Multi- and Nonlocal- Continuation</a></li><li><a class="tocitem" href="../SampledData/">Clocks and Sampled-Data Systems</a></li><li><a class="tocitem" href="../domain_connections/">Domains</a></li><li><a class="tocitem" href="../callable_params/">Callable parameters and interpolating data</a></li><li><a class="tocitem" href="../linear_analysis/">Linear Analysis</a></li><li class="is-active"><a class="tocitem" href>Disturbance and input modeling modeling</a><ul class="internal"><li><a class="tocitem" href="#A-flexible-component-based-workflow"><span>A flexible component-based workflow</span></a></li><li><a class="tocitem" href="#Modeling-for-state-estimation"><span>Modeling for state estimation</span></a></li><li><a class="tocitem" href="#Input-signal-library"><span>Input signal library</span></a></li><li><a class="tocitem" href="#Disturbance-model-library"><span>Disturbance-model library</span></a></li><li><a class="tocitem" href="#Further-reading"><span>Further reading</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li><li><a class="tocitem" href="../fmi/">Importing FMUs</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><input class="collapse-toggle" id="menuitem-4-1" type="checkbox"/><label class="tocitem" for="menuitem-4-1"><span class="docs-label">Basic Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/higher_order/">Automatic Transformation of Nth Order ODEs to 1st Order ODEs</a></li><li><a class="tocitem" href="../../examples/spring_mass/">Component-Based Modeling of a Spring-Mass System</a></li><li><a class="tocitem" href="../../examples/modelingtoolkitize_index_reduction/">Automated Index Reduction of DAEs</a></li><li><a class="tocitem" href="../../examples/remake/">Optimizing through an ODE solve and re-creating MTK Problems</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-2" type="checkbox"/><label class="tocitem" for="menuitem-4-2"><span class="docs-label">Advanced Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/tearing_parallelism/">Exposing More Parallelism By Tearing Algebraic Equations in ODESystems</a></li><li><a class="tocitem" href="../../examples/sparse_jacobians/">Automated Sparse Analytical Jacobians</a></li><li><a class="tocitem" href="../../examples/perturbation/">Symbolic-Numeric Perturbation Theory for ODEs</a></li></ul></li></ul></li><li><span class="tocitem">Basics</span><ul><li><a class="tocitem" href="../../basics/AbstractSystem/">The AbstractSystem Interface</a></li><li><a class="tocitem" href="../../basics/ContextualVariables/">Contextual Variable Types</a></li><li><a class="tocitem" href="../../basics/Variable_metadata/">Symbolic Metadata</a></li><li><a class="tocitem" href="../../basics/Composition/">Composing Models and Building Reusable Components</a></li><li><a class="tocitem" href="../../basics/Events/">Event Handling and Callback Functions</a></li><li><a class="tocitem" href="../../basics/Linearization/">Linearization</a></li><li><a class="tocitem" href="../../basics/InputOutput/">Input output</a></li><li><a class="tocitem" href="../../basics/MTKLanguage/">ModelingToolkit Language: Modeling with <code>@mtkmodel</code>, <code>@connectors</code> and <code>@mtkbuild</code></a></li><li><a class="tocitem" href="../../basics/Validation/">Model Validation and Units</a></li><li><a class="tocitem" href="../../basics/Debugging/">Debugging</a></li><li><a class="tocitem" href="../../basics/DependencyGraphs/">Dependency Graphs</a></li><li><a class="tocitem" href="../../basics/Precompilation/">Working with Precompilation and Binary Building</a></li><li><a class="tocitem" href="../../basics/FAQ/">Frequently Asked Questions</a></li></ul></li><li><span class="tocitem">System Types</span><ul><li><a class="tocitem" href="../../systems/ODESystem/">ODESystem</a></li><li><a class="tocitem" href="../../systems/SDESystem/">SDESystem</a></li><li><a class="tocitem" href="../../systems/JumpSystem/">JumpSystem</a></li><li><a class="tocitem" href="../../systems/NonlinearSystem/">NonlinearSystem</a></li><li><a class="tocitem" href="../../systems/OptimizationSystem/">OptimizationSystem</a></li><li><a class="tocitem" href="../../systems/PDESystem/">PDESystem</a></li><li><a class="tocitem" href="../../systems/DiscreteSystem/">DiscreteSystem</a></li><li><a class="tocitem" href="../../systems/ImplicitDiscreteSystem/">ImplicitDiscreteSystem</a></li></ul></li><li><a class="tocitem" href="../../comparison/">Comparison of ModelingToolkit vs Equation-Based and Block Modeling Languages</a></li><li><a class="tocitem" href="../../internals/">Internal Details</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Disturbance and input modeling modeling</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Disturbance and input modeling modeling</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SciML/ModelingToolkit.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SciML/ModelingToolkit.jl/blob/master/docs/src/tutorials/disturbance_modeling.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Disturbance-and-input-modeling-modeling"><a class="docs-heading-anchor" href="#Disturbance-and-input-modeling-modeling">Disturbance and input modeling modeling</a><a id="Disturbance-and-input-modeling-modeling-1"></a><a class="docs-heading-anchor-permalink" href="#Disturbance-and-input-modeling-modeling" title="Permalink"></a></h1><p>Disturbances are often seen as external factors that influence a system. Modeling and simulation of such external influences is common in order to ensure that the plant and or control system can adequately handle or suppress these disturbances. Disturbance modeling is also integral to the problem of state estimation, indeed, modeling how disturbances affect the evolution of the state of the system is crucial in order to accurately estimate this state.</p><p>This tutorial will show how to model disturbances in ModelingToolkit as <em>disturbance inputs</em>. This involves demonstrating best practices that make it easy to use a single model to handle both disturbed and undisturbed systems, and making use of the model for both simulation and state estimation.</p><h2 id="A-flexible-component-based-workflow"><a class="docs-heading-anchor" href="#A-flexible-component-based-workflow">A flexible component-based workflow</a><a id="A-flexible-component-based-workflow-1"></a><a class="docs-heading-anchor-permalink" href="#A-flexible-component-based-workflow" title="Permalink"></a></h2><p>We will consider a simple system consisting of two inertias connected through a flexible shaft, such as a simple transmission system in a car. We start by modeling the plant <em>without any input signals</em>:</p><pre><code class="language-julia hljs">using ModelingToolkit, OrdinaryDiffEq, LinearAlgebra, Test
using ModelingToolkitStandardLibrary.Mechanical.Rotational
using ModelingToolkitStandardLibrary.Blocks
t = ModelingToolkit.t_nounits
D = ModelingToolkit.D_nounits

@mtkmodel SystemModel begin
    @parameters begin
        m1 = 1
        m2 = 1
        k = 10 # Spring stiffness
        c = 3  # Damping coefficient
    end
    @components begin
        inertia1 = Inertia(; J = m1, phi = 0, w = 0)
        inertia2 = Inertia(; J = m2, phi = 0, w = 0)
        spring = Spring(; c = k)
        damper = Damper(; d = c)
        torque = Torque(use_support = false)
    end
    @equations begin
        connect(torque.flange, inertia1.flange_a)
        connect(inertia1.flange_b, spring.flange_a, damper.flange_a)
        connect(inertia2.flange_a, spring.flange_b, damper.flange_b)
    end
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ModelingToolkit.Model{typeof(Main.__SystemModel__), Dict{Symbol, Any}}(Main.__SystemModel__, Dict{Symbol, Any}(:components =&gt; Any[Union{Expr, Symbol}[:inertia1, :Inertia], Union{Expr, Symbol}[:inertia2, :Inertia], Union{Expr, Symbol}[:spring, :Spring], Union{Expr, Symbol}[:damper, :Damper], Union{Expr, Symbol}[:torque, :Torque]], :kwargs =&gt; Dict{Symbol, Dict}(:m2 =&gt; Dict{Symbol, Any}(:value =&gt; 1, :type =&gt; Real), :m1 =&gt; Dict{Symbol, Any}(:value =&gt; 1, :type =&gt; Real), :k =&gt; Dict{Symbol, Any}(:value =&gt; 10, :type =&gt; Real), :c =&gt; Dict{Symbol, Any}(:value =&gt; 3, :type =&gt; Real)), :independent_variable =&gt; t, :parameters =&gt; Dict{Symbol, Dict{Symbol, Any}}(:m2 =&gt; Dict(:default =&gt; 1, :type =&gt; Real), :m1 =&gt; Dict(:default =&gt; 1, :type =&gt; Real), :k =&gt; Dict(:default =&gt; 10, :type =&gt; Real), :c =&gt; Dict(:default =&gt; 3, :type =&gt; Real)), :equations =&gt; Any[&quot;connect(torque.flange, inertia1.flange_a)&quot;, &quot;connect(torque.flange, inertia1.flange_a)&quot;, &quot;connect(inertia1.flange_b, spring.flange_a, damper.flange_a)&quot;, &quot;connect(torque.flange, inertia1.flange_a)&quot;, &quot;connect(inertia1.flange_b, spring.flange_a, damper.flange_a)&quot;, &quot;connect(inertia2.flange_a, spring.flange_b, damper.flange_b)&quot;]), false)</code></pre><p>Here, we have added a <code>torque</code> component that allows us to add a torque input to drive the system, but we have not connected any signal to it yet. We have not yet made any attempts at modeling disturbances, and this is deliberate, we will handle this later in order to make the plant model as generically useful as possible.</p><p>In order to simulate this system in the presence of disturbances, we must 1. Reason about how disturbances may affect the system, and 2. attach <em>disturbance inputs</em> and <em>disturbance signals</em> to the model. We distinguish between an <em>input</em> and a <em>signal</em> here, where we by <em>input</em> mean an attachment point (connector) to which we may connect a <em>signal</em>, i.e., a time-varying function.</p><p>We create a new model that includes disturbance inputs and signals, and attach those to the already defined plant model. We assume that each of the two inertias can be affected by a disturbance torque, such as due to friction or an unknown load on the output inertia.</p><pre><code class="language-julia hljs">@mtkmodel ModelWithInputs begin
    @components begin
        input_signal = Blocks.Sine(frequency = 1, amplitude = 1)
        disturbance_signal1 = Blocks.Step(height = -1, start_time = 2) # We add an input signal that equals zero by default so that it has no effect during normal simulation
        disturbance_signal2 = Blocks.Step(height = 2, start_time = 4)
        disturbance_torque1 = Torque(use_support = false)
        disturbance_torque2 = Torque(use_support = false)
        system_model = SystemModel()
    end
    @equations begin
        connect(input_signal.output, :u, system_model.torque.tau)
        connect(disturbance_signal1.output, :d1, disturbance_torque1.tau) # When we connect the input _signals_, we do so through an analysis point. This allows us to easily disconnect the input signals in situations when we do not need them.
        connect(disturbance_signal2.output, :d2, disturbance_torque2.tau)
        connect(disturbance_torque1.flange, system_model.inertia1.flange_b)
        connect(disturbance_torque2.flange, system_model.inertia2.flange_b)
    end
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ModelingToolkit.Model{typeof(Main.__ModelWithInputs__), Dict{Symbol, Any}}(Main.__ModelWithInputs__, Dict{Symbol, Any}(:components =&gt; Any[Union{Expr, Symbol}[:input_signal, :(Blocks.Sine)], Union{Expr, Symbol}[:disturbance_signal1, :(Blocks.Step)], Union{Expr, Symbol}[:disturbance_signal2, :(Blocks.Step)], Union{Expr, Symbol}[:disturbance_torque1, :Torque], Union{Expr, Symbol}[:disturbance_torque2, :Torque], Union{Expr, Symbol}[:system_model, :SystemModel]], :independent_variable =&gt; t, :equations =&gt; Any[&quot;connect(input_signal.output, :u, system_model.torque.tau)&quot;, &quot;connect(input_signal.output, :u, system_model.torque.tau)&quot;, &quot;connect(disturbance_signal1.output, :d1, disturbance_torque1.tau)&quot;, &quot;connect(input_signal.output, :u, system_model.torque.tau)&quot;, &quot;connect(disturbance_signal1.output, :d1, disturbance_torque1.tau)&quot;, &quot;connect(disturbance_signal2.output, :d2, disturbance_torque2.tau)&quot;, &quot;connect(input_signal.output, :u, system_model.torque.tau)&quot;, &quot;connect(disturbance_signal1.output, :d1, disturbance_torque1.tau)&quot;, &quot;connect(disturbance_signal2.output, :d2, disturbance_torque2.tau)&quot;, &quot;connect(disturbance_torque1.flange, system_model.inertia1.flange_b)&quot;, &quot;connect(input_signal.output, :u, system_model.torque.tau)&quot;, &quot;connect(disturbance_signal1.output, :d1, disturbance_torque1.tau)&quot;, &quot;connect(disturbance_signal2.output, :d2, disturbance_torque2.tau)&quot;, &quot;connect(disturbance_torque1.flange, system_model.inertia1.flange_b)&quot;, &quot;connect(disturbance_torque2.flange, system_model.inertia2.flange_b)&quot;]), false)</code></pre><p>This outer model, <code>ModelWithInputs</code>, contains two disturbance inputs, both of type <code>Torque</code>. It also contains three signal specifications, one for the control input and two for the corresponding disturbance inputs. Note how we added the disturbance torque inputs at this level of the model, but the control input was added inside the system model. This is a design choice that is up to the modeler, here, we consider the driving torque to be a fundamental part of the model that is always required to make use of it, while the disturbance inputs may be of interest only in certain situations, and we thus add them when needed. Since we have added not only input connectors, but also connected input signals to them, this model is complete and ready for simulation, i.e., there are no <em>unbound inputs</em>.</p><pre><code class="language-julia hljs">@named model = ModelWithInputs() # Model with load disturbance
ssys = structural_simplify(model)
prob = ODEProblem(ssys, [], (0.0, 6.0))
sol = solve(prob, Tsit5())
using Plots
plot(sol)</code></pre><img src="e1d79496.svg" alt="Example block output"/><p>A thing to note in the specification of <code>ModelWithInputs</code> is the presence of three <a href="https://docs.sciml.ai/ModelingToolkit/dev/tutorials/linear_analysis/#ModelingToolkit.AnalysisPoint">analysis points</a>, <code>:u</code>, <code>:d1</code>, and <code>:d2</code>. When signals are connected through an analysis point, we may at any time linearize the model as if the signals were not connected, i.e., as if the corresponding inputs were unbound. We may also use this to generate a julia function for the dynamics on the form <span>$f(x,u,p,t,w)$</span> where the input <span>$u$</span> and disturbance <span>$w$</span> may be provided as separate function arguments, as if the corresponding input signals were not present in the model. More details regarding this will be presented further below, here, we just demonstrate how we could linearize this system model from the inputs to the angular velocity of the inertias</p><pre><code class="language-julia hljs">using ControlSystemsBase, ControlSystemsMTK # ControlSystemsMTK provides the high-level function named_ss and ControlSystemsBase provides the bodeplot function
P = named_ss(model, [ssys.u, ssys.d1, ssys.d2],
    [ssys.system_model.inertia1.w, ssys.system_model.inertia2.w])
bodeplot(P, plotphase = false)</code></pre><img src="83f3f9c6.svg" alt="Example block output"/><p>It&#39;s worth noting at this point that the fact that we could connect disturbance outputs from outside of the plant-model definition was enabled by the fact that we used a component-based workflow, where the plant model had the appropriate connectors available. If the plant model had modeled the system using direct equations without connectors, this would not have been possible and the model would thus be significantly less flexible.</p><p>We summarize the findings so far as a number of best practices:</p><div class="admonition is-success" id="Best-practices-1185462be5985482"><header class="admonition-header">Best practices<a class="admonition-anchor" href="#Best-practices-1185462be5985482" title="Permalink"></a></header><div class="admonition-body"><ul><li>Use a component-based workflow to model the plant</li><li>If possible, model the plant without explicit disturbance inputs to make it as generic as possible</li><li>When disturbance inputs are needed, create a new model that includes the plant model and the disturbance inputs</li><li>Only add input <em>signals</em> at the top level of the model, this applies to both control inputs and disturbance inputs.</li><li>Use analysis points to connect signals to inputs, this allows for easy disconnection of signals when needed, e.g., for linearization or function generation.</li></ul></div></div><h2 id="Modeling-for-state-estimation"><a class="docs-heading-anchor" href="#Modeling-for-state-estimation">Modeling for state estimation</a><a id="Modeling-for-state-estimation-1"></a><a class="docs-heading-anchor-permalink" href="#Modeling-for-state-estimation" title="Permalink"></a></h2><p>In the example above, we constructed a model for <em>simulation</em> of a disturbance affecting the system. When simulating, we connect an input signal of specified shape that simulates the disturbance, above, we used <code>Blocks.Step</code> as input signals. On the other hand, when performing state estimation, the exact shape of the disturbance is typically not known, we might only have some diffuse knowledge of the disturbance characteristics such as &quot;varies smoothly&quot;, &quot;makes sudden step changes&quot; or &quot;is approximately periodic with 24hr period&quot;. The encoding of such knowledge is commonly reasoned about in the frequency domain, where we specify a disturbance model as a dynamical system with a frequency response similar to the approximate spectrum of the disturbance. <a href="https://juliahub.com/pluto/editor.html?id=ad9ecbf9-bf83-45e7-bbe8-d2e5194f2240">For more details around this, see the in-depth tutorial notebook &quot;How to tune a Kalman filter&quot;</a>. Most algorithms for state estimation, such as a Kalman-filter like estimators, assume that disturbances are independent and identically distributed (i.i.d.). While seemingly restrictive at first glance, when combined with an appropriate disturbance models encoded as dynamical systems, this assumption still allows for a wide range of non i.i.d. disturbances to be modeled.</p><p>When modeling a system in MTK, we essentially (without considering algebraic equations for simplicity in exposition) construct a model of a dynamical system</p><p class="math-container">\[\begin{aligned}
\dot x &amp;= f(x, p, t) \\
y &amp;= g(x, p, t)
\end{aligned}\]</p><p>where <span>$x$</span> is the state, <span>$y$</span> are observed variables, <span>$p$</span> are parameters, and <span>$t$</span> is time. When using MTK, which variables constitute <span>$x$</span> and which are considered part of the output, <span>$y$</span>, is up to the tool rather than the user, this choice is made by MTK during the call to <code>@mtkbuild</code> or the lower-level function <code>structural_simplify</code>.</p><p>If we further consider external inputs to the system, such as controlled input signals <span>$u$</span> and disturbance inputs <span>$w$</span>, we can write the system as</p><p class="math-container">\[\begin{aligned}
\dot x &amp;= f(x, u, p, t, w) \\
y &amp;= g(x, u, p, t)
\end{aligned}\]</p><p>To make use of the model defined above for state estimation, we may want to generate a Julia function for the dynamics <span>$f$</span> and the output equations <span>$g$</span> that we can plug into, e.g., a nonlinear version of a Kalman filter or a particle filter, etc. MTK contains utilities to do this, namely, <a href="@ref"><code>generate_control_function</code></a> and <a href="@ref"><code>build_explicit_observed_function</code></a> (described in more details in <a href="../../basics/InputOutput/#inputoutput">&quot;Input output&quot;</a>). These functions take keyword arguments <code>disturbance_inputs</code> and <code>disturbance_argument</code>, that indicate which variables in the model are considered part of <span>$w$</span>, and whether or not these variables are to be added as function arguments to <span>$f$</span>, i.e., whether we have <span>$f(x, u, p, t)$</span> or <span>$f(x, u, p, t, w)$</span>. If we do not include the disturbance inputs as function arguments, MTK will assume that the <span>$w$</span> variables are all zero, but any dynamics associated with these variables, such as disturbance models, will be included in the generated function. This allows a state estimator to estimate the state of the disturbance model, provided that this state is <a href="https://en.wikipedia.org/wiki/Observability">observable</a> from the measured outputs of the system.</p><p>Below, we demonstrate</p><ol><li>How to add an integrating disturbance model</li><li>how to generate the functions <span>$f$</span> and <span>$g$</span> for a typical nonlinear state estimator with explicit disturbance inputs</li></ol><pre><code class="language-julia hljs">@mtkmodel IntegratingDisturbance begin
    @variables begin
        x(t) = 0.0
        w(t) = 0.0, [disturbance = true, input = true]
    end
    @components begin
        input = RealInput()
        output = RealOutput()
    end
    @equations begin
        D(x) ~ w
        w ~ input.u
        output.u ~ x
    end
end

@mtkmodel SystemModelWithDisturbanceModel begin
    @components begin
        input_signal = Blocks.Sine(frequency = 1, amplitude = 1)
        disturbance_signal1 = Blocks.Constant(k = 0)
        disturbance_signal2 = Blocks.Constant(k = 0)
        disturbance_torque1 = Torque(use_support = false)
        disturbance_torque2 = Torque(use_support = false)
        disturbance_model = Blocks.Integrator()
        system_model = SystemModel()
    end
    @equations begin
        connect(input_signal.output, :u, system_model.torque.tau)
        connect(disturbance_signal1.output, :d1, disturbance_model.input)
        connect(disturbance_model.output, disturbance_torque1.tau)
        connect(disturbance_signal2.output, :d2, disturbance_torque2.tau)
        connect(disturbance_torque1.flange, system_model.inertia1.flange_b)
        connect(disturbance_torque2.flange, system_model.inertia2.flange_b)
    end
end

@named model_with_disturbance = SystemModelWithDisturbanceModel()</code></pre><p class="math-container">\[ \begin{equation}
\left[
\begin{array}{c}
AnalysisPoint\left( \mathtt{input\_signal.output.u}\left( t \right), u, \left[
\begin{array}{c}
\mathtt{system\_model.torque.tau.u}\left( t \right) \\
\end{array}
\right] \right) \\
AnalysisPoint\left( \mathtt{disturbance\_signal1.output.u}\left( t \right), d1, \left[
\begin{array}{c}
\mathtt{disturbance\_model.input.u}\left( t \right) \\
\end{array}
\right] \right) \\
\mathrm{connect}\left( disturbance_{model_{+}output}, disturbance_{torque1_{+}tau} \right) \\
AnalysisPoint\left( \mathtt{disturbance\_signal2.output.u}\left( t \right), d2, \left[
\begin{array}{c}
\mathtt{disturbance\_torque2.tau.u}\left( t \right) \\
\end{array}
\right] \right) \\
\mathrm{connect}\left( disturbance_{torque1_{+}flange}, system_{model_{+}inertia1_{+}flange\_b} \right) \\
\mathrm{connect}\left( disturbance_{torque2_{+}flange}, system_{model_{+}inertia2_{+}flange\_b} \right) \\
\mathtt{input\_signal.output.u}\left( t \right) = \mathtt{input\_signal.offset} + ifelse\left( t &lt; \mathtt{input\_signal.start\_time}, 0, \mathtt{input\_signal.amplitude} \sin\left( \mathtt{input\_signal.phase} + 6.2832 \mathtt{input\_signal.frequency} \left(  - \mathtt{input\_signal.start\_time} + t \right) \right) \right) \\
\mathtt{disturbance\_signal1.output.u}\left( t \right) = \mathtt{disturbance\_signal1.k} \\
\mathtt{disturbance\_signal2.output.u}\left( t \right) = \mathtt{disturbance\_signal2.k} \\
\mathtt{disturbance\_torque1.phi\_support}\left( t \right) = 0 \\
\mathtt{disturbance\_torque1.flange.tau}\left( t \right) =  - \mathtt{disturbance\_torque1.tau.u}\left( t \right) \\
\mathtt{disturbance\_torque2.phi\_support}\left( t \right) = 0 \\
\mathtt{disturbance\_torque2.flange.tau}\left( t \right) =  - \mathtt{disturbance\_torque2.tau.u}\left( t \right) \\
\mathtt{disturbance\_model.u}\left( t \right) = \mathtt{disturbance\_model.input.u}\left( t \right) \\
\mathtt{disturbance\_model.y}\left( t \right) = \mathtt{disturbance\_model.output.u}\left( t \right) \\
\frac{\mathrm{d} \mathtt{disturbance\_model.x}\left( t \right)}{\mathrm{d}t} = \mathtt{disturbance\_model.k} \mathtt{disturbance\_model.u}\left( t \right) \\
\mathtt{disturbance\_model.y}\left( t \right) = \mathtt{disturbance\_model.x}\left( t \right) \\
\mathrm{connect}\left( torque_{+}flange, inertia1_{+}flange_{a} \right) \\
\mathrm{connect}\left( inertia1_{+}flange_{b}, spring_{+}flange_{a}, damper_{+}flange_{a} \right) \\
\mathrm{connect}\left( inertia2_{+}flange_{a}, spring_{+}flange_{b}, damper_{+}flange_{b} \right) \\
\mathtt{system\_model.inertia1.phi}\left( t \right) = \mathtt{system\_model.inertia1.flange\_a.phi}\left( t \right) \\
\mathtt{system\_model.inertia1.phi}\left( t \right) = \mathtt{system\_model.inertia1.flange\_b.phi}\left( t \right) \\
\frac{\mathrm{d} \mathtt{system\_model.inertia1.phi}\left( t \right)}{\mathrm{d}t} = \mathtt{system\_model.inertia1.w}\left( t \right) \\
\frac{\mathrm{d} \mathtt{system\_model.inertia1.w}\left( t \right)}{\mathrm{d}t} = \mathtt{system\_model.inertia1.a}\left( t \right) \\
\mathtt{system\_model.inertia1.J} \mathtt{system\_model.inertia1.a}\left( t \right) = \mathtt{system\_model.inertia1.flange\_b.tau}\left( t \right) + \mathtt{system\_model.inertia1.flange\_a.tau}\left( t \right) \\
\mathtt{system\_model.inertia2.phi}\left( t \right) = \mathtt{system\_model.inertia2.flange\_a.phi}\left( t \right) \\
\mathtt{system\_model.inertia2.phi}\left( t \right) = \mathtt{system\_model.inertia2.flange\_b.phi}\left( t \right) \\
\frac{\mathrm{d} \mathtt{system\_model.inertia2.phi}\left( t \right)}{\mathrm{d}t} = \mathtt{system\_model.inertia2.w}\left( t \right) \\
\frac{\mathrm{d} \mathtt{system\_model.inertia2.w}\left( t \right)}{\mathrm{d}t} = \mathtt{system\_model.inertia2.a}\left( t \right) \\
\mathtt{system\_model.inertia2.J} \mathtt{system\_model.inertia2.a}\left( t \right) = \mathtt{system\_model.inertia2.flange\_a.tau}\left( t \right) + \mathtt{system\_model.inertia2.flange\_b.tau}\left( t \right) \\
\mathtt{system\_model.spring.phi\_rel}\left( t \right) = \mathtt{system\_model.spring.flange\_b.phi}\left( t \right) - \mathtt{system\_model.spring.flange\_a.phi}\left( t \right) \\
\mathtt{system\_model.spring.flange\_b.tau}\left( t \right) = \mathtt{system\_model.spring.tau}\left( t \right) \\
\mathtt{system\_model.spring.flange\_a.tau}\left( t \right) =  - \mathtt{system\_model.spring.tau}\left( t \right) \\
\mathtt{system\_model.spring.tau}\left( t \right) = \mathtt{system\_model.spring.c} \left(  - \mathtt{system\_model.spring.phi\_rel0} + \mathtt{system\_model.spring.phi\_rel}\left( t \right) \right) \\
\mathtt{system\_model.damper.phi\_rel}\left( t \right) = \mathtt{system\_model.damper.flange\_b.phi}\left( t \right) - \mathtt{system\_model.damper.flange\_a.phi}\left( t \right) \\
\frac{\mathrm{d} \mathtt{system\_model.damper.phi\_rel}\left( t \right)}{\mathrm{d}t} = \mathtt{system\_model.damper.w\_rel}\left( t \right) \\
\frac{\mathrm{d} \mathtt{system\_model.damper.w\_rel}\left( t \right)}{\mathrm{d}t} = \mathtt{system\_model.damper.a\_rel}\left( t \right) \\
\mathtt{system\_model.damper.flange\_b.tau}\left( t \right) = \mathtt{system\_model.damper.tau}\left( t \right) \\
\mathtt{system\_model.damper.flange\_a.tau}\left( t \right) =  - \mathtt{system\_model.damper.tau}\left( t \right) \\
\mathtt{system\_model.damper.tau}\left( t \right) = \mathtt{system\_model.damper.d} \mathtt{system\_model.damper.w\_rel}\left( t \right) \\
\mathtt{system\_model.torque.phi\_support}\left( t \right) = 0 \\
\mathtt{system\_model.torque.flange.tau}\left( t \right) =  - \mathtt{system\_model.torque.tau.u}\left( t \right) \\
\end{array}
\right]
\end{equation}
 \]</p><p>We demonstrate that this model is complete and can be simulated:</p><pre><code class="language-julia hljs">ssys = structural_simplify(model_with_disturbance)
prob = ODEProblem(ssys, [], (0.0, 10.0))
sol = solve(prob, Tsit5())
using Test
@test SciMLBase.successful_retcode(sol)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr32"><span class="sgr1">Test Passed</span></span></code></pre><p>but we may also generate the functions <span>$f$</span> and <span>$g$</span> for state estimation:</p><pre><code class="language-julia hljs">inputs = [ssys.u]
disturbance_inputs = [ssys.d1, ssys.d2]
P = ssys.system_model
outputs = [P.inertia1.phi, P.inertia2.phi, P.inertia1.w, P.inertia2.w]

(f_oop, f_ip), x_sym, p_sym, io_sys = ModelingToolkit.generate_control_function(
    model_with_disturbance, inputs, disturbance_inputs; disturbance_argument = true)

g = ModelingToolkit.build_explicit_observed_function(
    io_sys, outputs; inputs)

op = ModelingToolkit.inputs(io_sys) .=&gt; 0
x0, _ = ModelingToolkit.get_u0_p(io_sys, op, op)
p = MTKParameters(io_sys, op)
u = zeros(1) # Control input
w = zeros(length(disturbance_inputs)) # Disturbance input
@test f_oop(x0, u, p, t, w) == zeros(5)
@test g(x0, u, p, 0.0) == [0, 0, 0, 0]

# Non-zero disturbance inputs should result in non-zero state derivatives. We call `sort` since we do not generally know the order of the state variables
w = [1.0, 2.0]
@test sort(f_oop(x0, u, p, t, w)) == [0, 0, 0, 1, 2]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr32"><span class="sgr1">Test Passed</span></span></code></pre><h2 id="Input-signal-library"><a class="docs-heading-anchor" href="#Input-signal-library">Input signal library</a><a id="Input-signal-library-1"></a><a class="docs-heading-anchor-permalink" href="#Input-signal-library" title="Permalink"></a></h2><p>The <a href="https://docs.sciml.ai/ModelingToolkitStandardLibrary/stable/API/blocks/"><code>Blocks</code> module in ModelingToolkitStandardLibrary</a> contains several predefined input signals, such as <code>Sine, Step, Ramp, Constant</code> etc., a few of which were used in the examples above. If you have an input signal represented as a sequence of samples, you may use an <a href="https://docs.sciml.ai/ModelingToolkitStandardLibrary/stable/tutorials/input_component/"><code>Interpolation</code> block</a>, e.g., as <code>src = Interpolation(ConstantInterpolation, data, timepoints)</code>, see the docstring for a complete example.</p><h2 id="Disturbance-model-library"><a class="docs-heading-anchor" href="#Disturbance-model-library">Disturbance-model library</a><a id="Disturbance-model-library-1"></a><a class="docs-heading-anchor-permalink" href="#Disturbance-model-library" title="Permalink"></a></h2><p>There is no library explicitly constructed for disturbance modeling. Standard blocks from the <a href="https://docs.sciml.ai/ModelingToolkitStandardLibrary/stable/API/blocks/"><code>Blocks</code> module in ModelingToolkitStandardLibrary</a>, such as <code>Integrator, TransferFunction, StateSpace</code>, can model any disturbance with rational spectrum. Examples of this includes disturbance models such as constants, piecewise constant, periodic, highpass, lowpass, and bandpass. For help with filter design, see <a href="https://juliacontrol.github.io/ControlSystems.jl/stable/man/creating_systems/#Filter-design">ControlSystems.jl: Filter-design</a> and the interface package <a href="https://juliacontrol.github.io/ControlSystemsMTK.jl/dev/">ControlSystemsMTK.jl</a>. In the example above, we made use of <code>Blocks.Integrator</code>, which is a disturbance model suitable for disturbances dominated by low-frequency components, such as piecewise constant signals or slowly drifting signals.</p><h2 id="Further-reading"><a class="docs-heading-anchor" href="#Further-reading">Further reading</a><a id="Further-reading-1"></a><a class="docs-heading-anchor-permalink" href="#Further-reading" title="Permalink"></a></h2><p>To see full examples that perform state estimation with ModelingToolkit models, see the following resources:</p><ul><li><a href="https://arxiv.org/abs/2502.01128">C codegen considered unnecessary: go directly to binary, do not pass C. Compilation of Julia code for deployment in model-based engineering</a></li><li><a href="https://github.com/baggepinnen/LowLevelParticleFiltersMTK.jl">LowLevelParticleFiltersMTK.jl</a></li></ul><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.get_comp_sensitivity-tutorials-disturbance_modeling" href="#ModelingToolkit.get_comp_sensitivity-tutorials-disturbance_modeling"><code>ModelingToolkit.get_comp_sensitivity</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_comp_sensitivity(sys, ap::AnalysisPoint; kwargs)
get_comp_sensitivity(sys, ap_name::Symbol; kwargs)</code></pre><p>Compute the complementary sensitivity function in analysis point <code>ap</code>. The complementary sensitivity function is obtained by introducing an infinitesimal perturbation <code>d</code> at the output of <code>ap</code>, linearizing the system and computing the transfer function between <code>d</code> and the input of <code>ap</code>.</p><p><strong>Arguments:</strong></p><ul><li><code>kwargs</code>: Are sent to <code>ModelingToolkit.linearize</code></li></ul><p>See also <a href="../linear_analysis/#ModelingToolkit.get_sensitivity"><code>get_sensitivity</code></a>, <a href="../linear_analysis/#ModelingToolkit.get_looptransfer"><code>get_looptransfer</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/60c95b9a71ec4350e4409b27b0eeb9d8c05fe1fe/src/systems/analysis_points.jl#L978-L989">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.get_comp_sensitivity_function-Tuple{ModelingToolkit.AbstractSystem, Any}-tutorials-disturbance_modeling" href="#ModelingToolkit.get_comp_sensitivity_function-Tuple{ModelingToolkit.AbstractSystem, Any}-tutorials-disturbance_modeling"><code>ModelingToolkit.get_comp_sensitivity_function</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_comp_sensitivity_function(
    sys::ModelingToolkit.AbstractSystem,
    aps;
    kwargs...
) -&gt; Tuple{ModelingToolkit.LinearizationFunction{DI, AI, _A, P, _B, _C, J1, J2, J3, J4, IA, @NamedTuple{abstol::Float64, reltol::Float64, nlsolve_alg::NonlinearSolveFirstOrder.GeneralizedFirstOrderAlgorithm{Missing, NonlinearSolveFirstOrder.GenericTrustRegionScheme{NonlinearSolveFirstOrder.RadiusUpdateSchemes.__Simple, Rational{Int64}, Rational{Int64}, Rational{Int64}, Rational{Int64}, Rational{Int64}, Rational{Int64}, Rational{Int64}}, NonlinearSolveBase.Dogleg{NonlinearSolveBase.NewtonDescent{Nothing}, NonlinearSolveBase.SteepestDescent{Nothing}}, Nothing, Nothing, Nothing, Val{false}}}} where {DI&lt;:AbstractVector{Int64}, AI&lt;:AbstractVector{Int64}, _A, P&lt;:ODEProblem, _B, _C, J1&lt;:Union{Nothing, ModelingToolkit.PreparedJacobian{true, DifferentiationInterfaceForwardDiffExt.ForwardDiffTwoArgJacobianPrep{Nothing, C, Tuple{Nothing, Nothing}}, ModelingToolkit.var&quot;#uff#816&quot;{var&quot;#1475#fun&quot;}, _A, ADTypes.AutoForwardDiff{nothing, Nothing}} where {C&lt;:(ForwardDiff.JacobianConfig{T, _A, _B, &lt;:Tuple{Any, Any}} where {T&lt;:(ForwardDiff.Tag{F} where F&lt;:ModelingToolkit.var&quot;#uff#816&quot;), _A, _B}), var&quot;#1475#fun&quot;, _A}}, J2&lt;:Union{Nothing, ModelingToolkit.PreparedJacobian{true, DifferentiationInterfaceForwardDiffExt.ForwardDiffTwoArgJacobianPrep{Nothing, C, Tuple{Nothing, Nothing}}, _A, _B, ADTypes.AutoForwardDiff{nothing, Nothing}} where {C&lt;:ForwardDiff.JacobianConfig, _A, _B}}, J3&lt;:Union{Nothing, ModelingToolkit.PreparedJacobian{true, DifferentiationInterfaceForwardDiffExt.ForwardDiffTwoArgJacobianPrep{Nothing, C, Tuple{Nothing, Nothing, Nothing}}, ModelingToolkit.var&quot;#pff#817&quot;{var&quot;#1476#fun&quot;, var&quot;#1477#setter&quot;}, _A, ADTypes.AutoForwardDiff{nothing, Nothing}} where {C&lt;:(ForwardDiff.JacobianConfig{T, _A, _B, &lt;:Tuple{Any, Any}} where {T&lt;:(ForwardDiff.Tag{F} where F&lt;:ModelingToolkit.var&quot;#pff#817&quot;), _A, _B}), var&quot;#1476#fun&quot;, var&quot;#1477#setter&quot;, _A}}, J4&lt;:(ModelingToolkit.PreparedJacobian{true, DifferentiationInterfaceForwardDiffExt.ForwardDiffTwoArgJacobianPrep{Nothing, C, Tuple{Nothing, Nothing, Nothing}}, ModelingToolkit.var&quot;#hpf#815&quot;{fun, setter}, _A, ADTypes.AutoForwardDiff{nothing, Nothing}} where {C&lt;:(ForwardDiff.JacobianConfig{T, _A, _B, &lt;:Tuple{Any, Any}} where {T&lt;:(ForwardDiff.Tag{F} where F&lt;:ModelingToolkit.var&quot;#hpf#815&quot;), _A, _B}), fun, setter, _A}), IA&lt;:Union{SciMLBase.NoInit, SciMLBase.OverrideInit{Nothing, Nothing, Nothing}}}, Any}
</code></pre><p>Return the complementary sensitivity function for the analysis point(s) <code>aps</code>, and the modified system simplified with the appropriate inputs and outputs.</p><p><strong>Keyword Arguments</strong></p><pre><code class="nohighlight hljs">- `loop_openings`: A list of analysis points whose connections should be removed and
  the outputs set to zero as a part of the linear analysis.

- `system_modifier`: A function taking the transformed system and applying any
  additional transformations, returning the modified system. The modified system
  is passed to `linearization_function`.</code></pre><p>All other keyword arguments are forwarded to <code>linearization_function</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/60c95b9a71ec4350e4409b27b0eeb9d8c05fe1fe/src/systems/analysis_points.jl#L869-L881">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.get_looptransfer-tutorials-disturbance_modeling" href="#ModelingToolkit.get_looptransfer-tutorials-disturbance_modeling"><code>ModelingToolkit.get_looptransfer</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_looptransfer(sys, ap::AnalysisPoint; kwargs)
get_looptransfer(sys, ap_name::Symbol; kwargs)</code></pre><p>Compute the (linearized) loop-transfer function in analysis point <code>ap</code>, from <code>ap.out</code> to <code>ap.in</code>.</p><div class="admonition is-info" id="Negative-feedback-bdb37f4684a709de"><header class="admonition-header">Negative feedback<a class="admonition-anchor" href="#Negative-feedback-bdb37f4684a709de" title="Permalink"></a></header><div class="admonition-body"><p>Feedback loops often use negative feedback, and the computed loop-transfer function will in this case have the negative feedback included. Standard analysis tools often assume a loop-transfer function without the negative gain built in, and the result of this function may thus need negation before use.</p></div></div><p><strong>Arguments:</strong></p><ul><li><code>kwargs</code>: Are sent to <code>ModelingToolkit.linearize</code></li></ul><p>See also <a href="../linear_analysis/#ModelingToolkit.get_sensitivity"><code>get_sensitivity</code></a>, <a href="../linear_analysis/#ModelingToolkit.get_comp_sensitivity"><code>get_comp_sensitivity</code></a>, <a href="#ModelingToolkit.open_loop-Tuple{Any, Union{Symbol, AnalysisPoint}}-tutorials-disturbance_modeling"><code>open_loop</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/60c95b9a71ec4350e4409b27b0eeb9d8c05fe1fe/src/systems/analysis_points.jl#L991-L1006">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.get_looptransfer_function-Tuple{ModelingToolkit.AbstractSystem, Any}-tutorials-disturbance_modeling" href="#ModelingToolkit.get_looptransfer_function-Tuple{ModelingToolkit.AbstractSystem, Any}-tutorials-disturbance_modeling"><code>ModelingToolkit.get_looptransfer_function</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_looptransfer_function(
    sys::ModelingToolkit.AbstractSystem,
    aps;
    kwargs...
) -&gt; Tuple{ModelingToolkit.LinearizationFunction{DI, AI, _A, P, _B, _C, J1, J2, J3, J4, IA, @NamedTuple{abstol::Float64, reltol::Float64, nlsolve_alg::NonlinearSolveFirstOrder.GeneralizedFirstOrderAlgorithm{Missing, NonlinearSolveFirstOrder.GenericTrustRegionScheme{NonlinearSolveFirstOrder.RadiusUpdateSchemes.__Simple, Rational{Int64}, Rational{Int64}, Rational{Int64}, Rational{Int64}, Rational{Int64}, Rational{Int64}, Rational{Int64}}, NonlinearSolveBase.Dogleg{NonlinearSolveBase.NewtonDescent{Nothing}, NonlinearSolveBase.SteepestDescent{Nothing}}, Nothing, Nothing, Nothing, Val{false}}}} where {DI&lt;:AbstractVector{Int64}, AI&lt;:AbstractVector{Int64}, _A, P&lt;:ODEProblem, _B, _C, J1&lt;:Union{Nothing, ModelingToolkit.PreparedJacobian{true, DifferentiationInterfaceForwardDiffExt.ForwardDiffTwoArgJacobianPrep{Nothing, C, Tuple{Nothing, Nothing}}, ModelingToolkit.var&quot;#uff#816&quot;{var&quot;#1475#fun&quot;}, _A, ADTypes.AutoForwardDiff{nothing, Nothing}} where {C&lt;:(ForwardDiff.JacobianConfig{T, _A, _B, &lt;:Tuple{Any, Any}} where {T&lt;:(ForwardDiff.Tag{F} where F&lt;:ModelingToolkit.var&quot;#uff#816&quot;), _A, _B}), var&quot;#1475#fun&quot;, _A}}, J2&lt;:Union{Nothing, ModelingToolkit.PreparedJacobian{true, DifferentiationInterfaceForwardDiffExt.ForwardDiffTwoArgJacobianPrep{Nothing, C, Tuple{Nothing, Nothing}}, _A, _B, ADTypes.AutoForwardDiff{nothing, Nothing}} where {C&lt;:ForwardDiff.JacobianConfig, _A, _B}}, J3&lt;:Union{Nothing, ModelingToolkit.PreparedJacobian{true, DifferentiationInterfaceForwardDiffExt.ForwardDiffTwoArgJacobianPrep{Nothing, C, Tuple{Nothing, Nothing, Nothing}}, ModelingToolkit.var&quot;#pff#817&quot;{var&quot;#1476#fun&quot;, var&quot;#1477#setter&quot;}, _A, ADTypes.AutoForwardDiff{nothing, Nothing}} where {C&lt;:(ForwardDiff.JacobianConfig{T, _A, _B, &lt;:Tuple{Any, Any}} where {T&lt;:(ForwardDiff.Tag{F} where F&lt;:ModelingToolkit.var&quot;#pff#817&quot;), _A, _B}), var&quot;#1476#fun&quot;, var&quot;#1477#setter&quot;, _A}}, J4&lt;:(ModelingToolkit.PreparedJacobian{true, DifferentiationInterfaceForwardDiffExt.ForwardDiffTwoArgJacobianPrep{Nothing, C, Tuple{Nothing, Nothing, Nothing}}, ModelingToolkit.var&quot;#hpf#815&quot;{fun, setter}, _A, ADTypes.AutoForwardDiff{nothing, Nothing}} where {C&lt;:(ForwardDiff.JacobianConfig{T, _A, _B, &lt;:Tuple{Any, Any}} where {T&lt;:(ForwardDiff.Tag{F} where F&lt;:ModelingToolkit.var&quot;#hpf#815&quot;), _A, _B}), fun, setter, _A}), IA&lt;:Union{SciMLBase.NoInit, SciMLBase.OverrideInit{Nothing, Nothing, Nothing}}}, Any}
</code></pre><p>Return the loop-transfer function for the analysis point(s) <code>aps</code>, and the modified system simplified with the appropriate inputs and outputs.</p><p><strong>Keyword Arguments</strong></p><pre><code class="nohighlight hljs">- `loop_openings`: A list of analysis points whose connections should be removed and
  the outputs set to zero as a part of the linear analysis.

- `system_modifier`: A function taking the transformed system and applying any
  additional transformations, returning the modified system. The modified system
  is passed to `linearization_function`.</code></pre><p>All other keyword arguments are forwarded to <code>linearization_function</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/60c95b9a71ec4350e4409b27b0eeb9d8c05fe1fe/src/systems/analysis_points.jl#L886-L898">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.get_sensitivity-tutorials-disturbance_modeling" href="#ModelingToolkit.get_sensitivity-tutorials-disturbance_modeling"><code>ModelingToolkit.get_sensitivity</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">    get_sensitivity(sys, ap::AnalysisPoint; kwargs)
    get_sensitivity(sys, ap_name::Symbol; kwargs)</code></pre><p>Compute the sensitivity function in analysis point <code>ap</code>. The sensitivity function is obtained by introducing an infinitesimal perturbation <code>d</code> at the input of <code>ap</code>, linearizing the system and computing the transfer function between <code>d</code> and the output of <code>ap</code>.</p><p><strong>Arguments:</strong></p><ul><li><code>kwargs</code>: Are sent to <code>ModelingToolkit.linearize</code></li></ul><p>See also <a href="../linear_analysis/#ModelingToolkit.get_comp_sensitivity"><code>get_comp_sensitivity</code></a>, <a href="../linear_analysis/#ModelingToolkit.get_looptransfer"><code>get_looptransfer</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/60c95b9a71ec4350e4409b27b0eeb9d8c05fe1fe/src/systems/analysis_points.jl#L965-L976">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.get_sensitivity_function-Tuple{ModelingToolkit.AbstractSystem, Any}-tutorials-disturbance_modeling" href="#ModelingToolkit.get_sensitivity_function-Tuple{ModelingToolkit.AbstractSystem, Any}-tutorials-disturbance_modeling"><code>ModelingToolkit.get_sensitivity_function</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_sensitivity_function(
    sys::ModelingToolkit.AbstractSystem,
    aps;
    kwargs...
) -&gt; Tuple{ModelingToolkit.LinearizationFunction{DI, AI, _A, P, _B, _C, J1, J2, J3, J4, IA, @NamedTuple{abstol::Float64, reltol::Float64, nlsolve_alg::NonlinearSolveFirstOrder.GeneralizedFirstOrderAlgorithm{Missing, NonlinearSolveFirstOrder.GenericTrustRegionScheme{NonlinearSolveFirstOrder.RadiusUpdateSchemes.__Simple, Rational{Int64}, Rational{Int64}, Rational{Int64}, Rational{Int64}, Rational{Int64}, Rational{Int64}, Rational{Int64}}, NonlinearSolveBase.Dogleg{NonlinearSolveBase.NewtonDescent{Nothing}, NonlinearSolveBase.SteepestDescent{Nothing}}, Nothing, Nothing, Nothing, Val{false}}}} where {DI&lt;:AbstractVector{Int64}, AI&lt;:AbstractVector{Int64}, _A, P&lt;:ODEProblem, _B, _C, J1&lt;:Union{Nothing, ModelingToolkit.PreparedJacobian{true, DifferentiationInterfaceForwardDiffExt.ForwardDiffTwoArgJacobianPrep{Nothing, C, Tuple{Nothing, Nothing}}, ModelingToolkit.var&quot;#uff#816&quot;{var&quot;#1475#fun&quot;}, _A, ADTypes.AutoForwardDiff{nothing, Nothing}} where {C&lt;:(ForwardDiff.JacobianConfig{T, _A, _B, &lt;:Tuple{Any, Any}} where {T&lt;:(ForwardDiff.Tag{F} where F&lt;:ModelingToolkit.var&quot;#uff#816&quot;), _A, _B}), var&quot;#1475#fun&quot;, _A}}, J2&lt;:Union{Nothing, ModelingToolkit.PreparedJacobian{true, DifferentiationInterfaceForwardDiffExt.ForwardDiffTwoArgJacobianPrep{Nothing, C, Tuple{Nothing, Nothing}}, _A, _B, ADTypes.AutoForwardDiff{nothing, Nothing}} where {C&lt;:ForwardDiff.JacobianConfig, _A, _B}}, J3&lt;:Union{Nothing, ModelingToolkit.PreparedJacobian{true, DifferentiationInterfaceForwardDiffExt.ForwardDiffTwoArgJacobianPrep{Nothing, C, Tuple{Nothing, Nothing, Nothing}}, ModelingToolkit.var&quot;#pff#817&quot;{var&quot;#1476#fun&quot;, var&quot;#1477#setter&quot;}, _A, ADTypes.AutoForwardDiff{nothing, Nothing}} where {C&lt;:(ForwardDiff.JacobianConfig{T, _A, _B, &lt;:Tuple{Any, Any}} where {T&lt;:(ForwardDiff.Tag{F} where F&lt;:ModelingToolkit.var&quot;#pff#817&quot;), _A, _B}), var&quot;#1476#fun&quot;, var&quot;#1477#setter&quot;, _A}}, J4&lt;:(ModelingToolkit.PreparedJacobian{true, DifferentiationInterfaceForwardDiffExt.ForwardDiffTwoArgJacobianPrep{Nothing, C, Tuple{Nothing, Nothing, Nothing}}, ModelingToolkit.var&quot;#hpf#815&quot;{fun, setter}, _A, ADTypes.AutoForwardDiff{nothing, Nothing}} where {C&lt;:(ForwardDiff.JacobianConfig{T, _A, _B, &lt;:Tuple{Any, Any}} where {T&lt;:(ForwardDiff.Tag{F} where F&lt;:ModelingToolkit.var&quot;#hpf#815&quot;), _A, _B}), fun, setter, _A}), IA&lt;:Union{SciMLBase.NoInit, SciMLBase.OverrideInit{Nothing, Nothing, Nothing}}}, Any}
</code></pre><p>Return the sensitivity function for the analysis point(s) <code>aps</code>, and the modified system simplified with the appropriate inputs and outputs.</p><p><strong>Keyword Arguments</strong></p><pre><code class="nohighlight hljs">- `loop_openings`: A list of analysis points whose connections should be removed and
  the outputs set to zero as a part of the linear analysis.

- `system_modifier`: A function taking the transformed system and applying any
  additional transformations, returning the modified system. The modified system
  is passed to `linearization_function`.</code></pre><p>All other keyword arguments are forwarded to <code>linearization_function</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/60c95b9a71ec4350e4409b27b0eeb9d8c05fe1fe/src/systems/analysis_points.jl#L852-L864">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.open_loop-Tuple{Any, Union{Symbol, AnalysisPoint}}-tutorials-disturbance_modeling" href="#ModelingToolkit.open_loop-Tuple{Any, Union{Symbol, AnalysisPoint}}-tutorials-disturbance_modeling"><code>ModelingToolkit.open_loop</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">open_loop(
    sys,
    ap::Union{Symbol, AnalysisPoint};
    system_modifier
) -&gt; Tuple{Any, Tuple{Any, Any}}
</code></pre><p>Apply <code>LoopTransferTransform</code> to the analysis point <code>ap</code> and return the result of <code>apply_transformation</code>.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>system_modifier</code>: a function which takes the modified system and returns a new system with any required further modifications performed.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/60c95b9a71ec4350e4409b27b0eeb9d8c05fe1fe/src/systems/analysis_points.jl#L913-L923">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Symbolics.connect-Tuple{ModelingToolkit.AbstractSystem, Symbol, Any, Vararg{Any}}-tutorials-disturbance_modeling" href="#Symbolics.connect-Tuple{ModelingToolkit.AbstractSystem, Symbol, Any, Vararg{Any}}-tutorials-disturbance_modeling"><code>Symbolics.connect</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">connect(output_connector, ap_name::Symbol, input_connector; verbose = true)
connect(output_connector, ap::AnalysisPoint, input_connector; verbose = true)</code></pre><p>Connect <code>output_connector</code> and <code>input_connector</code> with an <a href="../linear_analysis/#ModelingToolkit.AnalysisPoint"><code>AnalysisPoint</code></a> inbetween. The incoming connection <code>output_connector</code> is expected to be an output connector (for example, <code>ModelingToolkitStandardLibrary.Blocks.RealOutput</code>), and vice versa.</p><p><em>PLEASE NOTE</em>: The connection is assumed to be <em>causal</em>, meaning that</p><pre><code class="language-julia hljs">@named P = FirstOrder(k = 1, T = 1)
@named C = Gain(; k = -1)
connect(C.output, :plant_input, P.input)</code></pre><p>is correct, whereas</p><pre><code class="language-julia hljs">connect(P.input, :plant_input, C.output)</code></pre><p>typically is not (unless the model is an inverse model).</p><p><strong>Arguments</strong></p><ul><li><code>output_connector</code>: An output connector</li><li><code>input_connector</code>: An input connector</li><li><code>ap</code>: An explicitly created <a href="../linear_analysis/#ModelingToolkit.AnalysisPoint"><code>AnalysisPoint</code></a></li><li><code>ap_name</code>: If a name is given, an <a href="../linear_analysis/#ModelingToolkit.AnalysisPoint"><code>AnalysisPoint</code></a> with the given name will be created automatically.</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>verbose</code>: Warn if an input is connected to an output (reverse causality). Silence this warning if you are analyzing an inverse model.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/60c95b9a71ec4350e4409b27b0eeb9d8c05fe1fe/src/systems/analysis_points.jl#L183-L219">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.AnalysisPoint-Tuple{Symbol}-tutorials-disturbance_modeling" href="#ModelingToolkit.AnalysisPoint-Tuple{Symbol}-tutorials-disturbance_modeling"><code>ModelingToolkit.AnalysisPoint</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AnalysisPoint(name::Symbol) -&gt; AnalysisPoint
</code></pre><p>Create an <code>AnalysisPoint</code> with the given name, with no input or outputs specified.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/60c95b9a71ec4350e4409b27b0eeb9d8c05fe1fe/src/systems/analysis_points.jl#L108-L112">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.AnalysisPoint-tutorials-disturbance_modeling" href="#ModelingToolkit.AnalysisPoint-tutorials-disturbance_modeling"><code>ModelingToolkit.AnalysisPoint</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct AnalysisPoint</code></pre><pre><code class="nohighlight hljs">AnalysisPoint(input, name::Symbol, outputs::Vector)</code></pre><p>Create an AnalysisPoint for linear analysis. Analysis points can be created by calling</p><pre><code class="nohighlight hljs">connect(out, :ap_name, in...)</code></pre><p>Where <code>out</code> is the output being connected to the inputs <code>in...</code>. All involved connectors (input and outputs) are required to either have an unknown named <code>u</code> or a single unknown, all of which should have the same size.</p><p>See also <a href="../linear_analysis/#ModelingToolkit.get_sensitivity"><code>get_sensitivity</code></a>, <a href="../linear_analysis/#ModelingToolkit.get_comp_sensitivity"><code>get_comp_sensitivity</code></a>, <a href="../linear_analysis/#ModelingToolkit.get_looptransfer"><code>get_looptransfer</code></a>, <a href="#ModelingToolkit.open_loop-Tuple{Any, Union{Symbol, AnalysisPoint}}-tutorials-disturbance_modeling"><code>open_loop</code></a></p><p><strong>Fields</strong></p><ul><li><code>input::Any</code>: The input to the connection. In the context of ModelingToolkitStandardLibrary.jl, this is a <code>RealOutput</code> connector.</li></ul><ul><li><code>name::Symbol</code>: The name of the analysis point.</li></ul><ul><li><code>outputs::Union{Nothing, Vector{Any}}</code>: The outputs of the connection. In the context of ModelingToolkitStandardLibrary.jl, these are all <code>RealInput</code> connectors.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">using ModelingToolkit
using ModelingToolkitStandardLibrary.Blocks
using ModelingToolkit: t_nounits as t

@named P = FirstOrder(k = 1, T = 1)
@named C = Gain(; k = -1)
t = ModelingToolkit.get_iv(P)

eqs = [connect(P.output, C.input)
       connect(C.output, :plant_input, P.input)]
sys = ODESystem(eqs, t, systems = [P, C], name = :feedback_system)

matrices_S, _ = get_sensitivity(sys, :plant_input) # Compute the matrices of a state-space representation of the (input) sensitivity function.
matrices_T, _ = get_comp_sensitivity(sys, :plant_input)</code></pre><p>Continued linear analysis and design can be performed using ControlSystemsBase.jl. Create <code>ControlSystemsBase.StateSpace</code> objects using</p><pre><code class="language-julia hljs">using ControlSystemsBase, Plots
S = ss(matrices_S...)
T = ss(matrices_T...)
bodeplot([S, T], lab = [&quot;S&quot; &quot;T&quot;])</code></pre><p>The sensitivity functions obtained this way should be equivalent to the ones obtained with the code below</p><pre><code class="language-julia hljs">using ControlSystemsBase
P = tf(1.0, [1, 1])
C = 1                      # Negative feedback assumed in ControlSystems
S = sensitivity(P, C)      # or feedback(1, P*C)
T = comp_sensitivity(P, C) # or feedback(P*C)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/60c95b9a71ec4350e4409b27b0eeb9d8c05fe1fe/src/systems/analysis_points.jl#L1-L59">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../linear_analysis/">« Linear Analysis</a><a class="docs-footer-nextpage" href="../fmi/">Importing FMUs »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.11.0 on <span class="colophon-date" title="Tuesday 13 May 2025 13:45">Tuesday 13 May 2025</span>. Using Julia version 1.10.9.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
