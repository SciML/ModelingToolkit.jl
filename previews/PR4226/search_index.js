var documenterSearchIndex = {"docs":
[{"location":"tutorials/ode_modeling/#getting_started","page":"Getting Started with ModelingToolkit.jl","title":"Getting Started with ModelingToolkit.jl","text":"This is an introductory tutorial for ModelingToolkit (MTK). We will demonstrate the basics of the package by demonstrating how to define and simulate simple Ordinary Differential Equation (ODE) systems.","category":"section"},{"location":"tutorials/ode_modeling/#Installing-ModelingToolkit","page":"Getting Started with ModelingToolkit.jl","title":"Installing ModelingToolkit","text":"To install ModelingToolkit, use the Julia package manager. This can be done as follows:\n\nusing Pkg\nPkg.add(\"ModelingToolkit\")","category":"section"},{"location":"tutorials/ode_modeling/#Copy-Pastable-Simplified-Example","page":"Getting Started with ModelingToolkit.jl","title":"Copy-Pastable Simplified Example","text":"A much deeper tutorial with forcing functions and sparse Jacobians is below. But if you want to just see some code and run it, here's an example:\n\nusing ModelingToolkit\nusing ModelingToolkit: t_nounits as t, D_nounits as D\n\n@parameters τ = 3.0 # parameters\n@variables x(t) = 0.0 # dependent variables\neqs = [D(x) ~ (1 - x) / τ]\n\n@named fol_model = System(eqs, t)\n\nusing OrdinaryDiffEq\nfol = mtkcompile(fol_model)\nprob = ODEProblem(fol, [], (0.0, 10.0))\nsol = solve(prob)\n\nusing Plots\nplot(sol)\n\nNow let's start digging into MTK!","category":"section"},{"location":"tutorials/ode_modeling/#Your-very-first-ODE","page":"Getting Started with ModelingToolkit.jl","title":"Your very first ODE","text":"Let us start with a minimal example. The system to be modelled is a first-order lag element:\n\ndotx = fracf(t) - x(t)tau\n\nHere, t is the independent variable (time), x(t) is the (scalar) unknown variable, f(t) is an external forcing function, and tau is a parameter. In MTK, this system can be modelled as follows. For simplicity, we first set the forcing function to a time-independent value 1.\n\nusing ModelingToolkit\nusing ModelingToolkit: t_nounits as t, D_nounits as D\n\n@parameters τ = 3.0 # parameters and their values\n@variables x(t) = 0.0 # dependent variables and their initial conditions\neqs = [D(x) ~ (1 - x) / τ]\n\n@named fol_model = System(eqs, t)\nfol = mtkcompile(fol_model)\n\nNote that equations in MTK use the tilde character (~) as equality sign.\n\nmtkcompile transforms the System into a simplified form ready for numerical solving.\n\nAfter construction of the ODE, you can solve it using OrdinaryDiffEq.jl:\n\nusing OrdinaryDiffEq\nusing Plots\n\nprob = ODEProblem(fol, [], (0.0, 10.0))\nplot(solve(prob))\n\nThe parameter values are determined using the right hand side of the expressions in @parameters, and similarly initial conditions are determined using the right hand side of the expressions in @variables.","category":"section"},{"location":"tutorials/ode_modeling/#Using-different-values-for-parameters-and-initial-conditions","page":"Getting Started with ModelingToolkit.jl","title":"Using different values for parameters and initial conditions","text":"If you want to simulate the same model, but with different values for the parameters and initial conditions than the default values, you can overwrite them at the ODEProblem level:\n\nprob = ODEProblem(fol, [fol.x => 0.5, fol.τ => 1 / 3], (0.0, 10.0))\nplot(solve(prob))\n\nHere, the second argument of ODEProblem is an array of Pairs. The left hand side of each Pair is the parameter or variable you want to overwrite, and the right hand side is the value to overwrite it with. Note that variables and parameters must be referred to with their namespaced form (e.g., fol.τ).","category":"section"},{"location":"tutorials/ode_modeling/#Algebraic-relations-and-structural-simplification","page":"Getting Started with ModelingToolkit.jl","title":"Algebraic relations and structural simplification","text":"You could separate the calculation of the right-hand side, by introducing an intermediate variable RHS:\n\nusing ModelingToolkit\nusing ModelingToolkit: t_nounits as t, D_nounits as D\n\n@parameters τ = 3.0 # parameters and their values\n@variables x(t) = 0.0 RHS(t) # dependent variables and their initial conditions\neqs = [\n    RHS ~ (1 - x) / τ\n    D(x) ~ RHS\n]\n\n@named fol_model = System(eqs, t)\nfol = mtkcompile(fol_model)\n\nIf you copy this block of code to your REPL, you will not see the above LaTeX equations. Instead, you can look at the equations by using the equations function:\n\nequations(fol)\n\nNotice that there is only one equation in this system, Differential(t)(x(t)) ~ RHS(t). The other equation was removed from the system and was transformed into an observed variable. Observed equations are variables that can be computed on-demand but are not necessary for the solution of the system, and thus MTK tracks them separately. For this reason, we also did not need to specify an initial condition for RHS. You can check the observed equations via the observed function:\n\nobserved(fol)\n\nFor more information on this process, see Observables and Variable Elimination.\n\nMTK still knows how to calculate them out of the information available in a simulation result. The intermediate variable RHS therefore can be plotted along with the unknown variable. Note that this has to be requested explicitly:\n\nprob = ODEProblem(fol, [], (0.0, 10.0))\nsol = solve(prob)\nplot(sol, idxs = [fol.x, fol.RHS])","category":"section"},{"location":"tutorials/ode_modeling/#Named-Indexing-of-Solutions","page":"Getting Started with ModelingToolkit.jl","title":"Named Indexing of Solutions","text":"Note that the indexing of the solution also works via the symbol, and so to get the time series for x, you would do:\n\nsol[fol.x]\n\nor to get the second value in the time series for x:\n\nsol[fol.x, 2]\n\nSimilarly, the time series for RHS can be retrieved using the same symbolic indexing:\n\nsol[fol.RHS]","category":"section"},{"location":"tutorials/ode_modeling/#Specifying-a-time-variable-forcing-function","page":"Getting Started with ModelingToolkit.jl","title":"Specifying a time-variable forcing function","text":"What if the forcing function (the \"external input\") f(t) is not constant? Obviously, one could use an explicit, symbolic function of time:\n\n@parameters τ = 3.0 # parameters and their values\n@variables x(t) = 0.0 f(t) # dependent variables and their initial conditions\neqs = [\n    f ~ sin(t)\n    D(x) ~ (f - x) / τ\n]\n\n@named fol_model = System(eqs, t)\nfol_variable_f = mtkcompile(fol_model)\n\nHowever, this function might not be available in an explicit form. Instead, the function might be provided as time-series data. MTK handles this situation by allowing us to \"register\" arbitrary Julia functions, which are excluded from symbolic transformations and thus used as-is. For example, you could interpolate given the time-series using DataInterpolations.jl. Here, we illustrate this option with a simple lookup (\"zero-order hold\") of a vector of random values:\n\nvalue_vector = randn(10)\nf_fun(t) = t >= 10 ? value_vector[end] : value_vector[Int(floor(t)) + 1]\n@register_symbolic f_fun(t)\n\n@parameters τ = 0.75 # parameters and their values\n@variables x(t) = 0.0 f(t) # dependent variables and their initial conditions\neqs = [\n    f ~ f_fun(t)\n    D(x) ~ (f - x) / τ\n]\n\n@named fol_model = System(eqs, t)\nfol_external_f = mtkcompile(fol_model)\n\nprob = ODEProblem(fol_external_f, [], (0.0, 10.0))\nsol = solve(prob)\nplot(sol, idxs = [fol_external_f.x, fol_external_f.f])","category":"section"},{"location":"tutorials/ode_modeling/#Building-component-based,-hierarchical-models","page":"Getting Started with ModelingToolkit.jl","title":"Building component-based, hierarchical models","text":"Working with simple one-equation systems is already fun, but composing more complex systems from simple ones is even more fun. The best practice for such a \"modeling framework\" is to define reusable component systems and compose them:\n\n# Define a reusable component function that creates a first-order lag system\nfunction FOLComponent(; name, τ = 1.0, x0 = 0.0)\n    @parameters τ = τ\n    @variables x(t) = x0 f(t) RHS(t)\n    eqs = [\n        RHS ~ f\n        D(x) ~ (RHS - x) / τ\n    ]\n    return System(eqs, t, [x, f, RHS], [τ]; name)\nend\n\n# Create two instances of the component with different parameters\n@named fol_1 = FOLComponent(τ = 2.0, x0 = -0.5)\n@named fol_2 = FOLComponent(τ = 4.0, x0 = 1.0)\n\n# Connect them: fol_1 has constant input, fol_2 uses fol_1's output\nconnection_eqs = [\n    fol_1.f ~ 1.5\n    fol_2.f ~ fol_1.x\n]\n\n@named connected_model = System(connection_eqs, t, [], []; systems = [fol_1, fol_2])\nconnected = mtkcompile(connected_model)\n\nHere the total model consists of two of the same submodels (components), but with a different input function, parameter values and initial conditions. The first model has a constant input, and the second model uses the state x of the first system as an input. To avoid having to type the same differential equation multiple times, we define the submodel in a function that returns a System. We then reuse this function twice to create the component systems. The inputs of two submodels then still have to be specified in connection equations.\n\nAll equations, variables, and parameters are collected, but the structure of the hierarchical model is still preserved. This means you can still get information about fol_1 by addressing it by connected.fol_1, or its parameter by connected.fol_1.τ.\n\nAs expected, only the two equations with the derivatives of unknowns remain, as if you had manually eliminated as many variables as possible from the equations. Some observed variables are not expanded unless full_equations is used. As mentioned above, the hierarchical structure is preserved. So, the initial unknown and the parameter values can be specified accordingly when building the ODEProblem:\n\nprob = ODEProblem(connected, [], (0.0, 10.0))\nplot(solve(prob))\n\nMore on this topic may be found in Composing Models and Building Reusable Components.","category":"section"},{"location":"tutorials/ode_modeling/#Symbolic-and-sparse-derivatives","page":"Getting Started with ModelingToolkit.jl","title":"Symbolic and sparse derivatives","text":"One advantage of a symbolic toolkit is that derivatives can be calculated explicitly, and that the incidence matrix of partial derivatives (the \"sparsity pattern\") can also be explicitly derived. These two facts lead to a substantial speedup of all model calculations, e.g. when simulating a model over time using an ODE solver.\n\nBy default, analytical derivatives and sparse matrices, e.g. for the Jacobian, the matrix of first partial derivatives, are not used. Let's benchmark this (prob still is the problem using the connected system above):\n\nusing BenchmarkTools\n@btime solve(prob, Rodas4());\nnothing # hide\n\nNow have MTK provide sparse, analytical derivatives to the solver. This has to be specified during the construction of the ODEProblem:\n\nprob_an = ODEProblem(connected, [], (0.0, 10.0); jac = true)\n@btime solve(prob_an, Rodas4());\nnothing # hide\n\nprob_sparse = ODEProblem(connected, [], (0.0, 10.0); jac = true, sparse = true)\n@btime solve(prob_sparse, Rodas4());\nnothing # hide\n\nThe speedup using the analytical Jacobian is significant. For this small dense model (3 of 4 entries populated), using sparse matrices is counterproductive in terms of required memory allocations. For large, hierarchically built models, which tend to be sparse, speedup and the reduction of memory allocation can also be expected to be substantial. In addition, these problem builders allow for automatic parallelism by exploiting the structural information. For more information, see the System page.","category":"section"},{"location":"tutorials/ode_modeling/#Notes-and-pointers-how-to-go-on","page":"Getting Started with ModelingToolkit.jl","title":"Notes and pointers how to go on","text":"Here are some notes that may be helpful during your initial steps with MTK:\n\nFor high-level component-based modeling with convenient macros like @mtkmodel, see the ModelingToolkit Language Tutorial which covers @mtkmodel and @connector.\nThe approach shown in this tutorial using direct System construction is useful when you need to programmatically generate systems. For more details, check out the Programmatically Generating and Scripting Systems Tutorial.\nVector-valued parameters and variables are possible. A cleaner, more consistent treatment of these is still a work in progress, however. Once finished, this introductory tutorial will also cover this feature.\n\nWhere to go next?\n\nNot sure how MTK relates to similar tools and packages? Read Comparison of ModelingToolkit vs Equation-Based and Block Modeling Languages.\nFor a more detailed explanation of @mtkmodel checkout Defining components with @mtkmodel and connectors with @connectors\nDepending on what you want to do with MTK, have a look at some of the other Symbolic Modeling Tutorials.\nIf you want to automatically convert an existing function to a symbolic representation, you might go through the ModelingToolkitize Tutorials.\nTo learn more about the inner workings of MTK, consider the sections under Basics and System Types.","category":"section"},{"location":"examples/remake/#Optimizing-through-an-ODE-solve-and-re-creating-MTK-Problems","page":"Optimizing through an ODE solve and re-creating MTK Problems","title":"Optimizing through an ODE solve and re-creating MTK Problems","text":"Solving an ODE as part of an OptimizationProblem's loss function is a common scenario. In this example, we will go through an efficient way to model such scenarios using ModelingToolkit.jl.\n\nFirst, we build the ODE to be solved. For this example, we will use a Lotka-Volterra model:\n\nusing ModelingToolkit\nusing ModelingToolkit: t_nounits as t, D_nounits as D\n\n@parameters α β γ δ\n@variables x(t) y(t)\neqs = [D(x) ~ (α - β * y) * x\n       D(y) ~ (δ * x - γ) * y]\n@mtkcompile odesys = System(eqs, t)\n\nTo create the \"data\" for optimization, we will solve the system with a known set of parameters.\n\nusing OrdinaryDiffEq\n\nodeprob = ODEProblem(\n    odesys, [x => 1.0, y => 1.0, α => 1.5, β => 1.0, γ => 3.0, δ => 1.0], (0.0, 10.0))\ntimesteps = 0.0:0.1:10.0\nsol = solve(odeprob, Tsit5(); saveat = timesteps)\ndata = Array(sol)\n# add some random noise\ndata = data + 0.01 * randn(size(data))\n\nNow we will create the loss function for the Optimization solve. This will require creating an ODEProblem with the parameter values passed to the loss function. Creating a new ODEProblem is expensive and requires differentiating through the code generation process. This can be bug-prone and is unnecessary. Instead, we will leverage the remake function. This allows creating a copy of an existing problem with updating state/parameter values. It should be noted that the types of the values passed to the loss function may not agree with the types stored in the existing ODEProblem. Thus, we cannot use setp to modify the problem in-place. Here, we will use the replace function from SciMLStructures.jl since it allows updating the entire Tunable portion of the parameter object which contains the parameters to optimize.\n\nusing SymbolicIndexingInterface: parameter_values, state_values\nusing SciMLStructures: Tunable, canonicalize, replace, replace!\nusing PreallocationTools\n\nfunction loss(x, p)\n    odeprob = p[1] # ODEProblem stored as parameters to avoid using global variables\n    ps = parameter_values(odeprob) # obtain the parameter object from the problem\n    diffcache = p[5]\n    # get an appropriately typed preallocated buffer to store the `x` values in\n    buffer = get_tmp(diffcache, x)\n    # copy the current values to this buffer\n    copyto!(buffer, canonicalize(Tunable(), ps)[1])\n    # create a copy of the parameter object with the buffer\n    ps = replace(Tunable(), ps, buffer)\n    # set the updated values in the parameter object\n    setter = p[4]\n    setter(ps, x)\n    # remake the problem, passing in our new parameter object\n    newprob = remake(odeprob; p = ps)\n    timesteps = p[2]\n    sol = solve(newprob, AutoTsit5(Rosenbrock23()); saveat = timesteps)\n    truth = p[3]\n    data = Array(sol)\n    return sum((truth .- data) .^ 2) / length(truth)\nend\n\nNote how the problem, timesteps and true data are stored as model parameters. This helps avoid referencing global variables in the function, which would slow it down significantly.\n\nWe could have done the same thing by passing remake a map of parameter values. For example, let us enforce that the order of ODE parameters in x is [α β γ δ]. Then, we could have done:\n\nremake(odeprob; p = [α => x[1], β => x[2], γ => x[3], δ => x[4]])\n\nHowever, passing a symbolic map to remake is significantly slower than passing it a parameter object directly. Thus, we use replace to speed up the process. In general, remake is the most flexible method, but the flexibility comes at a cost of performance.\n\nWe can perform the optimization as below:\n\nusing Optimization\nusing OptimizationOptimJL\nusing SymbolicIndexingInterface\n\n# manually create an OptimizationFunction to ensure usage of `ForwardDiff`, which will\n# require changing the types of parameters from `Float64` to `ForwardDiff.Dual`\noptfn = OptimizationFunction(loss, Optimization.AutoForwardDiff())\n# function to set the parameters we are optimizing\nsetter = setp(odeprob, [α, β, γ, δ])\n# `DiffCache` to avoid allocations.\n# `copy` prevents the buffer stored by `DiffCache` from aliasing the one in\n# `parameter_values(odeprob)`.\ndiffcache = DiffCache(copy(canonicalize(Tunable(), parameter_values(odeprob))[1]))\n# parameter object is a tuple, to store differently typed objects together\noptprob = OptimizationProblem(\n    optfn, rand(4), (odeprob, timesteps, data, setter, diffcache),\n    lb = 0.1zeros(4), ub = 3ones(4))\nsol = solve(optprob, BFGS())","category":"section"},{"location":"examples/remake/#Re-creating-the-problem","page":"Optimizing through an ODE solve and re-creating MTK Problems","title":"Re-creating the problem","text":"There are multiple ways to re-create a problem with new state/parameter values. We will go over the various methods, listing their use cases.","category":"section"},{"location":"examples/remake/#Pure-remake","page":"Optimizing through an ODE solve and re-creating MTK Problems","title":"Pure remake","text":"This method is the most generic. It can handle symbolic maps, initializations of parameters/states dependent on each other and partial updates. However, this comes at the cost of performance. remake is also not always inferable.","category":"section"},{"location":"examples/remake/#remake-and-setp/setu","page":"Optimizing through an ODE solve and re-creating MTK Problems","title":"remake and setp/setu","text":"Calling remake(prob) creates a copy of the existing problem. This new problem has the exact same types as the original one, and the remake call is fully inferred. State/parameter values can be modified after the copy by using setp and/or setu. This is most appropriate when the types of state/parameter values does not need to be changed, only their values.","category":"section"},{"location":"examples/remake/#replace-and-remake","page":"Optimizing through an ODE solve and re-creating MTK Problems","title":"replace and remake","text":"replace returns a copy of a parameter object, with the appropriate portion replaced by new values. This is useful for changing the type of an entire portion, such as during the optimization process described above. remake is used in this case to create a copy of the problem with updated state/unknown values.","category":"section"},{"location":"examples/remake/#remake-and-replace!","page":"Optimizing through an ODE solve and re-creating MTK Problems","title":"remake and replace!","text":"replace! is similar to replace, except that it operates in-place. This means that the parameter values must be of the same types. This is useful for cases where bulk parameter replacement is required without needing to change types. For example, optimization methods where the gradient is not computed using dual numbers (as demonstrated above).","category":"section"},{"location":"API/PDESystem/#PDESystem","page":"PDESystem","title":"PDESystem","text":"PDESystem is the common symbolic PDE specification for the SciML ecosystem. It is currently being built as a component of the ModelingToolkit ecosystem,","category":"section"},{"location":"API/PDESystem/#Vision","page":"PDESystem","title":"Vision","text":"The vision for the common PDE interface is that a user should only have to specify their PDE once, mathematically, and have instant access to everything as simple as a finite difference method with constant grid spacing, to something as complex as a distributed multi-GPU discontinuous Galerkin method.\n\nThe key to the common PDE interface is a separation of the symbolic handling from the numerical world. All the discretizers should not “solve” the PDE, but instead be a conversion of the mathematical specification to a numerical problem. Preferably, the transformation should be to another ModelingToolkit.jl AbstractSystem, but in some cases this cannot be done or will not be performant, so a SciMLProblem is the other choice.\n\nThese elementary problems, such as solving linear systems Ax=b, solving nonlinear systems f(x)=0, ODEs, etc. are all defined by SciMLBase.jl, which then numerical solvers can all target these common forms. Thus, someone who works on linear solvers doesn't necessarily need to be working on a discontinuous Galerkin or finite element library, but instead \"linear solvers that are good for matrices A with properties ...\" which are then accessible by every other discretization method in the common PDE interface.\n\nSimilar to the rest of the AbstractSystem types, transformation, and analysis functions will allow for simplifying the PDE before solving it, and constructing block symbolic functions like Jacobians.","category":"section"},{"location":"API/PDESystem/#Constructors","page":"PDESystem","title":"Constructors","text":"","category":"section"},{"location":"API/PDESystem/#Domains-(WIP)","page":"PDESystem","title":"Domains (WIP)","text":"Domains are specifying by saying indepvar in domain, where indepvar is a single or a collection of independent variables, and domain is the chosen domain type. A 2-tuple can be used to indicate an Interval. Thus forms for the indepvar can be like:\n\nt ∈ (0.0, 1.0)\n(t, x) ∈ UnitDisk()\n[v, w, x, y, z] ∈ VectorUnitBall(5)","category":"section"},{"location":"API/PDESystem/#Domain-Types-(WIP)","page":"PDESystem","title":"Domain Types (WIP)","text":"Interval(a,b): Defines the domain of an interval from a to b (requires explicit import from DomainSets.jl, but a 2-tuple can be used instead)","category":"section"},{"location":"API/PDESystem/#discretize-and-symbolic_discretize","page":"PDESystem","title":"discretize and symbolic_discretize","text":"The only functions which act on a PDESystem are the following:\n\ndiscretize(sys,discretizer): produces the outputted AbstractSystem or SciMLProblem.\nsymbolic_discretize(sys,discretizer): produces a debugging symbolic description of the discretized problem.","category":"section"},{"location":"API/PDESystem/#Boundary-Conditions-(WIP)","page":"PDESystem","title":"Boundary Conditions (WIP)","text":"","category":"section"},{"location":"API/PDESystem/#Transformations","page":"PDESystem","title":"Transformations","text":"","category":"section"},{"location":"API/PDESystem/#Analyses","page":"PDESystem","title":"Analyses","text":"","category":"section"},{"location":"API/PDESystem/#Discretizer-Ecosystem","page":"PDESystem","title":"Discretizer Ecosystem","text":"","category":"section"},{"location":"API/PDESystem/#NeuralPDE.jl:-PhysicsInformedNN","page":"PDESystem","title":"NeuralPDE.jl: PhysicsInformedNN","text":"NeuralPDE.jl defines the PhysicsInformedNN discretizer which uses a DiffEqFlux.jl neural network to solve the differential equation.","category":"section"},{"location":"API/PDESystem/#MethodOfLines.jl:-MOLFiniteDifference","page":"PDESystem","title":"MethodOfLines.jl: MOLFiniteDifference","text":"MethodOfLines.jl defines the MOLFiniteDifference discretizer which performs a finite difference discretization. Includes support for higher approximation order stencils and nonuniform grids.","category":"section"},{"location":"basics/FAQ/#Frequently-Asked-Questions","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"","category":"section"},{"location":"basics/FAQ/#Why-are-my-parameters-some-obscure-object?","page":"Frequently Asked Questions","title":"Why are my parameters some obscure object?","text":"In ModelingToolkit.jl version 9, the parameter vector was replaced with a custom MTKParameters object, whose internals are intentionally undocumented and subject to change without a breaking release. This enables us to efficiently store and generate code for parameters of multiple types. To obtain parameter values use SymbolicIndexingInterface.jl or SciMLStructures.jl. For example:\n\nprob.ps[lorenz.β] # obtains the value of parameter `β`. Note the `.ps` instead of `.p`\ngetβ = getp(prob, lorenz.β) # returns a function that can fetch the value of `β`\ngetβ(sol) # can be used on any object that is based off of the same system\ngetβ(prob)\n\nIndexes into the MTKParameters object take the form of ParameterIndex objects, which are similarly undocumented. Following is the list of behaviors that should be relied on for MTKParameters:\n\nIt implements the SciMLStructures interface.\nIt can be queried for parameters using functions returned from SymbolicIndexingInterface.getp.\ngetindex(::MTKParameters, ::ParameterIndex) can be used to obtain the value of a parameter with the given index.\nsetindex!(::MTKParameters, value, ::ParameterIndex) can be used to set the value of a parameter with the given index.\nparameter_index(sys, sym) will return a ParameterIndex object if sys has been completed (through mtkcompile, complete or @mtkcompile).\ncopy(::MTKParameters) is defined and duplicates the parameter object, including the memory used by the underlying buffers.\n\nAny other behavior of MTKParameters (other getindex/setindex! methods, etc.) is an undocumented internal and should not be relied upon.","category":"section"},{"location":"basics/FAQ/#How-do-I-use-non-numeric/array-valued-parameters?","page":"Frequently Asked Questions","title":"How do I use non-numeric/array-valued parameters?","text":"In ModelingToolkit.jl version 9, parameters are required to have a symtype matching the type of their values. For example, this will error during problem construction:\n\n@parameters p = [1, 2, 3]\n\nSince by default parameters have a symtype of Real (which is interpreted as Float64) but the default value given to it is a Vector{Int}. For array-valued parameters, use the following syntax:\n\n@parameters p[1:n, 1:m]::T # `T` is the `eltype` of the parameter array\n@parameters p::T # `T` is the type of the array\n\nThe former approach is preferred, since the size of the array is known. If the array is not a Base.Array or the size is not known during model construction, the second syntax is required.\n\nThe same principle applies to any parameter type that is not Float64.\n\n@parameters p1::Int # integer-valued\n@parameters p2::Bool # boolean-valued\n@parameters p3::MyCustomStructType # non-numeric\n@parameters p4::ComponentArray{_...} # non-standard array","category":"section"},{"location":"basics/FAQ/#Getting-the-index-for-a-symbol","page":"Frequently Asked Questions","title":"Getting the index for a symbol","text":"Ordering of symbols is not guaranteed after symbolic transformations, and parameters are now stored in a custom MTKParameters object instead of a vector. Thus, values should be referred to by their name. For example sol[lorenz.x]. To obtain the index, use the following functions from SymbolicIndexingInterface.jl:\n\nvariable_index(sys, sym)\nparameter_index(sys, sym)\n\nNote that while the variable index will be an integer, the parameter index is a struct of type ParameterIndex whose internals should not be relied upon.","category":"section"},{"location":"basics/FAQ/#Can-I-index-with-strings?","page":"Frequently Asked Questions","title":"Can I index with strings?","text":"Strings are not considered symbolic variables, and thus cannot directly be used for symbolic indexing. However, ModelingToolkit does provide a method to parse the string representation of a variable, given the system in which that variable exists.","category":"section"},{"location":"basics/FAQ/#Transforming-value-maps-to-arrays","page":"Frequently Asked Questions","title":"Transforming value maps to arrays","text":"ModelingToolkit.jl allows (and recommends) input maps like [x => 2.0, y => 3.0] because symbol ordering is not guaranteed. However, what if you want to get the lowered array? You can use the internal function varmap_to_vars for unknowns. and the MTKParameters constructor for parameters. For example:\n\nunew = varmap_to_vars([x => 1.0, y => 2.0, z => 3.0], unknowns(sys))\npnew = ModelingToolkit.MTKParameters(sys, [β => 3.0, c => 10.0, γ => 2.0], unew)","category":"section"},{"location":"basics/FAQ/#How-do-I-handle-if-statements-in-my-symbolic-forms?","page":"Frequently Asked Questions","title":"How do I handle if statements in my symbolic forms?","text":"For statements that are in the if then else form, use Base.ifelse from the to represent the code in a functional form. For handling direct if statements, you can use equivalent boolean mathematical expressions. For example, if x > 0 ... can be implemented as just (x > 0) *, where if x <= 0 then the boolean will evaluate to 0 and thus the term will be excluded from the model.","category":"section"},{"location":"basics/FAQ/#ERROR:-TypeError:-non-boolean-(Num)-used-in-boolean-context?","page":"Frequently Asked Questions","title":"ERROR: TypeError: non-boolean (Num) used in boolean context?","text":"If you see the error:\n\nERROR: TypeError: non-boolean (Num) used in boolean context\n\nthen it's likely you are trying to trace through a function which cannot be directly represented in Julia symbols. The techniques to handle this problem, such as @register_symbolic, are described in detail in the Symbolics.jl documentation.","category":"section"},{"location":"basics/FAQ/#Using-ModelingToolkit-with-Optimization-/-Automatic-Differentiation","page":"Frequently Asked Questions","title":"Using ModelingToolkit with Optimization / Automatic Differentiation","text":"If you are using ModelingToolkit inside a loss function and are having issues with mixing MTK with automatic differentiation, getting performance, etc… don't! Instead, use MTK outside the loss function to generate the code, and then use the generated code inside the loss function.\n\nFor example, let's say you were building ODEProblems in the loss function like:\n\nfunction loss(p)\n    prob = ODEProblem(sys, [], [p1 => p[1], p2 => p[2]])\n    sol = solve(prob, Tsit5())\n    sum(abs2, sol)\nend\n\nSince ODEProblem on a MTK sys will have to generate code, this will be slower than caching the generated code, and will require automatic differentiation to go through the code generation process itself. All of this is unnecessary. Instead, generate the problem once outside the loss function, and update the parameter values inside the loss function:\n\nprob = ODEProblem(sys, [], [p1 => p[1], p2 => p[2]])\nfunction loss(p)\n    # update parameters\n    sol = solve(prob, Tsit5())\n    sum(abs2, sol)\nend\n\nIf a subset of the parameters are optimized, setp from SymbolicIndexingInterface.jl should be used to generate an efficient function for setting parameter values. For example:\n\nusing SymbolicIndexingInterface\n\nprob = ODEProblem(sys, [], [p1 => p[1], p2 => p[2]])\nsetter! = setp(sys, [p1, p2])\nfunction loss(p)\n    setter!(prob, p)\n    sol = solve(prob, Tsit5())\n    sum(abs2, sol)\nend\n\nSciMLStructures.jl can be leveraged to obtain all the parameters for optimization using the Tunable portion. By default, all numeric or numeric array parameters are marked as tunable, unless explicitly marked as tunable = false in the variable metadata.\n\nusing SciMLStructures: replace!, Tunable\n\nprob = ODEProblem(sys, [], [p1 => p[1], p2 => p[2]])\nfunction loss(p)\n    replace!(Tunable(), prob.p, p)\n    sol = solve(prob, Tsit5())\n    sum(abs2, sol)\nend\n\np, replace, alias = SciMLStructures.canonicalize(Tunable(), prob.p)\n# p is an `AbstractVector` which can be optimized\n# if `alias == true`, then `p` aliases the memory used by `prob.p`, so\n# changes to the array will be reflected in parameter values","category":"section"},{"location":"basics/FAQ/#ERROR:-ArgumentError:-[xˍt(t)]-are-missing-from-the-variable-map.","page":"Frequently Asked Questions","title":"ERROR: ArgumentError: [xˍt(t)] are missing from the variable map.","text":"This error can come up after running mtkcompile on a system that generates dummy derivatives (i.e. variables with ˍt).  For example, here even though all the variables are defined with initial values, the ODEProblem generation will throw an error that defaults are missing from the variable map.\n\nusing ModelingToolkit\nusing ModelingToolkit: t_nounits as t, D_nounits as D\n\nsts = @variables x1(t)=0.0 x2(t)=0.0 x3(t)=0.0 x4(t)=0.0\neqs = [x1 + x2 + 1 ~ 0\n       x1 + x2 + x3 + 2 ~ 0\n       x1 + D(x3) + x4 + 3 ~ 0\n       2 * D(D(x1)) + D(D(x2)) + D(D(x3)) + D(x4) + 4 ~ 0]\n@named sys = System(eqs, t)\nsys = mtkcompile(sys)\nprob = ODEProblem(sys, [], (0, 1))\n\nWe can solve this problem by using the missing_variable_defaults() function\n\nprob = ODEProblem(sys, ModelingToolkit.missing_variable_defaults(sys), (0, 1))\n\nThis function provides 0 for the default values, which is a safe assumption for dummy derivatives of most models.  However, the 2nd argument allows for a different default value or values to be used if needed.\n\njulia> ModelingToolkit.missing_variable_defaults(sys, [1,2,3])\n3-element Vector{Pair}:\n  x1ˍt(t) => 1\n x2ˍtt(t) => 2\n x3ˍtt(t) => 3","category":"section"},{"location":"basics/FAQ/#Change-the-unknown-variable-vector-type","page":"Frequently Asked Questions","title":"Change the unknown variable vector type","text":"Use the u0_constructor keyword argument to map an array to the desired container type. For example:\n\nusing ModelingToolkit, StaticArrays\nusing ModelingToolkit: t_nounits as t, D_nounits as D\n\nsts = @variables x1(t) = 0.0\neqs = [D(x1) ~ 1.1 * x1]\n@mtkcompile sys = System(eqs, t)\nprob = ODEProblem{false}(sys, [], (0, 1); u0_constructor = x -> SVector(x...))","category":"section"},{"location":"basics/FAQ/#Using-a-custom-independent-variable","page":"Frequently Asked Questions","title":"Using a custom independent variable","text":"When possible, we recommend using ModelingToolkit: t_nounits as t, D_nounits as D as the independent variable and its derivative. However, if you want to use your own, you can do so:\n\nusing ModelingToolkit\n\n@independent_variables x\nD = Differential(x)\n@variables y(x)\n@named sys = System([D(y) ~ x], x)","category":"section"},{"location":"basics/FAQ/#Ordering-of-tunable-parameters","page":"Frequently Asked Questions","title":"Ordering of tunable parameters","text":"Tunable parameters are floating point parameters, not used in callbacks and not marked with tunable = false in their metadata. These are expected to be used with AD and optimization libraries. As such, they are stored together in one Vector{T}. To obtain the ordering of tunable parameters in this buffer, use:\n\nIf you have an array in which a particular dimension is in the order of tunable parameters (e.g. the jacobian with respect to tunables) then that dimension of the array can be reordered into the required permutation using the symbolic variables:\n\nFor example:\n\nusing ModelingToolkit\n\n@parameters p q[1:3] r[1:2, 1:2]\n\n@named sys = System(Equation[], ModelingToolkit.t_nounits, [], [p, q, r])\nsys = complete(sys)\n\nThe canonicalized tunables portion of MTKParameters will be in the order of tunables:\n\nusing SciMLStructures: canonicalize, Tunable\n\nps = MTKParameters(sys, [p => 1.0, q => [2.0, 3.0, 4.0], r => [5.0 6.0; 7.0 8.0]])\narr = canonicalize(Tunable(), ps)[1]\n\nWe can reorder this to contain the value for p, then all values for q, then for r using:\n\nreorder_dimension_by_tunables(sys, arr, [p, q, r])\n\nThis also works with interleaved subarrays of symbolics:\n\nreorder_dimension_by_tunables(sys, arr, [q[1], r[1, :], q[2], r[2, :], q[3], p])\n\nAnd arbitrary dimensions of higher dimensional arrays:\n\nhighdimarr = stack([i * arr for i in 1:5]; dims = 1)\n\nreorder_dimension_by_tunables(sys, highdimarr, [q[1:2], r[1, :], q[3], r[2, :], p]; dim = 2)","category":"section"},{"location":"basics/Composition/#components","page":"Composing Models and Building Reusable Components","title":"Composing Models and Building Reusable Components","text":"The symbolic models of ModelingToolkit can be composed together to easily build large models. The composition is lazy and only instantiated at the time of conversion to numerical models, allowing a more performant way in terms of computation time and memory.","category":"section"},{"location":"basics/Composition/#Simple-Model-Composition-Example","page":"Composing Models and Building Reusable Components","title":"Simple Model Composition Example","text":"The following is an example of building a model in a library with an optional forcing function, and allowing the user to specify the forcing later. Here, the library author defines a component named decay. The user then builds two decay components and connects them, saying the forcing term of decay1 is a constant while the forcing term of decay2 is the value of the unknown variable x.\n\nusing ModelingToolkit\nusing ModelingToolkit: t_nounits as t, D_nounits as D\n\nfunction decay(; name)\n    @parameters a\n    @variables x(t) f(t)\n    System([\n            D(x) ~ -a * x + f\n        ], t;\n        name = name)\nend\n\n@named decay1 = decay()\n@named decay2 = decay()\n\nconnected = compose(\n    System([decay2.f ~ decay1.x\n            D(decay1.f) ~ 0], t; name = :connected), decay1, decay2)\n\nequations(connected)\n\n#4-element Vector{Equation}:\n# Differential(t)(decay1₊f(t)) ~ 0\n# decay2₊f(t) ~ decay1₊x(t)\n# Differential(t)(decay1₊x(t)) ~ decay1₊f(t) - (decay1₊a*(decay1₊x(t)))\n# Differential(t)(decay2₊x(t)) ~ decay2₊f(t) - (decay2₊a*(decay2₊x(t)))\n\nsimplified_sys = mtkcompile(connected)\n\nequations(simplified_sys)\n\nNow we can solve the system:\n\nx0 = [decay1.x => 1.0\n      decay1.f => 0.0\n      decay2.x => 1.0]\np = [decay1.a => 0.1\n     decay2.a => 0.2]\n\nusing OrdinaryDiffEq\nprob = ODEProblem(simplified_sys, [x0; p], (0.0, 100.0))\nsol = solve(prob, Tsit5())\nsol[decay2.f]","category":"section"},{"location":"basics/Composition/#Basics-of-Model-Composition","page":"Composing Models and Building Reusable Components","title":"Basics of Model Composition","text":"Every AbstractSystem has a system keyword argument for specifying subsystems. A model is the composition of itself and its subsystems. For example, if we have:\n\n@named sys = compose(System(eqs, indepvar, unknowns, ps), subsys)\n\nthe equations of sys is the concatenation of get_eqs(sys) and equations(subsys), the unknowns are the concatenation of their unknowns, etc. When the ODEProblem or ODEFunction is generated from this system, it will build and compile the functions associated with this composition.\n\nThe new equations within the higher level system can access the variables in the lower level system by namespacing via the nameof(subsys). For example, let's say there is a variable x in unknowns and a variable x in subsys. We can declare that these two variables are the same by specifying their equality: x ~ subsys.x in the eqs for sys. This algebraic relationship can then be simplified by transformations like mtkcompile which will be described later.","category":"section"},{"location":"basics/Composition/#Numerics-with-Composed-Models","page":"Composing Models and Building Reusable Components","title":"Numerics with Composed Models","text":"These composed models can then be directly transformed into their associated SciMLProblem type using the standard constructors. When this is done, the initial conditions and parameters must be specified in their namespaced form. For example:\n\nu0 = [x => 2.0\n      subsys.x => 2.0]\n\nNote that any default values within the given subcomponent will be used if no override is provided at construction time. If any values for initial conditions or parameters are unspecified, an error will be thrown.\n\nWhen the model is numerically solved, the solution can be accessed via its symbolic values. For example, if sol is the ODESolution, one can use sol[x] and sol[subsys.x] to access the respective timeseries in the solution. All other indexing rules stay the same, so sol[x,1:5] accesses the first through fifth values of x. Note that this can be done even if the variable x is eliminated from the system from transformations like alias_elimination or tearing: the variable will be lazily reconstructed on demand.","category":"section"},{"location":"basics/Composition/#Variable-scope-and-parameter-expressions","page":"Composing Models and Building Reusable Components","title":"Variable scope and parameter expressions","text":"In some scenarios, it could be useful for model parameters to be expressed in terms of other parameters, or shared between common subsystems. To facilitate this, ModelingToolkit supports symbolic expressions in default values, and scoped variables.\n\nWith symbolic parameters, it is possible to set the default value of a parameter or initial condition to an expression of other variables.\n\n# ...\nsys = System(\n# ...\n# directly in the defaults argument\n    defaults = Pair{Num, Any}[x => u,\ny => σ,\nz => u - 0.1])\n# by assigning to the parameter\nsys.y = u * 1.1\n\nIn a hierarchical system, variables of the subsystem get namespaced by the name of the system they are in. This prevents naming clashes, but also enforces that every unknown and parameter is local to the subsystem it is used in. In some cases it might be desirable to have variables and parameters that are shared between subsystems, or even global. This can be accomplished as follows.\n\n@parameters a b c d\n\n# a is a local variable\nb = ParentScope(b) # b is a variable that belongs to one level up in the hierarchy\nc = ParentScope(ParentScope(c)) # ParentScope can be nested\nd = GlobalScope(d)\n\np = [a, b, c, d]\n\nlevel0 = System(Equation[], t, [], p; name = :level0)\nlevel1 = System(Equation[], t, [], []; name = :level1) ∘ level0\nparameters(level1)\n#level0₊a\n#b\n#c\n#d\nlevel2 = System(Equation[], t, [], []; name = :level2) ∘ level1\nparameters(level2)\n#level1₊level0₊a\n#level1₊b\n#c\n#d\nlevel3 = System(Equation[], t, [], []; name = :level3) ∘ level2\nparameters(level3)\n#level2₊level1₊level0₊a\n#level2₊level1₊b\n#level2₊c\n#d","category":"section"},{"location":"basics/Composition/#Structural-Simplify","page":"Composing Models and Building Reusable Components","title":"Structural Simplify","text":"In many cases, the nicest way to build a model may leave a lot of unnecessary variables. Thus one may want to remove these equations before numerically solving. The mtkcompile function removes these trivial equality relationships and trivial singularity equations, i.e. equations which result in 0~0 expressions, in over-specified systems.","category":"section"},{"location":"basics/Composition/#Inheritance-and-Combine","page":"Composing Models and Building Reusable Components","title":"Inheritance and Combine","text":"Model inheritance can be done in two ways: implicitly or explicitly. First, one can use the extend function to extend a base model with another set of equations, unknowns, and parameters. An example can be found in the acausal components tutorial.\n\nThe explicit way is to shadow variables with equality expressions. For example, let's assume we have three separate systems which we want to compose to a single one. This is how one could explicitly forward all unknowns and parameters to the higher level system:\n\nusing ModelingToolkit, OrdinaryDiffEq, Plots\nusing ModelingToolkit: t_nounits as t, D_nounits as D\n\n## Library code\n@variables S(t), I(t), R(t)\nN = S + I + R\n@parameters β, γ\n\n@named seqn = System([D(S) ~ -β * S * I / N], t)\n@named ieqn = System([D(I) ~ β * S * I / N - γ * I], t)\n@named reqn = System([D(R) ~ γ * I], t)\n\nsir = compose(\n    System(\n        [\n            S ~ ieqn.S,\n            I ~ seqn.I,\n            R ~ ieqn.R,\n            ieqn.S ~ seqn.S,\n            seqn.I ~ ieqn.I,\n            seqn.R ~ reqn.R,\n            ieqn.R ~ reqn.R,\n            reqn.I ~ ieqn.I],\n        t,\n        [S, I, R],\n        [β, γ],\n        bindings = [seqn.β => β\n                    ieqn.β => β\n                    ieqn.γ => γ\n                    reqn.γ => γ], name = :sir),\n    seqn,\n    ieqn,\n    reqn)\n\nNote that the unknowns are forwarded by an equality relationship, while the parameters are forwarded through a relationship in their default values. The user of this model can then solve this model simply by specifying the values at the highest level:\n\nsireqn_simple = mtkcompile(sir)\n\nequations(sireqn_simple)\n\n## User Code\n\nu0 = [seqn.S => 990.0,\n    ieqn.I => 10.0,\n    reqn.R => 0.0]\n\np = [β => 0.5\n     γ => 0.25]\n\ntspan = (0.0, 40.0)\nprob = ODEProblem(sireqn_simple, u0, tspan, p, jac = true)\nsol = solve(prob, Tsit5())\nsol[reqn.R]","category":"section"},{"location":"basics/Composition/#Tearing-Problem-Construction","page":"Composing Models and Building Reusable Components","title":"Tearing Problem Construction","text":"Some system types (specifically NonlinearSystem) can be further reduced if mtkcompile has already been applied to them. This is done by using the alternative problem constructors (BlockNonlinearProblem). In these cases, the constructor uses the knowledge of the strongly connected components calculated during the process of simplification as the basis for building pre-simplified nonlinear systems in the implicit solving. In summary: these problems are structurally modified, but could be more efficient and more stable.","category":"section"},{"location":"basics/Composition/#Components-with-discontinuous-dynamics","page":"Composing Models and Building Reusable Components","title":"Components with discontinuous dynamics","text":"When modeling, e.g., impacts, saturations or Coulomb friction, the dynamic equations are discontinuous in either the unknown or one of its derivatives. This causes the solver to take very small steps around the discontinuity, and sometimes leads to early stopping due to dt <= dt_min. The correct way to handle such dynamics is to tell the solver about the discontinuity by a root-finding equation, which can be modeling using System's event support. Please see the tutorial on Callbacks and Events for details and examples.","category":"section"},{"location":"tutorials/dynamic_optimization/#Solving-Dynamic-Optimization-Problems","page":"Solving Dynamic Optimization Problems","title":"Solving Dynamic Optimization Problems","text":"Systems in ModelingToolkit.jl can be directly converted to dynamic optimization or optimal control problems. In such systems, one has one or more input variables that are externally controlled to control the dynamics of the system. A dynamic optimization solves for the optimal time trajectory of the input variables in order to maximize or minimize a desired objective function. For example, a car driver might like to know how to step on the accelerator if the goal is to finish a race while using the least gas.\n\nTo begin, let us take a rocket launch example. The input variable here is the thrust exerted by the engine. The rocket state is described by its current height, mass, and velocity. The mass decreases as the rocket loses fuel while thrusting.\n\nusing ModelingToolkit, OrdinaryDiffEq\nt = ModelingToolkit.t_nounits\nD = ModelingToolkit.D_nounits\n\n@parameters h_c m₀ h₀ g₀ D_c c Tₘ m_c\n@variables begin\n    h(..)\n    v(..)\n    m(..), [bounds = (m_c, 1)]\n    T(..), [input = true, bounds = (0, Tₘ)]\nend\n\ndrag(h, v) = D_c * v^2 * exp(-h_c * (h - h₀) / h₀)\ngravity(h) = g₀ * (h₀ / h)\n\neqs = [D(h(t)) ~ v(t),\n    D(v(t)) ~ (T(t) - drag(h(t), v(t))) / m(t) - gravity(h(t)),\n    D(m(t)) ~ -T(t) / c]\n\n(ts, te) = (0.0, 0.2)\ncosts = [-h(te)]\ncons = [T(te) ~ 0, m(te) ~ m_c]\n\n@named rocket = System(eqs, t; costs, constraints = cons)\nrocket = mtkcompile(rocket, inputs = [T(t)])\n\nu0map = [h(t) => h₀, m(t) => m₀, v(t) => 0]\npmap = [\n    g₀ => 1, m₀ => 1.0, h_c => 500, c => 0.5 * √(g₀ * h₀), D_c => 0.5 * 620 * m₀ / g₀,\n    Tₘ => 3.5 * g₀ * m₀, T(t) => 0.0, h₀ => 1, m_c => 0.6]\n\nWhat we would like to optimize here is the final height of the rocket. We do this by providing a vector of expressions corresponding to the costs. By default, the sense of the optimization is to minimize the provided cost. So to maximize the rocket height at the final time, we write -h(te) as the cost.\n\nNow we can construct a problem and solve it. Let us use JuMP as our backend here. Note that the package trigger is actually InfiniteOpt, and not JuMP - this package includes JuMP but is designed for optimization on function spaces. Additionally we need to load the solver package - we will use Ipopt here (a good choice in general).\n\nHere we have also loaded DiffEqDevTools because we will need to construct the ODE tableau. This is only needed if one desires a custom ODE tableau for the collocation - by default the solver will use RadauIIA5.\n\nusing InfiniteOpt, Ipopt, DiffEqDevTools\njprob = JuMPDynamicOptProblem(rocket, [u0map; pmap], (ts, te); dt = 0.001)\njsol = solve(jprob, JuMPCollocation(Ipopt.Optimizer, constructRadauIIA5()));\n\nThe solution has three fields: jsol.sol is the ODE solution for the states, jsol.input_sol is the ODE solution for the inputs, and jsol.model is the wrapped model that we can use to query things like objective and constraint residuals.\n\nLet's plot the final solution and the controller here:\n\nusing CairoMakie\nfig = Figure(resolution = (800, 400))\nax1 = Axis(fig[1, 1], title = \"Rocket trajectory\", xlabel = \"Time\")\nax2 = Axis(fig[1, 2], title = \"Control trajectory\", xlabel = \"Time\")\n\nfor u in unknowns(rocket)\n    lines!(ax1, jsol.sol.t, jsol.sol[u], label = string(u))\nend\nlines!(ax2, jsol.input_sol, label = \"Thrust\")\naxislegend(ax1)\naxislegend(ax2)\nfig","category":"section"},{"location":"tutorials/dynamic_optimization/#Free-final-time-problems","page":"Solving Dynamic Optimization Problems","title":"Free final time problems","text":"There are additionally a class of dynamic optimization problems where we would like to know how to control our system to achieve something in the least time. Such problems are called free final time problems, since the final time is unknown. To model these problems in ModelingToolkit, we declare the final time as a parameter.\n\nBelow we have a model system called the double integrator. We control the acceleration of a block in order to reach a desired destination in the least time.\n\n@variables begin\n    x(..)\n    v(..)\n    u(..), [bounds = (-1.0, 1.0), input = true]\nend\n\n@parameters tf\n\nconstr = [v(tf) ~ 0, x(tf) ~ 0]\ncost = [tf] # Minimize time\n\n@named block = System(\n    [D(x(t)) ~ v(t), D(v(t)) ~ u(t)], t; costs = cost, constraints = constr)\n\nblock = mtkcompile(block; inputs = [u(t)])\n\nu0map = [x(t) => 1.0, v(t) => 0.0]\ntspan = (0.0, tf)\nparammap = [u(t) => 0.0, tf => 1.0]\n\nThe tf mapping in the parameter map is treated as an initial guess.\n\nPlease note that, at the moment, free final time problems cannot support constraints defined at definite time values, like x(3) ~ 2.\n\nwarning: Warning\nThe Pyomo collocation methods (LagrangeRadau, LagrangeLegendre) currently are bugged for free final time problems. Strongly suggest using BackwardEuler() for such problems when using Pyomo as the backend.\n\nWhen declaring the problem in this case we need to provide the number of steps, since dt can't be known in advanced. Let's solve plot our final solution and the controller for the block, using InfiniteOpt as the backend:\n\niprob = InfiniteOptDynamicOptProblem(block, [u0map; parammap], tspan; steps = 100)\nisol = solve(iprob, InfiniteOptCollocation(Ipopt.Optimizer));\n\nLet's plot the final solution and the controller here:\n\nfig = Figure(resolution = (800, 400))\nax1 = Axis(fig[1, 1], title = \"Block trajectory\", xlabel = \"Time\")\nax2 = Axis(fig[1, 2], title = \"Control trajectory\", xlabel = \"Time\")\n\nfor u in unknowns(block)\n    lines!(ax1, isol.sol.t, isol.sol[u], label = string(u))\nend\nlines!(ax2, isol.input_sol, label = \"Acceleration\")\naxislegend(ax1)\naxislegend(ax2)\nfig","category":"section"},{"location":"tutorials/dynamic_optimization/#Parameter-estimation","page":"Solving Dynamic Optimization Problems","title":"Parameter estimation","text":"The dynamic optimization framework can also be used for parameter estimation. In this approach, we treat unknown parameters as tunable variables and minimize the difference between model predictions and observed data.\n\nLet's demonstrate this with the Lotka-Volterra equations. First, we'll generate some synthetic data by solving the system with known parameter values:\n\n@parameters α = 1.5 β = 1.0 [tunable=false] γ = 3.0 δ = 1.0\n@variables x_pe(t) y_pe(t)\n\neqs_pe = [D(x_pe) ~ α * x_pe - β * x_pe * y_pe,\n    D(y_pe) ~ -γ * y_pe + δ * x_pe * y_pe]\n\n@mtkcompile sys0_pe = System(eqs_pe, t)\ntspan_pe = (0.0, 1.0)\nu0map_pe = [x_pe => 4.0, y_pe => 2.0]\n\n# True parameter values (these are what we'll try to recover)\nparammap_pe = [α => 2.5, δ => 1.8]\n\noprob_pe = ODEProblem(sys0_pe, [u0map_pe; parammap_pe], tspan_pe)\nosol_pe = solve(oprob_pe, Tsit5())\n\n# Generate synthetic data at 51 time points\nts_pe = range(tspan_pe..., length=51)\ndata_pe = osol_pe(ts_pe, idxs=x_pe).u\n\nNow we'll set up the parameter estimation problem. We use EvalAt to evaluate the state at specific time points and construct a least-squares cost function:\n\ncosts_pe = [abs2(EvalAt(ti)(x_pe) - data_pe[i]) for (i, ti) in enumerate(ts_pe)]\n\n@mtkcompile sys_pe = System(eqs_pe, t; costs = costs_pe)\n\nBy default the cost values are sumed up, if a different behaviour is desired, the consolidate keyword can be set in the System definition.\n\nNext, we select which parameters to tune using subset_tunables. Here we'll estimate α and δ while keeping β and γ fixed:\n\nsys_pe′ = subset_tunables(sys_pe, [α, δ])\n\nNow we can solve the parameter estimation problem. Note the tune_parameters=true flag:\n\niprob_pe = InfiniteOptDynamicOptProblem(sys_pe′, u0map_pe, tspan_pe; dt=1/50, tune_parameters=true)\nisol_pe = solve(iprob_pe, InfiniteOptCollocation(Ipopt.Optimizer, InfiniteOpt.OrthogonalCollocation(3)))\n\nprintln(\"Estimated α = \", isol_pe.sol.ps[α], \" (true value: 2.5)\")\nprintln(\"Estimated δ = \", isol_pe.sol.ps[δ], \" (true value: 1.8)\")\n\nLet's visualize the fit:\n\nfig = Figure(resolution = (800, 400))\nax = Axis(fig[1, 1], title = \"Parameter Estimation Results\", xlabel = \"Time\", ylabel = \"Prey Population\")\nscatter!(ax, ts_pe, data_pe, label = \"Data\", markersize = 8)\nlines!(ax, isol_pe.sol.t, isol_pe.sol[x_pe], label = \"Fitted Model\", linewidth = 2)\naxislegend(ax)\nfig\n\nnote: Time Alignment for Cost Evaluation\nWhen using EvalAt for parameter estimation, different backends handle the case when evaluation times don't align with collocation points differently:JuMP: Will throw an error asking you to adjust dt if evaluation times don't match collocation points exactly.\nCasADi: Uses linear interpolation between collocation points for cost evaluations at intermediate times.\nInfiniteOpt: Automatically adds support points for the evaluation times, handling mismatched grids gracefully.For example, InfiniteOpt can use a different dt than what the data spacing requires:# With InfiniteOpt, dt doesn't need to match the data points:\niprob_pe2 = InfiniteOptDynamicOptProblem(sys_pe′, u0map_pe, tspan_pe,\n                                         dt = 1/120, tune_parameters=true)\nisol_pe2 = solve(iprob_pe2, InfiniteOptCollocation(Ipopt.Optimizer,\n                            InfiniteOpt.OrthogonalCollocation(3)))\n\nprintln(\"With dt=1/120: Estimated α = \", isol_pe2.sol.ps[α], \" (true value: 2.5)\")\nprintln(\"With dt=1/120: Estimated δ = \", isol_pe2.sol.ps[δ], \" (true value: 1.8)\")This flexibility makes InfiniteOpt particularly convenient for parameter estimation when your data points don't naturally align with a uniform collocation grid.","category":"section"},{"location":"tutorials/callable_params/#Callable-parameters-and-interpolating-data","page":"Callable parameters and interpolating data","title":"Callable parameters and interpolating data","text":"ModelingToolkit.jl allows creating parameters that represent functions to be called. This is especially useful for including interpolants and/or lookup tables inside ODEs. In this tutorial we will create an System which employs callable parameters to interpolate data inside an ODE and go over the various syntax options and their implications.","category":"section"},{"location":"tutorials/callable_params/#Callable-parameter-syntax","page":"Callable parameters and interpolating data","title":"Callable parameter syntax","text":"The syntax for callable parameters declared via @parameters must be one of the following\n\n(fn::FType)(..)\nfn(::argType1, ::argType2, ...)\n\nIn the first case, the parameter is callable with any number/combination of arguments, and has a type of FType (the callable must be a subtype of FType). In the second case, the parameter is callable with as many arguments as declared, and all must match the declared types.\n\nBy default, the return type of the callable symbolic is inferred to be Real. To change this, a ::retType annotation can be added at the end.\n\nTo declare a function that returns an array of values, the same array syntax can be used as for normal variables:\n\n@parameters (foo::FType)(..)[1:3]::retType\n@parameters foo(::argType1, ::argType2)[1:3]::retType\n\nretType here is the eltype of the returned array.","category":"section"},{"location":"tutorials/callable_params/#Storage-of-callable-parameters","page":"Callable parameters and interpolating data","title":"Storage of callable parameters","text":"Callable parameters declared with the ::FType syntax will be stored in a Vector{FType}. Thus, if FType is non-concrete, the buffer will also be non-concrete. This is sometimes necessary to allow the value of the callable to be switched out for a different type without rebuilding the model. Typically this syntax is preferable when FType is concrete or a small union.\n\nCallable parameters declared with the ::argType1, ... syntax will be stored in a Vector{FunctionWrappers.FunctionWrapper{retType, Tuple{argType1, ...}}}. This suffers the small overhead of a FunctionWrapper and restricts the signature of the callable, symbolic, but allows storing the parameter in a type-stable manner and swapping it out. This is preferable when the values that the callable can take do not share a common subtype. For example, when a callable can represent the activation of a neural network and can be tanh, sigmoid, etc. which have a common ancestor of Function.\n\nIf both ::FType and ::argTypes are specified, ::FType takes priority. For example,\n\n@parameters (p::LinearInterpolation)(::Real)\n\np will be stored in a Vector{LinearInterpolation}. If ::LinearInterpolation was not specified, it would be stored in a Vector{FunctionWrapper{Real, Tuple{Real}}}.","category":"section"},{"location":"tutorials/callable_params/#Example-using-interpolations","page":"Callable parameters and interpolating data","title":"Example using interpolations","text":"using ModelingToolkit\nusing OrdinaryDiffEq\nusing DataInterpolations\nusing ModelingToolkit: t_nounits as t, D_nounits as D\n\nts = collect(0.0:0.1:10.0)\nspline = LinearInterpolation(ts .^ 2, ts)\nTspline = typeof(spline)\n@variables x(t)\n@parameters (interp::Tspline)(..)\n\n@mtkcompile sys = System(D(x) ~ interp(t), t)\n\nThe derivative of x is obtained via an interpolation from DataInterpolations.jl. Note the parameter syntax. The (..) marks the parameter as callable. (interp::Tspline) indicates that the parameter is of type Tspline.\n\nprob = ODEProblem(sys, [x => 0.0, interp => spline], (0.0, 1.0))\nsolve(prob)\n\nNote that the the following will not work:\n\nODEProblem(\n    sys; [x => 0.0, interp => LinearInterpolation(0.0:0.1:1.0, 0.0:0.1:1.0)], (0.0, 1.0))\n\nSince the type of the spline doesn't match.","category":"section"},{"location":"API/dynamic_opt/#dynamic_opt_api","page":"Dynamic Optimization Solvers","title":"Dynamic Optimization Solvers","text":"Currently 4 backends are exposed for solving dynamic optimization problems using collocation: JuMP, InfiniteOpt, CasADi, and Pyomo.\n\nPlease note that there are differences in how to construct the collocation solver for the different cases. For example, the Python based ones, CasADi and Pyomo, expect the solver to be passed in as a string (CasADi and Pyomo come pre-loaded with Ipopt, but other solvers may need to be manually installed using pip or conda), while JuMP/InfiniteOpt expect the optimizer object to be passed in directly:\n\nJuMPCollocation(Ipopt.Optimizer, constructRK4())\nCasADiCollocation(\"ipopt\", constructRK4())\n\nJuMP and CasADi collocation require an ODE tableau to be passed in. These can be constructed by calling the constructX() functions from DiffEqDevTools. The list of tableaus can be found here. If none is passed in, both solvers will default to using Radau second-order with five collocation points.\n\nPyomo and InfiniteOpt each have their own built-in collocation methods.\n\nInfiniteOpt: The list of InfiniteOpt collocation methods can be found in the table on this page. If none is passed in, the solver defaults to FiniteDifference(Backward()), which is effectively implicit Euler.\nPyomo: The list of Pyomo collocation methods can be found at the bottom of this page. If none is passed in, the solver defaults to a LagrangeRadau(3).\n\nSome examples of the latter two collocations:\n\nPyomoCollocation(\"ipopt\", LagrangeRadau(2))\nInfiniteOptCollocation(Ipopt.Optimizer, OrthogonalCollocation(3))","category":"section"},{"location":"API/dynamic_opt/#Problem-constructors","page":"Dynamic Optimization Solvers","title":"Problem constructors","text":"","category":"section"},{"location":"tutorials/fmi/#Importing-FMUs","page":"Importing FMUs","title":"Importing FMUs","text":"ModelingToolkit is able to import FMUs following the FMI Standard versions 2 and 3. This integration is done through FMI.jl and requires importing it to enable the relevant functionality. Currently Model Exchange (ME) and CoSimulation (CS) FMUs are supported. Events, non-floating-point variables and array variables are not supported. Additionally, calculating the time derivatives of FMU states/outputs is not supported.\n\ndanger: Experimental\nThis functionality is currently experimental and subject to change without a breaking release of ModelingToolkit.jl.","category":"section"},{"location":"tutorials/fmi/#FMUs-of-full-models","page":"Importing FMUs","title":"FMUs of full models","text":"Here, we will demonstrate the usage of an FMU of an entire model (as opposed to a single component). First, the required libraries must be imported and the FMU loaded using FMI.jl.\n\nusing ModelingToolkit, FMI, FMIZoo, OrdinaryDiffEq\nusing ModelingToolkit: t_nounits as t, D_nounits as D\n\n# This is a spring-pendulum FMU from FMIZoo.jl. It is a v2 FMU\n# and we are importing it in ModelExchange format.\nfmu = loadFMU(\"SpringPendulum1D\", \"Dymola\", \"2022x\"; type = :ME)\n\nFollowing are the variables in the FMU (both states and parameters):\n\nfmu.modelDescription.modelVariables\n\nNext, FMIComponent is used to import the FMU as an MTK component. We provide the FMI major version as a Val to the constructor, along with the loaded FMU and the type as keyword arguments.\n\n@named model = ModelingToolkit.FMIComponent(Val(2); fmu, type = :ME)\n\nNote how hierarchical names in the FMU (e.g. mass.m or spring.f) are turned into flattened names, with __ being the namespace separator (mass__m and spring__f).\n\nnote: Note\nEventually we plan to reconstruct a hierarchical system structure mirroring the one indicated by the variables in the FMU. This would allow accessing the above mentioned variables as model.mass.m and model.spring.f instead of model.mass__m and model.spring__f respectively.\n\nDerivative variables such as der(mass.v) use the dummy derivative notation, and are hence transformed into a form similar to mass__vˍt. However, they can still be referred to as D(model.mass__v).\n\nequations(model)\n\nSince the FMI spec allows multiple names to alias the same quantity, ModelingToolkit.jl creates equations to alias them. For example, it can be seen above that der(mass.v) and mass.a have the same reference, and hence refer to the same quantity. Correspondingly, there is an equation mass__vˍt(t) ~ mass__a(t) in the system.\n\nnote: Note\nAny variables and/or parameters that are not part of the FMU should be ignored, as ModelingToolkit creates them to manage the FMU. Unexpected usage of these variables/parameters can lead to errors.\n\ninitial_conditions(model)\n\nAll parameters in the FMU are given a default equal to their start value, if present. Unknowns are not assigned defaults even if a start value is present, as this would conflict with ModelingToolkit's own initialization semantics.\n\nWe can simulate this model like any other ModelingToolkit system.\n\nsys = mtkcompile(model)\nprob = ODEProblem(sys, [sys.mass__s => 0.5, sys.mass__v => 0.0], (0.0, 5.0))\nsol = solve(prob, Tsit5())\n\nWe can interpolate the solution object to obtain values at arbitrary time points in the solved interval, just like a normal solution.\n\nsol(0.0:0.1:1.0; idxs = sys.mass__a)\n\nFMUs following version 3 of the specification can be simulated with almost the same process. This time, we will create a model from a CoSimulation FMU.\n\nfmu = loadFMU(\"SpringPendulum1D\", \"Dymola\", \"2023x\", \"3.0\"; type = :CS)\n@named inner = ModelingToolkit.FMIComponent(\n    Val(3); fmu, communication_step_size = 0.001, type = :CS,\n    reinitializealg = BrownFullBasicInit())\nnothing # hide\n\nThis FMU has fewer equations, partly due to missing aliasing variables and partly due to being a CS FMU. CoSimulation FMUs are bundled with an integrator. As such, they do not function like ME FMUs. Instead, a callback steps the FMU at periodic intervals in time and obtains the updated state. This state is held constant until the next time the callback triggers. The periodic interval must be specified through the communication_step_size keyword argument. A smaller step size typically leads to less error but is more computationally expensive.\n\nThis model alone does not have any differential variables, and calling mtkcompile will lead to an System with no unknowns.\n\nmtkcompile(inner)\n\nSimulating this model will cause the OrdinaryDiffEq integrator to immediately finish, and will not trigger the callback. Thus, we wrap this system in a trivial system with a differential variable.\n\n@variables x(t) = 1.0\n@mtkcompile sys = System([D(x) ~ x], t; systems = [inner])\n\nWe can now simulate sys.\n\nprob = ODEProblem(sys, [sys.inner.mass__s => 0.5, sys.inner.mass__v => 0.0], (0.0, 5.0))\nsol = solve(prob, Tsit5())\n\nThe variables of the FMU are discrete, and their timeseries can be obtained at intervals of communication_step_size.\n\nsol[sys.inner.mass__s]","category":"section"},{"location":"tutorials/fmi/#FMUs-of-components","page":"Importing FMUs","title":"FMUs of components","text":"FMUs can also be imported as individual components. For this example, we will use custom FMUs used in the test suite of ModelingToolkit.jl.\n\nfmu = loadFMU(\n    joinpath(@__DIR__, \"..\", \"..\", \"..\", \"test\", \"fmi\", \"fmus\", \"SimpleAdder.fmu\");\n    type = :ME)\nfmu.modelDescription.modelVariables\n\nThis FMU is equivalent to the following model:\n\n@mtkmodel SimpleAdder begin\n    @variables begin\n        a(t)\n        b(t)\n        c(t)\n        out(t)\n        out2(t)\n    end\n    @parameters begin\n        value = 1.0\n    end\n    @equations begin\n        out ~ a + b + value\n        D(c) ~ out\n        out2 ~ 2c\n    end\nend\n\na and b are inputs, c is a state, and out and out2 are outputs of the component.\n\n@named adder = ModelingToolkit.FMIComponent(\n    Val(2); fmu, type = :ME, reinitializealg = BrownFullBasicInit());\nisinput(adder.a)\nisinput(adder.b)\nisoutput(adder.out)\nisoutput(adder.out2)\n\nModelingToolkit recognizes input and output variables of the component, and attaches the appropriate metadata. We can now use this component as a subcomponent of a larger system.\n\n@variables a(t) b(t) c(t) [guess = 1.0];\n@mtkcompile sys = System(\n    [adder.a ~ a, adder.b ~ b, D(a) ~ t,\n        D(b) ~ adder.out + adder.c, c^2 ~ adder.out + adder.value],\n    t;\n    systems = [adder])\nequations(sys)\n\nNote how the output adder.out is used in an algebraic equation of the system. We have also given sys.c a guess, expecting it to be solved for by initialization. ModelingToolkit is able to use FMUs in initialization to solve for initial states. As mentioned earlier, we cannot differentiate through an FMU. Thus, automatic differentiation has to be disabled for the solver.\n\nprob = ODEProblem(\n    sys, [sys.adder.c => 2.0, sys.a => 1.0, sys.b => 1.0, sys.adder.value => 2.0],\n    (0.0, 1.0))\nsolve(prob, Rodas5P(autodiff = false))\n\nCoSimulation FMUs follow a nearly identical process. Since CoSimulation FMUs operate using callbacks, after triggering the callbacks and altering the discrete state the algebraic equations may no longer be satisfied. To resolve for the values of algebraic variables, we use the reinitializealg keyword of FMIComponent. This is a DAE initialization algorithm to use at the end of every callback. Since CoSimulation FMUs are not directly involved in the RHS of the system - instead operating through callbacks - we can use a solver with automatic differentiation.\n\nfmu = loadFMU(\n    joinpath(@__DIR__, \"..\", \"..\", \"..\", \"test\", \"fmi\", \"fmus\", \"SimpleAdder.fmu\");\n    type = :CS)\n@named adder = ModelingToolkit.FMIComponent(\n    Val(2); fmu, type = :CS, communication_step_size = 1e-3,\n    reinitializealg = BrownFullBasicInit())\n@mtkcompile sys = System(\n    [adder.a ~ a, adder.b ~ b, D(a) ~ t,\n        D(b) ~ adder.out + adder.c, c^2 ~ adder.out + adder.value],\n    t;\n    systems = [adder])\nprob = ODEProblem(\n    sys, [sys.adder.c => 2.0, sys.a => 1.0, sys.b => 1.0, sys.adder.value => 2.0],\n    (0.0, 1.0))\nsolve(prob, Rodas5P())","category":"section"},{"location":"basics/InputOutput/#inputoutput","page":"Input output","title":"Input output","text":"An input-output system is a system on the form\n\nbeginaligned\nM dot x = f(x u p t) \ny = g(x u p t)\nendaligned\n\nwhere x is the state, u is the input and y is an output (in some contexts called an observed variables in MTK).\n\nWhile many uses of ModelingToolkit for simulation do not require the user to think about inputs and outputs (IO), there are certain situations in which handling IO explicitly may be important, such as\n\nLinearization\nControl design\nSystem identification\nFMU export\nReal-time simulation with external data inputs\nCustom interfacing with other simulation tools\n\nThis documentation page lists utilities that are useful for working with inputs and outputs in ModelingToolkit.","category":"section"},{"location":"basics/InputOutput/#Generating-a-dynamics-function-with-inputs,-f","page":"Input output","title":"Generating a dynamics function with inputs, f","text":"ModelingToolkit can generate the dynamics of a system, the function Mdot x = f(x u p t) above, such that the user can pass not only the state x and parameters p but also an external input u. To this end, the function ModelingToolkit.generate_control_function exists.\n\nThis function takes a vector of variables that are to be considered inputs, i.e., part of the vector u. Alongside returning the function f, ModelingToolkit.generate_control_function also returns the chosen state realization of the system after simplification. This vector specifies the order of the state variables x, while the user-specified vector u specifies the order of the input variables u.\n\nnote: Un-simplified system\nThis function expects sys to be un-simplified, i.e., mtkcompile or @mtkcompile should not be called on the system before passing it into this function. generate_control_function calls a special version of mtkcompile internally.","category":"section"},{"location":"basics/InputOutput/#Example:","page":"Input output","title":"Example:","text":"The following example implements a simple first-order system with an input u and state x. The function f is generated using generate_control_function, and the function f is then tested with random input and state values.\n\nusing ModelingToolkit\nimport ModelingToolkit: t_nounits as t, D_nounits as D\n@variables x(t)=0 u(t)=0 y(t)\n@parameters k = 1\neqs = [D(x) ~ -k * (x + u)\n       y ~ x]\n\n@named sys = System(eqs, t)\nf, x_sym, ps = ModelingToolkit.generate_control_function(sys, [u], simplify = true);\nnothing # hide\n\nWe can inspect the state realization chosen by MTK\n\nx_sym\n\nas expected, x is chosen as the state variable.\n\nusing Test # hide\n@test isequal(x_sym[], x) # hide\n@test isequal(ps, [k]) # hide\nnothing  # hide\n\nNow we can test the generated function f with random input and state values\n\np = [1]\nx = [rand()]\nu = [rand()]\n@test f[1](x, u, p, 1) ≈ -p[] * (x + u) # Test that the function computes what we expect D(x) = -k*(x + u)","category":"section"},{"location":"basics/InputOutput/#Generating-an-output-function,-g","page":"Input output","title":"Generating an output function, g","text":"ModelingToolkit can also generate a function that computes a specified output of a system, the function y = g(x u p t) above. This is done using the function ModelingToolkit.build_explicit_observed_function. When generating an output function, the user must specify the output variable(s) of interest, as well as any inputs if inputs are relevant to compute the output.\n\nThe order of the user-specified output variables determines the order of the output vector y.","category":"section"},{"location":"basics/InputOutput/#Input-output-variable-metadata","page":"Input output","title":"Input-output variable metadata","text":"See Symbolic Metadata. Metadata specified when creating variables is not directly used by any of the functions above, but the user can use the accessor functions ModelingToolkit.inputs(sys) and ModelingToolkit.outputs(sys) to obtain all variables with such metadata for passing to the functions above. The presence of this metadata is not required for any IO functionality and may be omitted.","category":"section"},{"location":"basics/InputOutput/#Linearization","page":"Input output","title":"Linearization","text":"See Linearization.","category":"section"},{"location":"basics/InputOutput/#Docstrings","page":"Input output","title":"Docstrings","text":"Pages = [\"InputOutput.md\"]","category":"section"},{"location":"tutorials/nonlinear/#Modeling-Nonlinear-Systems","page":"Modeling Nonlinear Systems","title":"Modeling Nonlinear Systems","text":"ModelingToolkit.jl is not only useful for generating initial value problems (ODEProblem). The package can also build nonlinear systems. This is, for example, useful for finding the steady state of an ODE. This steady state is reached when the nonlinear system of differential equations equals zero.\n\nnote: Note\nThe high level @mtkmodel macro used in the getting started tutorial is not yet compatible with NonlinearSystem. We thus have to use a lower level interface to define nonlinear systems. For an introduction to this interface, read the programmatically generating Systems tutorial.\n\nusing ModelingToolkit, NonlinearSolve\n\n# Define a nonlinear system\n@variables x y z\n@parameters σ ρ β\neqs = [0 ~ σ * (y - x)\n       0 ~ x * (ρ - z) - y\n       0 ~ x * y - β * z]\n@mtkcompile ns = System(eqs)\n\nguesses = [x => 1.0, y => 0.0, z => 0.0]\nps = [σ => 10.0, ρ => 26.0, β => 8 / 3]\n\nprob = NonlinearProblem(ns, vcat(guesses, ps))\nsol = solve(prob, NewtonRaphson())\n\nWe found the x, y and z for which the right hand sides of eqs are all equal to zero.\n\nJust like with ODEProblems we can generate the NonlinearProblem with its analytical Jacobian function:\n\nprob = NonlinearProblem(ns, vcat(guesses, ps), jac = true)\nsol = solve(prob, NewtonRaphson())","category":"section"},{"location":"tutorials/discrete_system/#(Experimental)-Modeling-Discrete-Systems","page":"(Experimental) Modeling Discrete Systems","title":"(Experimental) Modeling Discrete Systems","text":"In this example, we will use the System API to create an SIR model.\n\nusing ModelingToolkit\nusing ModelingToolkit: t_nounits as t\nusing OrdinaryDiffEq: solve, FunctionMap\n\n@inline function rate_to_proportion(r, t)\n    1 - exp(-r * t)\nend\n@parameters c δt β γ\n@constants h = 1\n@variables S(t) I(t) R(t)\nk = ShiftIndex(t)\ninfection = rate_to_proportion(\n    β * c * I(k - 1) / (S(k - 1) * h + I(k - 1) + R(k - 1)), δt * h) * S(k - 1)\nrecovery = rate_to_proportion(γ * h, δt) * I(k - 1)\n\n# Equations\neqs = [S(k) ~ S(k - 1) - infection * h,\n    I(k) ~ I(k - 1) + infection - recovery,\n    R(k) ~ R(k - 1) + recovery]\n@mtkcompile sys = System(eqs, t)\n\nu0 = [S(k - 1) => 990.0, I(k - 1) => 10.0, R(k - 1) => 0.0]\np = [β => 0.05, c => 10.0, γ => 0.25, δt => 0.1]\ntspan = (0.0, 100.0)\nprob = DiscreteProblem(sys, vcat(u0, p), tspan)\nsol = solve(prob, FunctionMap())\n\nAll shifts must be non-positive, i.e., discrete-time variables may only be indexed at index k, k-1, k-2, .... If default values are provided, they are treated as the value of the variable at the previous timestep. For example, consider the following system to generate the Fibonacci series:\n\n@variables x(t) = 1.0\n@mtkcompile sys = System([x ~ x(k - 1) + x(k - 2)], t)\n\nThe \"default value\" here should be interpreted as the value of x at all past timesteps. For example, here x(k-1) and x(k-2) will be 1.0, and the initial value of x(k) will thus be 2.0. During problem construction, the past value of a variable should be provided. For example, providing [x => 1.0] while constructing this problem will error. Provide [x(k-1) => 1.0] instead. Note that values provided during problem construction do not apply to the entire history. Hence, if [x(k-1) => 2.0] is provided, the value of x(k-2) will still be 1.0.","category":"section"},{"location":"tutorials/disturbance_modeling/#Disturbance-and-input-modeling-modeling","page":"Disturbance and input modeling modeling","title":"Disturbance and input modeling modeling","text":"Disturbances are often seen as external factors that influence a system. Modeling and simulation of such external influences is common in order to ensure that the plant and or control system can adequately handle or suppress these disturbances. Disturbance modeling is also integral to the problem of state estimation, indeed, modeling how disturbances affect the evolution of the state of the system is crucial in order to accurately estimate this state.\n\nThis tutorial will show how to model disturbances in ModelingToolkit as disturbance inputs. This involves demonstrating best practices that make it easy to use a single model to handle both disturbed and undisturbed systems, and making use of the model for both simulation and state estimation.","category":"section"},{"location":"tutorials/disturbance_modeling/#A-flexible-component-based-workflow","page":"Disturbance and input modeling modeling","title":"A flexible component-based workflow","text":"We will consider a simple system consisting of two inertias connected through a flexible shaft, such as a simple transmission system in a car. We start by modeling the plant without any input signals:\n\nusing ModelingToolkit, OrdinaryDiffEq, LinearAlgebra, Test\nusing ModelingToolkitStandardLibrary.Mechanical.Rotational\nusing ModelingToolkitStandardLibrary.Blocks\nt = ModelingToolkit.t_nounits\nD = ModelingToolkit.D_nounits\n\n# Define the SystemModel component\nfunction SystemModel(; name, m1 = 1, m2 = 1, k = 10, c = 3)\n    @parameters begin\n        m1 = m1\n        m2 = m2\n        k = k # Spring stiffness\n        c = c # Damping coefficient\n    end\n    systems = @named begin\n        inertia1 = Inertia(; J = m1, phi = 0, w = 0)\n        inertia2 = Inertia(; J = m2, phi = 0, w = 0)\n        spring = Spring(; c = k)\n        damper = Damper(; d = c)\n        torque = Torque(use_support = false)\n    end\n\n    eqs = [\n        connect(torque.flange, inertia1.flange_a)\n        connect(inertia1.flange_b, spring.flange_a, damper.flange_a)\n        connect(inertia2.flange_a, spring.flange_b, damper.flange_b)\n    ]\n\n    System(eqs, t, [], [m1, m2, k, c];\n        systems,\n        name)\nend\n\nHere, we have added a torque component that allows us to add a torque input to drive the system, but we have not connected any signal to it yet. We have not yet made any attempts at modeling disturbances, and this is deliberate, we will handle this later in order to make the plant model as generically useful as possible.\n\nIn order to simulate this system in the presence of disturbances, we must 1. Reason about how disturbances may affect the system, and 2. attach disturbance inputs and disturbance signals to the model. We distinguish between an input and a signal here, where we by input mean an attachment point (connector) to which we may connect a signal, i.e., a time-varying function.\n\nWe create a new model that includes disturbance inputs and signals, and attach those to the already defined plant model. We assume that each of the two inertias can be affected by a disturbance torque, such as due to friction or an unknown load on the output inertia.\n\n# Define a model with inputs\nfunction ModelWithInputs(; name)\n    systems = @named begin\n        input_signal = Blocks.Sine(frequency = 1, amplitude = 1)\n        disturbance_signal1 = Blocks.Step(height = -1, start_time = 2) # We add an input signal that equals zero by default so that it has no effect during normal simulation\n        disturbance_signal2 = Blocks.Step(height = 2, start_time = 4)\n        disturbance_torque1 = Torque(use_support = false)\n        disturbance_torque2 = Torque(use_support = false)\n        system_model = SystemModel()\n    end\n\n    eqs = [\n        connect(input_signal.output, :u, system_model.torque.tau)\n        connect(disturbance_signal1.output, :d1, disturbance_torque1.tau) # When we connect the input _signals_, we do so through an analysis point. This allows us to easily disconnect the input signals in situations when we do not need them.\n        connect(disturbance_signal2.output, :d2, disturbance_torque2.tau)\n        connect(disturbance_torque1.flange, system_model.inertia1.flange_b)\n        connect(disturbance_torque2.flange, system_model.inertia2.flange_b)\n    ]\n\n    System(eqs, t;\n        systems,\n        name)\nend\n\nThis outer model, ModelWithInputs, contains two disturbance inputs, both of type Torque. It also contains three signal specifications, one for the control input and two for the corresponding disturbance inputs. Note how we added the disturbance torque inputs at this level of the model, but the control input was added inside the system model. This is a design choice that is up to the modeler, here, we consider the driving torque to be a fundamental part of the model that is always required to make use of it, while the disturbance inputs may be of interest only in certain situations, and we thus add them when needed. Since we have added not only input connectors, but also connected input signals to them, this model is complete and ready for simulation, i.e., there are no unbound inputs.\n\n@named model = ModelWithInputs() # Model with load disturbance\nssys = mtkcompile(model)\nprob = ODEProblem(ssys, [], (0.0, 6.0))\nsol = solve(prob, Tsit5())\nusing Plots\nplot(sol)\n\nA thing to note in the specification of ModelWithInputs is the presence of three analysis points, :u, :d1, and :d2. When signals are connected through an analysis point, we may at any time linearize the model as if the signals were not connected, i.e., as if the corresponding inputs were unbound. We may also use this to generate a julia function for the dynamics on the form f(xuptw) where the input u and disturbance w may be provided as separate function arguments, as if the corresponding input signals were not present in the model. More details regarding this will be presented further below, here, we just demonstrate how we could linearize this system model from the inputs to the angular velocity of the inertias\n\nusing ControlSystemsBase, ControlSystemsMTK # ControlSystemsMTK provides the high-level function named_ss and ControlSystemsBase provides the bodeplot function\nP = named_ss(model, [ssys.u, ssys.d1, ssys.d2],\n    [ssys.system_model.inertia1.w, ssys.system_model.inertia2.w])\nbodeplot(P, plotphase = false)\n\nIt's worth noting at this point that the fact that we could connect disturbance outputs from outside of the plant-model definition was enabled by the fact that we used a component-based workflow, where the plant model had the appropriate connectors available. If the plant model had modeled the system using direct equations without connectors, this would not have been possible and the model would thus be significantly less flexible.\n\nWe summarize the findings so far as a number of best practices:\n\ntip: Best practices\nUse a component-based workflow to model the plant\nIf possible, model the plant without explicit disturbance inputs to make it as generic as possible\nWhen disturbance inputs are needed, create a new model that includes the plant model and the disturbance inputs\nOnly add input signals at the top level of the model, this applies to both control inputs and disturbance inputs.\nUse analysis points to connect signals to inputs, this allows for easy disconnection of signals when needed, e.g., for linearization or function generation.","category":"section"},{"location":"tutorials/disturbance_modeling/#Modeling-for-state-estimation","page":"Disturbance and input modeling modeling","title":"Modeling for state estimation","text":"In the example above, we constructed a model for simulation of a disturbance affecting the system. When simulating, we connect an input signal of specified shape that simulates the disturbance, above, we used Blocks.Step as input signals. On the other hand, when performing state estimation, the exact shape of the disturbance is typically not known, we might only have some diffuse knowledge of the disturbance characteristics such as \"varies smoothly\", \"makes sudden step changes\" or \"is approximately periodic with 24hr period\". The encoding of such knowledge is commonly reasoned about in the frequency domain, where we specify a disturbance model as a dynamical system with a frequency response similar to the approximate spectrum of the disturbance. For more details around this, see the in-depth tutorial notebook \"How to tune a Kalman filter\". Most algorithms for state estimation, such as a Kalman-filter like estimators, assume that disturbances are independent and identically distributed (i.i.d.). While seemingly restrictive at first glance, when combined with an appropriate disturbance models encoded as dynamical systems, this assumption still allows for a wide range of non i.i.d. disturbances to be modeled.\n\nWhen modeling a system in MTK, we essentially (without considering algebraic equations for simplicity in exposition) construct a model of a dynamical system\n\nbeginaligned\ndot x = f(x p t) \ny = g(x p t)\nendaligned\n\nwhere x is the state, y are observed variables, p are parameters, and t is time. When using MTK, which variables constitute x and which are considered part of the output, y, is up to the tool rather than the user, this choice is made by MTK during the call to mtkcompile.\n\nIf we further consider external inputs to the system, such as controlled input signals u and disturbance inputs w, we can write the system as\n\nbeginaligned\ndot x = f(x u p t w) \ny = g(x u p t)\nendaligned\n\nTo make use of the model defined above for state estimation, we may want to generate a Julia function for the dynamics f and the output equations g that we can plug into, e.g., a nonlinear version of a Kalman filter or a particle filter, etc. MTK contains utilities to do this, namely, ModelingToolkit.generate_control_function and ModelingToolkit.build_explicit_observed_function (described in more details in \"Input output\").\n\nThese functions support two types of disturbance inputs:\n\nUnknown disturbances (disturbance_inputs): Variables that are part of w but NOT added as function arguments to f. MTK assumes these variables are zero, but any dynamics associated with them (such as disturbance models) are included in the generated function. This allows a state estimator to estimate the state of the disturbance model, provided that this state is observable from measured outputs.\nKnown disturbances (known_disturbance_inputs): Variables that are part of w AND added as function arguments to f, resulting in f(x u p t w). Use this when disturbances can be measured or are otherwise known.\n\nYou can mix and match: some disturbances can be unknown while others are known. For example, generate_control_function(sys, inputs; disturbance_inputs=[w1], known_disturbance_inputs=[w2, w3]) generates a function f(x, u, p, t, [w2, w3]) where w1 is set to zero but its dynamics are preserved, while w2 and w3 must be provided as arguments.\n\nBelow, we demonstrate\n\nHow to add an integrating disturbance model\nhow to generate the functions f and g for a typical nonlinear state estimator with explicit disturbance inputs\n\n# Define an integrating disturbance model\nfunction IntegratingDisturbance(; name)\n    @variables x(t) = 0.0 w(t) = 0.0 [disturbance = true, input = true]\n    systems = @named begin\n        input = RealInput()\n        output = RealOutput()\n    end\n    eqs = [\n        D(x) ~ w\n        w ~ input.u\n        output.u ~ x\n    ]\n    System(eqs, t, [x, w], []; systems, name)\nend\n\n# Define a system model with disturbance model\nfunction SystemModelWithDisturbanceModel(; name)\n    systems = @named begin\n        input_signal = Blocks.Sine(frequency = 1, amplitude = 1)\n        disturbance_signal1 = Blocks.Constant(k = 0)\n        disturbance_signal2 = Blocks.Constant(k = 0)\n        disturbance_torque1 = Torque(use_support = false)\n        disturbance_torque2 = Torque(use_support = false)\n        disturbance_model = Blocks.Integrator()\n        system_model = SystemModel()\n    end\n\n    eqs = [\n        connect(input_signal.output, :u, system_model.torque.tau)\n        connect(disturbance_signal1.output, :d1, disturbance_model.input)\n        connect(disturbance_model.output, disturbance_torque1.tau)\n        connect(disturbance_signal2.output, :d2, disturbance_torque2.tau)\n        connect(disturbance_torque1.flange, system_model.inertia1.flange_b)\n        connect(disturbance_torque2.flange, system_model.inertia2.flange_b)\n    ]\n\n    System(eqs, t;\n        systems,\n        name)\nend\n\n@named model_with_disturbance = SystemModelWithDisturbanceModel()\n\nWe demonstrate that this model is complete and can be simulated:\n\nssys = mtkcompile(model_with_disturbance)\nprob = ODEProblem(ssys, [], (0.0, 10.0))\nsol = solve(prob, Tsit5())\nusing Test\n@test SciMLBase.successful_retcode(sol)\n\nbut we may also generate the functions f and g for state estimation:\n\nwarning: Example currently disabled\nThis example is currently disabled due to compatibility issues with generate_control_function and analysis points in the current ModelingToolkit stack.\n\ninputs = [ssys.u]\ndisturbance_inputs = [ssys.d1, ssys.d2]\nP = ssys.system_model\noutputs = [P.inertia1.phi, P.inertia2.phi, P.inertia1.w, P.inertia2.w]\n\n(f_oop, f_ip), x_sym,\np_sym,\nio_sys = ModelingToolkit.generate_control_function(\n    model_with_disturbance, inputs; known_disturbance_inputs = disturbance_inputs)\n\ng = ModelingToolkit.build_explicit_observed_function(\n    io_sys, outputs; inputs)\n\nop = ModelingToolkit.inputs(io_sys) .=> 0\nx0 = ModelingToolkit.get_u0(io_sys, op)\np = MTKParameters(io_sys, op)\nu = zeros(1) # Control input\nw = zeros(length(disturbance_inputs)) # Disturbance input (known disturbances are provided as arguments)\n@test f_oop(x0, u, p, t, w) == zeros(5)\n@test g(x0, u, p, 0.0) == [0, 0, 0, 0]\n\n# Non-zero disturbance inputs should result in non-zero state derivatives. We call `sort` since we do not generally know the order of the state variables\nw = [1.0, 2.0]\n@test sort(f_oop(x0, u, p, t, w)) == [0, 0, 0, 1, 2]","category":"section"},{"location":"tutorials/disturbance_modeling/#Input-signal-library","page":"Disturbance and input modeling modeling","title":"Input signal library","text":"The Blocks module in ModelingToolkitStandardLibrary contains several predefined input signals, such as Sine, Step, Ramp, Constant etc., a few of which were used in the examples above. If you have an input signal represented as a sequence of samples, you may use an Interpolation block, e.g., as src = Interpolation(ConstantInterpolation, data, timepoints), see the docstring for a complete example.","category":"section"},{"location":"tutorials/disturbance_modeling/#Disturbance-model-library","page":"Disturbance and input modeling modeling","title":"Disturbance-model library","text":"There is no library explicitly constructed for disturbance modeling. Standard blocks from the Blocks module in ModelingToolkitStandardLibrary, such as Integrator, TransferFunction, StateSpace, can model any disturbance with rational spectrum. Examples of this includes disturbance models such as constants, piecewise constant, periodic, highpass, lowpass, and bandpass. For help with filter design, see ControlSystems.jl: Filter-design and the interface package ControlSystemsMTK.jl. In the example above, we made use of Blocks.Integrator, which is a disturbance model suitable for disturbances dominated by low-frequency components, such as piecewise constant signals or slowly drifting signals.","category":"section"},{"location":"tutorials/disturbance_modeling/#Further-reading","page":"Disturbance and input modeling modeling","title":"Further reading","text":"To see full examples that perform state estimation with ModelingToolkit models, see the following resources:\n\nC codegen considered unnecessary: go directly to binary, do not pass C. Compilation of Julia code for deployment in model-based engineering\nLowLevelParticleFiltersMTK.jl","category":"section"},{"location":"tutorials/disturbance_modeling/#Index","page":"Disturbance and input modeling modeling","title":"Index","text":"Pages = [\"disturbance_modeling.md\"]","category":"section"},{"location":"tutorials/disturbance_modeling/#ModelingToolkit.get_comp_sensitivity-tutorials-disturbance_modeling","page":"Disturbance and input modeling modeling","title":"ModelingToolkit.get_comp_sensitivity","text":"get_comp_sensitivity(sys, ap::AnalysisPoint; kwargs)\nget_comp_sensitivity(sys, ap_name::Symbol; kwargs)\n\nCompute the complementary sensitivity function in analysis point ap. The complementary sensitivity function is obtained by introducing an infinitesimal perturbation d at the output of ap, linearizing the system and computing the transfer function between d and the input of ap.\n\nArguments:\n\nkwargs: Are sent to ModelingToolkit.linearize\n\nSee also get_sensitivity, get_looptransfer.\n\n\n\n\n\n","category":"function"},{"location":"tutorials/disturbance_modeling/#ModelingToolkit.get_comp_sensitivity_function-Tuple{ModelingToolkitBase.AbstractSystem, Any}-tutorials-disturbance_modeling","page":"Disturbance and input modeling modeling","title":"ModelingToolkit.get_comp_sensitivity_function","text":"get_comp_sensitivity_function(\n    sys::ModelingToolkitBase.AbstractSystem,\n    aps;\n    kwargs...\n) -> Tuple{ModelingToolkit.LinearizationFunction{Vector{Int64}, Vector{Int64}, Vector{SymbolicUtils.BasicSymbolicImpl.var\"typeof(BasicSymbolicImpl)\"{SymReal}}, P, _A, _B, J1, J2, J3, J4, IA, @NamedTuple{abstol::Float64, reltol::Float64, nlsolve_alg::Nothing}} where {P<:ODEProblem, _A, _B, J1<:Union{Nothing, ModelingToolkit.PreparedJacobian{true, DifferentiationInterfaceForwardDiffExt.ForwardDiffTwoArgJacobianPrep{Nothing, C, Tuple{Nothing, Nothing}}, ModelingToolkit.var\"#uff#6\"{var\"#64#fun\"}, _A, ADTypes.AutoForwardDiff{nothing, Nothing}} where {C<:(ForwardDiff.JacobianConfig{T, _A, _B, <:Tuple{Any, Any}} where {T<:(ForwardDiff.Tag{F} where F<:ModelingToolkit.var\"#uff#6\"), _A, _B}), var\"#64#fun\", _A}}, J2<:Union{Nothing, ModelingToolkit.PreparedJacobian{true, DifferentiationInterfaceForwardDiffExt.ForwardDiffTwoArgJacobianPrep{Nothing, C, Tuple{Nothing, Nothing}}, _A, _B, ADTypes.AutoForwardDiff{nothing, Nothing}} where {C<:ForwardDiff.JacobianConfig, _A, _B}}, J3<:Union{Nothing, ModelingToolkit.PreparedJacobian{true, DifferentiationInterfaceForwardDiffExt.ForwardDiffTwoArgJacobianPrep{Nothing, C, Tuple{Nothing, Nothing, Nothing}}, ModelingToolkit.var\"#pff#7\"{var\"#65#fun\", var\"#66#setter\"}, _A, ADTypes.AutoForwardDiff{nothing, Nothing}} where {C<:(ForwardDiff.JacobianConfig{T, _A, _B, <:Tuple{Any, Vector{T} where T<:(ForwardDiff.Dual{T, _A, _B} where {_B, _A, T})}} where {T<:(ForwardDiff.Tag{F} where F<:(ModelingToolkit.var\"#pff#7\"{_A, SymbolicIndexingInterface.OOPSetter{_A1, System, var\"#s177\"}} where {_A, _A1, T, var\"#s177\"<:AbstractVector{T}})), _A, _B}), var\"#65#fun\", var\"#66#setter\", _A}}, J4<:(ModelingToolkit.PreparedJacobian{true, DifferentiationInterfaceForwardDiffExt.ForwardDiffTwoArgJacobianPrep{Nothing, C, Tuple{Nothing, Nothing, Nothing}}, ModelingToolkit.var\"#hpf#5\"{fun, setter}, _A, ADTypes.AutoForwardDiff{nothing, Nothing}} where {C<:(ForwardDiff.JacobianConfig{T, _A, _B, <:Tuple{Any, Vector{T} where T<:(ForwardDiff.Dual{T, _A, _B} where {_B, _A, T<:(ForwardDiff.Tag{F} where F<:(ModelingToolkit.var\"#hpf#5\"{_A, SymbolicIndexingInterface.OOPSetter{_A1, System, var\"#s177\"}} where {_A, _A1, T, var\"#s177\"<:AbstractVector{T}}))})}} where {T<:(ForwardDiff.Tag{F} where F<:(ModelingToolkit.var\"#hpf#5\"{_A, SymbolicIndexingInterface.OOPSetter{_A1, System, var\"#s177\"}} where {_A, _A1, T, var\"#s177\"<:AbstractVector{T}})), _A, _B}), fun, setter, _A}), IA<:Union{SciMLBase.NoInit, SciMLBase.OverrideInit{Nothing, Nothing, Nothing}}}, System}\n\n\nReturn the complementary sensitivity function for the analysis point(s) aps, and the modified system simplified with the appropriate inputs and outputs.\n\nKeyword Arguments\n\nloop_openings: A list of analysis points whose connections should be removed and the outputs set to the input as a part of the linear analysis.\nsystem_modifier: A function taking the transformed system and applying any additional transformations, returning the modified system. The modified system is passed to linearization_function. \n\nAll other keyword arguments are forwarded to linearization_function.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/disturbance_modeling/#ModelingToolkit.get_looptransfer-tutorials-disturbance_modeling","page":"Disturbance and input modeling modeling","title":"ModelingToolkit.get_looptransfer","text":"get_looptransfer(sys, ap::AnalysisPoint; kwargs)\nget_looptransfer(sys, ap_name::Symbol; kwargs)\n\nCompute the (linearized) loop-transfer function in analysis point ap, from ap.out to ap.in.\n\ninfo: Negative feedback\nFeedback loops often use negative feedback, and the computed loop-transfer function will in this case have the negative feedback included. Standard analysis tools often assume a loop-transfer function without the negative gain built in, and the result of this function may thus need negation before use.\n\nArguments:\n\nkwargs: Are sent to ModelingToolkit.linearize\n\nSee also get_sensitivity, get_comp_sensitivity, open_loop.\n\n\n\n\n\n","category":"function"},{"location":"tutorials/disturbance_modeling/#ModelingToolkit.get_looptransfer_function-Tuple{ModelingToolkitBase.AbstractSystem, Any}-tutorials-disturbance_modeling","page":"Disturbance and input modeling modeling","title":"ModelingToolkit.get_looptransfer_function","text":"get_looptransfer_function(\n    sys::ModelingToolkitBase.AbstractSystem,\n    aps;\n    kwargs...\n) -> Tuple{ModelingToolkit.LinearizationFunction{Vector{Int64}, Vector{Int64}, Vector{SymbolicUtils.BasicSymbolicImpl.var\"typeof(BasicSymbolicImpl)\"{SymReal}}, P, _A, _B, J1, J2, J3, J4, IA, @NamedTuple{abstol::Float64, reltol::Float64, nlsolve_alg::Nothing}} where {P<:ODEProblem, _A, _B, J1<:Union{Nothing, ModelingToolkit.PreparedJacobian{true, DifferentiationInterfaceForwardDiffExt.ForwardDiffTwoArgJacobianPrep{Nothing, C, Tuple{Nothing, Nothing}}, ModelingToolkit.var\"#uff#6\"{var\"#64#fun\"}, _A, ADTypes.AutoForwardDiff{nothing, Nothing}} where {C<:(ForwardDiff.JacobianConfig{T, _A, _B, <:Tuple{Any, Any}} where {T<:(ForwardDiff.Tag{F} where F<:ModelingToolkit.var\"#uff#6\"), _A, _B}), var\"#64#fun\", _A}}, J2<:Union{Nothing, ModelingToolkit.PreparedJacobian{true, DifferentiationInterfaceForwardDiffExt.ForwardDiffTwoArgJacobianPrep{Nothing, C, Tuple{Nothing, Nothing}}, _A, _B, ADTypes.AutoForwardDiff{nothing, Nothing}} where {C<:ForwardDiff.JacobianConfig, _A, _B}}, J3<:Union{Nothing, ModelingToolkit.PreparedJacobian{true, DifferentiationInterfaceForwardDiffExt.ForwardDiffTwoArgJacobianPrep{Nothing, C, Tuple{Nothing, Nothing, Nothing}}, ModelingToolkit.var\"#pff#7\"{var\"#65#fun\", var\"#66#setter\"}, _A, ADTypes.AutoForwardDiff{nothing, Nothing}} where {C<:(ForwardDiff.JacobianConfig{T, _A, _B, <:Tuple{Any, Vector{T} where T<:(ForwardDiff.Dual{T, _A, _B} where {_B, _A, T})}} where {T<:(ForwardDiff.Tag{F} where F<:(ModelingToolkit.var\"#pff#7\"{_A, SymbolicIndexingInterface.OOPSetter{_A1, System, var\"#s177\"}} where {_A, _A1, T, var\"#s177\"<:AbstractVector{T}})), _A, _B}), var\"#65#fun\", var\"#66#setter\", _A}}, J4<:(ModelingToolkit.PreparedJacobian{true, DifferentiationInterfaceForwardDiffExt.ForwardDiffTwoArgJacobianPrep{Nothing, C, Tuple{Nothing, Nothing, Nothing}}, ModelingToolkit.var\"#hpf#5\"{fun, setter}, _A, ADTypes.AutoForwardDiff{nothing, Nothing}} where {C<:(ForwardDiff.JacobianConfig{T, _A, _B, <:Tuple{Any, Vector{T} where T<:(ForwardDiff.Dual{T, _A, _B} where {_B, _A, T<:(ForwardDiff.Tag{F} where F<:(ModelingToolkit.var\"#hpf#5\"{_A, SymbolicIndexingInterface.OOPSetter{_A1, System, var\"#s177\"}} where {_A, _A1, T, var\"#s177\"<:AbstractVector{T}}))})}} where {T<:(ForwardDiff.Tag{F} where F<:(ModelingToolkit.var\"#hpf#5\"{_A, SymbolicIndexingInterface.OOPSetter{_A1, System, var\"#s177\"}} where {_A, _A1, T, var\"#s177\"<:AbstractVector{T}})), _A, _B}), fun, setter, _A}), IA<:Union{SciMLBase.NoInit, SciMLBase.OverrideInit{Nothing, Nothing, Nothing}}}, System}\n\n\nReturn the loop-transfer function for the analysis point(s) aps, and the modified system simplified with the appropriate inputs and outputs.\n\nKeyword Arguments\n\nloop_openings: A list of analysis points whose connections should be removed and the outputs set to the input as a part of the linear analysis.\nsystem_modifier: A function taking the transformed system and applying any additional transformations, returning the modified system. The modified system is passed to linearization_function. \n\nAll other keyword arguments are forwarded to linearization_function.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/disturbance_modeling/#ModelingToolkit.get_sensitivity-tutorials-disturbance_modeling","page":"Disturbance and input modeling modeling","title":"ModelingToolkit.get_sensitivity","text":"get_sensitivity(sys, ap::AnalysisPoint; kwargs)\nget_sensitivity(sys, ap_name::Symbol; kwargs)\n\nCompute the sensitivity function in analysis point ap. The sensitivity function is obtained by introducing an infinitesimal perturbation d at the input of ap, linearizing the system and computing the transfer function between d and the output of ap.\n\nArguments:\n\nkwargs: Are sent to ModelingToolkit.linearize\n\nSee also get_comp_sensitivity, get_looptransfer.\n\n\n\n\n\n","category":"function"},{"location":"tutorials/disturbance_modeling/#ModelingToolkit.get_sensitivity_function-Tuple{ModelingToolkitBase.AbstractSystem, Any}-tutorials-disturbance_modeling","page":"Disturbance and input modeling modeling","title":"ModelingToolkit.get_sensitivity_function","text":"get_sensitivity_function(\n    sys::ModelingToolkitBase.AbstractSystem,\n    aps;\n    kwargs...\n) -> Tuple{ModelingToolkit.LinearizationFunction{Vector{Int64}, Vector{Int64}, Vector{SymbolicUtils.BasicSymbolicImpl.var\"typeof(BasicSymbolicImpl)\"{SymReal}}, P, _A, _B, J1, J2, J3, J4, IA, @NamedTuple{abstol::Float64, reltol::Float64, nlsolve_alg::Nothing}} where {P<:ODEProblem, _A, _B, J1<:Union{Nothing, ModelingToolkit.PreparedJacobian{true, DifferentiationInterfaceForwardDiffExt.ForwardDiffTwoArgJacobianPrep{Nothing, C, Tuple{Nothing, Nothing}}, ModelingToolkit.var\"#uff#6\"{var\"#64#fun\"}, _A, ADTypes.AutoForwardDiff{nothing, Nothing}} where {C<:(ForwardDiff.JacobianConfig{T, _A, _B, <:Tuple{Any, Any}} where {T<:(ForwardDiff.Tag{F} where F<:ModelingToolkit.var\"#uff#6\"), _A, _B}), var\"#64#fun\", _A}}, J2<:Union{Nothing, ModelingToolkit.PreparedJacobian{true, DifferentiationInterfaceForwardDiffExt.ForwardDiffTwoArgJacobianPrep{Nothing, C, Tuple{Nothing, Nothing}}, _A, _B, ADTypes.AutoForwardDiff{nothing, Nothing}} where {C<:ForwardDiff.JacobianConfig, _A, _B}}, J3<:Union{Nothing, ModelingToolkit.PreparedJacobian{true, DifferentiationInterfaceForwardDiffExt.ForwardDiffTwoArgJacobianPrep{Nothing, C, Tuple{Nothing, Nothing, Nothing}}, ModelingToolkit.var\"#pff#7\"{var\"#65#fun\", var\"#66#setter\"}, _A, ADTypes.AutoForwardDiff{nothing, Nothing}} where {C<:(ForwardDiff.JacobianConfig{T, _A, _B, <:Tuple{Any, Vector{T} where T<:(ForwardDiff.Dual{T, _A, _B} where {_B, _A, T})}} where {T<:(ForwardDiff.Tag{F} where F<:(ModelingToolkit.var\"#pff#7\"{_A, SymbolicIndexingInterface.OOPSetter{_A1, System, var\"#s177\"}} where {_A, _A1, T, var\"#s177\"<:AbstractVector{T}})), _A, _B}), var\"#65#fun\", var\"#66#setter\", _A}}, J4<:(ModelingToolkit.PreparedJacobian{true, DifferentiationInterfaceForwardDiffExt.ForwardDiffTwoArgJacobianPrep{Nothing, C, Tuple{Nothing, Nothing, Nothing}}, ModelingToolkit.var\"#hpf#5\"{fun, setter}, _A, ADTypes.AutoForwardDiff{nothing, Nothing}} where {C<:(ForwardDiff.JacobianConfig{T, _A, _B, <:Tuple{Any, Vector{T} where T<:(ForwardDiff.Dual{T, _A, _B} where {_B, _A, T<:(ForwardDiff.Tag{F} where F<:(ModelingToolkit.var\"#hpf#5\"{_A, SymbolicIndexingInterface.OOPSetter{_A1, System, var\"#s177\"}} where {_A, _A1, T, var\"#s177\"<:AbstractVector{T}}))})}} where {T<:(ForwardDiff.Tag{F} where F<:(ModelingToolkit.var\"#hpf#5\"{_A, SymbolicIndexingInterface.OOPSetter{_A1, System, var\"#s177\"}} where {_A, _A1, T, var\"#s177\"<:AbstractVector{T}})), _A, _B}), fun, setter, _A}), IA<:Union{SciMLBase.NoInit, SciMLBase.OverrideInit{Nothing, Nothing, Nothing}}}, System}\n\n\nReturn the sensitivity function for the analysis point(s) aps, and the modified system simplified with the appropriate inputs and outputs.\n\nKeyword Arguments\n\nloop_openings: A list of analysis points whose connections should be removed and the outputs set to the input as a part of the linear analysis.\nsystem_modifier: A function taking the transformed system and applying any additional transformations, returning the modified system. The modified system is passed to linearization_function. \n\nAll other keyword arguments are forwarded to linearization_function.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/disturbance_modeling/#ModelingToolkit.linearization_ap_transform-Tuple{Any, Union{Vector{Symbol}, Vector{AnalysisPoint}, Symbol, AnalysisPoint}, Any, Any}-tutorials-disturbance_modeling","page":"Disturbance and input modeling modeling","title":"ModelingToolkit.linearization_ap_transform","text":"sys, input_vars, output_vars =\n\nlinearization_ap_transform(\n    sys,\n    inputs::Union{Vector{Symbol}, Vector{AnalysisPoint}, Symbol, AnalysisPoint},\n    outputs,\n    loop_openings\n) -> Tuple{Any, Vector{SymbolicUtils.BasicSymbolicImpl.var\"typeof(BasicSymbolicImpl)\"{SymReal}}, Vector{SymbolicUtils.BasicSymbolicImpl.var\"typeof(BasicSymbolicImpl)\"{SymReal}}}\n\n\nApply analysis-point transformations to prepare a system for linearization.\n\nReturns\n\nsys: The transformed system.\ninput_vars: A vector of input variables corresponding to the input analysis points.\noutput_vars: A vector of output variables corresponding to the output analysis points.\n\n\n\n\n\n","category":"method"},{"location":"basics/Precompilation/#Working-with-Precompilation-and-Binary-Building","page":"Working with Precompilation and Binary Building","title":"Working with Precompilation and Binary Building","text":"","category":"section"},{"location":"basics/Precompilation/#tl;dr,-I-just-want-precompilation-to-work","page":"Working with Precompilation and Binary Building","title":"tl;dr, I just want precompilation to work","text":"The tl;dr is, if you want to make precompilation work then instead of\n\nODEProblem(sys, u0, tspan, p)\n\nuse:\n\nODEProblem(sys, u0, tspan, p, eval_module = @__MODULE__, eval_expression = true)\n\nAs a full example, here's an example of a module that would precompile effectively:\n\nmodule PrecompilationMWE\nusing ModelingToolkit\n\n@variables x(ModelingToolkit.t_nounits)\n@named sys = System([ModelingToolkit.D_nounits(x) ~ -x + 1], ModelingToolkit.t_nounits)\nprob = ODEProblem(mtkcompile(sys), [x => 30.0], (0, 100), [],\n    eval_expression = true, eval_module = @__MODULE__)\n\nend\n\nIf you use that in your package's code then 99% of the time that's the right answer to get precompilation working.","category":"section"},{"location":"basics/Precompilation/#I'm-doing-something-fancier-and-need-a-bit-more-of-an-explanation","page":"Working with Precompilation and Binary Building","title":"I'm doing something fancier and need a bit more of an explanation","text":"Oh you dapper soul, time for the bigger explanation. Julia's eval function evaluates a function into a module at a specified world-age. If you evaluate a function within a function and try to call it from within that same function, you will hit a world-age error. This looks like:\n\nfunction worldageerror()\n    f = eval(:((x) -> 2x))\n    f(2)\nend\n\njulia> worldageerror()\nERROR: MethodError: no method matching (::var\"#5#6\")(::Int64)\n\nClosest candidates are:\n  (::var\"#5#6\")(::Any) (method too new to be called from this world context.)\n   @ Main REPL[12]:2\n\nThis is done for many reasons, in particular if the code that is called within a function could change at any time, then Julia functions could not ever properly optimize because the meaning of any function or dispatch could always change and you would lose performance by guarding against that. For a full discussion of world-age, see this paper.\n\nHowever, this would be greatly inhibiting to standard ModelingToolkit usage because then something as simple as building an ODEProblem in a function and then using it would get a world age error:\n\nfunction wouldworldage()\n    prob = ODEProblem(sys, [], (0.0, 1.0))\n    sol = solve(prob)\nend\n\nThe reason is because prob.f would be constructed via eval, and thus prob.f could not be called in the function, which means that no solve could ever work in the same function that generated the problem. That does mean that:\n\nfunction wouldworldage()\n    prob = ODEProblem(sys, [], (0.0, 1.0))\nend\nsol = solve(prob)\n\nis fine, or putting\n\nprob = ODEProblem(sys, [], (0.0, 1.0))\nsol = solve(prob)\n\nat the top level of a module is perfectly fine too. They just cannot happen in the same function.\n\nThis would be a major limitation to ModelingToolkit, and thus we developed RuntimeGeneratedFunctions to get around this limitation. It will not be described beyond that, it is dark art and should not be investigated. But it does the job. But that does mean that it plays... oddly with Julia's compilation.\n\nThere are ways to force RuntimeGeneratedFunctions to perform their evaluation and caching within a given module, but that is not recommended because it does not play nicely with Julia v1.9's introduction of package images for binary caching.\n\nThus when trying to make things work with precompilation, we recommend using eval. This is done by simply adding eval_expression=true to the problem constructor. However, this is not a silver bullet because the moment you start using eval, all potential world-age restrictions apply, and thus it is recommended this is simply used for evaluating at the top level of modules for the purpose of precompilation and ensuring binaries of your MTK functions are built correctly.\n\nHowever, there is one caveat that eval in Julia works depending on the module that it is given. If you have MyPackage that you are precompiling into, or say you are using juliac or PackageCompiler or some other static ahead-of-time (AOT) Julia compiler, then you don't want to accidentally eval that function to live in ModelingToolkit and instead want to make sure it is eval'd to live in MyPackage (since otherwise it will not cache into the binary). ModelingToolkit cannot know that in advance, and thus you have to pass in the module you wish for the functions to \"live\" in. This is done via the eval_module argument.\n\nHence ODEProblem(sys, u0, tspan, p, eval_module=@__MODULE__, eval_expression=true) will work if you are running this expression in the scope of the module you wish to be precompiling. However, if you are attempting to AOT compile a different module, this means that eval_module needs to be appropriately chosen. And, because eval_expression=true, all caveats of world-age apply.","category":"section"},{"location":"API/problems/#Building-and-solving-numerical-problems","page":"Building and solving numerical problems","title":"Building and solving numerical problems","text":"Systems are numerically solved by building and solving the appropriate problem type. Numerical solvers expect to receive functions taking a predefeined set of arguments and returning specific values. This format of argument and return value depends on the function and the problem. ModelingToolkit is capable of compiling and generating code for a variety of such numerical problems.","category":"section"},{"location":"API/problems/#Dynamical-systems","page":"Building and solving numerical problems","title":"Dynamical systems","text":"","category":"section"},{"location":"API/problems/#Linear-and-Nonlinear-systems","page":"Building and solving numerical problems","title":"Linear and Nonlinear systems","text":"","category":"section"},{"location":"API/problems/#Optimization-and-optimal-control","page":"Building and solving numerical problems","title":"Optimization and optimal control","text":"","category":"section"},{"location":"API/problems/#The-state-vector-and-parameter-object","page":"Building and solving numerical problems","title":"The state vector and parameter object","text":"Typically the unknowns of the system are present as a Vector of the appropriate length in the numerical problem. The state vector can also be constructed manually without building a problem.\n\nBy default, the parameters of the system are stored in a custom data structure called MTKParameters. The internals of this data structure are undocumented, and it should only be interacted with through defined public API. SymbolicIndexingInterface.jl contains functionality useful for this purpose.\n\nThe following functions are useful when working with MTKParameters objects, and especially the Tunables portion. For more information about the \"portions\" of MTKParameters, refer to the SciMLStructures.jl documentation.","category":"section"},{"location":"API/problems/#Initialization","page":"Building and solving numerical problems","title":"Initialization","text":"","category":"section"},{"location":"API/problems/#Linear-analysis","page":"Building and solving numerical problems","title":"Linear analysis","text":"There are also utilities for manipulating the results of these analyses in a symbolic context.","category":"section"},{"location":"API/problems/#Analysis-point-transformations","page":"Building and solving numerical problems","title":"Analysis point transformations","text":"Linear analysis can also be done using analysis points to perform several common workflows.","category":"section"},{"location":"API/problems/#ModelingToolkit.SemilinearODEFunction","page":"Building and solving numerical problems","title":"ModelingToolkit.SemilinearODEFunction","text":"ModelingToolkit.SemilinearODEFunction(sys::System; kwargs...)\nModelingToolkit.SemilinearODEFunction{iip}(sys::System; kwargs...)\nModelingToolkit.SemilinearODEFunction{iip, specialize}(sys::System; kwargs...)\n\nCreate a ModelingToolkit.SemilinearODEFunction from the given sys. iip is a boolean indicating whether the function should be in-place. specialization is a SciMLBase.AbstractSpecalize subtype indicating the level of specialization of the ModelingToolkit.SemilinearODEFunction.\n\nThis is a special form of an ODE which uses a SplitFunction internally. The equations are separated into linear, quadratic and general terms and phrased as matrix operations. See calculate_semiquadratic_form for information on how the equations are split. This formulation allows leveraging split ODE solvers such as KenCarp4 and is useful for systems where the stiff and non-stiff terms can be separated out in such a manner. Typically the linear part of the equations is the stiff part, but the keywords stiff_linear, stiff_quadratic and stiff_nonlinear can be used to control which parts are considered as stiff.\n\nBeyond the arguments listed below, this constructor accepts all keyword arguments supported by the DifferentialEquations.jl solve function. For a complete list and detailed descriptions, see the DifferentialEquations.jl solve documentation.\n\nKeyword arguments\n\nu0: The u0 vector for the corresponding problem, if available. Can be obtained using ModelingToolkitBase.get_u0.\np: The parameter object for the corresponding problem, if available. Can be obtained using ModelingToolkitBase.get_p.\nt: The initial time for the corresponding problem, if available.\neval_expression: Whether to compile any functions via eval or RuntimeGeneratedFunctions.\neval_module: If eval_expression == true, the module to eval into. Otherwise, the module in which to generate the RuntimeGeneratedFunction.\ncheckbounds: Whether to enable bounds checking in the generated code.\nsimplify: Whether to simplify any symbolically computed jacobians/hessians/etc.\ncse: Whether to enable Common Subexpression Elimination (CSE) on the generated code. This typically improves performance of the generated code but reduces readability.\nsparse: Whether to generate jacobian/hessian/etc. functions that return/operate on sparse matrices. Also controls whether the mass matrix is sparse, wherever applicable.\ncheck_compatibility: Whether to check if the given system sys contains all the information necessary to create a ModelingToolkit.SemilinearODEFunction and no more. If disabled, assumes that sys at least contains the necessary information.\nexpression: Val{true} to return an Expr that constructs the corresponding problem instead of the problem itself. Val{false} otherwise.  Constructing the expression does not support callbacks\njac: Whether to symbolically compute and generate code for the jacobian function.\nsparsity: Whether to provide symbolically compute and provide sparsity patterns for the jacobian/hessian/etc.\nstiff_linear: Whether the linear part of the equations should be part of the stiff function in the split form. Has no effect if the equations have no linear part.\nstiff_quadratic: Whether the quadratic part of the equations should be part of the stiff function in the split form. Has no effect if the equations have no quadratic part.\nstiff_nonlinear: Whether the non-linear non-quadratic part of the equations should be part of the stiff function in the split form. Has no effect if the equations have no such non-linear non-quadratic part.\nkwargs...: Additional keyword arguments passed to the solver\n\nAll other keyword arguments are forwarded to the ModelingToolkit.SemilinearODEFunction struct constructor. Note that all three of stiff_linear, stiff_quadratic, stiff_nonlinear cannot be identical, and at least two of A, B, C returned from calculate_semiquadratic_form must be non-nothing. In other words, both of the functions in the split form must be non-empty.\n\n\n\n\n\n","category":"type"},{"location":"API/problems/#ModelingToolkit.SemilinearODEProblem","page":"Building and solving numerical problems","title":"ModelingToolkit.SemilinearODEProblem","text":"SciMLBase.ModelingToolkit.SemilinearODEProblem(sys::System, op, tspan::NTuple{2}; kwargs...)\nSciMLBase.ModelingToolkit.SemilinearODEProblem{iip}(sys::System, op, tspan::NTuple{2}; kwargs...)\nSciMLBase.ModelingToolkit.SemilinearODEProblem{iip, specialize}(sys::System, op, tspan::NTuple{2}; kwargs...)\n\nBuild a ModelingToolkit.SemilinearODEProblem given a system sys and operating point op  and timespan tspan. iip is a boolean indicating whether the problem should be in-place. specialization is a SciMLBase.AbstractSpecalize subtype indicating the level of specialization of the ModelingToolkit.SemilinearODEFunction. The operating point should be an iterable collection of key-value pairs mapping variables/parameters in the system to the (initial) values they should take in ModelingToolkit.SemilinearODEProblem. Any values not provided will fallback to the corresponding default (if present).\n\nModelingToolkitBase will build an initialization problem where all initial values for unknowns or observables of sys (either explicitly provided or in defaults) will be constraints. To remove an initial condition in the defaults (without providing a replacement) give the corresponding variable a value of nothing in the operating point. The initialization problem will also run parameter initialization. See the Initialization documentation for more information.\n\nThis is a special form of an ODE which uses a SplitFunction internally. The equations are separated into linear, quadratic and general terms and phrased as matrix operations. See calculate_semiquadratic_form for information on how the equations are split. This formulation allows leveraging split ODE solvers such as KenCarp4 and is useful for systems where the stiff and non-stiff terms can be separated out in such a manner. Typically the linear part of the equations is the stiff part, but the keywords stiff_linear, stiff_quadratic and stiff_nonlinear can be used to control which parts are considered as stiff.\n\nKeyword arguments\n\neval_expression: Whether to compile any functions via eval or RuntimeGeneratedFunctions.\neval_module: If eval_expression == true, the module to eval into. Otherwise, the module in which to generate the RuntimeGeneratedFunction.\nguesses: The guesses for variables in the system, used as initial values for the initialization problem.\nwarn_initialize_determined: Warn if the initialization system is under/over-determined.\ninitialization_eqs: Extra equations to use in the initialization problem.\nfully_determined: Override whether the initialization system is fully determined.\nuse_scc: Whether to use SCCNonlinearProblem for initialization if the system is fully determined.\ncheck_initialization_units: Enable or disable unit checks when constructing the initialization problem.\ntofloat: Passed to varmap_to_vars when building the parameter vector of a non-split system.\nu0_eltype: The eltype of the u0 vector. If nothing, finds the promoted floating point type from op.\nu0_constructor: A function to apply to the u0 value returned from varmap_to_vars. to construct the final u0 value.\np_constructor: A function to apply to each array buffer created when constructing the parameter object.\nwarn_cyclic_dependency: Whether to emit a warning listing out cycles in initial conditions provided for unknowns and parameters.\ncircular_dependency_max_cycle_length: Maximum length of cycle to check for. Only applicable if warn_cyclic_dependency == true.\ncircular_dependency_max_cycles: Maximum number of cycles to check for. Only applicable if warn_cyclic_dependency == true.\nsubstitution_limit: The number times to substitute initial conditions into each other to attempt to arrive at a numeric value.\nmissing_guess_value: An instance of MissingGuessValue which indicates what happens when the initialization problem is missing guess values for variables.\ninitsys_mtkcompile_kwargs: A NamedTuple of keyword arguments to pass to mtkcompile when it is called on the initialization system.\ncallback: An extra callback or CallbackSet to add to the problem, in addition to the ones defined symbolically in the system.\ncheck_compatibility: Whether to check if the given system sys contains all the information necessary to create a ModelingToolkit.SemilinearODEProblem and no more. If disabled, assumes that sys at least contains the necessary information.\nexpression: Val{true} to return an Expr that constructs the corresponding problem instead of the problem itself. Val{false} otherwise.  Constructing the expression does not support callbacks\nstiff_linear: Whether the linear part of the equations should be part of the stiff function in the split form. Has no effect if the equations have no linear part.\nstiff_quadratic: Whether the quadratic part of the equations should be part of the stiff function in the split form. Has no effect if the equations have no quadratic part.\nstiff_nonlinear: Whether the non-linear non-quadratic part of the equations should be part of the stiff function in the split form. Has no effect if the equations have no such non-linear non-quadratic part.\n\nAll other keyword arguments are forwarded to the ModelingToolkit.SemilinearODEFunction constructor. Note that all three of stiff_linear, stiff_quadratic, stiff_nonlinear cannot be identical, and at least two of A, B, C returned from calculate_semiquadratic_form must be non-nothing. In other words, both of the functions in the split form must be non-empty.\n\nExtended docs\n\nThe following API is internal and may change or be removed without notice. Its usage is highly discouraged.\n\nbuild_initializeprob: If false, avoids building the initialization problem.\ncheck_length: Whether to check the number of equations along with number of unknowns and length of u0 vector for consistency. If false, do not check with equations. This is forwarded to check_eqs_u0.\ntime_dependent_init: Whether to build a time-dependent initialization for the problem. A time-dependent initialization solves for a consistent u0, whereas a time-independent one only runs parameter initialization.\nalgebraic_only: Whether to build the initialization problem using only algebraic equations.\nallow_incomplete: Whether to allow incomplete initialization problems.\n\n\n\n\n\n","category":"type"},{"location":"API/problems/#SciMLBase.SCCNonlinearProblem","page":"Building and solving numerical problems","title":"SciMLBase.SCCNonlinearProblem","text":"SciMLBase.SciMLBase.SCCNonlinearProblem(sys::System, op; kwargs...)\nSciMLBase.SciMLBase.SCCNonlinearProblem{iip}(sys::System, op; kwargs...)\nSciMLBase.SciMLBase.SCCNonlinearProblem{iip, specialize}(sys::System, op; kwargs...)\n\nBuild a SciMLBase.SCCNonlinearProblem given a system sys and operating point op . iip is a boolean indicating whether the problem should be in-place. specialization is a SciMLBase.AbstractSpecalize subtype indicating the level of specialization of the SciMLBase.NonlinearFunction. The operating point should be an iterable collection of key-value pairs mapping variables/parameters in the system to the (initial) values they should take in SciMLBase.SCCNonlinearProblem. Any values not provided will fallback to the corresponding default (if present).\n\nKeyword arguments\n\neval_expression: Whether to compile any functions via eval or RuntimeGeneratedFunctions.\neval_module: If eval_expression == true, the module to eval into. Otherwise, the module in which to generate the RuntimeGeneratedFunction.\nguesses: The guesses for variables in the system, used as initial values for the initialization problem.\nwarn_initialize_determined: Warn if the initialization system is under/over-determined.\ninitialization_eqs: Extra equations to use in the initialization problem.\nfully_determined: Override whether the initialization system is fully determined.\nuse_scc: Whether to use SCCNonlinearProblem for initialization if the system is fully determined.\ncheck_initialization_units: Enable or disable unit checks when constructing the initialization problem.\ntofloat: Passed to varmap_to_vars when building the parameter vector of a non-split system.\nu0_eltype: The eltype of the u0 vector. If nothing, finds the promoted floating point type from op.\nu0_constructor: A function to apply to the u0 value returned from varmap_to_vars. to construct the final u0 value.\np_constructor: A function to apply to each array buffer created when constructing the parameter object.\nwarn_cyclic_dependency: Whether to emit a warning listing out cycles in initial conditions provided for unknowns and parameters.\ncircular_dependency_max_cycle_length: Maximum length of cycle to check for. Only applicable if warn_cyclic_dependency == true.\ncircular_dependency_max_cycles: Maximum number of cycles to check for. Only applicable if warn_cyclic_dependency == true.\nsubstitution_limit: The number times to substitute initial conditions into each other to attempt to arrive at a numeric value.\nmissing_guess_value: An instance of MissingGuessValue which indicates what happens when the initialization problem is missing guess values for variables.\ninitsys_mtkcompile_kwargs: A NamedTuple of keyword arguments to pass to mtkcompile when it is called on the initialization system.\n\ncheck_compatibility: Whether to check if the given system sys contains all the information necessary to create a SciMLBase.SCCNonlinearProblem and no more. If disabled, assumes that sys at least contains the necessary information.\nexpression: Val{true} to return an Expr that constructs the corresponding problem instead of the problem itself. Val{false} otherwise.\n\nAll other keyword arguments are forwarded to the SciMLBase.NonlinearFunction constructor.\n\nExtended docs\n\nThe following API is internal and may change or be removed without notice. Its usage is highly discouraged.\n\nbuild_initializeprob: If false, avoids building the initialization problem.\ncheck_length: Whether to check the number of equations along with number of unknowns and length of u0 vector for consistency. If false, do not check with equations. This is forwarded to check_eqs_u0.\ntime_dependent_init: Whether to build a time-dependent initialization for the problem. A time-dependent initialization solves for a consistent u0, whereas a time-independent one only runs parameter initialization.\nalgebraic_only: Whether to build the initialization problem using only algebraic equations.\nallow_incomplete: Whether to allow incomplete initialization problems.\n\n\n\n\n\n","category":"type"},{"location":"API/problems/#ModelingToolkit.linearization_function","page":"Building and solving numerical problems","title":"ModelingToolkit.linearization_function","text":"lin_fun, simplified_sys = linearization_function(sys::AbstractSystem, inputs, outputs; simplify = false, initialize = true, initialization_solver_alg = nothing, kwargs...)\n\nReturn a function that linearizes the system sys. The function linearize provides a higher-level and easier to use interface.\n\nlin_fun is a function (variables, p, t) -> (; f_x, f_z, g_x, g_z, f_u, g_u, h_x, h_z, h_u), i.e., it returns a NamedTuple with the Jacobians of f,g,h for the nonlinear sys (technically for simplified_sys) on the form\n\nbeginaligned\nx = f(x z u) \n0 = g(x z u) \ny = h(x z u)\nendaligned\n\nwhere x are differential unknown variables, z algebraic variables, u inputs and y outputs. To obtain a linear statespace representation, see linearize. The input argument variables is a vector defining the operating point, corresponding to unknowns(simplified_sys) and p is a vector corresponding to the parameters of simplified_sys. Note: all variables in inputs have been converted to parameters in simplified_sys.\n\nThe simplified_sys has undergone mtkcompile and had any occurring input or output variables replaced with the variables provided in arguments inputs and outputs. The unknowns of this system also indicate the order of the unknowns that holds for the linearized matrices.\n\nArguments:\n\nsys: A System of ODEs. This function will automatically apply simplification passes on sys and return the resulting simplified_sys.\ninputs: A vector of variables that indicate the inputs of the linearized input-output model.\noutputs: A vector of variables that indicate the outputs of the linearized input-output model.\nsimplify: Apply simplification in tearing.\ninitialize: If true, a check is performed to ensure that the operating point is consistent (satisfies algebraic equations). If the op is not consistent, initialization is performed.\ninitialization_solver_alg: A NonlinearSolve algorithm to use for solving for a feasible set of state and algebraic variables that satisfies the specified operating point.\nautodiff: An ADType supported by DifferentiationInterface.jl to use for calculating the necessary jacobians. Defaults to using AutoForwardDiff()\nkwargs: Are passed on to find_solvables!\n\nSee also linearize which provides a higher-level interface.\n\n\n\n\n\n","category":"function"},{"location":"API/problems/#ModelingToolkit.LinearizationProblem","page":"Building and solving numerical problems","title":"ModelingToolkit.LinearizationProblem","text":"mutable struct LinearizationProblem{F<:ModelingToolkit.LinearizationFunction, T}\n\nA struct representing a linearization operation to be performed. Can be symbolically indexed to efficiently update the operating point for multiple linearizations in a loop. The value of the independent variable can be set by mutating the .t field of this struct.\n\n\n\n\n\n","category":"type"},{"location":"API/problems/#ModelingToolkit.linearize","page":"Building and solving numerical problems","title":"ModelingToolkit.linearize","text":"(; A, B, C, D), simplified_sys, extras = linearize(sys, inputs, outputs;    t=0.0, op = Dict(), allow_input_derivatives = false, zero_dummy_der=false, kwargs...)\n(; A, B, C, D), extras                 = linearize(simplified_sys, lin_fun; t=0.0, op = Dict(), allow_input_derivatives = false, zero_dummy_der=false)\n\nLinearize sys between inputs and outputs, both vectors of variables. Return a NamedTuple with the matrices of a linear statespace representation on the form\n\nbeginaligned\nx = Ax + Bu\ny = Cx + Du\nendaligned\n\nThe first signature automatically calls linearization_function internally, while the second signature expects the outputs of linearization_function as input.\n\nop denotes the operating point around which to linearize. If none is provided, the default values of sys are used.\n\nIf allow_input_derivatives = false, an error will be thrown if input derivatives (u) appear as inputs in the linearized equations. If input derivatives are allowed, the returned B matrix will be of double width, corresponding to the input [u; u̇].\n\nzero_dummy_der can be set to automatically set the operating point to zero for all dummy derivatives.\n\nThe return value extras is a NamedTuple (; x, p, t) containing the result of the initialization problem that was solved to determine the operating point.\n\nSee also linearization_function which provides a lower-level interface, linearize_symbolic and ModelingToolkit.reorder_unknowns.\n\nSee extended help for an example.\n\nThe implementation and notation follows that of \"Linear Analysis Approach for Modelica Models\", Allain et al. 2009\n\nExtended help\n\nThis example builds the following feedback interconnection and linearizes it from the input of F to the output of P.\n\n\n  r ┌─────┐       ┌─────┐     ┌─────┐\n───►│     ├──────►│     │  u  │     │\n    │  F  │       │  C  ├────►│  P  │ y\n    └─────┘     ┌►│     │     │     ├─┬─►\n                │ └─────┘     └─────┘ │\n                │                     │\n                └─────────────────────┘\n\nusing ModelingToolkit\nusing ModelingToolkit: t_nounits as t, D_nounits as D\nfunction plant(; name)\n    @variables x(t) = 1\n    @variables u(t)=0 y(t)=0\n    eqs = [D(x) ~ -x + u\n           y ~ x]\n    System(eqs, t; name = name)\nend\n\nfunction ref_filt(; name)\n    @variables x(t)=0 y(t)=0\n    @variables u(t)=0 [input = true]\n    eqs = [D(x) ~ -2 * x + u\n           y ~ x]\n    System(eqs, t, name = name)\nend\n\nfunction controller(kp; name)\n    @variables y(t)=0 r(t)=0 u(t)=0\n    @parameters kp = kp\n    eqs = [\n        u ~ kp * (r - y),\n    ]\n    System(eqs, t; name = name)\nend\n\n@named f = ref_filt()\n@named c = controller(1)\n@named p = plant()\n\nconnections = [f.y ~ c.r # filtered reference to controller reference\n               c.u ~ p.u # controller output to plant input\n               p.y ~ c.y]\n\n@named cl = System(connections, t, systems = [f, c, p])\n\nlsys0, ssys = linearize(cl, [f.u], [p.x])\ndesired_order = [f.x, p.x]\nlsys = ModelingToolkit.reorder_unknowns(lsys0, unknowns(ssys), desired_order)\n\n@assert lsys.A == [-2 0; 1 -2]\n@assert lsys.B == [1; 0;;]\n@assert lsys.C == [0 1]\n@assert lsys.D[] == 0\n\n## Symbolic linearization\nlsys_sym, _ = ModelingToolkit.linearize_symbolic(cl, [f.u], [p.x])\n\n@assert substitute(lsys_sym.A, ModelingToolkit.defaults(cl)) == lsys.A\n\n\n\n\n\n","category":"function"},{"location":"API/problems/#ModelingToolkit.similarity_transform","page":"Building and solving numerical problems","title":"ModelingToolkit.similarity_transform","text":"(; Ã, B̃, C̃, D̃) = similarity_transform(sys, T; unitary=false)\n\nPerform a similarity transform T : Tx̃ = x on linear system represented by matrices in NamedTuple sys such that\n\nÃ = T⁻¹AT\nB̃ = T⁻¹ B\nC̃ = CT\nD̃ = D\n\nIf unitary=true, T is assumed unitary and the matrix adjoint is used instead of the inverse.\n\n\n\n\n\n","category":"function"},{"location":"API/problems/#ModelingToolkit.reorder_unknowns","page":"Building and solving numerical problems","title":"ModelingToolkit.reorder_unknowns","text":"reorder_unknowns(sys::NamedTuple, old, new)\n\nPermute the state representation of sys obtained from linearize so that the state unknown is changed from old to new Example:\n\nlsys, ssys = linearize(pid, [reference.u, measurement.u], [ctr_output.u])\ndesired_order = [int.x, der.x] # Unknowns that are present in unknowns(ssys)\nlsys = ModelingToolkit.reorder_unknowns(lsys, unknowns(ssys), desired_order)\n\nSee also ModelingToolkit.similarity_transform\n\n\n\n\n\n","category":"function"},{"location":"examples/modelingtoolkitize_index_reduction/#Automated-Index-Reduction-of-DAEs","page":"Automated Index Reduction of DAEs","title":"Automated Index Reduction of DAEs","text":"In many cases one may accidentally write down a DAE that is not easily solvable by numerical methods. In this tutorial, we will walk through an example of a pendulum which accidentally generates an index-3 DAE, and show how to use the modelingtoolkitize to correct the model definition before solving.","category":"section"},{"location":"examples/modelingtoolkitize_index_reduction/#Copy-Pastable-Example","page":"Automated Index Reduction of DAEs","title":"Copy-Pastable Example","text":"using ModelingToolkit\nusing LinearAlgebra\nusing OrdinaryDiffEq\nusing Plots\n\nfunction pendulum!(du, u, p, t)\n    x, dx, y, dy, T = u\n    g, L = p\n    du[1] = dx\n    du[2] = T * x\n    du[3] = dy\n    du[4] = T * y - g\n    du[5] = x^2 + y^2 - L^2\n    return nothing\nend\npendulum_fun! = ODEFunction(pendulum!, mass_matrix = Diagonal([1, 1, 1, 1, 0]))\nu0 = [1.0, 0, 0, 0, 0]\np = [9.8, 1]\ntspan = (0, 10.0)\npendulum_prob = ODEProblem(pendulum_fun!, u0, tspan, p)\ntraced_sys = modelingtoolkitize(pendulum_prob)\npendulum_sys = mtkcompile(dae_index_lowering(traced_sys))\nprob = ODEProblem(pendulum_sys, [], tspan)\nsol = solve(prob, Rodas5P(), abstol = 1e-8, reltol = 1e-8)\nplot(sol, idxs = unknowns(traced_sys))","category":"section"},{"location":"examples/modelingtoolkitize_index_reduction/#Explanation","page":"Automated Index Reduction of DAEs","title":"Explanation","text":"","category":"section"},{"location":"examples/modelingtoolkitize_index_reduction/#Attempting-to-Solve-the-Equation","page":"Automated Index Reduction of DAEs","title":"Attempting to Solve the Equation","text":"In this tutorial, we will look at the pendulum system:\n\nbeginaligned\n    x^prime = v_x\n    v_x^prime = Tx\n    y^prime = v_y\n    v_y^prime = Ty - g\n    0 = x^2 + y^2 - L^2\nendaligned\n\nThese equations can be derived using the Lagrangian equation of the first kind. Specifically, for a pendulum with unit mass and length L, which thus has kinetic energy frac12(v_x^2 + v_y^2), potential energy gy, and holonomic constraint x^2 + y^2 - L^2 = 0. The Lagrange multiplier related to this constraint is equal to half of T, and represents the tension in the rope of the pendulum.\n\nAs a good DifferentialEquations.jl user, one would follow the mass matrix DAE tutorial to arrive at code for simulating the model:\n\nusing OrdinaryDiffEq, LinearAlgebra\nfunction pendulum!(du, u, p, t)\n    x, dx, y, dy, T = u\n    g, L = p\n    du[1] = dx\n    du[2] = T * x\n    du[3] = dy\n    du[4] = T * y - g\n    du[5] = x^2 + y^2 - L^2\nend\npendulum_fun! = ODEFunction(pendulum!, mass_matrix = Diagonal([1, 1, 1, 1, 0]))\nu0 = [1.0, 0, 0, 0, 0];\np = [9.8, 1];\ntspan = (0, 10.0);\npendulum_prob = ODEProblem(pendulum_fun!, u0, tspan, p)\nsolve(pendulum_prob, Rodas5P())\n\nHowever, one will quickly be greeted with the unfortunate message:\n\n┌ Warning: First function call produced NaNs. Exiting.\n└ @ OrdinaryDiffEq C:\\Users\\accou\\.julia\\packages\\OrdinaryDiffEq\\yCczp\\src\\initdt.jl:76\n┌ Warning: Automatic dt set the starting dt as NaN, causing instability.\n└ @ OrdinaryDiffEq C:\\Users\\accou\\.julia\\packages\\OrdinaryDiffEq\\yCczp\\src\\solve.jl:485\n┌ Warning: NaN dt detected. Likely a NaN value in the unknowns, parameters, or derivative value caused this outcome.\n└ @ SciMLBase C:\\Users\\accou\\.julia\\packages\\SciMLBase\\DrPil\\src\\integrator_interface.jl:325\n\nDid you implement the DAE incorrectly? No. Is the solver broken? No.","category":"section"},{"location":"examples/modelingtoolkitize_index_reduction/#Understanding-DAE-Index","page":"Automated Index Reduction of DAEs","title":"Understanding DAE Index","text":"It turns out that this is a property of the DAE that we are attempting to solve. This kind of DAE is known as an index-3 DAE. For a complete discussion of DAE index, see this article. Essentially, the issue here is that we have 4 differential variables (x, v_x, y, v_y) and one algebraic variable T (which we can know because there is no D(T) term in the equations). An index-1 DAE always satisfies that the Jacobian of the algebraic equations is non-singular. Here, the first 4 equations are differential equations, with the last term the algebraic relationship. However, the partial derivative of x^2 + y^2 - L^2 w.r.t. T is zero, and thus the Jacobian of the algebraic equations is the zero matrix, and thus it's singular. This is a rapid way to see whether the DAE is index 1!\n\nThe problem with higher order DAEs is that the matrices used in Newton solves are singular or close to singular when applied to such problems. Because of this fact, the nonlinear solvers (or Rosenbrock methods) break down, making them difficult to solve. The classic paper DAEs are not ODEs goes into detail on this and shows that many methods are no longer convergent when index is higher than one. So, it's not necessarily the fault of the solver or the implementation: this is known.\n\nBut that's not a satisfying answer, so what do you do about it?","category":"section"},{"location":"examples/modelingtoolkitize_index_reduction/#Transforming-Higher-Order-DAEs-to-Index-1-DAEs","page":"Automated Index Reduction of DAEs","title":"Transforming Higher Order DAEs to Index-1 DAEs","text":"It turns out that higher order DAEs can be transformed into lower order DAEs. If you differentiate the last equation two times and perform a substitution, you can arrive at the following set of equations:\n\nbeginaligned\nx^prime = v_x \nv_x^prime = x T \ny^prime = v_y \nv_y^prime = y T - g \n0 = 2 left(v_x^2 + v_y^2 + y ( y T - g ) + T x^2 right)\nendaligned\n\nNote that this is mathematically-equivalent to the equation that we had before, but the Jacobian w.r.t. T of the algebraic equation is no longer zero because of the substitution. This means that if you wrote down this version of the model, it will be index-1 and solve correctly! In fact, this is how DAE index is commonly defined: the number of differentiations it takes to transform the DAE into an ODE, where an ODE is an index-0 DAE by substituting out all of the algebraic relationships.","category":"section"},{"location":"examples/modelingtoolkitize_index_reduction/#Automating-the-Index-Reduction","page":"Automated Index Reduction of DAEs","title":"Automating the Index Reduction","text":"However, requiring the user to sit there and work through this process on potentially millions of equations is an unfathomable mental overhead. But, we can avoid this by using methods like the Pantelides algorithm for automatically performing this reduction to index 1. While this requires the ModelingToolkit symbolic form, we use modelingtoolkitize to transform the numerical code into symbolic code, run dae_index_lowering lowering, then transform back to numerical code with ODEProblem, and solve with a numerical solver. Let's try that out:\n\ntraced_sys = modelingtoolkitize(pendulum_prob)\npendulum_sys = mtkcompile(dae_index_lowering(traced_sys))\nprob = ODEProblem(pendulum_sys, Pair[], tspan)\nsol = solve(prob, Rodas5P())\n\nusing Plots\nplot(sol, idxs = unknowns(traced_sys))\n\nNote that plotting using unknowns(traced_sys) is done so that any variables which are symbolically eliminated, or any variable reordering done for enhanced parallelism/performance, still show up in the resulting plot and the plot is shown in the same order as the original numerical code.","category":"section"},{"location":"tutorials/domain_connections/#domains","page":"Domains","title":"Domains","text":"","category":"section"},{"location":"tutorials/domain_connections/#Basics","page":"Domains","title":"Basics","text":"A domain in ModelingToolkit.jl is a network of connected components that share properties of the medium in the network.  For example, a collection of hydraulic components connected together will have a fluid medium.  Using the domain feature, one only needs to define and set the fluid medium properties once, in one component, rather than at each component.  The way this works in ModelingToolkit.jl is by defining a connector (with Through/Flow and Across variables) with parameters defining the medium of the domain.  Then a second connector is defined, with the same parameters, and the same Through/Flow variable, which acts as the setter.  For example, a hydraulic domain may have a hydraulic connector, HydraulicPort, that defines a fluid medium with density (ρ), viscosity (μ), and a bulk modulus (β), a through/flow variable mass flow (dm) and an across variable pressure (p).\n\nusing ModelingToolkit\nusing ModelingToolkit: t_nounits as t, D_nounits as D\n\n@connector function HydraulicPort(; p_int, name)\n    pars = @parameters begin\n        ρ\n        β\n        μ\n    end\n\n    vars = @variables begin\n        p(t) = p_int\n        dm(t), [connect = Flow]\n    end\n\n    System(Equation[], t, vars, pars; name, bindings = [dm => 0])\nend\nnothing #hide\n\nThe fluid medium setter for HydralicPort may be defined as HydraulicFluid with the same parameters and through/flow variable.  But now, the parameters can be set through the function keywords.\n\n@connector function HydraulicFluid(;\n        density = 997,\n        bulk_modulus = 2.09e9,\n        viscosity = 0.0010016,\n        name)\n    pars = @parameters begin\n        ρ = density\n        β = bulk_modulus\n        μ = viscosity\n    end\n\n    vars = @variables begin\n        dm(t), [connect = Flow]\n    end\n\n    eqs = [\n        dm ~ 0\n    ]\n\n    System(eqs, t, vars, pars; name, bindings = [dm => 0])\nend\nnothing #hide\n\nNow, we can connect a HydraulicFluid component to any HydraulicPort connector, and the parameters of all HydraulicPort's in the network will be automatically set.  Let's consider a simple example, connecting a pressure source component to a volume component.  Note that we don't need to define density for the volume component, it's supplied by the HydraulicPort (port.ρ).\n\n@component function FixedPressure(; p, name)\n    pars = @parameters p = p\n    systems = @named begin\n        port = HydraulicPort(; p_int = p)\n    end\n\n    eqs = [port.p ~ p]\n\n    System(eqs, t, [], pars; name, systems)\nend\n\n@component function FixedVolume(; vol, p_int, name)\n    pars = @parameters begin\n        p_int = p_int\n        vol = vol\n    end\n\n    systems = @named begin\n        port = HydraulicPort(; p_int)\n    end\n\n    vars = @variables begin\n        rho(t) = port.ρ\n        drho(t) = 0\n    end\n\n    # let\n    dm = port.dm\n    p = port.p\n\n    eqs = [D(rho) ~ drho\n           rho ~ port.ρ * (1 + p / port.β)\n           dm ~ drho * vol]\n\n    System(eqs, t, vars, pars; name, systems)\nend\nnothing #hide\n\nWhen the system is defined we can generate a fluid component and connect it to the system.  Here fluid is connected to the src.port, but it could also be connected to vol.port, any connection in the network is fine.\n\n@component function HydraulicSystem(; name)\n    systems = @named begin\n        src = FixedPressure(; p = 200e5)\n        vol = FixedVolume(; vol = 0.1, p_int = 200e5)\n\n        fluid = HydraulicFluid(; density = 876)\n    end\n\n    eqs = [connect(fluid, src.port)\n           connect(src.port, vol.port)]\n\n    System(eqs, t, [], []; systems, name)\nend\n\n@named odesys = HydraulicSystem()\nnothing #hide\n\nTo see how the domain works, we can examine the set parameter values for each of the ports src.port and vol.port.  First we assemble the system using mtkcompile() and then check the default value of vol.port.ρ, whichs points to the setter value fluid₊ρ.  Likewise, src.port.ρ, will also point to the setter value fluid₊ρ.  Therefore, there is now only 1 defined density value fluid₊ρ which sets the density for the connected network.\n\nsys = mtkcompile(odesys)\nModelingToolkit.bindings(sys)[odesys.vol.port.ρ]","category":"section"},{"location":"tutorials/domain_connections/#Multiple-Domain-Networks","page":"Domains","title":"Multiple Domain Networks","text":"If we have a more complicated system, for example a hydraulic actuator, with a separated fluid on both sides of the piston, it's possible we might have 2 separate domain networks.  In this case we can connect 2 separate fluids, or the same fluid, to both networks.  First a simple actuator is defined with 2 ports.\n\n@component function Actuator(; p_int, mass, area, name)\n    pars = @parameters begin\n        p_int = p_int\n        mass = mass\n        area = area\n    end\n\n    systems = @named begin\n        port_a = HydraulicPort(; p_int)\n        port_b = HydraulicPort(; p_int)\n    end\n\n    vars = @variables begin\n        x(t) = 0\n        dx(t) = 0\n        ddx(t) = 0\n    end\n\n    eqs = [D(x) ~ dx\n           D(dx) ~ ddx\n           mass * ddx ~ (port_a.p - port_b.p) * area\n           port_a.dm ~ +(port_a.ρ) * dx * area\n           port_b.dm ~ -(port_b.ρ) * dx * area]\n\n    System(eqs, t, vars, pars; name, systems)\nend\nnothing #hide\n\nA system with 2 different fluids is defined and connected to each separate domain network.\n\n@component function ActuatorSystem2(; name)\n    systems = @named begin\n        src_a = FixedPressure(; p = 200e5)\n        src_b = FixedPressure(; p = 200e5)\n        act = Actuator(; p_int = 200e5, mass = 1000, area = 0.1)\n\n        fluid_a = HydraulicFluid(; density = 876)\n        fluid_b = HydraulicFluid(; density = 999)\n    end\n\n    eqs = [connect(fluid_a, src_a.port)\n           connect(fluid_b, src_b.port)\n           connect(src_a.port, act.port_a)\n           connect(src_b.port, act.port_b)]\n\n    System(eqs, t, [], []; systems, name)\nend\n\n@named actsys2 = ActuatorSystem2()\nnothing #hide\n\nAfter running mtkcompile() on actsys2, the defaults will show that act.port_a.ρ points to fluid_a₊ρ and act.port_b.ρ points to fluid_b₊ρ.  This is a special case, in most cases a hydraulic system will have only 1 fluid, however this simple system has 2 separate domain networks.  Therefore, we can connect a single fluid to both networks.  This does not interfere with the mathematical equations of the system, since no unknown variables are connected.\n\n@component function ActuatorSystem1(; name)\n    systems = @named begin\n        src_a = FixedPressure(; p = 200e5)\n        src_b = FixedPressure(; p = 200e5)\n        act = Actuator(; p_int = 200e5, mass = 1000, area = 0.1)\n\n        fluid = HydraulicFluid(; density = 876)\n    end\n\n    eqs = [connect(fluid, src_a.port)\n           connect(fluid, src_b.port)\n           connect(src_a.port, act.port_a)\n           connect(src_b.port, act.port_b)]\n\n    System(eqs, t, [], []; systems, name)\nend\n\n@named actsys1 = ActuatorSystem1()\nnothing #hide","category":"section"},{"location":"tutorials/domain_connections/#Special-Connection-Cases-(domain_connect())","page":"Domains","title":"Special Connection Cases (domain_connect())","text":"In some cases a component will be defined with 2 connectors of the same domain, but they are not connected.  For example the Restrictor defined here gives equations to define the behavior of how the 2 connectors port_a and port_b are physically connected.\n\n@component function Restrictor(; name, p_int)\n    pars = @parameters begin\n        K = 0.1\n        p_int = p_int\n    end\n\n    systems = @named begin\n        port_a = HydraulicPort(; p_int)\n        port_b = HydraulicPort(; p_int)\n    end\n\n    eqs = [port_a.dm ~ (port_a.p - port_b.p) * K\n           0 ~ port_a.dm + port_b.dm]\n\n    System(eqs, t, [], pars; systems, name)\nend\nnothing #hide\n\nAdding the Restrictor to the original system example will cause a break in the domain network, since a connect(port_a, port_b) is not defined.\n\n@component function RestrictorSystem(; name)\n    systems = @named begin\n        src = FixedPressure(; p = 200e5)\n        res = Restrictor(; p_int = 200e5)\n        vol = FixedVolume(; vol = 0.1, p_int = 200e5)\n\n        fluid = HydraulicFluid(; density = 876)\n    end\n\n    eqs = [connect(fluid, src.port)\n           connect(src.port, res.port_a)\n           connect(res.port_b, vol.port)]\n\n    System(eqs, t, [], []; systems, name)\nend\n\n@mtkcompile ressys = RestrictorSystem()\nnothing #hide\n\nWhen mtkcompile() is applied to this system it can be seen that the defaults are missing for res.port_b and vol.port.\n\nModelingToolkit.bindings(ressys)[ressys.res.port_a.ρ]\nModelingToolkit.bindings(ressys)[ressys.res.port_b.ρ]\nModelingToolkit.bindings(ressys)[ressys.vol.port.ρ]\n\nTo ensure that the Restrictor component does not disrupt the domain network, the domain_connect() function can be used, which explicitly only connects the domain network and not the unknown variables.\n\n@component function Restrictor(; name, p_int)\n    pars = @parameters begin\n        K = 0.1\n        p_int = p_int\n    end\n\n    systems = @named begin\n        port_a = HydraulicPort(; p_int)\n        port_b = HydraulicPort(; p_int)\n    end\n\n    eqs = [domain_connect(port_a, port_b) # <-- connect the domain network\n           port_a.dm ~ (port_a.p - port_b.p) * K\n           0 ~ port_a.dm + port_b.dm]\n\n    System(eqs, t, [], pars; systems, name)\nend\n\n@mtkcompile ressys = RestrictorSystem()\nnothing #hide\n\nNow that the Restrictor component is properly defined using domain_connect(), the defaults for res.port_b and vol.port are properly defined.\n\nModelingToolkit.bindings(ressys)[ressys.res.port_a.ρ]\nModelingToolkit.bindings(ressys)[ressys.res.port_b.ρ]\nModelingToolkit.bindings(ressys)[ressys.vol.port.ρ]","category":"section"},{"location":"tutorials/optimization/#Modeling-Optimization-Problems","page":"Modeling Optimization Problems","title":"Modeling Optimization Problems","text":"ModelingToolkit.jl is not only useful for generating initial value problems (ODEProblem). The package can also build optimization systems.\n\nnote: Note\nThe high level @mtkmodel macro used in the getting started tutorial is not yet compatible with OptimizationSystem. We thus have to use a lower level interface to define optimization systems. For an introduction to this interface, read the programmatically generating Systems tutorial.","category":"section"},{"location":"tutorials/optimization/#Unconstrained-Rosenbrock-Function","page":"Modeling Optimization Problems","title":"Unconstrained Rosenbrock Function","text":"Let's optimize the classical Rosenbrock function in two dimensions.\n\nusing ModelingToolkit, Optimization, OptimizationOptimJL\n@variables begin\n    x = 1.0, [bounds = (-2.0, 2.0)]\n    y = 3.0, [bounds = (-1.0, 3.0)]\nend\n@parameters a=1.0 b=1.0\nrosenbrock = (a - x)^2 + b * (y - x^2)^2\n@mtkcompile sys = OptimizationSystem(rosenbrock, [x, y], [a, b])\n\nEvery optimization problem consists of a set of optimization variables. In this case, we create two variables: x and y, with initial guesses 1 and 3 for their optimal values. Additionally, we assign box constraints for each of them, using bounds, Bounds is an example of symbolic metadata. Fore more information, take a look at the symbolic metadata documentation page.\n\nWe also create two parameters with @parameters. Parameters are useful if you want to solve the same optimization problem multiple times, with different values for these parameters. Default values for these parameters can also be assigned, here 1 is used for both a and b. These optimization values and parameters are used in an objective function, here the Rosenbrock function.\n\nNext, the actual OptimizationProblem can be created. The initial guesses for the optimization variables can be overwritten, via an array of Pairs, in the second argument of OptimizationProblem. Values for the parameters of the system can also be overwritten from their default values, in the third argument of OptimizationProblem. ModelingToolkit is also capable of constructing analytical gradients and Hessians of the objective function.\n\nu0 = [y => 2.0]\np = [b => 100.0]\n\nprob = OptimizationProblem(sys, vcat(u0, p), grad = true, hess = true)\nu_opt = solve(prob, GradientDescent())\n\nA visualization of the Rosenbrock function is depicted below.\n\nusing Plots\nx_plot = -2:0.01:2\ny_plot = -1:0.01:3\ncontour(\n    x_plot, y_plot, (x, y) -> (1 - x)^2 + 100 * (y - x^2)^2, fill = true, color = :viridis,\n    ratio = :equal, xlims = (-2, 2))\nscatter!([u_opt[1]], [u_opt[2]], ms = 10, label = \"minimum\")","category":"section"},{"location":"tutorials/optimization/#Rosenbrock-Function-with-Constraints","page":"Modeling Optimization Problems","title":"Rosenbrock Function with Constraints","text":"ModelingToolkit is also capable of handing more complicated constraints than box constraints. Non-linear equality and inequality constraints can be added to the OptimizationSystem. Let's add an inequality constraint to the previous example:\n\nusing ModelingToolkit, Optimization, OptimizationOptimJL\n\n@variables begin\n    x = 0.14, [bounds = (-2.0, 2.0)]\n    y = 0.14, [bounds = (-1.0, 3.0)]\nend\n@parameters a=1.0 b=100.0\nrosenbrock = (a - x)^2 + b * (y - x^2)^2\ncons = [\n    x^2 + y^2 ≲ 1\n]\n@mtkcompile sys = OptimizationSystem(rosenbrock, [x, y], [a, b], constraints = cons)\nprob = OptimizationProblem(sys, [], grad = true, hess = true, cons_j = true, cons_h = true)\nu_opt = solve(prob, IPNewton())\n\nInequality constraints are constructed via a ≲ (or ≳). (To write these symbols in your own code write \\lesssim or \\gtrsim and then press tab.) An equality constraint can be specified via a ~, e.g., x^2 + y^2 ~ 1.\n\nA visualization of the Rosenbrock function and the inequality constraint is depicted below.\n\nusing Plots\nx_plot = -2:0.01:2\ny_plot = -1:0.01:3\ncontour(\n    x_plot, y_plot, (x, y) -> (1 - x)^2 + 100 * (y - x^2)^2, fill = true, color = :viridis,\n    ratio = :equal, xlims = (-2, 2))\ncontour!(x_plot, y_plot, (x, y) -> x^2 + y^2, levels = [1], color = :lightblue, line = 4)\nscatter!([u_opt[1]], [u_opt[2]], ms = 10, label = \"minimum\")","category":"section"},{"location":"tutorials/optimization/#Nested-Systems","page":"Modeling Optimization Problems","title":"Nested Systems","text":"Needs more text, but it's super cool and auto-parallelizes and sparsifies too. Plus, you can hierarchically nest systems to have it generate huge optimization problems.","category":"section"},{"location":"tutorials/linear_analysis/#Linear-Analysis","page":"Linear Analysis","title":"Linear Analysis","text":"Linear analysis refers to the process of linearizing a nonlinear model and analysing the resulting linear dynamical system. To facilitate linear analysis, ModelingToolkit provides the concept of an AnalysisPoint, which can be inserted in-between two causal blocks (such as those from ModelingToolkitStandardLibrary.Blocks sub module). Once a model containing analysis points is built, several operations are available:\n\nget_sensitivity get the sensitivity function (wiki), S(s), as defined in the field of control theory.\nget_comp_sensitivity get the complementary sensitivity function T(s)  S(s)+T(s)=1.\nget_looptransfer get the (open) loop-transfer function where the loop starts and ends in the analysis point. For a typical simple feedback connection with a plant P(s) and a controller C(s), the loop-transfer function at the plant output is P(s)C(s).\nlinearize can be called with two analysis points denoting the input and output of the linearized system.\nopen_loop return a new (nonlinear) system where the loop has been broken in the analysis point, i.e., the connection the analysis point usually implies has been removed.\n\nAn analysis point can be created explicitly using the constructor AnalysisPoint, or automatically when connecting two causal components using connect:\n\nconnect(comp1.output, :analysis_point_name, comp2.input)\n\nA single output can also be connected to multiple inputs:\n\nconnect(comp1.output, :analysis_point_name, comp2.input, comp3.input, comp4.input)\n\nwarning: Causality\nAnalysis points are causal, i.e., they imply a directionality for the flow of information. The order of the connections in the connect statement is thus important, i.e., connect(out, :name, in) is different from connect(in, :name, out).\n\nThe directionality of an analysis point can be thought of as an arrow in a block diagram, where the name of the analysis point applies to the arrow itself.\n\n┌─────┐         ┌─────┐\n│     │  name   │     │\n│  out├────────►│in   │\n│     │         │     │\n└─────┘         └─────┘\n\nThis is signified by the name being the middle argument to connect.\n\nOf the above mentioned functions, all except for open_loop return the output of ModelingToolkit.linearize, which is\n\nmatrices, simplified_sys = linearize(_...)\n# matrices = (; A, B, C, D)\n\ni.e., matrices is a named tuple containing the matrices of a linear state-space system on the form\n\nbeginaligned\ndot x = Ax + Bu\ny = Cx + Du\nendaligned","category":"section"},{"location":"tutorials/linear_analysis/#Example","page":"Linear Analysis","title":"Example","text":"The following example builds a simple closed-loop system with a plant P and a controller C. Two analysis points are inserted, one before and one after P. We then derive a number of sensitivity functions and show the corresponding code using the package ControlSystemBase.jl\n\nusing ModelingToolkitStandardLibrary.Blocks, ModelingToolkit\nusing ModelingToolkit: t_nounits as t\n\n@named P = FirstOrder(k = 1, T = 1) # A first-order system with pole in -1\n@named C = Gain(-1)             # A P controller\n\neqs = [connect(P.output, :plant_output, C.input)  # Connect with an automatically created analysis point called :plant_output\n       connect(C.output, :plant_input, P.input)]\nsys = System(eqs, t, systems = [P, C], name = :feedback_system)\n\nmatrices_S = get_sensitivity(sys, :plant_input)[1] # Compute the matrices of a state-space representation of the (input)sensitivity function.\nmatrices_T = get_comp_sensitivity(sys, :plant_input)[1]\n\nContinued linear analysis and design can be performed using ControlSystemsBase.jl. We create ControlSystemsBase.StateSpace objects using\n\nusing ControlSystemsBase, Plots\nS = ss(matrices_S...)\nT = ss(matrices_T...)\nbodeplot([S, T], lab = [\"S\" \"\" \"T\" \"\"], plot_title = \"Bode plot of sensitivity functions\",\n    margin = 5Plots.mm)\n\nThe sensitivity functions obtained this way should be equivalent to the ones obtained with the code below\n\nusing ControlSystemsBase\nP = tf(1.0, [1, 1]) |> ss\nC = 1                      # Negative feedback assumed in ControlSystems\nS = sensitivity(P, C)      # or feedback(1, P*C)\nT = comp_sensitivity(P, C) # or feedback(P*C)\n\nWe may also derive the loop-transfer function L(s) = P(s)C(s) using\n\nmatrices_L = get_looptransfer(sys, :plant_output)[1]\nL = ss(matrices_L...)\n\nwhich is equivalent to the following with ControlSystems\n\nL = P * (-C) # Add the minus sign to build the negative feedback into the controller\n\nTo obtain the transfer function between two analysis points, we call linearize\n\nusing ModelingToolkit # hide\nmatrices_PS = linearize(sys, :plant_input, :plant_output)[1]\n\nthis particular transfer function should be equivalent to the linear system P(s)S(s), i.e., equivalent to\n\nfeedback(P, C)","category":"section"},{"location":"tutorials/linear_analysis/#Obtaining-transfer-functions","page":"Linear Analysis","title":"Obtaining transfer functions","text":"A statespace system from ControlSystemsBase can be converted to a transfer function using the function tf:\n\ntf(S)","category":"section"},{"location":"tutorials/linear_analysis/#Gain-and-phase-margins","page":"Linear Analysis","title":"Gain and phase margins","text":"Further linear analysis can be performed using the analysis methods from ControlSystemsBase. For example, calculating the gain and phase margins of a system can be done using\n\nmargin(P)\n\n(they are infinite for this system). A Nyquist plot can be produced using\n\nnyquistplot(P)","category":"section"},{"location":"tutorials/linear_analysis/#Index","page":"Linear Analysis","title":"Index","text":"Pages = [\"linear_analysis.md\"]","category":"section"},{"location":"tutorials/linear_analysis/#ModelingToolkit.get_comp_sensitivity-tutorials-linear_analysis","page":"Linear Analysis","title":"ModelingToolkit.get_comp_sensitivity","text":"get_comp_sensitivity(sys, ap::AnalysisPoint; kwargs)\nget_comp_sensitivity(sys, ap_name::Symbol; kwargs)\n\nCompute the complementary sensitivity function in analysis point ap. The complementary sensitivity function is obtained by introducing an infinitesimal perturbation d at the output of ap, linearizing the system and computing the transfer function between d and the input of ap.\n\nArguments:\n\nkwargs: Are sent to ModelingToolkit.linearize\n\nSee also get_sensitivity, get_looptransfer.\n\n\n\n\n\n","category":"function"},{"location":"tutorials/linear_analysis/#ModelingToolkit.get_comp_sensitivity_function-Tuple{ModelingToolkitBase.AbstractSystem, Any}-tutorials-linear_analysis","page":"Linear Analysis","title":"ModelingToolkit.get_comp_sensitivity_function","text":"get_comp_sensitivity_function(\n    sys::ModelingToolkitBase.AbstractSystem,\n    aps;\n    kwargs...\n) -> Tuple{ModelingToolkit.LinearizationFunction{Vector{Int64}, Vector{Int64}, Vector{SymbolicUtils.BasicSymbolicImpl.var\"typeof(BasicSymbolicImpl)\"{SymReal}}, P, _A, _B, J1, J2, J3, J4, IA, @NamedTuple{abstol::Float64, reltol::Float64, nlsolve_alg::Nothing}} where {P<:ODEProblem, _A, _B, J1<:Union{Nothing, ModelingToolkit.PreparedJacobian{true, DifferentiationInterfaceForwardDiffExt.ForwardDiffTwoArgJacobianPrep{Nothing, C, Tuple{Nothing, Nothing}}, ModelingToolkit.var\"#uff#6\"{var\"#64#fun\"}, _A, ADTypes.AutoForwardDiff{nothing, Nothing}} where {C<:(ForwardDiff.JacobianConfig{T, _A, _B, <:Tuple{Any, Any}} where {T<:(ForwardDiff.Tag{F} where F<:ModelingToolkit.var\"#uff#6\"), _A, _B}), var\"#64#fun\", _A}}, J2<:Union{Nothing, ModelingToolkit.PreparedJacobian{true, DifferentiationInterfaceForwardDiffExt.ForwardDiffTwoArgJacobianPrep{Nothing, C, Tuple{Nothing, Nothing}}, _A, _B, ADTypes.AutoForwardDiff{nothing, Nothing}} where {C<:ForwardDiff.JacobianConfig, _A, _B}}, J3<:Union{Nothing, ModelingToolkit.PreparedJacobian{true, DifferentiationInterfaceForwardDiffExt.ForwardDiffTwoArgJacobianPrep{Nothing, C, Tuple{Nothing, Nothing, Nothing}}, ModelingToolkit.var\"#pff#7\"{var\"#65#fun\", var\"#66#setter\"}, _A, ADTypes.AutoForwardDiff{nothing, Nothing}} where {C<:(ForwardDiff.JacobianConfig{T, _A, _B, <:Tuple{Any, Vector{T} where T<:(ForwardDiff.Dual{T, _A, _B} where {_B, _A, T})}} where {T<:(ForwardDiff.Tag{F} where F<:(ModelingToolkit.var\"#pff#7\"{_A, SymbolicIndexingInterface.OOPSetter{_A1, System, var\"#s177\"}} where {_A, _A1, T, var\"#s177\"<:AbstractVector{T}})), _A, _B}), var\"#65#fun\", var\"#66#setter\", _A}}, J4<:(ModelingToolkit.PreparedJacobian{true, DifferentiationInterfaceForwardDiffExt.ForwardDiffTwoArgJacobianPrep{Nothing, C, Tuple{Nothing, Nothing, Nothing}}, ModelingToolkit.var\"#hpf#5\"{fun, setter}, _A, ADTypes.AutoForwardDiff{nothing, Nothing}} where {C<:(ForwardDiff.JacobianConfig{T, _A, _B, <:Tuple{Any, Vector{T} where T<:(ForwardDiff.Dual{T, _A, _B} where {_B, _A, T<:(ForwardDiff.Tag{F} where F<:(ModelingToolkit.var\"#hpf#5\"{_A, SymbolicIndexingInterface.OOPSetter{_A1, System, var\"#s177\"}} where {_A, _A1, T, var\"#s177\"<:AbstractVector{T}}))})}} where {T<:(ForwardDiff.Tag{F} where F<:(ModelingToolkit.var\"#hpf#5\"{_A, SymbolicIndexingInterface.OOPSetter{_A1, System, var\"#s177\"}} where {_A, _A1, T, var\"#s177\"<:AbstractVector{T}})), _A, _B}), fun, setter, _A}), IA<:Union{SciMLBase.NoInit, SciMLBase.OverrideInit{Nothing, Nothing, Nothing}}}, System}\n\n\nReturn the complementary sensitivity function for the analysis point(s) aps, and the modified system simplified with the appropriate inputs and outputs.\n\nKeyword Arguments\n\nloop_openings: A list of analysis points whose connections should be removed and the outputs set to the input as a part of the linear analysis.\nsystem_modifier: A function taking the transformed system and applying any additional transformations, returning the modified system. The modified system is passed to linearization_function. \n\nAll other keyword arguments are forwarded to linearization_function.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/linear_analysis/#ModelingToolkit.get_looptransfer-tutorials-linear_analysis","page":"Linear Analysis","title":"ModelingToolkit.get_looptransfer","text":"get_looptransfer(sys, ap::AnalysisPoint; kwargs)\nget_looptransfer(sys, ap_name::Symbol; kwargs)\n\nCompute the (linearized) loop-transfer function in analysis point ap, from ap.out to ap.in.\n\ninfo: Negative feedback\nFeedback loops often use negative feedback, and the computed loop-transfer function will in this case have the negative feedback included. Standard analysis tools often assume a loop-transfer function without the negative gain built in, and the result of this function may thus need negation before use.\n\nArguments:\n\nkwargs: Are sent to ModelingToolkit.linearize\n\nSee also get_sensitivity, get_comp_sensitivity, open_loop.\n\n\n\n\n\n","category":"function"},{"location":"tutorials/linear_analysis/#ModelingToolkit.get_looptransfer_function-Tuple{ModelingToolkitBase.AbstractSystem, Any}-tutorials-linear_analysis","page":"Linear Analysis","title":"ModelingToolkit.get_looptransfer_function","text":"get_looptransfer_function(\n    sys::ModelingToolkitBase.AbstractSystem,\n    aps;\n    kwargs...\n) -> Tuple{ModelingToolkit.LinearizationFunction{Vector{Int64}, Vector{Int64}, Vector{SymbolicUtils.BasicSymbolicImpl.var\"typeof(BasicSymbolicImpl)\"{SymReal}}, P, _A, _B, J1, J2, J3, J4, IA, @NamedTuple{abstol::Float64, reltol::Float64, nlsolve_alg::Nothing}} where {P<:ODEProblem, _A, _B, J1<:Union{Nothing, ModelingToolkit.PreparedJacobian{true, DifferentiationInterfaceForwardDiffExt.ForwardDiffTwoArgJacobianPrep{Nothing, C, Tuple{Nothing, Nothing}}, ModelingToolkit.var\"#uff#6\"{var\"#64#fun\"}, _A, ADTypes.AutoForwardDiff{nothing, Nothing}} where {C<:(ForwardDiff.JacobianConfig{T, _A, _B, <:Tuple{Any, Any}} where {T<:(ForwardDiff.Tag{F} where F<:ModelingToolkit.var\"#uff#6\"), _A, _B}), var\"#64#fun\", _A}}, J2<:Union{Nothing, ModelingToolkit.PreparedJacobian{true, DifferentiationInterfaceForwardDiffExt.ForwardDiffTwoArgJacobianPrep{Nothing, C, Tuple{Nothing, Nothing}}, _A, _B, ADTypes.AutoForwardDiff{nothing, Nothing}} where {C<:ForwardDiff.JacobianConfig, _A, _B}}, J3<:Union{Nothing, ModelingToolkit.PreparedJacobian{true, DifferentiationInterfaceForwardDiffExt.ForwardDiffTwoArgJacobianPrep{Nothing, C, Tuple{Nothing, Nothing, Nothing}}, ModelingToolkit.var\"#pff#7\"{var\"#65#fun\", var\"#66#setter\"}, _A, ADTypes.AutoForwardDiff{nothing, Nothing}} where {C<:(ForwardDiff.JacobianConfig{T, _A, _B, <:Tuple{Any, Vector{T} where T<:(ForwardDiff.Dual{T, _A, _B} where {_B, _A, T})}} where {T<:(ForwardDiff.Tag{F} where F<:(ModelingToolkit.var\"#pff#7\"{_A, SymbolicIndexingInterface.OOPSetter{_A1, System, var\"#s177\"}} where {_A, _A1, T, var\"#s177\"<:AbstractVector{T}})), _A, _B}), var\"#65#fun\", var\"#66#setter\", _A}}, J4<:(ModelingToolkit.PreparedJacobian{true, DifferentiationInterfaceForwardDiffExt.ForwardDiffTwoArgJacobianPrep{Nothing, C, Tuple{Nothing, Nothing, Nothing}}, ModelingToolkit.var\"#hpf#5\"{fun, setter}, _A, ADTypes.AutoForwardDiff{nothing, Nothing}} where {C<:(ForwardDiff.JacobianConfig{T, _A, _B, <:Tuple{Any, Vector{T} where T<:(ForwardDiff.Dual{T, _A, _B} where {_B, _A, T<:(ForwardDiff.Tag{F} where F<:(ModelingToolkit.var\"#hpf#5\"{_A, SymbolicIndexingInterface.OOPSetter{_A1, System, var\"#s177\"}} where {_A, _A1, T, var\"#s177\"<:AbstractVector{T}}))})}} where {T<:(ForwardDiff.Tag{F} where F<:(ModelingToolkit.var\"#hpf#5\"{_A, SymbolicIndexingInterface.OOPSetter{_A1, System, var\"#s177\"}} where {_A, _A1, T, var\"#s177\"<:AbstractVector{T}})), _A, _B}), fun, setter, _A}), IA<:Union{SciMLBase.NoInit, SciMLBase.OverrideInit{Nothing, Nothing, Nothing}}}, System}\n\n\nReturn the loop-transfer function for the analysis point(s) aps, and the modified system simplified with the appropriate inputs and outputs.\n\nKeyword Arguments\n\nloop_openings: A list of analysis points whose connections should be removed and the outputs set to the input as a part of the linear analysis.\nsystem_modifier: A function taking the transformed system and applying any additional transformations, returning the modified system. The modified system is passed to linearization_function. \n\nAll other keyword arguments are forwarded to linearization_function.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/linear_analysis/#ModelingToolkit.get_sensitivity-tutorials-linear_analysis","page":"Linear Analysis","title":"ModelingToolkit.get_sensitivity","text":"get_sensitivity(sys, ap::AnalysisPoint; kwargs)\nget_sensitivity(sys, ap_name::Symbol; kwargs)\n\nCompute the sensitivity function in analysis point ap. The sensitivity function is obtained by introducing an infinitesimal perturbation d at the input of ap, linearizing the system and computing the transfer function between d and the output of ap.\n\nArguments:\n\nkwargs: Are sent to ModelingToolkit.linearize\n\nSee also get_comp_sensitivity, get_looptransfer.\n\n\n\n\n\n","category":"function"},{"location":"tutorials/linear_analysis/#ModelingToolkit.get_sensitivity_function-Tuple{ModelingToolkitBase.AbstractSystem, Any}-tutorials-linear_analysis","page":"Linear Analysis","title":"ModelingToolkit.get_sensitivity_function","text":"get_sensitivity_function(\n    sys::ModelingToolkitBase.AbstractSystem,\n    aps;\n    kwargs...\n) -> Tuple{ModelingToolkit.LinearizationFunction{Vector{Int64}, Vector{Int64}, Vector{SymbolicUtils.BasicSymbolicImpl.var\"typeof(BasicSymbolicImpl)\"{SymReal}}, P, _A, _B, J1, J2, J3, J4, IA, @NamedTuple{abstol::Float64, reltol::Float64, nlsolve_alg::Nothing}} where {P<:ODEProblem, _A, _B, J1<:Union{Nothing, ModelingToolkit.PreparedJacobian{true, DifferentiationInterfaceForwardDiffExt.ForwardDiffTwoArgJacobianPrep{Nothing, C, Tuple{Nothing, Nothing}}, ModelingToolkit.var\"#uff#6\"{var\"#64#fun\"}, _A, ADTypes.AutoForwardDiff{nothing, Nothing}} where {C<:(ForwardDiff.JacobianConfig{T, _A, _B, <:Tuple{Any, Any}} where {T<:(ForwardDiff.Tag{F} where F<:ModelingToolkit.var\"#uff#6\"), _A, _B}), var\"#64#fun\", _A}}, J2<:Union{Nothing, ModelingToolkit.PreparedJacobian{true, DifferentiationInterfaceForwardDiffExt.ForwardDiffTwoArgJacobianPrep{Nothing, C, Tuple{Nothing, Nothing}}, _A, _B, ADTypes.AutoForwardDiff{nothing, Nothing}} where {C<:ForwardDiff.JacobianConfig, _A, _B}}, J3<:Union{Nothing, ModelingToolkit.PreparedJacobian{true, DifferentiationInterfaceForwardDiffExt.ForwardDiffTwoArgJacobianPrep{Nothing, C, Tuple{Nothing, Nothing, Nothing}}, ModelingToolkit.var\"#pff#7\"{var\"#65#fun\", var\"#66#setter\"}, _A, ADTypes.AutoForwardDiff{nothing, Nothing}} where {C<:(ForwardDiff.JacobianConfig{T, _A, _B, <:Tuple{Any, Vector{T} where T<:(ForwardDiff.Dual{T, _A, _B} where {_B, _A, T})}} where {T<:(ForwardDiff.Tag{F} where F<:(ModelingToolkit.var\"#pff#7\"{_A, SymbolicIndexingInterface.OOPSetter{_A1, System, var\"#s177\"}} where {_A, _A1, T, var\"#s177\"<:AbstractVector{T}})), _A, _B}), var\"#65#fun\", var\"#66#setter\", _A}}, J4<:(ModelingToolkit.PreparedJacobian{true, DifferentiationInterfaceForwardDiffExt.ForwardDiffTwoArgJacobianPrep{Nothing, C, Tuple{Nothing, Nothing, Nothing}}, ModelingToolkit.var\"#hpf#5\"{fun, setter}, _A, ADTypes.AutoForwardDiff{nothing, Nothing}} where {C<:(ForwardDiff.JacobianConfig{T, _A, _B, <:Tuple{Any, Vector{T} where T<:(ForwardDiff.Dual{T, _A, _B} where {_B, _A, T<:(ForwardDiff.Tag{F} where F<:(ModelingToolkit.var\"#hpf#5\"{_A, SymbolicIndexingInterface.OOPSetter{_A1, System, var\"#s177\"}} where {_A, _A1, T, var\"#s177\"<:AbstractVector{T}}))})}} where {T<:(ForwardDiff.Tag{F} where F<:(ModelingToolkit.var\"#hpf#5\"{_A, SymbolicIndexingInterface.OOPSetter{_A1, System, var\"#s177\"}} where {_A, _A1, T, var\"#s177\"<:AbstractVector{T}})), _A, _B}), fun, setter, _A}), IA<:Union{SciMLBase.NoInit, SciMLBase.OverrideInit{Nothing, Nothing, Nothing}}}, System}\n\n\nReturn the sensitivity function for the analysis point(s) aps, and the modified system simplified with the appropriate inputs and outputs.\n\nKeyword Arguments\n\nloop_openings: A list of analysis points whose connections should be removed and the outputs set to the input as a part of the linear analysis.\nsystem_modifier: A function taking the transformed system and applying any additional transformations, returning the modified system. The modified system is passed to linearization_function. \n\nAll other keyword arguments are forwarded to linearization_function.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/linear_analysis/#ModelingToolkit.linearization_ap_transform-Tuple{Any, Union{Vector{Symbol}, Vector{AnalysisPoint}, Symbol, AnalysisPoint}, Any, Any}-tutorials-linear_analysis","page":"Linear Analysis","title":"ModelingToolkit.linearization_ap_transform","text":"sys, input_vars, output_vars =\n\nlinearization_ap_transform(\n    sys,\n    inputs::Union{Vector{Symbol}, Vector{AnalysisPoint}, Symbol, AnalysisPoint},\n    outputs,\n    loop_openings\n) -> Tuple{Any, Vector{SymbolicUtils.BasicSymbolicImpl.var\"typeof(BasicSymbolicImpl)\"{SymReal}}, Vector{SymbolicUtils.BasicSymbolicImpl.var\"typeof(BasicSymbolicImpl)\"{SymReal}}}\n\n\nApply analysis-point transformations to prepare a system for linearization.\n\nReturns\n\nsys: The transformed system.\ninput_vars: A vector of input variables corresponding to the input analysis points.\noutput_vars: A vector of output variables corresponding to the output analysis points.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/stochastic_diffeq/#Modeling-with-Stochasticity","page":"Modeling with Stochasticity","title":"Modeling with Stochasticity","text":"All previous differential equations tutorials deal with deterministic Systems. In this tutorial, we add randomness. In particular, we show how to represent a stochastic differential equation as a SDESystem.\n\nnote: Note\nThe high level @mtkmodel macro used in the getting started tutorial is not yet compatible with SDESystem. We thus have to use a lower level interface to define stochastic differential equations. For an introduction to this interface, read the programmatically generating Systems tutorial.\n\nLet's take the Lorenz equation and add noise to each of the states. To show the flexibility of ModelingToolkit, we do not use homogeneous noise, with constant variance, but instead use heterogeneous noise, where the magnitude of the noise scales with (0.3 times) the magnitude of each of the states:\n\nbeginaligned\nfracdxdt = (sigma (y-x))  + 03xfracdBdt \nfracdydt = (x(rho-z) - y) + 03yfracdBdt  \nfracdzdt = (xy - beta z)  + 03zfracdBdt  \nendaligned\n\nWhere B, is standard Brownian motion, also called the Wiener process. We use notation similar to the Langevin equation, often used in physics. By \"multiplying\" the equations by dt, the notation used in probability theory can be recovered.\n\nWe use this Langevin-like notation because it allows us to extend MTK modeling capacity from ODEs to SDEs, using only a single new concept, @brownians variables, which represent fracdBdt in the above equation.\n\nusing ModelingToolkit, StochasticDiffEq\nusing ModelingToolkit: t_nounits as t, D_nounits as D\nusing Plots\n\n@parameters σ=10.0 ρ=2.33 β=26.0\n@variables x(t)=5.0 y(t)=5.0 z(t)=1.0\n@brownians B\neqs = [D(x) ~ σ * (y - x) + 0.3x * B,\n    D(y) ~ x * (ρ - z) - y + 0.3y * B,\n    D(z) ~ x * y - β * z + 0.3z * B]\n\n@mtkcompile de = System(eqs, t)\n\nEven though we did not explicitly use SDESystem, ModelingToolkit can still infer this from the equations.\n\ntypeof(de)\n\nWe continue by solving and plotting the SDE.\n\nprob = SDEProblem(de, [], (0.0, 100.0))\nsol = solve(prob, SRIW1())\nplot(sol, idxs = [(1, 2, 3)])\n\nThe noise present in all 3 equations is correlated, as can be seen on the below figure. The figure also shows the multiplicative nature of the noise. Because states x and y generally take on larger values, the noise also takes on a more pronounced effect on these states compared to the state z.\n\nplot(sol)\n\nIf you want uncorrelated noise for each equation, multiple @brownians variables have to be declared.\n\n@brownians Bx By Bz\neqs = [D(x) ~ σ * (y - x) + 0.3x * Bx,\n    D(y) ~ x * (ρ - z) - y + 0.3y * By,\n    D(z) ~ x * y - β * z + 0.3z * Bz]\n@mtkcompile de = System(eqs, t)\nprob = SDEProblem(de, [], (0.0, 100.0))\nsol = solve(prob, SRIW1())\nplot(sol)","category":"section"},{"location":"API/model_building/#model_building_api","page":"Model building reference","title":"Model building reference","text":"This page lists functionality and utilities related to building hierarchical models. It is recommended to read the page on the System before this.","category":"section"},{"location":"API/model_building/#Common-definitions-of-t-and-D","page":"Model building reference","title":"Common definitions of t and D","text":"ModelingToolkit provides common definitions for the independent variable t (time) and the derivative with respect to it D.\n\nUsers are recommended to use the appropriate common definition in their models. The required definitions can be imported with convenient aliased names. For example:\n\nusing ModelingToolkit: t_nounits as t, D_nounits as D\n\nAllows using t and D to refer to t_nounits and D_nounits respectively.","category":"section"},{"location":"API/model_building/#Hierarchical-model-composition","page":"Model building reference","title":"Hierarchical model composition","text":"The System data structure can represent a tree-like hierarchy of systems for building models from composable blocks. The ModelingToolkit.get_systems function can be used for querying the subsystems of a system. The @component macro should be used when writing building blocks for model composition.\n\nEvery constructor function should build either a component or a connector. Components define the dynamics of the system. Connectors are used to connect components together and propagate information between them. See also @connector.","category":"section"},{"location":"API/model_building/#Scoping-of-variables","page":"Model building reference","title":"Scoping of variables","text":"When building hierarchical systems, is is often necessary to pass variables from a parent system to the subsystems. If done naively, this will result in the child system assuming it \"owns\" the variables passed to it and any occurrences of those variables in the child system will be namespaced. To prevent this, ModelingToolkit has the concept of variable scope. The scope allows specifying which system a variable belongs to relative to the system in which it is used.\n\nNote that the scopes must be applied to individual variables and not expressions. For example, ParentScope(x + y) is incorrect. Instead, ParentScope(x) + ParentScope(y) is the correct usage. Applying the same scope (more generally, the same function) to all variables in an expression is a common task, and ModelingToolkit exposes a utility for the same:\n\nIt is still tedious to manually use apply_to_variables on any symbolic expression passed to a subsystem. The @named macro automatically wraps all symbolic arguments in ParentScope and uses the identifier being assigned as the name of the system.","category":"section"},{"location":"API/model_building/#Exploring-the-tree-structure","page":"Model building reference","title":"Exploring the tree structure","text":"The System type implements the AbstractTrees interface. This can be used to explore the hierarchical structure.","category":"section"},{"location":"API/model_building/#connect_semantics","page":"Model building reference","title":"Connection semantics","text":"ModelingToolkit implements connection semantics similar to those in the Modelica specification. We do not support the concept of inner and outer elements or expandable connectors. Connectors in ModelingToolkit are systems with the appropriate metadata added via the @connector macro.\n\nConnections can be expanded using expand_connections.\n\nSimilar to the stream and flow keyword arguments in the specification, ModelingToolkit allows specifying how variables in a connector behave in a connection.\n\nThese are specified using the connect metadata. ModelingToolkit also supports instream. Refer to the Modelica specification on Stream connectors for more information.","category":"section"},{"location":"API/model_building/#System-composition-utilities","page":"Model building reference","title":"System composition utilities","text":"","category":"section"},{"location":"API/model_building/#Flattening-systems","page":"Model building reference","title":"Flattening systems","text":"The hierarchical structure can be flattened. This operation is performed during simplification.","category":"section"},{"location":"API/model_building/#System-simplification","page":"Model building reference","title":"System simplification","text":"Systems can be simplified to reformulate them in a way that enables it to be solved numerically, and also perform other optimizations. This is done via the mtkcompile function. Connection expansion and flattening are preprocessing steps of simplification.\n\nIt is also possible (though not always advisable) to build numerical problems from systems without passing them through mtkcompile. To do this, the system must first be marked as \"complete\" via the complete function. This process is used to indicate that a system will not be modified further and allows ModelingToolkit to perform any necessary preprocessing to it. mtkcompile calls complete internally.","category":"section"},{"location":"API/model_building/#Exploring-the-results-of-simplification","page":"Model building reference","title":"Exploring the results of simplification","text":"Similar to how full_equations returns the equations of a system with all variables eliminated during mtkcompile substituted, we can perform this substitution on an arbitrary expression.","category":"section"},{"location":"API/model_building/#Experimental-simplification","page":"Model building reference","title":"Experimental simplification","text":"ModelingToolkit may have a variety of experimental simplification passes. These are not enabled by default, but can be used by passing to the additional_passes keyword argument of mtkcompile.","category":"section"},{"location":"API/model_building/#Event-handling","page":"Model building reference","title":"Event handling","text":"Time-dependent systems may have several events. These are used to trigger discontinuities in the model. They compile to standard callbacks from DiffEqCallbacks.jl.\n\nThe affect functions for the above callbacks can be symbolic or user-defined functions. Symbolic affects are handled using equations as described in the Events section of the documentation. User-defined functions can be used via ImperativeAffect.","category":"section"},{"location":"API/model_building/#Modelingtoolkitize","page":"Model building reference","title":"Modelingtoolkitize","text":"ModelingToolkit can take some numerical problems created non-symbolically and build a symbolic representation from them.","category":"section"},{"location":"API/model_building/#Using-FMUs","page":"Model building reference","title":"Using FMUs","text":"ModelingToolkit is capable of importing FMUs as black-box symbolic models. Currently only a subset of FMU features are supported. This functionality requires importing FMI.jl.","category":"section"},{"location":"API/model_building/#Model-transformations","page":"Model building reference","title":"Model transformations","text":"ModelingToolkit exposes a variety of transformations that can be applied to models to aid in symbolic analysis.","category":"section"},{"location":"API/model_building/#Hybrid-systems","page":"Model building reference","title":"Hybrid systems","text":"Hybrid systems are dynamical systems involving one or more discrete-time subsystems. These discrete time systems follow clock semantics - they are synchronous systems and the relevant variables are only defined at points where the clock ticks.\n\nWhile ModelingToolkit is unable to simplify, compile and solve such systems on its own, it has the ability to represent them. Compilation strategies can be implemented independently on top of mtkcompile using the additional_passes functionality.\n\nwarn: Warn\nThese operators are considered experimental API.\n\nModelingToolkit uses the clock definition in SciMLBase","category":"section"},{"location":"API/model_building/#State-machines","page":"Model building reference","title":"State machines","text":"While ModelingToolkit has the capability to represent state machines, it lacks the ability to compile and simulate them.\n\nwarn: Warn\nThis functionality is considered experimental API","category":"section"},{"location":"API/model_building/#ModelingToolkit.substitute_component","page":"Model building reference","title":"ModelingToolkit.substitute_component","text":"substitute_component(\n    sys::ModelingToolkitBase.AbstractSystem,\n    rule::Pair{T<:ModelingToolkitBase.AbstractSystem, T<:ModelingToolkitBase.AbstractSystem}\n) -> Any\n\n\nGiven a hierarchical system sys and a rule lhs => rhs, replace the subsystem lhs in sys by rhs. The lhs must be the namespaced version of a subsystem of sys (e.g. obtained via sys.inner.component). The rhs must be valid as per the following conditions:\n\nrhs must not be namespaced.\nThe name of rhs must be the same as the unnamespaced name of lhs.\nNeither one of lhs or rhs can be marked as complete.\nBoth lhs and rhs must share the same independent variable.\nrhs must contain at least all of the unknowns and parameters present in lhs.\nCorresponding unknowns in rhs must share the same connection and causality (input/output) metadata as their counterparts in lhs.\nFor each subsystem of lhs, there must be an identically named subsystem of rhs. These two corresponding subsystems must satisfy conditions 3, 4, 5, 6, 7. If the subsystem of lhs is a connector, the corresponding subsystem of rhs must also be a connector of the same type.\n\nsys also cannot be marked as complete.\n\n\n\n\n\n","category":"function"},{"location":"API/model_building/#ModelingToolkitBase.mtkcompile","page":"Model building reference","title":"ModelingToolkitBase.mtkcompile","text":"function mtkcompile(sys::System; kwargs...)\n\nCompile the given system into a form that ModelingToolkit can generate code for. Also performs a variety of symbolic-numeric enhancements. For ODEs, this includes processes such as order reduction, index reduction, alias elimination and tearing. A subset of the unknowns of the system may be eliminated as observables, eliminating the need for the numerical solver to solve for these variables.\n\nDoes not rely on metadata to identify variables/parameters/brownians. Instead, queries the system for which symbolic quantites belong to which category. Any variables not present in the equations of the system will be removed in this process.\n\nKeyword Arguments\n\nWhen simplify=true, the simplify function will be applied during the tearing process.\nallow_symbolic=false, allow_parameter=true, and conservative=false limit the coefficient types during tearing. In particular, conservative=true limits tearing to only solve for trivial linear systems where the coefficient has the absolute value of 1.\nfully_determined=true controls whether or not an error will be thrown if the number of equations don't match the number of inputs, outputs, and equations.\ninputs, outputs and disturbance_inputs are passed as keyword arguments.All inputs get converted to parameters and are allowed to be unconnected, allowing models where n_unknowns = n_equations - n_inputs.\nsort_eqs=true controls whether equations are sorted lexicographically before simplification or not.\n\n\n\n\n\n","category":"function"},{"location":"API/model_building/#ModelingToolkit.IfLifting","page":"Model building reference","title":"ModelingToolkit.IfLifting","text":"If lifting converts (nested) if statements into a series of continuous events + a logically equivalent if statement + parameters.\n\nLifting proceeds through the following process:\n\nrewrite comparisons to be of the form eqn [op] 0; subtract the RHS from the LHS \nreplace comparisons with generated parameters; for each comparison eqn [op] 0, generate an event (dependent on op) that sets the parameter\n\nwarn: Warn\nThis is an experimental simplification pass. It may have bugs. Please open issues with MWEs for any bugs encountered while using this.\n\n\n\n\n\n","category":"function"},{"location":"API/model_building/#ModelingToolkit.FMIComponent","page":"Model building reference","title":"ModelingToolkit.FMIComponent","text":"FMIComponent(\n    ::Val{Ver};\n    fmu,\n    tolerance,\n    communication_step_size,\n    reinitializealg,\n    type,\n    name\n)\n\n\nA component that wraps an FMU loaded via FMI.jl. The FMI version (2 or 3) should be provided as a Val to the function. Supports Model Exchange and CoSimulation FMUs. All inputs, continuous variables and outputs must be FMI.fmi2Real or FMI.fmi3Float64. Does not support events or discrete variables in the FMU. Does not support automatic differentiation. Parameters of the FMU will have defaults corresponding to their initial values in the FMU specification. All other variables will not have a default. Hierarchical names in the FMU of the form namespace.variable are transformed into symbolic variables with the name namespace__variable.\n\nKeyword Arguments\n\nfmu: The FMU loaded via FMI.loadFMU.\ntolerance: The tolerance to provide to the FMU. Not used for v3 FMUs since it is not supported by FMI.jl.\ncommunication_step_size: The periodic interval at which communication with CoSimulation FMUs will occur. Must be provided for CoSimulation FMU components.\nreinitializealg: The DAE initialization algorithm to use for the callback managing the FMU. For CoSimulation FMUs whose states/outputs are used in algebraic equations of the system, this needs to be an algorithm that will solve for the new algebraic variables. For example, OrdinaryDiffEqCore.BrownFullBasicInit().\ntype: Either :ME or :CS depending on whether fmu is a Model Exchange or CoSimulation FMU respectively.\nname: The name of the system.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Internal-Details","page":"Internal Details","title":"Internal Details","text":"This section documents the internal implementation details of ModelingToolkit. These APIs are not considered stable and may change without notice in non-breaking releases. They are documented here to help future contributors understand the library's inner workings.","category":"section"},{"location":"internals/#Overview","page":"Internal Details","title":"Overview","text":"ModelingToolkit's internal architecture consists of several key components:\n\nStructural Transformation: Algorithms for transforming equation systems, including index reduction, tearing, and algebraic simplification\nBipartite Graphs: Graph representations used to analyze relationships between equations and variables\nSystem Structure: Internal representations of system state and transformations\n\nThese components work together to enable ModelingToolkit's symbolic manipulation and code generation capabilities.\n\nwarning: Warning\nThe functions and types documented in this section are internal implementation details. Users should not rely on these APIs as they may change or be removed without deprecation warnings.","category":"section"},{"location":"internals/#Misc","page":"Internal Details","title":"Misc","text":"Bindings, initial conditions and guesses are stored as AtomicArrayDict. This is a custom wrapper which only supports symbolic keys, and disallows keys which are indexed array variables.\nKeys of parameter bindings cannot be present in get_ps(sys).","category":"section"},{"location":"tutorials/modelingtoolkitize/#Modelingtoolkitize:-Automatically-Translating-Numerical-to-Symbolic-Code","page":"Modelingtoolkitize: Automatically Translating Numerical to Symbolic Code","title":"Modelingtoolkitize: Automatically Translating Numerical to Symbolic Code","text":"","category":"section"},{"location":"tutorials/modelingtoolkitize/#What-is-modelingtoolkitize?","page":"Modelingtoolkitize: Automatically Translating Numerical to Symbolic Code","title":"What is modelingtoolkitize?","text":"From the other tutorials you will have learned that ModelingToolkit is a symbolic library with all kinds of goodies, such as the ability to derive analytical expressions for things like Jacobians, determine the sparsity of a set of equations, perform index reduction, tearing, and other transformations to improve both stability and performance. All of these are good things, but all of these require that one has defined the problem symbolically.\n\nBut what happens if one wants to use ModelingToolkit functionality on code that is already written for DifferentialEquations.jl, NonlinearSolve.jl, Optimization.jl, or beyond?\n\nmodelingtoolktize is a function in ModelingToolkit which takes a numerically-defined SciMLProblem and transforms it into its symbolic ModelingToolkit equivalent. By doing so, ModelingToolkit analysis passes and transformations can be run as intermediate steps to improve a simulation code before it's passed to the solver.\n\nnote: Note\nmodelingtoolkitize does have some limitations, i.e. not all codes that work with the numerical solvers will work with modelingtoolkitize. Namely, it requires the ability to trace the equations with Symbolics.jl Num types. Generally, a code which is compatible with forward-mode automatic differentiation is compatible with modelingtoolkitize.\n\nwarn: Warn\nmodelingtoolkitize expressions cannot keep control flow structures (loops), and thus equations with long loops will be translated into large expressions, which can increase the compile time of the equations and reduce the SIMD vectorization achieved by LLVM.","category":"section"},{"location":"tutorials/modelingtoolkitize/#Example-Usage:-Generating-an-Analytical-Jacobian-Expression-for-an-ODE-Code","page":"Modelingtoolkitize: Automatically Translating Numerical to Symbolic Code","title":"Example Usage: Generating an Analytical Jacobian Expression for an ODE Code","text":"Take, for example, the Robertson ODE defined as an ODEProblem for OrdinaryDiffEq.jl:\n\nusing OrdinaryDiffEq, ModelingToolkit\nfunction rober(du, u, p, t)\n    y₁, y₂, y₃ = u\n    k₁, k₂, k₃ = p\n    du[1] = -k₁ * y₁ + k₃ * y₂ * y₃\n    du[2] = k₁ * y₁ - k₂ * y₂^2 - k₃ * y₂ * y₃\n    du[3] = k₂ * y₂^2\n    nothing\nend\nprob = ODEProblem(rober, [1.0, 0.0, 0.0], (0.0, 1e5), (0.04, 3e7, 1e4))\n\nIf we want to get a symbolic representation, we can simply call modelingtoolkitize on the prob, which will return an System:\n\n@mtkcompile sys = modelingtoolkitize(prob)\n\nUsing this, we can symbolically build the Jacobian and then rebuild the ODEProblem:\n\nprob_jac = ODEProblem(sys, [], (0.0, 1e5), jac = true)","category":"section"},{"location":"tutorials/attractors/#attractors","page":"Multi- and Nonlocal- Continuation","title":"Multi- and Nonlocal- Continuation","text":"In the tutorial on Bifurcation Diagrams we saw how one can create them by integrating ModelingToolkit.jl with BifurcationKit.jl. This approach is also often called continuation in the broader literature, because in essence we are \"continuing\" the location of individual un/stable fixed points or limit cycles in a dynamical system across a parameter axis.\n\nRecently, an alternative continuation framework was proposed that takes a fundamentally different approach to continuation that is particularly suitable for complex systems. This framework is implemented in Attractors.jl as part of the DynamicalSystems.jl software library. This new continuation is called global continuation, while the one of BifurcationKit.jl is called local continuation.\n\nInstead of continuing an individual fixed point or limit cycle, the global continuation finds all attractors of the dynamical system and continues all of them, in parallel, in a single continuation. It distinguishes and labels automatically the different attractors. Hence \"multi-\" for multiple attractors. Another key difference is that instead of estimating the local (or linear, or Jacobian) stability of the attractors, it estimates various measures of nonlocal stability (e.g, related with the size of the basins of attraction, or the size of a perturbation that would make the dynamical system state converge to an alternative attractor). Hence the \"nonlocal-\" component. More differences and pros & cons are discussed in the documentation of Attractors.jl.\n\nnote: Attractors and basins\nThis tutorial assumes that you have some familiarity with dynamical systems, specifically what are attractors and basins of attraction. If you don't have this yet, we recommend Chapter 1 of the textbook Nonlinear Dynamics.","category":"section"},{"location":"tutorials/attractors/#Creating-the-DynamicalSystem-via-MTK","page":"Multi- and Nonlocal- Continuation","title":"Creating the DynamicalSystem via MTK","text":"Let's showcase this framework by modelling a chaotic bistable dynamical system that we define via ModelingToolkit.jl, which will the be casted into a DynamicalSystem type for the DynamicalSystems.jl library. The equations of our system are\n\nusing ModelingToolkit\nusing ModelingToolkit: t_nounits as t, D_nounits as D\n\n@variables x(t)=-4.0 y(t)=5.0 z(t)=0.0\n@parameters a=5.0 b=0.1\n\neqs = [\n    D(x) ~ y - x,\n    D(y) ~ -x * z + b * abs(z),\n    D(z) ~ x * y - a\n]\n\nBecause our dynamical system is super simple, we will directly make an System and cast it in an ODEProblem as in the Systems tutorial. Since all state variables and parameters have a default value we can immediately write\n\n@named modlorenz = System(eqs, t)\nssys = mtkcompile(modlorenz)\n# The timespan given to the problem is irrelevant for DynamicalSystems.jl\nprob = ODEProblem(ssys, [], (0.0, 1.0))\n\nThis prob can be turned to a dynamical system as simply as\n\nusing Attractors # or `DynamicalSystems`\nds = CoupledODEs(prob)\n\nDynamicalSystems.jl integrates fully with ModelingToolkit.jl out of the box and understands whether a given problem has been created via ModelingToolkit.jl. For example you can use the symbolic variables, or their Symbol representations, to access a system state or parameter\n\nobserve_state(ds, x)\n\ncurrent_parameter(ds, :a) # or `a` directly","category":"section"},{"location":"tutorials/attractors/#Finding-all-attractors-in-the-state-space","page":"Multi- and Nonlocal- Continuation","title":"Finding all attractors in the state space","text":"Attractors.jl provides an extensive interface for finding all (within a state space region and numerical accuracy) attractors of a dynamical system. This interface is structured around the type AttractorMapper and is discussed in the Attractors.jl documentation in detail. Here we will briefly mention one of the possible approaches, the recurrences-based algorithm. It finds attractors by finding locations in the state space where the trajectory returns again and again.\n\nTo use this technique, we first need to create a tessellation of the state space\n\ngrid = (\n    range(-15.0, 15.0; length = 150), # x\n    range(-20.0, 20.0; length = 150), # y\n    range(-20.0, 20.0; length = 150) # z\n)\n\nwhich we then give as input to the AttractorsViaRecurrences mapper along with the dynamical system\n\nmapper = AttractorsViaRecurrences(ds, grid;\n    consecutive_recurrences = 1000,\n    consecutive_lost_steps = 100\n)\n\nto learn about the metaparameters of the algorithm visit the documentation of Attractors.jl.\n\nThis mapper object is incredibly powerful! It can be used to map initial conditions to attractor they converge to, while ensuring that initial conditions that converge to the same attractor are given the same label. For example, if we use the mapper as a function and give it an initial condition we get\n\nmapper([-4.0, 5, 0])\n\nmapper([4.0, 2, 0])\n\nmapper([1.0, 3, 2])\n\nThe numbers returned are simply the unique identifiers of the attractors the initial conditions converged to.\n\nDynamicalSystems.jl library is the only dynamical systems software (in any language) that provides such an infrastructure for mapping initial conditions of any arbitrary dynamical system to its unique attractors. And this is only the tip of this iceberg! The rest of the functionality of Attractors.jl is all full of brand new cutting edge progress in dynamical systems research.\n\nThe found attractors are stored in the mapper internally, to obtain them we use the function\n\nattractors = extract_attractors(mapper)\n\nThis is a dictionary that maps attractor IDs to the attractor sets themselves. StateSpaceSet is a wrapper of a vector of points and behaves exactly like a vector of points. We can plot them easily like\n\nusing CairoMakie\nfig = Figure()\nax = Axis(fig[1, 1])\ncolors = [\"#7143E0\", \"#191E44\"]\nfor (id, A) in attractors\n    scatter!(ax, A[:, [1, 3]]; color = colors[id])\nend\nfig","category":"section"},{"location":"tutorials/attractors/#Basins-of-attraction","page":"Multi- and Nonlocal- Continuation","title":"Basins of attraction","text":"Estimating the basins of attraction of these attractors is a matter of a couple lines of code. First we define the state space are to estimate the basins for. Here we can re-use the grid we defined above. Then we only have to call\n\nbasins = basins_of_attraction(mapper, grid)\n\nWe won't run this in this tutorial because it is a length computation (150×150×150). We will however estimate a slice of the 3D basins of attraction. DynamicalSystems.jl allows for a rather straightforward setting of initial conditions:\n\nics = [Dict(:x => x, :y => 0, :z => z) for x in grid[1] for z in grid[3]]\n\nnow we can estimate the basins of attraction on a slice on the x-z grid\n\nfs, labels = basins_fractions(mapper, ics)\nlabels = reshape(labels, (length(grid[1]), length(grid[3])))\n\nand visualize them\n\nheatmap(grid[1], grid[3], labels; colormap = colors)","category":"section"},{"location":"tutorials/attractors/#Global-continuation","page":"Multi- and Nonlocal- Continuation","title":"Global continuation","text":"We've already outlined the principles of the global continuation, so let's just do it here! We first have to define a global continuation algorithm, which for this tutorial, it is just a wrapper of the existing mapper\n\nascm = AttractorSeedContinueMatch(mapper);\n\nwe need two more ingredients to perform the global continuation. One is a sampler of initial conditions in the state space. Here we'll uniformly sample initial conditions within this grid we have already defined\n\nsampler, = statespace_sampler(grid);\n\nthe last ingredient is what parameter(s) to perform the continuation over. In contrast to local continuation, where we can only specify a parameter range, in global continuation one can specify an exact parameter curve to continue over. This curve can span any-dimensional parameter space, in contrast to the 1D or 2D parameter spaces supported in local continuation. Here we will use the curve\n\nparams(θ) = [:a => 5 + 0.5cos(θ), :b => 0.1 + 0.01sin(θ)]\nθs = range(0, 2π; length = 101)\npcurve = params.(θs)\n\nwhich makes an ellipsis over the parameter space.\n\nWe put these three ingredients together to call the global continuation\n\nfractions_cont, attractors_cont = global_continuation(ascm, pcurve, sampler);\n\nThe output of the continuation is how the attractors and their basins fractions change over this parameter curve. We can visualize this directly using a convenience function\n\nfig = plot_basins_attractors_curves(\n    fractions_cont, attractors_cont, A -> minimum(A[:, 1]), θs\n)\n\nThe top panel shows the relative basins of attractions of the attractors and the bottom panel shows their minimum x-position. The colors correspond to unique attractors. Perhaps making a video is easier to understand:\n\nanimate_attractors_continuation(\n    ds, attractors_cont, fractions_cont, pcurve;\n    savename = \"curvecont.mp4\"\n);\n\n<video width=\"auto\" controls loop>\n<source src=\"../curvecont.mp4\" type=\"video/mp4\">\n</video>\n\nTo learn more about this global continuation and its various options, and more details about how it compares with local continuation, visit the documentation of Attractors.jl.","category":"section"},{"location":"API/variables/#symbolic_metadata","page":"Symbolic variables and variable metadata","title":"Symbolic variables and variable metadata","text":"ModelingToolkit uses Symbolics.jl for the symbolic manipulation infrastructure. In fact, the @variables macro is defined in Symbolics.jl. In addition to @variables, ModelingToolkit defines @parameters, @independent_variables, @constants and @brownians. These macros function identically to @variables but allow ModelingToolkit to attach additional metadata.\n\nSymbolic variables can have metadata attached to them. The defaults and guesses assigned at variable construction time are examples of this metadata. ModelingToolkit also defines additional types of metadata.","category":"section"},{"location":"API/variables/#Variable-defaults","page":"Symbolic variables and variable metadata","title":"Variable defaults","text":"Variables can be assigned default values to avoid having to specify defaults to the System constructor.","category":"section"},{"location":"API/variables/#Variable-descriptions","page":"Symbolic variables and variable metadata","title":"Variable descriptions","text":"Descriptive strings can be attached to variables using the [description = \"descriptive string\"] syntax:\n\nusing ModelingToolkit\nusing ModelingToolkit: t_nounits as t, D_nounits as D\n@variables u [description = \"This is my input\"]\ngetdescription(u)\n\nWhen variables with descriptions are present in systems, they will be printed when the system is shown in the terminal:\n\n@variables u(t) [description = \"A short description of u\"]\n@parameters p [description = \"A description of p\"]\n@named sys = System([u ~ p], t)\nshow(stdout, \"text/plain\", sys) # hide\n\nCalling help on the variable u displays the description, alongside other metadata:\n\nhelp?> u\n\n  A variable of type Symbolics.Num (Num wraps anything in a type that is a subtype of Real)\n\n  Metadata\n  ≡≡≡≡≡≡≡≡≡≡\n\n  ModelingToolkit.VariableDescription: This is my input\n\n  Symbolics.VariableSource: (:variables, :u)","category":"section"},{"location":"API/variables/#Connect","page":"Symbolic variables and variable metadata","title":"Connect","text":"Variables in connectors can have connect metadata which describes the type of connections.\n\nFlow is used for variables that represent physical quantities that \"flow\" ex: current in a resistor. These variables sum up to zero in connections.\n\nStream can be specified for variables that flow bi-directionally.\n\nusing ModelingToolkit\nusing ModelingToolkit: t_nounits as t, D_nounits as D\n\n@variables i(t) [connect = Flow]\n@variables k(t) [connect = Stream]\nhasconnect(i)\n\ngetconnect(k)","category":"section"},{"location":"API/variables/#Input-or-output","page":"Symbolic variables and variable metadata","title":"Input or output","text":"Designate a variable as either an input or an output using the following\n\nusing ModelingToolkit\nusing ModelingToolkit: t_nounits as t, D_nounits as D\n\n@variables u [input = true]\nisinput(u)\n\n@variables y [output = true]\nisoutput(y)","category":"section"},{"location":"API/variables/#Bounds","page":"Symbolic variables and variable metadata","title":"Bounds","text":"Bounds are useful when parameters are to be optimized, or to express intervals of uncertainty.\n\n@variables u [bounds = (-1, 1)];\nhasbounds(u)\ngetbounds(u)\n\nBounds can also be specified for array variables. A scalar array bound is applied to each element of the array. A bound may also be specified as an array, in which case the size of the array must match the size of the symbolic variable.\n\n@variables x[1:2, 1:2] [bounds = (-1, 1)];\nhasbounds(x)\ngetbounds(x)\ngetbounds(x[1, 1])\ngetbounds(x[1:2, 1])\n@variables x[1:2] [bounds = (-Inf, [1.0, Inf])];\nhasbounds(x)\ngetbounds(x)\ngetbounds(x[2])\nhasbounds(x[2])","category":"section"},{"location":"API/variables/#Guess","page":"Symbolic variables and variable metadata","title":"Guess","text":"Specify an initial guess for variables of a System. This is used when building the InitializationProblem.\n\n@variables u [guess = 1];\nhasguess(u)\ngetguess(u)\n\nWhen a system is constructed, the guesses of the involved variables are stored in a Dict in the system. After this point, the guess metadata of the variable is irrelevant.","category":"section"},{"location":"API/variables/#Mark-input-as-a-disturbance","page":"Symbolic variables and variable metadata","title":"Mark input as a disturbance","text":"Indicate that an input is not available for control, i.e., it's a disturbance input.\n\n@variables u [input = true, disturbance = true]\nisdisturbance(u)","category":"section"},{"location":"API/variables/#Mark-parameter-as-tunable","page":"Symbolic variables and variable metadata","title":"Mark parameter as tunable","text":"Indicate that a parameter can be automatically tuned by parameter optimization or automatic control tuning apps.\n\n@parameters Kp [tunable = true]\nistunable(Kp)\n\nnote: Note\n@constants is a convenient way to create @parameters with tunable = false metadata","category":"section"},{"location":"API/variables/#Probability-distributions","page":"Symbolic variables and variable metadata","title":"Probability distributions","text":"A probability distribution may be associated with a parameter to indicate either uncertainty about its value, or as a prior distribution for Bayesian optimization.\n\nusing Distributions;\nd = Normal(10, 1);\n@parameters m [dist = d];\nhasdist(m)\ngetdist(m)","category":"section"},{"location":"API/variables/#Irreducible","page":"Symbolic variables and variable metadata","title":"Irreducible","text":"A variable can be marked irreducible to prevent it from being moved to an observed state. This forces the variable to be computed during solving so that it can be accessed in callbacks\n\n@variables important_value [irreducible = true]\nisirreducible(important_value)","category":"section"},{"location":"API/variables/#State-Priority","page":"Symbolic variables and variable metadata","title":"State Priority","text":"When a model is structurally simplified, the algorithm will try to ensure that the variables with higher state priority become states of the system. A variable's state priority is a number set using the state_priority metadata.\n\n@variables important_dof [state_priority = 10] unimportant_dof [state_priority = -2]\nstate_priority(important_dof)","category":"section"},{"location":"API/variables/#Units","page":"Symbolic variables and variable metadata","title":"Units","text":"Units for variables can be designated using symbolic metadata. For more information, please see the model validation and units section of the docs. Note that getunit is not equivalent to get_unit - the former is a metadata getter for individual variables (and is provided so the same interface function for unit exists like other metadata), while the latter is used to handle more general symbolic expressions.\n\nusing DynamicQuantities;\n@variables speed [unit = u\"m/s\"];\nhasunit(speed)\ngetunit(speed)","category":"section"},{"location":"API/variables/#Variable-type","page":"Symbolic variables and variable metadata","title":"Variable type","text":"This metadata is used by the System constructor for automatically identifying the different types of variables in a system.","category":"section"},{"location":"API/variables/#Miscellaneous-metadata","page":"Symbolic variables and variable metadata","title":"Miscellaneous metadata","text":"User-defined metadata can be added using the misc metadata. This can be queried using the hasmisc and getmisc functions.\n\n@variables u [misc = :conserved_parameter] y [misc = [2, 4, 6]];\nhasmisc(u)\ngetmisc(y)","category":"section"},{"location":"API/variables/#Dumping-metadata","page":"Symbolic variables and variable metadata","title":"Dumping metadata","text":"ModelingToolkit allows dumping the metadata of a variable as a NamedTuple.","category":"section"},{"location":"API/variables/#Additional-functions","page":"Symbolic variables and variable metadata","title":"Additional functions","text":"For systems that contain parameters with metadata like described above, have some additional functions defined for convenience. In the example below, we define a system with tunable parameters and extract bounds vectors\n\n@variables x(t)=0 u(t)=0 [input=true] y(t)=0 [output=true]\n@parameters T [tunable = true, bounds = (0, Inf)]\n@parameters k [tunable = true, bounds = (0, Inf)]\neqs = [D(x) ~ (-x + k * u) / T # A first-order system with time constant T and gain k\n       y ~ x]\nsys = System(eqs, t, name = :tunable_first_order)\n\np = tunable_parameters(sys) # extract all parameters marked as tunable\n\nlb, ub = getbounds(p) # operating on a vector, we get lower and upper bound vectors\n\nb = getbounds(sys) # Operating on the system, we get a dict\n\nSee also:","category":"section"},{"location":"API/variables/#Symbolic-operators","page":"Symbolic variables and variable metadata","title":"Symbolic operators","text":"ModelingToolkit makes heavy use of \"operators\". These are custom functions that are applied to symbolic variables. The most common operator is the Differential operator, defined in Symbolics.jl.\n\nModelingToolkit also defines a plethora of custom operators.\n\nWhile not an operator, ShiftIndex is commonly used to use Shift operators in a more convenient way when writing discrete systems.","category":"section"},{"location":"API/variables/#Sampled-time-operators","page":"Symbolic variables and variable metadata","title":"Sampled time operators","text":"The following operators are used in hybrid ODE systems, where part of the dynamics of the system happen at discrete intervals on a clock. While ModelingToolkit cannot yet simulate such systems, it has the capability to represent them.\n\nwarn: Warn\nThese operators are considered experimental API.","category":"section"},{"location":"examples/spring_mass/#Component-Based-Modeling-of-a-Spring-Mass-System","page":"Component-Based Modeling of a Spring-Mass System","title":"Component-Based Modeling of a Spring-Mass System","text":"In this tutorial, we will build a simple component-based model of a spring-mass system. A spring-mass system consists of one or more masses connected by springs. Hooke's law gives the force exerted by a spring when it is extended or compressed by a given distance. This specifies a differential-equation system where the acceleration of the masses is specified using the forces acting on them.","category":"section"},{"location":"examples/spring_mass/#Copy-Paste-Example","page":"Component-Based Modeling of a Spring-Mass System","title":"Copy-Paste Example","text":"using ModelingToolkit, Plots, OrdinaryDiffEq, LinearAlgebra\nusing ModelingToolkit: t_nounits as t, D_nounits as D\nusing Symbolics: scalarize\n\nfunction Mass(; name, m = 1.0, xy = [0.0, 0.0], u = [0.0, 0.0])\n    ps = @parameters m = m\n    sts = @variables pos(t)[1:2]=xy v(t)[1:2]=u\n    eqs = scalarize(D.(pos) .~ v)\n    System(eqs, t, [pos..., v...], ps; name)\nend\n\nfunction Spring(; name, k = 1e4, l = 1.0)\n    ps = @parameters k=k l=l\n    @variables x(t), dir(t)[1:2]\n    System(Equation[], t, [x, dir...], ps; name)\nend\n\nfunction connect_spring(spring, a, b)\n    [spring.x ~ norm(scalarize(a .- b))\n     scalarize(spring.dir .~ scalarize(a .- b))]\nend\n\nfunction spring_force(spring)\n    -spring.k .* scalarize(spring.dir) .* (spring.x - spring.l) ./ spring.x\nend\n\nm = 1.0\nxy = [1.0, -1.0]\nk = 1e4\nl = 1.0\ncenter = [0.0, 0.0]\ng = [0.0, -9.81]\n@named mass = Mass(m = m, xy = xy)\n@named spring = Spring(k = k, l = l)\n\neqs = [connect_spring(spring, mass.pos, center)\n       scalarize(D.(mass.v) .~ spring_force(spring) / mass.m .+ g)]\n\n@named _model = System(eqs, t, [spring.x; spring.dir; mass.pos], [])\n@named model = compose(_model, mass, spring)\nsys = mtkcompile(model)\n\nprob = ODEProblem(sys, [], (0.0, 3.0))\nsol = solve(prob, Rosenbrock23())\nplot(sol)","category":"section"},{"location":"examples/spring_mass/#Explanation","page":"Component-Based Modeling of a Spring-Mass System","title":"Explanation","text":"","category":"section"},{"location":"examples/spring_mass/#Building-the-components","page":"Component-Based Modeling of a Spring-Mass System","title":"Building the components","text":"For each component, we use a Julia function that returns an System. At the top, we define the fundamental properties of a Mass: it has a mass m, a position pos and a velocity v. We also define that the velocity is the rate of change of position with respect to time.\n\nfunction Mass(; name, m = 1.0, xy = [0.0, 0.0], u = [0.0, 0.0])\n    ps = @parameters m = m\n    sts = @variables pos(t)[1:2]=xy v(t)[1:2]=u\n    eqs = scalarize(D.(pos) .~ v)\n    System(eqs, t, [pos..., v...], ps; name)\nend\n\nNote that this is an incompletely specified System. It cannot be simulated on its own, since the equations for the velocity v[1:2](t) are unknown. Notice the addition of a name keyword. This allows us to generate different masses with different names. A Mass can now be constructed as:\n\nMass(name = :mass1)\n\nOr using the @named helper macro\n\n@named mass1 = Mass()\n\nNext, we build the spring component. It is characterized by the spring constant k and the length l of the spring when no force is applied to it. The state of a spring is defined by its current length and direction.\n\nfunction Spring(; name, k = 1e4, l = 1.0)\n    ps = @parameters k=k l=l\n    @variables x(t), dir(t)[1:2]\n    System(Equation[], t, [x, dir...], ps; name)\nend\n\nWe now define functions that help construct the equations for a mass-spring system. First, the connect_spring function connects a spring between two positions a and b. Note that a and b can be the pos of a Mass, or just a fixed position such as [0., 0.]. In that sense, the length of the spring x is given by the length of the vector dir joining a and b.\n\nfunction connect_spring(spring, a, b)\n    [spring.x ~ norm(scalarize(a .- b))\n     scalarize(spring.dir .~ scalarize(a .- b))]\nend\n\nLastly, we define the spring_force function that takes a spring and returns the force exerted by this spring.\n\nfunction spring_force(spring)\n    -spring.k .* scalarize(spring.dir) .* (spring.x - spring.l) ./ spring.x\nend\n\nTo create our system, we will first create the components: a mass and a spring. This is done as follows:\n\nm = 1.0\nxy = [1.0, -1.0]\nk = 1e4\nl = 1.0\ncenter = [0.0, 0.0]\ng = [0.0, -9.81]\n@named mass = Mass(m = m, xy = xy)\n@named spring = Spring(k = k, l = l)\n\nWe can now create the equations describing this system, by connecting spring to mass and a fixed point.\n\neqs = [connect_spring(spring, mass.pos, center)\n       scalarize(D.(mass.v) .~ spring_force(spring) / mass.m .+ g)]\n\nFinally, we can build the model using these equations and components.\n\n@named _model = System(eqs, t, [spring.x; spring.dir; mass.pos], [])\n@named model = compose(_model, mass, spring)\n\nWe can take a look at the equations in the model using the equations function.\n\nequations(model)\n\nThe unknowns of this model are:\n\nunknowns(model)\n\nAnd the parameters of this model are:\n\nparameters(model)","category":"section"},{"location":"examples/spring_mass/#Simplifying-and-solving-this-system","page":"Component-Based Modeling of a Spring-Mass System","title":"Simplifying and solving this system","text":"This system can be solved directly as a DAE using one of the DAE solvers from DifferentialEquations.jl. However, we can symbolically simplify the system first beforehand. Running mtkcompile eliminates unnecessary variables from the model to give the leanest numerical representation of the system.\n\nsys = mtkcompile(model)\nequations(sys)\n\nWe are left with only 4 equations involving 4 unknown variables (mass.pos[1], mass.pos[2], mass.v[1], mass.v[2]). We can solve the system by converting it to an ODEProblem. Some observed variables are not expanded by default. To view the complete equations, one can do\n\nfull_equations(sys)\n\nThis is done as follows:\n\nprob = ODEProblem(sys, [], (0.0, 3.0))\nsol = solve(prob, Rosenbrock23())\nplot(sol)\n\nWhat if we want the timeseries of a different variable? That information is not lost! Instead, mtkcompile simply changes unknown variables into observed variables.\n\nobserved(sys)\n\nThese are explicit algebraic equations which can be used to reconstruct the required variables on the fly. This leads to dramatic computational savings since implicitly solving an ODE scales as O(n^3), so fewer unknowns are significantly better!\n\nWe can access these variables using the solution object. For example, let's retrieve the x-position of the mass over time:\n\nsol[mass.pos[1]]\n\nWe can also plot the path of the mass:\n\nplot(sol, idxs = (mass.pos[1], mass.pos[2]))","category":"section"},{"location":"basics/ContextualVariables/#Contextual-Variable-Types","page":"Contextual Variable Types","title":"Contextual Variable Types","text":"ModelingToolkit.jl has a system of contextual variable types which allows for helping the system transformation machinery do complex manipulations and automatic detection. The standard variable definition in ModelingToolkit.jl is the @variable which is defined by Symbolics.jl. For example:\n\n@variables x y(x)\n\nThis is used for the “normal” variable of a given system, like the unknowns of a differential equation or objective function. All the macros below support the same syntax as @variables.","category":"section"},{"location":"basics/ContextualVariables/#Parameters","page":"Contextual Variable Types","title":"Parameters","text":"All modeling projects have some form of parameters. @parameters marks a variable as being the parameter of some system, which allows automatic detection algorithms to ignore such variables when attempting to find the unknowns of a system.","category":"section"},{"location":"basics/ContextualVariables/#constants","page":"Contextual Variable Types","title":"Constants","text":"Constants, defined by e.g. @constants myconst1 are like parameters that:\n\nalways have a default value, which must be assigned when the constants are declared\ndo not show up in the list of parameters of a system.\n\nThe intended use-cases for constants are:\n\nrepresenting literals (e.g., π) symbolically, which results in cleaner Latexification of equations (avoids turning d ~ 2π*r into d = 6.283185307179586 r)\nallowing auto-generated unit conversion factors to live outside the list of parameters\nrepresenting fundamental constants (e.g., speed of light c) that should never be adjusted inadvertently.","category":"section"},{"location":"basics/ContextualVariables/#Wildcard-Variable-Arguments","page":"Contextual Variable Types","title":"Wildcard Variable Arguments","text":"@variables u(..)\n\nIt is possible to define a dependent variable which is an open function as above, for which its arguments must be specified each time it is used. This is useful with PDEs for example, where one may need to use u(t, x) in the equations, but will need to be able to write u(t, 0.0) to define a boundary condition at x = 0.","category":"section"},{"location":"basics/ContextualVariables/#Variable-metadata","page":"Contextual Variable Types","title":"Variable metadata","text":"In many engineering systems, some variables act like “flows” while others do not. For example, in circuit models you have current which flows, and the related voltage which does not. Or in thermal models you have heat flows. In these cases, the connect statement enforces conservation of flow between all of the connected components.\n\nFor example, the following specifies that x is a 2x2 matrix of flow variables with the unit m^3/s:\n\n@variables x[1:2, 1:2] [connect = Flow; unit = u\"m^3/s\"]\n\nModelingToolkit defines connect, unit, noise, and description keys for the metadata. One can get and set metadata by\n\njulia> @variables x [unit = u\"m^3/s\"];\n\njulia> hasmetadata(x, VariableUnit)\ntrue\n\njulia> ModelingToolkit.get_unit(x)\nm³ s⁻¹\n\njulia> x = setmetadata(x, VariableUnit, u\"m/s\")\nx\n\njulia> ModelingToolkit.get_unit(x)\nm s⁻¹\n\nSee Symbolic Metadata for more details on variable metadata.","category":"section"},{"location":"tutorials/change_independent_variable/#Changing-the-independent-variable-of-ODEs","page":"Changing the independent variable of ODEs","title":"Changing the independent variable of ODEs","text":"Ordinary differential equations describe the rate of change of some dependent variables with respect to one independent variable. For the modeler it is often most natural to write down the equations with a particular independent variable, say time t. However, in many cases there are good reasons for changing the independent variable:\n\nOne may want y(x) as a function of x instead of (x(t) y(t)) as a function of t\nSome differential equations vary more nicely (e.g. less stiff) with respect to one independent variable than another.\nIt can reduce the number of equations that must be solved (e.g. y(x) is one equation, while (x(t) y(t)) are two).\n\nTo manually change the independent variable of an ODE, one must rewrite all equations in terms of a new variable and transform differentials with the chain rule. This is mechanical and error-prone. ModelingToolkit provides the utility function change_independent_variable that automates this process.","category":"section"},{"location":"tutorials/change_independent_variable/#1.-Get-one-dependent-variable-as-a-function-of-another","page":"Changing the independent variable of ODEs","title":"1. Get one dependent variable as a function of another","text":"Consider a projectile shot with some initial velocity in a vertical gravitational field with constant horizontal velocity.\n\nusing ModelingToolkit\nusing ModelingToolkit: t_nounits as t, D_nounits as D\n@variables x(t) y(t)\n@parameters g=9.81 v # gravitational acceleration and horizontal velocity\neqs = [D(D(y)) ~ -g, D(x) ~ v]\ninitialization_eqs = [D(x) ~ D(y)] # 45° initial angle\nM1 = System(eqs, t; initialization_eqs, name = :M)\nM1s = mtkcompile(M1)\n@assert length(equations(M1s)) == 3 # hide\nM1s # hide\n\nThis is the standard parametrization that arises naturally from kinematics and Newton's laws. It expresses the position (x(t) y(t)) as a function of time t. But suppose we want to determine whether the projectile hits a target 10 meters away. There are at least three ways of answering this:\n\nSolve the ODE for (x(t) y(t)) and use a callback to terminate when x reaches 10 meters, and evaluate y at the final time.\nSolve the ODE for (x(t) y(t)) and use root finding to find the time when x reaches 10 meters, and evaluate y at that time.\nSolve the ODE for y(x) and evaluate it at 10 meters.\n\nWe will demonstrate the last method by changing the independent variable from t to x. This transformation is well-defined for any non-zero horizontal velocity v, so x and t are one-to-one.\n\nM2 = change_independent_variable(M1, x)\nM2s = mtkcompile(M2; allow_symbolic = true)\n# a sanity test on the 10 x/y variables that are accessible to the user # hide\n@assert allequal([x, M1s.x]) # hide\n@assert allequal([M2.x, M2s.x]) # hide\n@assert allequal([y, M1s.y]) # hide\n@assert allunique([M1.x, M1.y, M2.y, M2s.y]) # hide\n@assert length(equations(M2s)) == 2 # hide\nM2s # display this # hide\n\nThe derivatives are now with respect to the new independent variable x, which can be accessed with M2.x.\n\ninfo: Info\nAt this point x, M1.x, M1s.x, M2.x, M2s.x are three different variables. Meanwhile y, M1.y, M1s.y, M2.y and M2s.y are four different variables. It can be instructive to inspect these yourself to see their subtle differences.\n\nNotice how the number of equations has also decreased from three to two, as mathrmdxmathrmdt has been turned into an observed equation. It is straightforward to evolve the ODE for 10 meters and plot the resulting trajectory y(x):\n\nusing OrdinaryDiffEq, Plots\nprob = ODEProblem(M2s, [M2s.y => 0.0, v => 8.0], [0.0, 10.0]) # throw 10 meters\nsol = solve(prob, Tsit5())\nplot(sol; idxs = M2.y) # must index by M2.y = y(x); not M1.y = y(t)!\n\ntip: Usage tips\nLook up the documentation of change_independent_variable for tips on how to use it.For example, if you also need t(x), you can tell it to add a differential equation for the old independent variable in terms of the new one using the inverse function rule (here mathrmdtmathrmdx = 1  (mathrmdxmathrmdt)). If you know an analytical expression between the independent variables (here t = xv), you can also pass it directly to the function to avoid the extra differential equation.","category":"section"},{"location":"tutorials/change_independent_variable/#2.-Alleviating-stiffness-by-changing-to-logarithmic-time","page":"Changing the independent variable of ODEs","title":"2. Alleviating stiffness by changing to logarithmic time","text":"In cosmology, the Friedmann equations describe the expansion of the universe. In terms of conformal time t, they can be written\n\n@variables a(t) Ω(t)\na = GlobalScope(a) # global var needed by all species\nfunction species(w; kw...)\n    eqs = [D(Ω) ~ -3(1 + w) * D(a) / a * Ω]\n    return System(eqs, t, [Ω], []; kw...)\nend\n@named r = species(1 // 3) # radiation\n@named m = species(0) # matter\n@named Λ = species(-1) # dark energy / cosmological constant\neqs = [Ω ~ r.Ω + m.Ω + Λ.Ω, D(a) ~ √(Ω) * a^2]\ninitialization_eqs = [Λ.Ω + r.Ω + m.Ω ~ 1]\nM1 = System(eqs, t, [Ω, a], []; initialization_eqs, name = :M)\nM1 = compose(M1, r, m, Λ)\nM1s = mtkcompile(M1)\n\nOf course, we can solve this ODE as it is:\n\nprob = ODEProblem(M1s, [M1s.a => 1.0, M1s.r.Ω => 5e-5, M1s.m.Ω => 0.3], (0.0, -3.3))\nsol = solve(prob, Tsit5(); reltol = 1e-5)\n@assert Symbol(sol.retcode) == :Unstable # surrounding text assumes this was unstable # hide\nplot(sol, idxs = [M1s.a, M1s.r.Ω / M1s.Ω, M1s.m.Ω / M1s.Ω, M1s.Λ.Ω / M1s.Ω])\n\nBut the solver becomes unstable due to stiffness. Also notice the interesting dynamics taking place towards the end of the integration (in the early universe), which gets compressed into a very small time interval. These ODEs would benefit from being defined with respect to a logarithmic \"time\" that better captures the evolution of the universe through orders of magnitude of time, rather than linear time.\n\nIt is therefore common to write these ODEs in terms of b = ln a. To do this, we will change the independent variable in two stages; first from t to a, and then from a to b. Notice that mathrmdamathrmdt  0 provided that Omega  0, and mathrmdbmathrmda  0, so the transformation is well-defined since t leftrightarrow a leftrightarrow b are one-to-one. First, we transform from t to a:\n\nM2 = change_independent_variable(M1, M1.a)\n@assert !ModelingToolkit.isautonomous(M2) # hide\nM2 # hide\n\nUnlike the original, notice that this system is non-autonomous because the independent variable a appears explicitly in the equations! This means that to change the independent variable from a to b, we must provide not only the rate of change relation db(a)da = exp(-b), but also the equation a(b) = exp(b) so a can be eliminated in favor of b:\n\na = M2.a # get independent variable of M2\nDa = Differential(a)\n@variables b(a)\nM3 = change_independent_variable(M2, b, [Da(b) ~ exp(-b), a ~ exp(b)])\n\nWe can now solve and plot the ODE in terms of b:\n\nM3s = mtkcompile(M3; allow_symbolic = true)\nprob = ODEProblem(M3s, [M3s.r.Ω => 5e-5, M3s.m.Ω => 0.3], (0, -15))\nsol = solve(prob, Tsit5())\n@assert Symbol(sol.retcode) == :Success # surrounding text assumes the solution was successful # hide\nplot(sol, idxs = [M3s.r.Ω / M3s.Ω, M3s.m.Ω / M3s.Ω, M3s.Λ.Ω / M3s.Ω])\n\nNotice that the variables vary \"more nicely\" with respect to b than t, making the solver happier and avoiding numerical problems.","category":"section"},{"location":"examples/perturbation/#perturb_diff","page":"Symbolic-Numeric Perturbation Theory for ODEs","title":"Symbolic-Numeric Perturbation Theory for ODEs","text":"warning: Example currently disabled\nThis example demonstrates perturbation theory for ODEs but is currently non-executable due to compatibility issues between the series() and taylor_coeff() functions from Symbolics.jl and the current ModelingToolkit stack. The code is shown for educational purposes. See the Mixed Symbolic-Numeric Perturbation Theory tutorial for a working algebraic version.\n\nIn the Mixed Symbolic-Numeric Perturbation Theory tutorial, we discussed how to solve algebraic equations using Symbolics.jl. Here we extend the method to differential equations. The procedure is similar, but the Taylor series coefficients now become functions of an independent variable (usually time).","category":"section"},{"location":"examples/perturbation/#Free-fall-in-a-varying-gravitational-field","page":"Symbolic-Numeric Perturbation Theory for ODEs","title":"Free fall in a varying gravitational field","text":"Our first ODE example is a well-known physics problem: what is the altitude x(t) of an object (say, a ball or a rocket) thrown vertically with initial velocity ẋ(0) from the surface of a planet with mass M and radius R? According to Newton's second law and law of gravity, it is the solution of the ODE\n\nẍ = -fracGM(R+x)^2 = -fracGMR^2 frac1left(1+ϵfracxRright)^2\n\nIn the last equality, we introduced a perturbative expansion parameter ϵ. When ϵ=1, we recover the original problem. When ϵ=0, the problem reduces to the trivial problem ẍ = -g with constant gravitational acceleration g = GMR^2 and solution x(t) = x(0) + ẋ(0) t - frac12 g t^2. This is a good setup for perturbation theory.\n\nTo make the problem dimensionless, we redefine x leftarrow x  R and t leftarrow t  sqrtR^3GM. Then the ODE becomes\n\nusing ModelingToolkit\nusing ModelingToolkit: t_nounits as t, D_nounits as D\n@variables ϵ x(t)\neq = D(D(x)) ~ -(1 + ϵ * x)^(-2)\n\nNext, expand x(t) in a series up to second order in ϵ:\n\nusing Symbolics\n@variables y₀(t) y₁(t) y₂(t) # coefficients (y₀=0th order, y₁=1st, y₂=2nd)\nx_series = series([y₀, y₁, y₂], ϵ)\n\nInsert this into the equation and collect perturbed equations to each order:\n\neq_pert = substitute(eq, x => x_series)\neqs_pert = taylor_coeff(eq_pert, ϵ, 0:2)\n\nnote: Note\nThe 0-th order equation can be solved analytically, but ModelingToolkit does currently not feature automatic analytical solution of ODEs, so we proceed with solving it numerically.\n\nThese are the ODEs we want to solve. Now construct an System, which automatically inserts dummy derivatives for the velocities:\n\n@mtkcompile sys = System(eqs_pert, t)\n\nTo solve the System, we generate an ODEProblem with initial conditions x(0) = 0, and ẋ(0) = 1, and solve it:\n\nusing OrdinaryDiffEq\nu0 = Dict([unknowns(sys) .=> 0.0; D(y₀) => 1.0]) # nonzero initial velocity\nprob = ODEProblem(sys, u0, (0.0, 3.0))\nsol = solve(prob)\n\nThis is the solution for the coefficients in the series for x(t) and their derivatives. Finally, we calculate the solution to the original problem by summing the series for different ϵ:\n\nusing Plots\np = plot()\nfor ϵᵢ in 0.0:0.1:1.0\n    # Compute x(t) = y₀(t) + y₁(t)*ϵ + y₂(t)*ϵ² from solution values\n    xs = sol[y₀] .+ ϵᵢ .* sol[y₁] .+ ϵᵢ^2 .* sol[y₂]\n    plot!(p, sol.t, xs, label = \"ϵ = $ϵᵢ\")\nend\np\n\nThis makes sense: for larger ϵ, gravity weakens with altitude, and the trajectory goes higher for a fixed initial velocity.\n\nAn advantage of the perturbative method is that we run the ODE solver only once and calculate trajectories for several ϵ for free. Had we solved the full unperturbed ODE directly, we would need to do repeat it for every ϵ.","category":"section"},{"location":"examples/perturbation/#Weakly-nonlinear-oscillator","page":"Symbolic-Numeric Perturbation Theory for ODEs","title":"Weakly nonlinear oscillator","text":"Our second example applies perturbation theory to nonlinear oscillators – a very important class of problems. As we will see, perturbation theory has difficulty providing a good solution to this problem, but the process is nevertheless instructive. This example closely follows chapter 7.6 of Nonlinear Dynamics and Chaos by Steven Strogatz.\n\nThe goal is to solve the ODE\n\neq = D(D(x)) + 2 * ϵ * D(x) + x ~ 0\n\nwith initial conditions x(0) = 0 and ẋ(0) = 1. With ϵ = 0, the problem reduces to the simple linear harmonic oscillator with the exact solution x(t) = sin(t).\n\nWe follow the same steps as in the previous example to construct the System:\n\neq_pert = substitute(eq, x => x_series)\neqs_pert = taylor_coeff(eq_pert, ϵ, 0:2)\n@mtkcompile sys = System(eqs_pert, t)\n\nWe solve and plot it as in the previous example, and compare the solution with ϵ=01 to the exact solution x(t ϵ) = e^-ϵ t sin(sqrt(1-ϵ^2)t)  sqrt1-ϵ^2 of the unperturbed equation:\n\nu0 = [y₀ => 0.0, y₁ => 0.0, y₂ => 0.0, D(y₀) => 1.0, D(y₁) => 0.0, D(y₂) => 0.0] # nonzero initial velocity\nprob = ODEProblem(sys, u0, (0.0, 50.0))\nsol = solve(prob)\nplot(sol, idxs = substitute(x_series, ϵ => 0.1); label = \"Perturbative (ϵ=0.1)\")\n\nx_exact(t, ϵ) = exp(-ϵ * t) * sin(√(1 - ϵ^2) * t) / √(1 - ϵ^2)\nplot!(sol.t, x_exact.(sol.t, 0.1); label = \"Exact (ϵ=0.1)\")\n\nThis is similar to Figure 7.6.2 in Nonlinear Dynamics and Chaos. The two curves fit well for the first couple of cycles, but then the perturbative solution diverges from the exact solution. The main reason is that the problem has two or more time-scales that introduce secular terms in the solution. One solution is to explicitly account for the two time scales and use an analytic method called two-timing, but this is outside the scope of this example.","category":"section"},{"location":"#ModelingToolkit.jl:-High-Performance-Symbolic-Numeric-Equation-Based-Modeling","page":"Home","title":"ModelingToolkit.jl: High-Performance Symbolic-Numeric Equation-Based Modeling","text":"ModelingToolkit.jl is a modeling language for high-performance symbolic-numeric computation in scientific computing and scientific machine learning. It then mixes ideas from symbolic computational algebra systems with causal and acausal equation-based modeling frameworks to give an extendable and parallel modeling system. It allows for users to give a high-level description of a model for symbolic preprocessing to analyze and enhance the model. Automatic symbolic transformations, such as index reduction of differential-algebraic equations, make it possible to solve equations that are impossible to solve with a purely numeric-based technique.","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"To install ModelingToolkit.jl, use the Julia package manager:\n\nusing Pkg\nPkg.add(\"ModelingToolkit\")","category":"section"},{"location":"#Citation","page":"Home","title":"Citation","text":"If you use ModelingToolkit in your work, please cite the following:\n\n@misc{ma2021modelingtoolkit,\n      title={ModelingToolkit: A Composable Graph Transformation System For Equation-Based Modeling},\n      author={Yingbo Ma and Shashi Gowda and Ranjan Anantharaman and Chris Laughman and Viral Shah and Chris Rackauckas},\n      year={2021},\n      eprint={2103.05244},\n      archivePrefix={arXiv},\n      primaryClass={cs.MS}\n}","category":"section"},{"location":"#Feature-Summary","page":"Home","title":"Feature Summary","text":"danger: ModelingToolkit version 10\nModelingToolkit version 10 just released. Please refer to the changelog for a summary of the changes. Some documentation pages may be broken while downstram packages update to the new version.\n\nModelingToolkit.jl is a symbolic-numeric modeling package. Thus it combines some of the features from symbolic computing packages like SymPy or Mathematica with the ideas of equation-based modeling systems like the causal Simulink and the acausal Modelica. It bridges the gap between many different kinds of equations, allowing one to quickly and easily transform systems of DAEs into optimization problems, or vice-versa, and then simplify and parallelize the resulting expressions before generating code.","category":"section"},{"location":"#Feature-List","page":"Home","title":"Feature List","text":"Causal and acausal modeling (Simulink/Modelica)\nAutomated model transformation, simplification, and composition\nAutomatic conversion of numerical models into symbolic models\nComposition of models through the components, a lazy connection system, and tools for expanding/flattening\nPervasive parallelism in symbolic computations and generated functions\nTransformations like alias elimination and tearing of nonlinear systems for efficiently numerically handling large-scale systems of equations\nThe ability to use the entire Symbolics.jl Computer Algebra System (CAS) as part of the modeling process.\nImport models from common formats like SBML, CellML, BioNetGen, and more.\nExtensibility: the whole system is written in pure Julia, so adding new functions, simplification rules, and model transformations has no barrier.\n\nFor information on how to use the Symbolics.jl CAS system that ModelingToolkit.jl is built on, consult the Symbolics.jl documentation","category":"section"},{"location":"#Equation-Types","page":"Home","title":"Equation Types","text":"Ordinary differential equations\nStochastic differential equations\nPartial differential equations\nNonlinear systems\nOptimization problems\nContinuous-Time Markov Chains\nChemical Reactions (via Catalyst.jl)\nNonlinear Optimal Control","category":"section"},{"location":"#Standard-Library","page":"Home","title":"Standard Library","text":"For quick development, ModelingToolkit.jl includes ModelingToolkitStandardLibrary.jl, a standard library of prebuilt components for the ModelingToolkit ecosystem.","category":"section"},{"location":"#Model-Import-Formats","page":"Home","title":"Model Import Formats","text":"CellMLToolkit.jl: Import CellML models into ModelingToolkit\nRepository of more than a thousand pre-made models\nFocus on biomedical models in areas such as: Calcium Dynamics, Cardiovascular Circulation, Cell Cycle, Cell Migration, Circadian Rhythms, Electrophysiology, Endocrine, Excitation-Contraction Coupling, Gene Regulation, Hepatology, Immunology, Ion Transport, Mechanical Constitutive Laws, Metabolism, Myofilament Mechanics, Neurobiology, pH Regulation, PKPD, Protein Modules, Signal Transduction, and Synthetic Biology.\nSBMLToolkit.jl: Import SBML models into ModelingToolkit\nUses the robust libsbml library for parsing and transforming the SBML\nReactionNetworkImporters.jl: Import various models into ModelingToolkit\nSupports the BioNetGen .net file\nSupports importing networks specified by stoichiometric matrices","category":"section"},{"location":"#Extension-Libraries","page":"Home","title":"Extension Libraries","text":"Because ModelingToolkit.jl is the core foundation of an equation-based modeling ecosystem, there is a large set of libraries adding features to this system. Below is an incomplete list of extension libraries one may want to be aware of:\n\nCatalyst.jl: Symbolic representations of chemical reactions\nSymbolically build and represent large systems of chemical reactions\nGenerate code for ODEs, SDEs, continuous-time Markov Chains, and more\nSimulate the models using the SciML ecosystem with O(1) Gillespie methods\nDataDrivenDiffEq.jl: Automatic identification of equations from data\nAutomated construction of ODEs and DAEs from data\nRepresentations of Koopman operators and Dynamic Mode Decomposition (DMD)\nMomentClosure.jl: Automatic transformation of ReactionSystems into deterministic systems\nGenerates Systems for the moment closures\nAllows for geometrically-distributed random reaction rates\nReactionMechanismSimulator.jl: Simulating and analyzing large chemical reaction mechanisms\nIdeal gas and dilute liquid phases.\nConstant T and P and constant V adiabatic ideal gas reactors.\nConstant T and V dilute liquid reactors.\nDiffusion limited rates. Sensitivity analysis for all reactors.\nFlux diagrams with molecular images (if molecular information is provided).\nNumCME.jl: High-performance simulation of chemical master equations (CME)\nTransient solution of the CME\nDynamic state spaces\nAccepts reaction systems defined using Catalyst.jl DSL.\nFiniteStateProjection.jl: High-performance simulation of chemical master equations (CME) via finite state projections\nAccepts reaction systems defined using Catalyst.jl DSL.","category":"section"},{"location":"#Compatible-Numerical-Solvers","page":"Home","title":"Compatible Numerical Solvers","text":"All of the symbolic systems have a direct conversion to a numerical system, which can then be handled through the SciML interfaces. For example, after building a model and performing symbolic manipulations, a System can be converted into an ODEProblem to then be solved by a numerical ODE solver. Below is a list of the solver libraries which are the numerical targets of the ModelingToolkit system:\n\nDifferentialEquations.jl\nMulti-package interface of high performance numerical solvers for System, SDESystem, and JumpSystem\nNonlinearSolve.jl\nHigh performance numerical solving of NonlinearSystem\nOptimization.jl\nMulti-package interface for numerical solving OptimizationSystem\nNeuralPDE.jl\nPhysics-Informed Neural Network (PINN) training on PDESystem\nMethodOfLines.jl\nAutomated finite difference method (FDM) discretization of PDESystem","category":"section"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"Please refer to the SciML ColPrac: Contributor's Guide on Collaborative Practices for Community Packages for guidance on PRs, issues, and other matters relating to contributing to SciML.\nSee the SciML Style Guide for common coding practices and other style decisions.\nThere are a few community forums:\nThe #diffeq-bridged and #sciml-bridged channels in the Julia Slack\nThe #diffeq-bridged and #sciml-bridged channels in the Julia Zulip\nOn the Julia Discourse forums\nSee also SciML Community page","category":"section"},{"location":"#Reproducibility","page":"Home","title":"Reproducibility","text":"<details><summary>The documentation of this SciML package was built using these direct dependencies,</summary>\n\nusing Pkg # hide\nPkg.status() # hide\n\n</details>\n\n<details><summary>and using this machine and Julia version.</summary>\n\nusing InteractiveUtils # hide\nversioninfo() # hide\n\n</details>\n\n<details><summary>A more complete overview of all dependencies and their versions is also provided.</summary>\n\nusing Pkg # hide\nPkg.status(; mode = PKGMODE_MANIFEST) # hide\n\n</details>\n\nusing TOML\nusing Markdown\nversion = TOML.parse(read(\"../../Project.toml\", String))[\"version\"]\nname = TOML.parse(read(\"../../Project.toml\", String))[\"name\"]\nlink_manifest = \"https://github.com/SciML/\" * name * \".jl/tree/gh-pages/v\" * version *\n                \"/assets/Manifest.toml\"\nlink_project = \"https://github.com/SciML/\" * name * \".jl/tree/gh-pages/v\" * version *\n               \"/assets/Project.toml\"\nMarkdown.parse(\"\"\"You can also download the\n[manifest]($link_manifest)\nfile and the\n[project]($link_project)\nfile.\n\"\"\")","category":"section"},{"location":"API/System/#System_type","page":"The System type","title":"The System type","text":"ModelingToolkit.jl uses System to symbolically represent all types of numerical problems. Users create Systems representing the problem they want to solve and mtkcompile transforms them into a format ModelingToolkit.jl can generate code for (alongside performing other optimizations).","category":"section"},{"location":"API/System/#Utility-constructors","page":"The System type","title":"Utility constructors","text":"Several utility constructors also exist to easily construct alternative system formulations.","category":"section"},{"location":"API/System/#Accessor-functions","page":"The System type","title":"Accessor functions","text":"Several accessor functions exist to query systems for the information they contain. In general, for every field x there exists a has_x function which checks if the system contains the field and a get_x function for obtaining the value in the field. Note that fields of a system cannot be accessed via getproperty - that is reserved for accessing variables, subsystems or analysis points of the hierarchical system.","category":"section"},{"location":"API/System/#getproperty-syntax","page":"The System type","title":"getproperty syntax","text":"ModelingToolkit allows obtaining in a system using getproperty. For a system sys with a subcomponent inner containing variable var, sys.inner.var will obtain the appropriately namespaced version of var. Note that this can also be used to access subsystems (sys.inner) or analysis points.\n\nnote: Note\nBy default, top-level systems not marked as complete will apply their namespace. Systems marked as complete will not do this namespacing. This namespacing behavior can be toggled independently of whether the system is completed using toggle_namespacing and the current namespacing behavior can be queried via ModelingToolkit.does_namespacing.","category":"section"},{"location":"API/System/#Functions-for-querying-system-equations","page":"The System type","title":"Functions for querying system equations","text":"","category":"section"},{"location":"API/System/#String-parsing","page":"The System type","title":"String parsing","text":"ModelingToolkit can parse system variables from strings.","category":"section"},{"location":"API/System/#Dumping-system-data","page":"The System type","title":"Dumping system data","text":"","category":"section"},{"location":"API/System/#Inputs-and-outputs","page":"The System type","title":"Inputs and outputs","text":"","category":"section"},{"location":"API/System/#Debugging-utilities","page":"The System type","title":"Debugging utilities","text":"","category":"section"},{"location":"API/System/#Input-validation","page":"The System type","title":"Input validation","text":"The following values can be passed to the check keyword of System to toggle validation of input. Flags can be combined with bitwise | and &.\n\nThese can also be used by custom AbstractSystem subtypes.","category":"section"},{"location":"API/System/#Utility-functions","page":"The System type","title":"Utility functions","text":"These utility functions can be useful when manipulating systems, especially when building custom AbstractSystem subtypes.","category":"section"},{"location":"API/System/#Namespace-manipulation","page":"The System type","title":"Namespace manipulation","text":"ModelingToolkit namespaces variables from subsystems when using them in a parent system to disambiguate from identically named variables in other subsystems or the parent system. The following functions are useful for manipulating namespacing functionality.","category":"section"},{"location":"API/System/#Linearization-and-Analysis","page":"The System type","title":"Linearization and Analysis","text":"Functions for linearization and analysis of systems.","category":"section"},{"location":"API/System/#Additional-Equation-Classification","page":"The System type","title":"Additional Equation Classification","text":"","category":"section"},{"location":"API/System/#ModelingToolkit.linearization_ap_transform","page":"The System type","title":"ModelingToolkit.linearization_ap_transform","text":"sys, input_vars, output_vars =\n\nlinearization_ap_transform(\n    sys,\n    inputs::Union{Vector{Symbol}, Vector{AnalysisPoint}, Symbol, AnalysisPoint},\n    outputs,\n    loop_openings\n) -> Tuple{Any, Vector{SymbolicUtils.BasicSymbolicImpl.var\"typeof(BasicSymbolicImpl)\"{SymReal}}, Vector{SymbolicUtils.BasicSymbolicImpl.var\"typeof(BasicSymbolicImpl)\"{SymReal}}}\n\n\nApply analysis-point transformations to prepare a system for linearization.\n\nReturns\n\nsys: The transformed system.\ninput_vars: A vector of input variables corresponding to the input analysis points.\noutput_vars: A vector of output variables corresponding to the output analysis points.\n\n\n\n\n\n","category":"function"},{"location":"API/System/#ModelingToolkit.get_sensitivity_function","page":"The System type","title":"ModelingToolkit.get_sensitivity_function","text":"get_sensitivity_function(\n    sys::ModelingToolkitBase.AbstractSystem,\n    aps;\n    kwargs...\n) -> Tuple{ModelingToolkit.LinearizationFunction{Vector{Int64}, Vector{Int64}, Vector{SymbolicUtils.BasicSymbolicImpl.var\"typeof(BasicSymbolicImpl)\"{SymReal}}, P, _A, _B, J1, J2, J3, J4, IA, @NamedTuple{abstol::Float64, reltol::Float64, nlsolve_alg::Nothing}} where {P<:ODEProblem, _A, _B, J1<:Union{Nothing, ModelingToolkit.PreparedJacobian{true, DifferentiationInterfaceForwardDiffExt.ForwardDiffTwoArgJacobianPrep{Nothing, C, Tuple{Nothing, Nothing}}, ModelingToolkit.var\"#uff#6\"{var\"#64#fun\"}, _A, ADTypes.AutoForwardDiff{nothing, Nothing}} where {C<:(ForwardDiff.JacobianConfig{T, _A, _B, <:Tuple{Any, Any}} where {T<:(ForwardDiff.Tag{F} where F<:ModelingToolkit.var\"#uff#6\"), _A, _B}), var\"#64#fun\", _A}}, J2<:Union{Nothing, ModelingToolkit.PreparedJacobian{true, DifferentiationInterfaceForwardDiffExt.ForwardDiffTwoArgJacobianPrep{Nothing, C, Tuple{Nothing, Nothing}}, _A, _B, ADTypes.AutoForwardDiff{nothing, Nothing}} where {C<:ForwardDiff.JacobianConfig, _A, _B}}, J3<:Union{Nothing, ModelingToolkit.PreparedJacobian{true, DifferentiationInterfaceForwardDiffExt.ForwardDiffTwoArgJacobianPrep{Nothing, C, Tuple{Nothing, Nothing, Nothing}}, ModelingToolkit.var\"#pff#7\"{var\"#65#fun\", var\"#66#setter\"}, _A, ADTypes.AutoForwardDiff{nothing, Nothing}} where {C<:(ForwardDiff.JacobianConfig{T, _A, _B, <:Tuple{Any, Vector{T} where T<:(ForwardDiff.Dual{T, _A, _B} where {_B, _A, T})}} where {T<:(ForwardDiff.Tag{F} where F<:(ModelingToolkit.var\"#pff#7\"{_A, SymbolicIndexingInterface.OOPSetter{_A1, System, var\"#s177\"}} where {_A, _A1, T, var\"#s177\"<:AbstractVector{T}})), _A, _B}), var\"#65#fun\", var\"#66#setter\", _A}}, J4<:(ModelingToolkit.PreparedJacobian{true, DifferentiationInterfaceForwardDiffExt.ForwardDiffTwoArgJacobianPrep{Nothing, C, Tuple{Nothing, Nothing, Nothing}}, ModelingToolkit.var\"#hpf#5\"{fun, setter}, _A, ADTypes.AutoForwardDiff{nothing, Nothing}} where {C<:(ForwardDiff.JacobianConfig{T, _A, _B, <:Tuple{Any, Vector{T} where T<:(ForwardDiff.Dual{T, _A, _B} where {_B, _A, T<:(ForwardDiff.Tag{F} where F<:(ModelingToolkit.var\"#hpf#5\"{_A, SymbolicIndexingInterface.OOPSetter{_A1, System, var\"#s177\"}} where {_A, _A1, T, var\"#s177\"<:AbstractVector{T}}))})}} where {T<:(ForwardDiff.Tag{F} where F<:(ModelingToolkit.var\"#hpf#5\"{_A, SymbolicIndexingInterface.OOPSetter{_A1, System, var\"#s177\"}} where {_A, _A1, T, var\"#s177\"<:AbstractVector{T}})), _A, _B}), fun, setter, _A}), IA<:Union{SciMLBase.NoInit, SciMLBase.OverrideInit{Nothing, Nothing, Nothing}}}, System}\n\n\nReturn the sensitivity function for the analysis point(s) aps, and the modified system simplified with the appropriate inputs and outputs.\n\nKeyword Arguments\n\nloop_openings: A list of analysis points whose connections should be removed and the outputs set to the input as a part of the linear analysis.\nsystem_modifier: A function taking the transformed system and applying any additional transformations, returning the modified system. The modified system is passed to linearization_function. \n\nAll other keyword arguments are forwarded to linearization_function.\n\n\n\n\n\n","category":"function"},{"location":"API/System/#ModelingToolkit.get_comp_sensitivity_function","page":"The System type","title":"ModelingToolkit.get_comp_sensitivity_function","text":"get_comp_sensitivity_function(\n    sys::ModelingToolkitBase.AbstractSystem,\n    aps;\n    kwargs...\n) -> Tuple{ModelingToolkit.LinearizationFunction{Vector{Int64}, Vector{Int64}, Vector{SymbolicUtils.BasicSymbolicImpl.var\"typeof(BasicSymbolicImpl)\"{SymReal}}, P, _A, _B, J1, J2, J3, J4, IA, @NamedTuple{abstol::Float64, reltol::Float64, nlsolve_alg::Nothing}} where {P<:ODEProblem, _A, _B, J1<:Union{Nothing, ModelingToolkit.PreparedJacobian{true, DifferentiationInterfaceForwardDiffExt.ForwardDiffTwoArgJacobianPrep{Nothing, C, Tuple{Nothing, Nothing}}, ModelingToolkit.var\"#uff#6\"{var\"#64#fun\"}, _A, ADTypes.AutoForwardDiff{nothing, Nothing}} where {C<:(ForwardDiff.JacobianConfig{T, _A, _B, <:Tuple{Any, Any}} where {T<:(ForwardDiff.Tag{F} where F<:ModelingToolkit.var\"#uff#6\"), _A, _B}), var\"#64#fun\", _A}}, J2<:Union{Nothing, ModelingToolkit.PreparedJacobian{true, DifferentiationInterfaceForwardDiffExt.ForwardDiffTwoArgJacobianPrep{Nothing, C, Tuple{Nothing, Nothing}}, _A, _B, ADTypes.AutoForwardDiff{nothing, Nothing}} where {C<:ForwardDiff.JacobianConfig, _A, _B}}, J3<:Union{Nothing, ModelingToolkit.PreparedJacobian{true, DifferentiationInterfaceForwardDiffExt.ForwardDiffTwoArgJacobianPrep{Nothing, C, Tuple{Nothing, Nothing, Nothing}}, ModelingToolkit.var\"#pff#7\"{var\"#65#fun\", var\"#66#setter\"}, _A, ADTypes.AutoForwardDiff{nothing, Nothing}} where {C<:(ForwardDiff.JacobianConfig{T, _A, _B, <:Tuple{Any, Vector{T} where T<:(ForwardDiff.Dual{T, _A, _B} where {_B, _A, T})}} where {T<:(ForwardDiff.Tag{F} where F<:(ModelingToolkit.var\"#pff#7\"{_A, SymbolicIndexingInterface.OOPSetter{_A1, System, var\"#s177\"}} where {_A, _A1, T, var\"#s177\"<:AbstractVector{T}})), _A, _B}), var\"#65#fun\", var\"#66#setter\", _A}}, J4<:(ModelingToolkit.PreparedJacobian{true, DifferentiationInterfaceForwardDiffExt.ForwardDiffTwoArgJacobianPrep{Nothing, C, Tuple{Nothing, Nothing, Nothing}}, ModelingToolkit.var\"#hpf#5\"{fun, setter}, _A, ADTypes.AutoForwardDiff{nothing, Nothing}} where {C<:(ForwardDiff.JacobianConfig{T, _A, _B, <:Tuple{Any, Vector{T} where T<:(ForwardDiff.Dual{T, _A, _B} where {_B, _A, T<:(ForwardDiff.Tag{F} where F<:(ModelingToolkit.var\"#hpf#5\"{_A, SymbolicIndexingInterface.OOPSetter{_A1, System, var\"#s177\"}} where {_A, _A1, T, var\"#s177\"<:AbstractVector{T}}))})}} where {T<:(ForwardDiff.Tag{F} where F<:(ModelingToolkit.var\"#hpf#5\"{_A, SymbolicIndexingInterface.OOPSetter{_A1, System, var\"#s177\"}} where {_A, _A1, T, var\"#s177\"<:AbstractVector{T}})), _A, _B}), fun, setter, _A}), IA<:Union{SciMLBase.NoInit, SciMLBase.OverrideInit{Nothing, Nothing, Nothing}}}, System}\n\n\nReturn the complementary sensitivity function for the analysis point(s) aps, and the modified system simplified with the appropriate inputs and outputs.\n\nKeyword Arguments\n\nloop_openings: A list of analysis points whose connections should be removed and the outputs set to the input as a part of the linear analysis.\nsystem_modifier: A function taking the transformed system and applying any additional transformations, returning the modified system. The modified system is passed to linearization_function. \n\nAll other keyword arguments are forwarded to linearization_function.\n\n\n\n\n\n","category":"function"},{"location":"API/System/#ModelingToolkit.get_looptransfer_function","page":"The System type","title":"ModelingToolkit.get_looptransfer_function","text":"get_looptransfer_function(\n    sys::ModelingToolkitBase.AbstractSystem,\n    aps;\n    kwargs...\n) -> Tuple{ModelingToolkit.LinearizationFunction{Vector{Int64}, Vector{Int64}, Vector{SymbolicUtils.BasicSymbolicImpl.var\"typeof(BasicSymbolicImpl)\"{SymReal}}, P, _A, _B, J1, J2, J3, J4, IA, @NamedTuple{abstol::Float64, reltol::Float64, nlsolve_alg::Nothing}} where {P<:ODEProblem, _A, _B, J1<:Union{Nothing, ModelingToolkit.PreparedJacobian{true, DifferentiationInterfaceForwardDiffExt.ForwardDiffTwoArgJacobianPrep{Nothing, C, Tuple{Nothing, Nothing}}, ModelingToolkit.var\"#uff#6\"{var\"#64#fun\"}, _A, ADTypes.AutoForwardDiff{nothing, Nothing}} where {C<:(ForwardDiff.JacobianConfig{T, _A, _B, <:Tuple{Any, Any}} where {T<:(ForwardDiff.Tag{F} where F<:ModelingToolkit.var\"#uff#6\"), _A, _B}), var\"#64#fun\", _A}}, J2<:Union{Nothing, ModelingToolkit.PreparedJacobian{true, DifferentiationInterfaceForwardDiffExt.ForwardDiffTwoArgJacobianPrep{Nothing, C, Tuple{Nothing, Nothing}}, _A, _B, ADTypes.AutoForwardDiff{nothing, Nothing}} where {C<:ForwardDiff.JacobianConfig, _A, _B}}, J3<:Union{Nothing, ModelingToolkit.PreparedJacobian{true, DifferentiationInterfaceForwardDiffExt.ForwardDiffTwoArgJacobianPrep{Nothing, C, Tuple{Nothing, Nothing, Nothing}}, ModelingToolkit.var\"#pff#7\"{var\"#65#fun\", var\"#66#setter\"}, _A, ADTypes.AutoForwardDiff{nothing, Nothing}} where {C<:(ForwardDiff.JacobianConfig{T, _A, _B, <:Tuple{Any, Vector{T} where T<:(ForwardDiff.Dual{T, _A, _B} where {_B, _A, T})}} where {T<:(ForwardDiff.Tag{F} where F<:(ModelingToolkit.var\"#pff#7\"{_A, SymbolicIndexingInterface.OOPSetter{_A1, System, var\"#s177\"}} where {_A, _A1, T, var\"#s177\"<:AbstractVector{T}})), _A, _B}), var\"#65#fun\", var\"#66#setter\", _A}}, J4<:(ModelingToolkit.PreparedJacobian{true, DifferentiationInterfaceForwardDiffExt.ForwardDiffTwoArgJacobianPrep{Nothing, C, Tuple{Nothing, Nothing, Nothing}}, ModelingToolkit.var\"#hpf#5\"{fun, setter}, _A, ADTypes.AutoForwardDiff{nothing, Nothing}} where {C<:(ForwardDiff.JacobianConfig{T, _A, _B, <:Tuple{Any, Vector{T} where T<:(ForwardDiff.Dual{T, _A, _B} where {_B, _A, T<:(ForwardDiff.Tag{F} where F<:(ModelingToolkit.var\"#hpf#5\"{_A, SymbolicIndexingInterface.OOPSetter{_A1, System, var\"#s177\"}} where {_A, _A1, T, var\"#s177\"<:AbstractVector{T}}))})}} where {T<:(ForwardDiff.Tag{F} where F<:(ModelingToolkit.var\"#hpf#5\"{_A, SymbolicIndexingInterface.OOPSetter{_A1, System, var\"#s177\"}} where {_A, _A1, T, var\"#s177\"<:AbstractVector{T}})), _A, _B}), fun, setter, _A}), IA<:Union{SciMLBase.NoInit, SciMLBase.OverrideInit{Nothing, Nothing, Nothing}}}, System}\n\n\nReturn the loop-transfer function for the analysis point(s) aps, and the modified system simplified with the appropriate inputs and outputs.\n\nKeyword Arguments\n\nloop_openings: A list of analysis points whose connections should be removed and the outputs set to the input as a part of the linear analysis.\nsystem_modifier: A function taking the transformed system and applying any additional transformations, returning the modified system. The modified system is passed to linearization_function. \n\nAll other keyword arguments are forwarded to linearization_function.\n\n\n\n\n\n","category":"function"},{"location":"API/System/#ModelingToolkit.get_sensitivity","page":"The System type","title":"ModelingToolkit.get_sensitivity","text":"get_sensitivity(sys, ap::AnalysisPoint; kwargs)\nget_sensitivity(sys, ap_name::Symbol; kwargs)\n\nCompute the sensitivity function in analysis point ap. The sensitivity function is obtained by introducing an infinitesimal perturbation d at the input of ap, linearizing the system and computing the transfer function between d and the output of ap.\n\nArguments:\n\nkwargs: Are sent to ModelingToolkit.linearize\n\nSee also get_comp_sensitivity, get_looptransfer.\n\n\n\n\n\n","category":"function"},{"location":"API/System/#ModelingToolkit.get_comp_sensitivity","page":"The System type","title":"ModelingToolkit.get_comp_sensitivity","text":"get_comp_sensitivity(sys, ap::AnalysisPoint; kwargs)\nget_comp_sensitivity(sys, ap_name::Symbol; kwargs)\n\nCompute the complementary sensitivity function in analysis point ap. The complementary sensitivity function is obtained by introducing an infinitesimal perturbation d at the output of ap, linearizing the system and computing the transfer function between d and the input of ap.\n\nArguments:\n\nkwargs: Are sent to ModelingToolkit.linearize\n\nSee also get_sensitivity, get_looptransfer.\n\n\n\n\n\n","category":"function"},{"location":"API/System/#ModelingToolkit.get_looptransfer","page":"The System type","title":"ModelingToolkit.get_looptransfer","text":"get_looptransfer(sys, ap::AnalysisPoint; kwargs)\nget_looptransfer(sys, ap_name::Symbol; kwargs)\n\nCompute the (linearized) loop-transfer function in analysis point ap, from ap.out to ap.in.\n\ninfo: Negative feedback\nFeedback loops often use negative feedback, and the computed loop-transfer function will in this case have the negative feedback included. Standard analysis tools often assume a loop-transfer function without the negative gain built in, and the result of this function may thus need negation before use.\n\nArguments:\n\nkwargs: Are sent to ModelingToolkit.linearize\n\nSee also get_sensitivity, get_comp_sensitivity, open_loop.\n\n\n\n\n\n","category":"function"},{"location":"tutorials/programmatically_generating/#programmatically","page":"Programmatically Generating and Scripting Systems","title":"Programmatically Generating and Scripting Systems","text":"In the following tutorial, we will discuss how to programmatically generate Systems. This is useful for functions that generate Systems, for example when you implement a reader that parses some file format, such as SBML, to generate an System. It is also useful for functions that transform an System, for example when you write a function that log-transforms a variable in an System.","category":"section"},{"location":"tutorials/programmatically_generating/#The-Representation-of-a-ModelingToolkit-System","page":"Programmatically Generating and Scripting Systems","title":"The Representation of a ModelingToolkit System","text":"ModelingToolkit is built on Symbolics.jl, a symbolic Computer Algebra System (CAS) developed in Julia. As such, all CAS functionality is also available to be used on ModelingToolkit systems, such as symbolic differentiation, Groebner basis calculations, and whatever else you can think of. Under the hood, all ModelingToolkit variables and expressions are Symbolics.jl variables and expressions. Thus when scripting a ModelingToolkit system, one simply needs to generate Symbolics.jl variables and equations as demonstrated in the Symbolics.jl documentation. This looks like:\n\nusing ModelingToolkit # reexports Symbolics\n@independent_variables t\n@variables x(t) y(t) # Define variables\nD = Differential(t)\neqs = [D(x) ~ y\n       D(y) ~ x] # Define an array of equations\n\nHowever, ModelingToolkit has many higher-level features which will make scripting ModelingToolkit systems more convenient. For example, as shown in the next section, defining your own independent variables and differentials is rarely needed.","category":"section"},{"location":"tutorials/programmatically_generating/#The-Non-DSL-(non-@mtkmodel)-Way-of-Defining-an-System","page":"Programmatically Generating and Scripting Systems","title":"The Non-DSL (non-@mtkmodel) Way of Defining an System","text":"Using @mtkmodel, like in the getting started tutorial, is the preferred way of defining ODEs with MTK. However generating the contents of a @mtkmodel programmatically can be tedious. Let us look at how we can define the same system without @mtkmodel.\n\nusing ModelingToolkit\nusing ModelingToolkit: t_nounits as t, D_nounits as D\n@variables x(t) = 0.0  # independent and dependent variables\n@parameters τ = 3.0       # parameters\n@constants h = 1    # constants\neqs = [D(x) ~ (h - x) / τ] # create an array of equations\n\n# your first ODE, consisting of a single equation, indicated by ~\n@named model = System(eqs, t)\n\n# Perform the standard transformations and mark the model complete\n# Note: Complete models cannot be subsystems of other models!\nfol = mtkcompile(model)\nprob = ODEProblem(fol, [], (0.0, 10.0))\nusing OrdinaryDiffEq\nsol = solve(prob)\n\nusing Plots\nplot(sol)\n\nAs you can see, generating an System is as simple as creating an array of equations and passing it to the System constructor.\n\n@named automatically gives a name to the System, and is shorthand for\n\nfol_model = System(eqs, t; name = :fol_model) # @named fol_model = System(eqs, t)\n\nThus, if we had read a name from a file and wish to populate an System with said name, we could do:\n\nnamesym = :name_from_file\nfol_model = System(eqs, t; name = namesym)","category":"section"},{"location":"tutorials/programmatically_generating/#Warning-About-Mutation","page":"Programmatically Generating and Scripting Systems","title":"Warning About Mutation","text":"Be advsied that it's never a good idea to mutate an System, or any AbstractSystem.","category":"section"},{"location":"internals/structural_transformation/#Structural-Transformation","page":"Structural Transformation","title":"Structural Transformation","text":"warning: Internal API\nThe functions documented on this page are internal implementation details of ModelingToolkit. They are not part of the public API and may change or be removed without notice in non-breaking releases. This documentation is provided to help contributors understand the codebase.\n\nThese functions are used for structural analysis and transformation of equation systems, including index reduction, tearing, and other algebraic manipulations used in the simplification process.","category":"section"},{"location":"internals/structural_transformation/#Tearing-and-Algebraic-Simplification","page":"Structural Transformation","title":"Tearing and Algebraic Simplification","text":"","category":"section"},{"location":"internals/structural_transformation/#Index-Reduction","page":"Structural Transformation","title":"Index Reduction","text":"","category":"section"},{"location":"internals/structural_transformation/#Consistency-Checking","page":"Structural Transformation","title":"Consistency Checking","text":"","category":"section"},{"location":"internals/structural_transformation/#Incidence-Matrix-Operations","page":"Structural Transformation","title":"Incidence Matrix Operations","text":"","category":"section"},{"location":"internals/structural_transformation/#Variable-Ordering-and-Masks","page":"Structural Transformation","title":"Variable Ordering and Masks","text":"","category":"section"},{"location":"internals/structural_transformation/#Shift-Operations","page":"Structural Transformation","title":"Shift Operations","text":"These functions handle shift operations in discrete-time systems.","category":"section"},{"location":"internals/structural_transformation/#System-Structure-Types-and-Functions","page":"Structural Transformation","title":"System Structure Types and Functions","text":"","category":"section"},{"location":"internals/structural_transformation/#Graph-Types","page":"Structural Transformation","title":"Graph Types","text":"","category":"section"},{"location":"internals/structural_transformation/#ModelingToolkit.StructuralTransformations.tearing","page":"Structural Transformation","title":"ModelingToolkit.StructuralTransformations.tearing","text":"tearing(sys)\n\nTear the nonlinear equations in system. When simplify=true, we simplify the new residual equations after tearing. End users are encouraged to call mtkcompile instead, which calls this function internally.\n\n\n\n\n\n","category":"function"},{"location":"internals/structural_transformation/#ModelingToolkit.StructuralTransformations.dae_index_lowering","page":"Structural Transformation","title":"ModelingToolkit.StructuralTransformations.dae_index_lowering","text":"dae_index_lowering(sys::System; kwargs...) -> System\n\nPerform the Pantelides algorithm to transform a higher index DAE to an index 1 DAE. kwargs are forwarded to pantelides!. End users are encouraged to call mtkcompile instead, which calls this function internally.\n\n\n\n\n\n","category":"function"},{"location":"internals/structural_transformation/#ModelingToolkit.StructuralTransformations.dummy_derivative","page":"Structural Transformation","title":"ModelingToolkit.StructuralTransformations.dummy_derivative","text":"dummy_derivative(sys)\n\nPerform index reduction and use the dummy derivative technique to ensure that the system is balanced.\n\n\n\n\n\n","category":"function"},{"location":"internals/structural_transformation/#ModelingToolkit.StructuralTransformations.sorted_incidence_matrix","page":"Structural Transformation","title":"ModelingToolkit.StructuralTransformations.sorted_incidence_matrix","text":"sorted_incidence_matrix(\n    sys::ModelingToolkitBase.AbstractSystem\n) -> Any\n\n\nObtain the incidence matrix of the system sorted by the SCCs. Requires that the system is simplified and has a schedule.\n\n\n\n\n\n","category":"function"},{"location":"API/codegen/#Code-generation-utilities","page":"Code generation utilities","title":"Code generation utilities","text":"These are lower-level functions that ModelingToolkit leverages to generate code for building numerical problems.\n\nFor functions such as jacobian calculation which require symbolic computation, there are calculate_* equivalents to obtain the symbolic result without building a function.\n\nAll code generation eventually calls build_function_wrapper.","category":"section"},{"location":"API/codegen/#ModelingToolkit.generate_semiquadratic_functions","page":"Code generation utilities","title":"ModelingToolkit.generate_semiquadratic_functions","text":"generate_semiquadratic_functions(\n    sys::System,\n    A,\n    B,\n    C;\n    stiff_linear,\n    stiff_quadratic,\n    stiff_nonlinear,\n    expression,\n    wrap_gfw,\n    eval_expression,\n    eval_module,\n    kwargs...\n) -> Tuple{Tuple{Expr, Expr}, Tuple{Expr, Expr}}\n\n\nGenerate f1 and f2 for SemilinearODEFunction (internally represented as a SplitFunction). A, B, C are the matrices returned from calculate_semiquadratic_form. This expects that the system has the necessary extra parmameters added by add_semiquadratic_parameters.\n\nKeyword Arguments\n\nstiff_linear: Whether the linear part of the equations should be part of the stiff function in the split form. Has no effect if the equations have no linear part.\nstiff_quadratic: Whether the quadratic part of the equations should be part of the stiff function in the split form. Has no effect if the equations have no quadratic part.\nstiff_nonlinear: Whether the non-linear non-quadratic part of the equations should be part of the stiff function in the split form. Has no effect if the equations have no such non-linear non-quadratic part.\nexpression: Val{true} if this should return an Expr (or tuple of Exprs) of the generated code. Val{false} otherwise.\nwrap_gfw: Val{true} if the returned functions should be wrapped in a callable struct to make them callable using the expected syntax. The callable struct itself is internal API. If expression == Val{true}, the returned expression will construct the callable struct. If this function returns a tuple of functions/expressions, both will be identical if wrap_gfw == Val{true}.\neval_expression: Whether to compile any functions via eval or RuntimeGeneratedFunctions.\neval_module: If eval_expression == true, the module to eval into. Otherwise, the module in which to generate the RuntimeGeneratedFunction.\n\nAll other keyword arguments are forwarded to build_function_wrapper. Note that all three of stiff_linear, stiff_quadratic, stiff_nonlinear cannot be identical, and at least two of A, B, C returned from calculate_semiquadratic_form must be non-nothing. In other words, both of the functions in the split form must be non-empty.\n\nwarn: Warn\nThis API is experimental and may change in a future non-breaking release.\n\n\n\n\n\n","category":"function"},{"location":"API/codegen/#ModelingToolkit.generate_semiquadratic_jacobian","page":"Code generation utilities","title":"ModelingToolkit.generate_semiquadratic_jacobian","text":"generate_semiquadratic_jacobian(\n    sys::System,\n    A,\n    B,\n    C,\n    Cjac;\n    sparse,\n    stiff_linear,\n    stiff_quadratic,\n    stiff_nonlinear,\n    expression,\n    wrap_gfw,\n    eval_expression,\n    eval_module,\n    kwargs...\n) -> Tuple{Expr, Expr}\n\n\nGenerate the jacobian of f1 for SemilinearODEFunction (internally represented as a SplitFunction). A, B, C are the matrices returned from calculate_semiquadratic_form. Cjac is the jacobian of C with respect to the unknowns of the system, or nothing if C === nothing. This expects that the system has the necessary extra parmameters added by add_semiquadratic_parameters.\n\nKeyword Arguments\n\nstiff_linear: Whether the linear part of the equations should be part of the stiff function in the split form. Has no effect if the equations have no linear part.\nstiff_quadratic: Whether the quadratic part of the equations should be part of the stiff function in the split form. Has no effect if the equations have no quadratic part.\nstiff_nonlinear: Whether the non-linear non-quadratic part of the equations should be part of the stiff function in the split form. Has no effect if the equations have no such non-linear non-quadratic part.\nexpression: Val{true} if this should return an Expr (or tuple of Exprs) of the generated code. Val{false} otherwise.\nwrap_gfw: Val{true} if the returned functions should be wrapped in a callable struct to make them callable using the expected syntax. The callable struct itself is internal API. If expression == Val{true}, the returned expression will construct the callable struct. If this function returns a tuple of functions/expressions, both will be identical if wrap_gfw == Val{true}.\neval_expression: Whether to compile any functions via eval or RuntimeGeneratedFunctions.\neval_module: If eval_expression == true, the module to eval into. Otherwise, the module in which to generate the RuntimeGeneratedFunction.\n\nAll other keyword arguments are forwarded to build_function_wrapper. Note that all three of stiff_linear, stiff_quadratic, stiff_nonlinear cannot be identical, and at least two of A, B, C returned from calculate_semiquadratic_form must be non-nothing. In other words, both of the functions in the split form must be non-empty.\n\nwarn: Warn\nThis API is experimental and may change in a future non-breaking release.\n\n\n\n\n\n","category":"function"},{"location":"API/codegen/#ModelingToolkit.get_semiquadratic_W_sparsity","page":"Code generation utilities","title":"ModelingToolkit.get_semiquadratic_W_sparsity","text":"get_semiquadratic_W_sparsity(\n    sys::System,\n    A,\n    B,\n    C,\n    Cjac;\n    stiff_linear,\n    stiff_quadratic,\n    stiff_nonlinear,\n    mm\n) -> SparseArrays.SparseMatrixCSC{Bool, Int64}\n\n\nReturn the sparsity pattern of the  jacobian of f1 for SemilinearODEFunction (internally represented as a SplitFunction). A, B, C are the matrices returned from calculate_semiquadratic_form. Cjac is the jacobian of C with respect to the unknowns of the system, or nothing if C === nothing. This expects that the system has the necessary extra parmameters added by add_semiquadratic_parameters.\n\nKeyword Arguments\n\nstiff_linear: Whether the linear part of the equations should be part of the stiff function in the split form. Has no effect if the equations have no linear part.\nstiff_quadratic: Whether the quadratic part of the equations should be part of the stiff function in the split form. Has no effect if the equations have no quadratic part.\nstiff_nonlinear: Whether the non-linear non-quadratic part of the equations should be part of the stiff function in the split form. Has no effect if the equations have no such non-linear non-quadratic part.\nexpression: Val{true} if this should return an Expr (or tuple of Exprs) of the generated code. Val{false} otherwise.\nwrap_gfw: Val{true} if the returned functions should be wrapped in a callable struct to make them callable using the expected syntax. The callable struct itself is internal API. If expression == Val{true}, the returned expression will construct the callable struct. If this function returns a tuple of functions/expressions, both will be identical if wrap_gfw == Val{true}.\neval_expression: Whether to compile any functions via eval or RuntimeGeneratedFunctions.\neval_module: If eval_expression == true, the module to eval into. Otherwise, the module in which to generate the RuntimeGeneratedFunction.\n\nmm: The mass matrix of sys.\n\nNote that all three of stiff_linear, stiff_quadratic, stiff_nonlinear cannot be identical, and at least two of A, B, C returned from calculate_semiquadratic_form must be non-nothing. In other words, both of the functions in the split form must be non-empty.\n\nwarn: Warn\nThis API is experimental and may change in a future non-breaking release.\n\n\n\n\n\n","category":"function"},{"location":"examples/tearing_parallelism/#Exposing-More-Parallelism-By-Tearing-Algebraic-Equations-in-Systems","page":"Exposing More Parallelism By Tearing Algebraic Equations in Systems","title":"Exposing More Parallelism By Tearing Algebraic Equations in Systems","text":"Sometimes it can be very non-trivial to parallelize a system. In this tutorial, we will demonstrate how to make use of mtkcompile to expose more parallelism in the solution process and parallelize the resulting simulation.","category":"section"},{"location":"examples/tearing_parallelism/#The-Component-Library","page":"Exposing More Parallelism By Tearing Algebraic Equations in Systems","title":"The Component Library","text":"The following tutorial will use the following set of components describing electrical circuits:\n\nusing ModelingToolkit, OrdinaryDiffEq\nusing ModelingToolkit: t_nounits as t, D_nounits as D\n\n# Basic electric components\n@connector function Pin(; name)\n    @variables v(t)=1.0 i(t)=1.0 [connect=Flow]\n    System(Equation[], t, [v, i], [], name = name)\nend\n\nfunction Ground(; name)\n    @named g = Pin()\n    eqs = [g.v ~ 0]\n    compose(System(eqs, t, [], [], name = name), g)\nend\n\nfunction ConstantVoltage(; name, V = 1.0)\n    val = V\n    @named p = Pin()\n    @named n = Pin()\n    @parameters V = V\n    eqs = [V ~ p.v - n.v\n           0 ~ p.i + n.i]\n    compose(System(eqs, t, [], [V], name = name), p, n)\nend\n\n@connector function HeatPort(; name)\n    @variables T(t)=293.15 Q_flow(t)=0.0 [connect=Flow]\n    System(Equation[], t, [T, Q_flow], [], name = name)\nend\n\nfunction HeatingResistor(; name, R = 1.0, TAmbient = 293.15, alpha = 1.0)\n    @named p = Pin()\n    @named n = Pin()\n    @named h = HeatPort()\n    @variables v(t) RTherm(t)\n    @parameters R=R TAmbient=TAmbient alpha=alpha\n    eqs = [RTherm ~ R * (1 + alpha * (h.T - TAmbient))\n           v ~ p.i * RTherm\n           h.Q_flow ~ -v * p.i # -LossPower\n           v ~ p.v - n.v\n           0 ~ p.i + n.i]\n    compose(System(eqs, t, [v, RTherm], [R, TAmbient, alpha],\n            name = name), p, n, h)\nend\n\nfunction HeatCapacitor(; name, rho = 8050, V = 1, cp = 460, TAmbient = 293.15)\n    @parameters rho=rho V=V cp=cp\n    C = rho * V * cp\n    @named h = HeatPort()\n    eqs = [\n        D(h.T) ~ h.Q_flow / C\n    ]\n    compose(System(eqs, t, [], [rho, V, cp],\n            name = name), h)\nend\n\nfunction Capacitor(; name, C = 1.0)\n    @named p = Pin()\n    @named n = Pin()\n    @variables v(t) = 0.0\n    @parameters C = C\n    eqs = [v ~ p.v - n.v\n           0 ~ p.i + n.i\n           D(v) ~ p.i / C]\n    compose(System(eqs, t, [v], [C],\n            name = name), p, n)\nend\n\nfunction parallel_rc_model(i; name, source, ground, R, C)\n    resistor = HeatingResistor(name = Symbol(:resistor, i), R = R)\n    capacitor = Capacitor(name = Symbol(:capacitor, i), C = C)\n    heat_capacitor = HeatCapacitor(name = Symbol(:heat_capacitor, i))\n\n    rc_eqs = [connect(source.p, resistor.p)\n              connect(resistor.n, capacitor.p)\n              connect(capacitor.n, source.n, ground.g)\n              connect(resistor.h, heat_capacitor.h)]\n\n    compose(System(rc_eqs, t, name = Symbol(name, i)),\n        [resistor, capacitor, source, ground, heat_capacitor])\nend","category":"section"},{"location":"examples/tearing_parallelism/#The-Model","page":"Exposing More Parallelism By Tearing Algebraic Equations in Systems","title":"The Model","text":"Assuming that the components are defined, our model is 50 resistors and capacitors connected in parallel. Thus following the acausal components tutorial, we can connect a bunch of RC components as follows:\n\nV = 2.0\n@named source = ConstantVoltage(V = V)\n@named ground = Ground()\nN = 50\nRs = 10 .^ range(0, stop = -4, length = N)\nCs = 10 .^ range(-3, stop = 0, length = N)\nrc_systems = map(1:N) do i\n    parallel_rc_model(i; name = :rc, source = source, ground = ground, R = Rs[i], C = Cs[i])\nend;\n@variables E(t) = 0.0\neqs = [\n    D(E) ~ sum(((i, sys),) -> getproperty(sys, Symbol(:resistor, i)).h.Q_flow,\n    enumerate(rc_systems))\n]\n@named _big_rc = System(eqs, t, [E], [])\n@named big_rc = compose(_big_rc, rc_systems)\n\nNow let's say we want to expose a bit more parallelism via running tearing. How do we do that?\n\nsys = mtkcompile(big_rc)\n\nDone, that's it. There's no more to it.","category":"section"},{"location":"examples/tearing_parallelism/#What-Happened?","page":"Exposing More Parallelism By Tearing Algebraic Equations in Systems","title":"What Happened?","text":"Yes, that's a good question! Let's investigate a little bit more what had happened. If you look at the system we defined:\n\nlength(equations(big_rc))\n\nYou see, it started as a massive 1051 set of equations. However, after eliminating redundancies, we arrive at 151 equations:\n\nequations(sys)\n\nThat's not all though. In addition, the tearing process has turned the sets of nonlinear equations into separate blocks and constructed a DAG for the dependencies between the blocks. We can use the bipartite graph functionality to dig in and investigate what this means:\n\nusing ModelingToolkit.BipartiteGraphs\nts = TearingState(expand_connections(big_rc))\ninc_org = BipartiteGraphs.incidence_matrix(ts.structure.graph)\n# Note: sorted_incidence_matrix requires the system and matrix dimensions to match\n# blt_reduced = StructuralTransformations.sorted_incidence_matrix(sys)\n\n(Image: )\n\nThe figure on the left is the original incidence matrix of the algebraic equations. Notice that the original formulation of the model has dependencies between different equations, and so the full set of equations must be solved together. That exposes no parallelism. However, the Block Lower Triangular (BLT) transformation exposes independent blocks. This is then further improved by the tearing process, which removes 90% of the equations and transforms the nonlinear equations into 50 independent blocks, which can now all be solved in parallel. The conclusion is that, your attempts to parallelize are neigh: performing parallelism after structural simplification greatly improves the problem that can be parallelized, so this is better than trying to do it by hand.\n\nAfter performing this, you can construct the ODEProblem and set parallel_form to use the exposed parallelism in multithreaded function constructions, but this showcases why mtkcompile is so important to that process.","category":"section"},{"location":"basics/Debugging/#Debugging","page":"Debugging","title":"Debugging","text":"Every (mortal) modeler writes models that contain mistakes or are susceptible to numerical errors in their hunt for the perfect model. Debugging such errors is part of the modeling process, and ModelingToolkit includes some functionality that helps with this.\n\nFor example, consider an ODE model with \"dangerous\" functions (here √):\n\nusing ModelingToolkit, OrdinaryDiffEq\nusing ModelingToolkit: t_nounits as t, D_nounits as D\n\n@variables u1(t) u2(t) u3(t)\neqs = [D(u1) ~ -√(u1), D(u2) ~ -√(u2), D(u3) ~ -√(u3)]\ninitial_conditions = [u1 => 1.0, u2 => 2.0, u3 => 3.0]\n@named sys = System(eqs, t; initial_conditions)\nsys = mtkcompile(sys)\n\nThis problem causes the ODE solver to crash:\n\nprob = ODEProblem(sys, [], (0.0, 10.0));\nsol = solve(prob, Tsit5());\n\nThis suggests that something went wrong, but not exactly what went wrong and where it did. In such situations, the debug_system function is helpful:\n\ndsys = debug_system(sys; functions = [sqrt]);\ndprob = ODEProblem(dsys, [], (0.0, 10.0));\ndsol = solve(dprob, Tsit5());\n\nNow we see that it crashed because u1 decreased so much that it became negative and outside the domain of the √ function. We could have figured that out ourselves, but it is not always so obvious for more complex models.\n\nSuppose we also want to validate that u1 + u2 >= 2.0. We can do this via the assertions functionality.\n\n@mtkcompile sys = System(eqs, t; initial_conditions, assertions = [(u1 + u2 >= 2.0) => \"Oh no!\"])\n\nThe assertions must be an iterable of pairs, where the first element is the symbolic condition and the second is a message to be logged when the condition fails. All assertions are added to the generated code and will cause the solver to reject steps that fail the assertions. For systems such as the above where the assertion is guaranteed to eventually fail, the solver will likely exit with a dtmin failure..\n\nprob = ODEProblem(sys, [], (0.0, 10.0))\nsol = solve(prob, Tsit5())\n\nWe can use debug_system to log the failing assertions in each call to the RHS function.\n\ndsys = debug_system(sys; functions = []);\ndprob = ODEProblem(dsys, [], (0.0, 10.0));\ndsol = solve(dprob, Tsit5(); dtmin = 0.1); # high dtmin only to show less clutter on this page\n\nNote the logs containing the failed assertion and corresponding message. To temporarily disable logging in a system returned from debug_system, use ModelingToolkit.ASSERTION_LOG_VARIABLE.\n\ndprob[ModelingToolkit.ASSERTION_LOG_VARIABLE] = false;\nsolve(dprob, Tsit5());","category":"section"},{"location":"comparison/#Comparison-of-ModelingToolkit-vs-Equation-Based-and-Block-Modeling-Languages","page":"Comparison of ModelingToolkit vs Equation-Based and Block Modeling Languages","title":"Comparison of ModelingToolkit vs Equation-Based and Block Modeling Languages","text":"","category":"section"},{"location":"comparison/#Comparison-Against-Modelica","page":"Comparison of ModelingToolkit vs Equation-Based and Block Modeling Languages","title":"Comparison Against Modelica","text":"Both Modelica and ModelingToolkit.jl are acausal modeling languages.\nModelica is a language with many different implementations, such as Dymola and OpenModelica, which have differing levels of performance and can give different results on the same model. Many of the commonly used Modelica compilers are not open-source. ModelingToolkit.jl is a language with a single canonical open-source implementation.\nAll current Modelica compiler implementations are fixed and not extendable by the users from the Modelica language itself. For example, the Dymola compiler shares its symbolic processing pipeline, which is roughly equivalent to the dae_index_lowering and mtkcompile of ModelingToolkit.jl. ModelingToolkit.jl is an open and hackable transformation system which allows users to add new non-standard transformations and control the order of application.\nModelica is a declarative programming language. ModelingToolkit.jl is a declarative symbolic modeling language used from within the Julia programming language. Its programming language semantics, such as loop constructs and conditionals, can be used to more easily generate models.\nModelica is an object-oriented single dispatch language. ModelingToolkit.jl, built on Julia, uses multiple dispatch extensively to simplify code.\nMany Modelica compilers supply a GUI. ModelingToolkit.jl does not.\nModelica is designed for simulating ODE and DAE systems (which can include nonlinear dynamics). In contrast, ModelingToolkit.jl supports a much broader range of system types, including SDEs, PDEs, time-independent nonlinear systems (e.g. various forms of optimization problems) and more.","category":"section"},{"location":"comparison/#Comparison-Against-Simulink","page":"Comparison of ModelingToolkit vs Equation-Based and Block Modeling Languages","title":"Comparison Against Simulink","text":"Simulink is a causal modeling environment, whereas ModelingToolkit.jl is an acausal modeling environment. For an overview of the differences, consult academic reviews such as this one. In this sense, ModelingToolkit.jl is more similar to the Simscape sub-environment.\nSimulink is used from MATLAB while ModelingToolkit.jl is used from Julia. Thus any user-defined functions have the performance of their host language. For information on the performance differences between Julia and MATLAB, consult open benchmarks, which demonstrate Julia as an order of magnitude or more faster in many cases due to its JIT compilation.\nSimulink uses the MATLAB differential equation solvers, while ModelingToolkit.jl uses DifferentialEquations.jl. For a systematic comparison between the solvers, consult open benchmarks, which demonstrate two orders of magnitude performance advantage for the native Julia solvers across many benchmark problems.\nSimulink comes with a Graphical User Interface (GUI), ModelingToolkit.jl does not.\nSimulink is a proprietary software, meaning users cannot actively modify or extend the software. ModelingToolkit.jl is built in Julia and used in Julia, where users can actively extend and modify the software interactively in the REPL and contribute to its open-source repositories.\nSimulink covers ODE and DAE systems. ModelingToolkit.jl has a much more expansive set of system types, including SDEs, PDEs, optimization problems, and more.","category":"section"},{"location":"comparison/#Comparison-Against-CASADI","page":"Comparison of ModelingToolkit vs Equation-Based and Block Modeling Languages","title":"Comparison Against CASADI","text":"CASADI is written in C++ but used from Python/MATLAB, meaning that it cannot be directly extended by users unless they are using the C++ interface and run a local build of CASADI. ModelingToolkit.jl is both written and used from Julia, meaning that users can easily extend the library on the fly, even interactively in the REPL.\nCASADI includes limited support for Computer Algebra System (CAS) functionality, while ModelingToolkit.jl is built on the full Symbolics.jl CAS.\nCASADI supports DAE and ODE problems via SUNDIALS IDAS and CVODES. ModelingToolkit.jl supports DAE and ODE problems via DifferentialEquations.jl, of which Sundials.jl is <1% of the total available solvers and is outperformed by the native Julia solvers on the vast majority of the benchmark equations. In addition, the DifferentialEquations.jl interface is confederated, meaning that any user can dynamically extend the system to add new solvers to the interface by defining new dispatches of solve.\nCASADI's DAEBuilder does not implement efficiency transformations like tearing, which are standard in the ModelingToolkit.jl transformation pipeline.\nCASADI supports special functionality for quadratic programming problems, while ModelingToolkit only provides nonlinear programming via OptimizationSystem.\nModelingToolkit.jl integrates with its host language Julia, so Julia code can be automatically converted into ModelingToolkit expressions. Users of CASADI must explicitly create CASADI expressions.","category":"section"},{"location":"comparison/#Comparison-Against-Modia.jl","page":"Comparison of ModelingToolkit vs Equation-Based and Block Modeling Languages","title":"Comparison Against Modia.jl","text":"Modia.jl uses Julia's expression objects for representing its equations. ModelingToolkit.jl uses Symbolics.jl, and thus the Julia expressions follow Julia semantics and can be manipulated using a computer algebra system (CAS).\nModia's compilation pipeline is similar to the Dymola symbolic processing pipeline with some improvements. ModelingToolkit.jl has an open transformation pipeline that allows for users to extend and reorder transformation passes, where mtkcompile is an adaptation of the Modia.jl-improved alias elimination and tearing algorithms.\nBoth Modia and ModelingToolkit generate DAEProblem and ODEProblem forms for solving with DifferentialEquations.jl.\nModelingToolkit.jl integrates with its host language Julia, so Julia code can be automatically converted into ModelingToolkit expressions. Users of Modia must explicitly create Modia expressions.\nModia covers DAE systems. ModelingToolkit.jl has a much more expansive set of system types, including SDEs, PDEs, optimization problems, and more.","category":"section"},{"location":"comparison/#Comparison-Against-Causal.jl","page":"Comparison of ModelingToolkit vs Equation-Based and Block Modeling Languages","title":"Comparison Against Causal.jl","text":"Causal.jl is a causal modeling environment, whereas ModelingToolkit.jl is an acausal modeling environment. For an overview of the differences, consult academic reviews such as this one.\nBoth ModelingToolkit.jl and Causal.jl use DifferentialEquations.jl as the backend solver library.\nCausal.jl lets one add arbitrary equation systems to a given node, and allow the output to effect the next node. This means an SDE may drive an ODE. These two portions are solved with different solver methods in tandem. In ModelingToolkit.jl, such connections promote the whole system to an SDE. This results in better accuracy and stability, though in some cases it can be less performant.\nCausal.jl, similar to Simulink, breaks algebraic loops via inexact heuristics. ModelingToolkit.jl treats algebraic loops exactly through algebraic equations in the generated model.","category":"section"},{"location":"examples/sparse_jacobians/#Automated-Sparse-Analytical-Jacobians","page":"Automated Sparse Analytical Jacobians","title":"Automated Sparse Analytical Jacobians","text":"In many cases where you have large stiff differential equations, getting a sparse Jacobian can be essential for performance. In this tutorial, we will show how to use modelingtoolkitize to regenerate an ODEProblem code with the analytical solution to the sparse Jacobian, along with the sparsity pattern required by DifferentialEquations.jl's solvers to specialize the solving process.\n\nFirst, let's start out with an implementation of the 2-dimensional Brusselator partial differential equation discretized using finite differences:\n\nusing OrdinaryDiffEq, ModelingToolkit\n\nconst N = 32\nconst xyd_brusselator = range(0, stop = 1, length = N)\nbrusselator_f(x, y, t) = (((x - 0.3)^2 + (y - 0.6)^2) <= 0.1^2) * (t >= 1.1) * 5.0\nlimit(a, N) = a == N + 1 ? 1 : a == 0 ? N : a\nfunction brusselator_2d_loop(du, u, p, t)\n    A, B, alpha, dx = p\n    alpha = alpha / dx^2\n    @inbounds for I in CartesianIndices((N, N))\n        i, j = Tuple(I)\n        x, y = xyd_brusselator[I[1]], xyd_brusselator[I[2]]\n        ip1, im1, jp1,\n        jm1 = limit(i + 1, N), limit(i - 1, N), limit(j + 1, N),\n        limit(j - 1, N)\n        du[i,\n        j,\n        1] = alpha * (u[im1, j, 1] + u[ip1, j, 1] + u[i, jp1, 1] + u[i, jm1, 1] -\n                       4u[i, j, 1]) +\n                      B + u[i, j, 1]^2 * u[i, j, 2] - (A + 1) * u[i, j, 1] +\n                      brusselator_f(x, y, t)\n        du[i,\n        j,\n        2] = alpha * (u[im1, j, 2] + u[ip1, j, 2] + u[i, jp1, 2] + u[i, jm1, 2] -\n                       4u[i, j, 2]) +\n                      A * u[i, j, 1] - u[i, j, 1]^2 * u[i, j, 2]\n    end\nend\np = (3.4, 1.0, 10.0, step(xyd_brusselator))\n\nfunction init_brusselator_2d(xyd)\n    N = length(xyd)\n    u = zeros(N, N, 2)\n    for I in CartesianIndices((N, N))\n        x = xyd[I[1]]\n        y = xyd[I[2]]\n        u[I, 1] = 22 * (y * (1 - y))^(3 / 2)\n        u[I, 2] = 27 * (x * (1 - x))^(3 / 2)\n    end\n    u\nend\nu0 = init_brusselator_2d(xyd_brusselator)\nprob = ODEProblem(brusselator_2d_loop, u0, (0.0, 11.5), p)\n\nNow let's use modelingtoolkitize to generate the symbolic version:\n\n@mtkcompile sys = modelingtoolkitize(prob);\n\nNow we regenerate the problem using jac=true for the analytical Jacobian and sparse=true to make it sparse:\n\nsparseprob = ODEProblem(sys, Pair[], (0.0, 11.5), jac = true, sparse = true)\n\nHard? No! How much did that help?\n\nusing BenchmarkTools\n@btime solve(prob, FBDF(), save_everystep = false);\nreturn nothing # hide\n\n@btime solve(sparseprob, FBDF(), save_everystep = false);\nreturn nothing # hide\n\nIt is also possible to use the numerical Jacobian, but take advantage of the analytical sparsity pattern:\n\nsparsepatternprob = ODEProblem(sys, Pair[], (0.0, 11.5), sparse = true)\n@btime solve(sparsepatternprob, FBDF(), save_everystep = false);\nreturn nothing # hide","category":"section"},{"location":"tutorials/SampledData/#Clocks-and-Sampled-Data-Systems","page":"Clocks and Sampled-Data Systems","title":"Clocks and Sampled-Data Systems","text":"A sampled-data system contains both continuous-time and discrete-time components, such as a continuous-time plant model and a discrete-time control system. ModelingToolkit supports the modeling and simulation of sampled-data systems by means of clocks.\n\ndanger: Experimental\nThe sampled-data interface is currently experimental and at any time subject to breaking changes not respecting semantic versioning.\n\nnote: Negative shifts\nThe initial release of the sampled-data interface only supports negative shifts.\n\nA clock can be seen as an event source, i.e., when the clock ticks, an event is generated. In response to the event the discrete-time logic is executed, for example, a control signal is computed. For basic modeling of sampled-data systems, the user does not have to interact with clocks explicitly, instead, the modeling is performed using the operators\n\nSample\nHold\nShiftIndex\n\nWhen a continuous-time variable x is sampled using xd = Sample(dt)(x), the result is a discrete-time variable xd that is defined and updated whenever the clock ticks. xd is only defined when the clock ticks, which it does with an interval of dt. If dt is unspecified, the tick rate of the clock associated with xd is inferred from the context in which xd appears. Any variable taking part in the same equation as xd is inferred to belong to the same discrete partition as xd, i.e., belonging to the same clock. A system may contain multiple different discrete-time partitions, each with a unique clock. This allows for modeling of multi-rate systems and discrete-time processes located on different computers etc.\n\nTo make a discrete-time variable available to the continuous partition, the Hold operator is used. xc = Hold(xd) creates a continuous-time variable xc that is updated whenever the clock associated with xd ticks, and holds its value constant between ticks.\n\nThe operators Sample and Hold are thus providing the interface between continuous and discrete partitions.\n\nThe ShiftIndex operator is used to refer to past and future values of discrete-time variables. The example below illustrates its use, implementing the discrete-time system\n\nbeginalign\n    x(k+1) = 05x(k) + u(k)  \n    y(k) = x(k)\nendalign\n\nusing ModelingToolkit\nusing ModelingToolkit: t_nounits as t\n@variables x(t) y(t) u(t)\ndt = 0.1                # Sample interval\nclock = Clock(dt)    # A periodic clock with tick rate dt\nk = ShiftIndex(clock)\n\neqs = [\n    x(k) ~ 0.5x(k - 1) + u(k - 1),\n    y ~ x\n]\n\nA few things to note in this basic example:\n\nThe equation x(k+1) = 0.5x(k) + u(k) has been rewritten in terms of negative shifts since positive shifts are not yet supported.\nx and u are automatically inferred to be discrete-time variables, since they appear in an equation with a discrete-time ShiftIndex k.\ny is also automatically inferred to be a discrete-time-time variable, since it appears in an equation with another discrete-time variable x. x,u,y all belong to the same discrete-time partition, i.e., they are all updated at the same instantaneous point in time at which the clock ticks.\nThe equation y ~ x does not use any shift index, this is equivalent to y(k) ~ x(k), i.e., discrete-time variables without shift index are assumed to refer to the variable at the current time step.\nThe equation x(k) ~ 0.5x(k-1) + u(k-1) indicates how x is updated, i.e., what the value of x will be at the current time step in terms of the past value. The output y, is given by the value of x at the current time step, i.e., y(k) ~ x(k). If this logic was implemented in an imperative programming style, the logic would thus be\n\nfunction discrete_step(x, u)\n    x = 0.5x + u # x is updated to a new value, i.e., x(k) is computed\n    y = x # y is assigned the current value of x, y(k) = x(k)\n    return x, y # The state x now refers to x at the current time step, x(k), and y equals x, y(k) = x(k)\nend\n\nAn alternative and equivalent way of writing the same system is\n\neqs = [\n    x(k + 1) ~ 0.5x(k) + u(k),\n    y(k) ~ x(k)\n]\n\nbut the use of positive time shifts is not yet supported. Instead, we shifted all indices by -1 above, resulting in exactly the same difference equations. However, the next system is not equivalent to the previous one:\n\neqs = [\n    x(k) ~ 0.5x(k - 1) + u(k),\n    y ~ x\n]\n\nIn this last example, u(k) refers to the input at the new time point k., this system is equivalent to\n\neqs = [\n    x(k+1) ~ 0.5x(k) + u(k+1),\n    y(k) ~ x(k)\n]","category":"section"},{"location":"tutorials/SampledData/#Higher-order-shifts","page":"Clocks and Sampled-Data Systems","title":"Higher-order shifts","text":"The expression x(k-1) refers to the value of x at the previous clock tick. Similarly, x(k-2) refers to the value of x at the clock tick before that. In general, x(k-n) refers to the value of x at the nth clock tick before the current one. As an example, the Z-domain transfer function\n\nH(z) = dfracb_2 z^2 + b_1 z + b_0a_2 z^2 + a_1 z + a_0\n\nmay thus be modeled as\n\nt = ModelingToolkit.t_nounits\n@variables y(t) [description = \"Output\"] u(t) [description = \"Input\"]\nk = ShiftIndex(Clock(dt))\neqs = [\n    a2 * y(k) + a1 * y(k - 1) + a0 * y(k - 2) ~ b2 * u(k) + b1 * u(k - 1) + b0 * u(k - 2)\n]\n\n(see also ModelingToolkitStandardLibrary for a discrete-time transfer-function component.)","category":"section"},{"location":"tutorials/SampledData/#Initial-conditions","page":"Clocks and Sampled-Data Systems","title":"Initial conditions","text":"The initial condition of discrete-time variables is defined using the ShiftIndex operator, for example\n\nODEProblem(model, [x(k) => 1.0], (0.0, 10.0))\n\nIf higher-order shifts are present, the corresponding initial conditions must be specified, e.g., the presence of the equation\n\nx(k) = x(k - 1) + x(k - 2)\n\nrequires specification of the initial condition for both x(k-1) and x(k-2).","category":"section"},{"location":"tutorials/SampledData/#Multiple-clocks","page":"Clocks and Sampled-Data Systems","title":"Multiple clocks","text":"Multi-rate systems are easy to model using multiple different clocks. The following set of equations is valid, and defines two different discrete-time partitions, each with its own clock:\n\nyd1 ~ Sample(dt1)(y)\nud1 ~ kp * (Sample(dt1)(r) - yd1)\nyd2 ~ Sample(dt2)(y)\nud2 ~ kp * (Sample(dt2)(r) - yd2)\n\nyd1 and ud1 belong to the same clock which ticks with an interval of dt1, while yd2 and ud2 belong to a different clock which ticks with an interval of dt2. The two clocks are not synchronized, i.e., they are not guaranteed to tick at the same point in time, even if one tick interval is a rational multiple of the other. Mechanisms for synchronization of clocks are not yet implemented.","category":"section"},{"location":"tutorials/SampledData/#Accessing-discrete-time-variables-in-the-solution","page":"Clocks and Sampled-Data Systems","title":"Accessing discrete-time variables in the solution","text":"","category":"section"},{"location":"tutorials/SampledData/#A-complete-example","page":"Clocks and Sampled-Data Systems","title":"A complete example","text":"Below, we model a simple continuous first-order system called plant that is controlled using a discrete-time controller controller. The reference signal is filtered using a discrete-time filter filt before being fed to the controller.\n\nusing ModelingToolkit, Plots, OrdinaryDiffEq\nusing ModelingToolkit: t_nounits as t\nusing ModelingToolkit: D_nounits as D\ndt = 0.5 # Sample interval\n@variables r(t)\nclock = Clock(dt)\nk = ShiftIndex(clock)\n\nfunction plant(; name)\n    @variables x(t)=1 u(t)=0 y(t)=0\n    eqs = [D(x) ~ -x + u\n           y ~ x]\n    System(eqs, t; name = name)\nend\n\nfunction filt(; name) # Reference filter\n    @variables x(t)=0 u(t)=0 y(t)=0\n    a = 1 / exp(dt)\n    eqs = [x(k) ~ a * x(k - 1) + (1 - a) * u(k)\n           y ~ x]\n    System(eqs, t, name = name)\nend\n\nfunction controller(kp; name)\n    @variables y(t)=0 r(t)=0 ud(t)=0 yd(t)=0\n    @parameters kp = kp\n    eqs = [yd ~ Sample(y)\n           ud ~ kp * (r - yd)]\n    System(eqs, t; name = name)\nend\n\n@named f = filt()\n@named c = controller(1)\n@named p = plant()\n\nconnections = [r ~ sin(t)          # reference signal\n               f.u ~ r             # reference to filter input\n               f.y ~ c.r           # filtered reference to controller reference\n               Hold(c.ud) ~ p.u    # controller output to plant input (zero-order-hold)\n               p.y ~ c.y]          # plant output to controller feedback\n\n@named cl = System(connections, t, systems = [f, c, p])","category":"section"},{"location":"tutorials/initialization/#initialization","page":"Initialization of Systems","title":"Initialization of Systems","text":"While for simple numerical ODEs choosing an initial condition can be an easy affair, with ModelingToolkit's more general differential-algebraic equation (DAE) system there is more care needed due to the flexibility of the solver state. In this tutorial we will walk through the functionality involved in initialization of System and the diagnostics to better understand and debug the initialization problem.","category":"section"},{"location":"tutorials/initialization/#Primer-on-Initialization-of-Differential-Algebraic-Equations","page":"Initialization of Systems","title":"Primer on Initialization of Differential-Algebraic Equations","text":"Before getting started, let's do a brief walkthrough of the mathematical principles of initialization of DAE systems. Take a DAE written in semi-explicit form:\n\nbeginaligned\n    x^prime = f(xyt) \n    0 = g(xyt)\nendaligned\n\nwhere x are the differential variables and y are the algebraic variables. An initial condition u0 = x(t_0) y(t_0) is said to be consistent if g(x(t_0)y(t_0)t_0) = 0.\n\nFor ODEs, this is trivially satisfied. However, for more complicated systems it may not be easy to know how to choose the variables such that all of the conditions are satisfied. This is even more complicated when taking into account ModelingToolkit's simplification engine, given that variables can be eliminated and equations can be changed. If this happens, how do you know how to initialize the system?","category":"section"},{"location":"tutorials/initialization/#Initialization-By-Example:-The-Cartesian-Pendulum","page":"Initialization of Systems","title":"Initialization By Example: The Cartesian Pendulum","text":"To illustrate how to perform the initialization, let's take a look at the Cartesian pendulum:\n\nusing ModelingToolkit, OrdinaryDiffEq, Plots\nusing ModelingToolkit: t_nounits as t, D_nounits as D\n\n@parameters g\n@variables x(t) y(t) [state_priority = 10] λ(t)\neqs = [D(D(x)) ~ λ * x\n       D(D(y)) ~ λ * y - g\n       x^2 + y^2 ~ 1]\n@mtkcompile pend = System(eqs, t)\n\nWhile we defined the system using second derivatives and a length constraint, the structural simplification system improved the numerics of the system to be solvable using the dummy derivative technique, which results in 3 algebraic equations and 2 differential equations. In this case, the differential equations with respect to y and D(y), though it could have just as easily have been x and D(x). How do you initialize such a system if you don't know in advance what variables may defined the equation's state?\n\nTo see how the system works, let's start the pendulum in the far right position, i.e. x(0) = 1 and y(0) = 0. We can do this by:\n\nprob = ODEProblem(pend, [x => 1, y => 0, g => 1], (0.0, 1.5), guesses = [λ => 1])\n\nThis solves via:\n\nsol = solve(prob, Rodas5P())\nplot(sol, idxs = (x, y))\n\nand we can check it satisfies our conditions via:\n\nconditions = getfield.(equations(pend)[3:end], :rhs)\n\n[sol[conditions][1]; sol[x][1] - 1; sol[y][1]]\n\nNotice that we set [x => 1, y => 0] as our initial conditions and [λ => 1] as our guess. The difference is that the initial conditions are required to be satisfied, while the guesses are simply a guess for what the initial value might be. Every variable must have either an initial condition or a guess, and thus since we did not know what λ would be we set it to 1 and let the initialization scheme find the correct value for λ. Indeed, the value for λ at the initial time is not 1:\n\nsol[λ][1]\n\nWe can similarly choose λ = 0 and solve for y to start the system:\n\nprob = ODEProblem(pend, [x => 1, λ => 0, g => 1], (0.0, 1.5); guesses = [y => 1])\nsol = solve(prob, Rodas5P())\nplot(sol, idxs = (x, y))\n\nor choose to satisfy derivative conditions:\n\nprob = ODEProblem(\n    pend, [x => 1, D(y) => 0, g => 1], (0.0, 1.5); guesses = [λ => 0, y => 1])\nsol = solve(prob, Rodas5P())\nplot(sol, idxs = (x, y))\n\nNotice that since a derivative condition is given, we are required to give a guess for y.\n\nWe can also directly give equations to be satisfied at the initial point by using the initialization_eqs keyword argument, for example:\n\nprob = ODEProblem(pend, [x => 1, g => 1], (0.0, 1.5); guesses = [λ => 0, y => 1],\n    initialization_eqs = [y ~ 0])\nsol = solve(prob, Rodas5P())\nplot(sol, idxs = (x, y))\n\nAdditionally, note that the initial conditions are allowed to be functions of other variables and parameters:\n\nprob = ODEProblem(\n    pend, [x => 1, D(y) => g, g => 1], (0.0, 3.0); guesses = [λ => 0, y => 1])\nsol = solve(prob, Rodas5P())\nplot(sol, idxs = (x, y))","category":"section"},{"location":"tutorials/initialization/#Determinability:-Underdetermined-and-Overdetermined-Systems","page":"Initialization of Systems","title":"Determinability: Underdetermined and Overdetermined Systems","text":"For this system we have 3 conditions to satisfy:\n\nconditions = getfield.(equations(pend)[3:end], :rhs)\n\nwhen we initialize with\n\nprob = ODEProblem(pend, [x => 1, y => 0, g => 1], (0.0, 1.5); guesses = [y => 0, λ => 1])\n\nwe have two extra conditions to satisfy, x ~ 1 and y ~ 0 at the initial point. That gives 5 equations for 5 variables and thus the system is well-formed. What happens if that's not the case?\n\nprob = ODEProblem(pend, [x => 1, g => 1], (0.0, 1.5); guesses = [y => 0, λ => 1])\n\nHere we have 4 equations for 5 unknowns (note: the warning is post-simplification of the nonlinear system, which solves the trivial x ~ 1 equation analytical and thus says 3 equations for 4 unknowns). This warning thus lets you know the system is underdetermined and thus the solution is not necessarily unique. It can still be solved:\n\nsol = solve(prob, Rodas5P())\nplot(sol, idxs = (x, y))\n\nand the found initial condition satisfies all constraints which were given. In the opposite direction, we may have an overdetermined system:\n\nprob = ODEProblem(\n    pend, [x => 1, y => 0.0, D(y) => 0, g => 1], (0.0, 1.5); guesses = [λ => 1])\n\nCan that be solved?\n\nsol = solve(prob, Rodas5P())\nplot(sol, idxs = (x, y))\n\nIndeed since we saw D(y) = 0 at the initial point above, it turns out that this solution is solvable with the chosen initial conditions. However, for overdetermined systems we often aren't that lucky. If the set of initial conditions cannot be satisfied, then you will get a SciMLBase.ReturnCode.InitialFailure:\n\nprob = ODEProblem(\n    pend, [x => 1, y => 0.0, D(y) => 2.0, λ => 1, g => 1], (0.0, 1.5); guesses = [λ => 1])\nsol = solve(prob, Rodas5P())\n\nWhat this means is that the initial condition finder failed to find an initial condition. While this can be sometimes due to numerical error (which is then helped by picking guesses closer to the correct value), most circumstances of this come from ill-formed models. Especially if your system is overdetermined and you receive an InitialFailure, the initial conditions may not be analytically satisfiable!. In our case here, if you sit down with a pen and paper long enough you will see that λ = 0 is required for this equation, but since we chose λ = 1 we end up with a set of equations that are impossible to satisfy.\n\nnote: Note\nIf you would prefer to have an error instead of a warning in the context of non-fully determined systems, pass the keyword argument fully_determined = true into the problem constructor. Additionally, any warning about not being fully determined can be suppressed via passing warn_initialize_determined = false.","category":"section"},{"location":"tutorials/initialization/#Constant-constraints-in-initialization","page":"Initialization of Systems","title":"Constant constraints in initialization","text":"Consider the pendulum system again:\n\nequations(pend)\nobserved(pend)\n\nSuppose we want to solve the same system with multiple different initial y-velocities from a given position.\n\nprob = ODEProblem(\n    pend, [x => 1, D(y) => 0, g => 1], (0.0, 1.5); guesses = [λ => 0, y => 1, x => 1])\nsol1 = solve(prob, Rodas5P())\n\nsol1[D(y), 1]\n\nRepeatedly re-creating the ODEProblem with different values of D(y) and x or repeatedly calling remake is slow. Instead, for any variable => constant constraint in the ODEProblem initialization (whether provided to the ODEProblem constructor or a default value) we can update the constant value. ModelingToolkit refers to these values using the Initial operator. For example:\n\nprob.ps[[Initial(x), Initial(D(y))]]\n\nTo solve with a different starting y-velocity, we can simply do\n\nprob.ps[Initial(D(y))] = -0.1\nsol2 = solve(prob, Rodas5P())\n\nsol2[D(y), 1]\n\nNote that this only applies for constant constraints for the current ODEProblem. For example, D(x) does not have a constant constraint - it is solved for by initialization. Thus, mutating Initial(D(x)) does not have any effect:\n\nsol2[D(x), 1]\nprob.ps[Initial(D(x))] = 1.0\nsol3 = solve(prob, Rodas5P())\nsol3[D(x), 1]\n\nTo enforce this constraint, we would have to remake the problem (or construct a new one).\n\nprob2 = remake(prob; u0 = [y => 0.0, D(x) => 0.0, x => nothing, D(y) => nothing]);\nsol4 = solve(prob2, Rodas5P())\nsol4[D(x), 1]\n\nNote the need to provide x => nothing, D(y) => nothing to override the previously provided initial conditions. Since remake is a partial update, the constraints provided to it are merged with the ones already present in the problem. Existing constraints can be removed by providing a value of nothing.","category":"section"},{"location":"tutorials/initialization/#Initialization-of-parameters","page":"Initialization of Systems","title":"Initialization of parameters","text":"Parameters may also be treated as unknowns in the initialization system. Doing so works almost identically to the standard case. For a parameter to be an initialization unknown (henceforth referred to as \"solved parameter\") it must represent a floating point number (have a symtype of Real or <:AbstractFloat) or an array of such numbers. Additionally, it must have a guess and one of the following conditions must be satisfied:\n\nThe value of the parameter as passed to ODEProblem is an expression involving other variables/parameters. For example, if [p => 2q + x] is passed to ODEProblem. In this case, p ~ 2q + x is used as an equation during initialization.\nThe parameter has a default (and no value for it is given to ODEProblem, since that is condition 1). The default will be used as an equation during initialization.\nThe parameter has a default of missing. If ODEProblem is given a value for this parameter, it is used as an equation during initialization (whether the value is an expression or not).\nODEProblem is given a value of missing for the parameter. If the parameter has a default, it will be used as an equation during initialization.\n\nAll parameter dependencies (where the dependent parameter is a floating point number or array thereof) also become equations during initialization, and the dependent parameters become unknowns.\n\nremake will reconstruct the initialization system and problem, given the new constraints provided to it. The new values will be combined with the original variable-value mapping provided to ODEProblem and used to construct the initialization problem.\n\nThe variable on the left hand side of all parameter dependencies also has an Initial variant, which is used if a constant constraint is provided for the variable.","category":"section"},{"location":"tutorials/initialization/#Parameter-initialization-by-example","page":"Initialization of Systems","title":"Parameter initialization by example","text":"Consider the following system, where the sum of two unknowns is a constant parameter total.\n\nusing ModelingToolkit, OrdinaryDiffEq # hidden\nusing ModelingToolkit: t_nounits as t, D_nounits as D # hidden\n\n@variables x(t) y(t)\n@parameters total\n@mtkcompile sys = System([D(x) ~ -x, total ~ x + y], t;\n    bindings = [total => missing], guesses = [total => 1.0])\n\nGiven any two of x, y and total we can determine the remaining variable.\n\nprob = ODEProblem(sys, [x => 1.0, y => 2.0], (0.0, 1.0))\ninteg = init(prob, Tsit5())\n@assert integ.ps[total] ≈ 3.0 # hide\ninteg.ps[total]\n\nSuppose we want to re-create this problem, but now solve for x given total and y:\n\nprob2 = remake(prob; u0 = [y => 1.0], p = [total => 4.0])\ninitsys = prob2.f.initializeprob.f.sys\n\nThe system is now overdetermined. In fact:\n\n[equations(initsys); observed(initsys)]\n\nThe system can never be satisfied and will always lead to an InitialFailure. This is due to the aforementioned behavior of retaining the original variable-value mapping provided to ODEProblem. To fix this, we pass x => nothing to remake to remove its retained value.\n\nprob2 = remake(prob; u0 = [y => 1.0, x => nothing], p = [total => 4.0])\ninitsys = prob2.f.initializeprob.f.sys\n\nThe system is fully determined, and the equations are solvable.\n\n[equations(initsys); observed(initsys)]","category":"section"},{"location":"tutorials/initialization/#Diving-Deeper:-Constructing-the-Initialization-System","page":"Initialization of Systems","title":"Diving Deeper: Constructing the Initialization System","text":"To get a better sense of the initialization system and to help debug it, you can construct the initialization system directly. The initialization system is a NonlinearSystem which requires the system-level information and the additional nonlinear equations being tagged to the system.\n\nisys = generate_initializesystem(pend; op = [x => 1.0, y => 0.0], guesses = [λ => 1])\n\nWe can inspect what its equations and unknown values are:\n\nequations(isys)\n\nunknowns(isys)\n\nNotice that all initial conditions are treated as initial equations. Additionally, for systems with observables, those observables are too treated as initial equations. We can see the resulting simplified system via the command:\n\nisys = mtkcompile(isys; fully_determined = false)\n\nNote fully_determined=false allows for the simplification to occur when the number of equations does not match the number of unknowns, which we can use to investigate our overdetermined system:\n\nisys = ModelingToolkit.generate_initializesystem(\n    pend; op = [x => 1, y => 0.0, D(y) => 2.0, λ => 1], guesses = [λ => 1])\n\nisys = mtkcompile(isys; fully_determined = false)\n\nequations(isys)\n\nunknowns(isys)\n\nobserved(isys)\n\nAfter simplification we see that we have 5 equatinos to solve with 3 variables, and the system that is given is not solvable.","category":"section"},{"location":"tutorials/initialization/#Numerical-Isolation:-InitializationProblem","page":"Initialization of Systems","title":"Numerical Isolation: InitializationProblem","text":"To inspect the numerics of the initialization problem, we can use the InitializationProblem constructor which acts just like an ODEProblem or NonlinearProblem constructor, but creates the special initialization system for a given sys. This is done as follows:\n\niprob = ModelingToolkit.InitializationProblem(pend, 0.0,\n    [x => 1, y => 0.0, D(y) => 2.0, λ => 1, g => 1], guesses = [λ => 1])\n\nWe can see that because the system is overdetermined we receive a NonlinearLeastSquaresProblem, solvable by NonlinearSolve.jl. Using NonlinearSolve we can recreate the initialization solve directly:\n\nusing NonlinearSolve\nsol = solve(iprob)\n\nnote: Note\nFor more information on solving NonlinearProblems and NonlinearLeastSquaresProblems, check out the NonlinearSolve.jl tutorials!.\n\nWe can see that the default solver stalls\n\nsol.stats\n\nafter doing many iterations, showing that it tried to compute but could not find a valid solution. Trying other solvers:\n\nsol = solve(iprob, GaussNewton())\n\ngives the same issue, indicating that the chosen initialization system is unsatisfiable. We can check the residuals:\n\nsol.resid\n\nto see the problem is not equation 2 but other equations in the system. Meanwhile, changing some of the conditions:\n\niprob = ModelingToolkit.InitializationProblem(pend, 0.0,\n    [x => 1, y => 0.0, D(y) => 0.0, λ => 0, g => 1], guesses = [λ => 1])\n\ngives a NonlinearLeastSquaresProblem which can be solved:\n\nsol = solve(iprob)\n\nsol.resid\n\nIn comparison, if we have a well-conditioned system:\n\niprob = ModelingToolkit.InitializationProblem(pend, 0.0,\n    [x => 1, D(x) => 0.0, g => 1], guesses = [λ => 1, y => 0])\n\nnotice that we instead obtained a NonlinearProblem. In this case we can use different solvers which can take advantage of the fact that the Jacobian is square.\n\nsol = solve(iprob)\n\nsol = solve(iprob, TrustRegion())","category":"section"},{"location":"tutorials/initialization/#More-Features-of-the-Initialization-System:-Steady-State-and-Observable-Initialization","page":"Initialization of Systems","title":"More Features of the Initialization System: Steady-State and Observable Initialization","text":"warning: Example currently disabled\nThis section's examples are currently disabled due to a compatibility issue with the initialization system and the current ModelingToolkit stack.\n\nLet's take a Lotka-Volterra system:\n\n@variables x(t) y(t) z(t)\n@parameters α=1.5 β=1.0 γ=3.0 δ=1.0\n\neqs = [D(x) ~ α * x - β * x * y\n       D(y) ~ -γ * y + δ * x * y\n       z ~ x + y]\n\n@named sys = System(eqs, t)\nsimpsys = mtkcompile(sys)\ntspan = (0.0, 10.0)\n\nUsing the derivative initializations, we can set the ODE to start at the steady state by initializing the derivatives to zero:\n\nprob = ODEProblem(simpsys, [D(x) => 0.0, D(y) => 0.0], tspan, guesses = [x => 1, y => 1])\nsol = solve(prob, Tsit5(), abstol = 1e-16)\n\nNotice that this is a \"numerical zero\", not an exact zero, and thus the solution will leave the steady state in this instance because it's an unstable steady state.\n\nAdditionally, notice that in this setup we have an observable z ~ x + y. If we instead know the initial condition for the observable we can use that directly:\n\nprob = ODEProblem(simpsys, [D(x) => 0.0, z => 2.0], tspan, guesses = [x => 1, y => 1])\nsol = solve(prob, Tsit5())\n\nWe can check that indeed the solution does satisfy that D(x) = 0 at the start:\n\nsol[α * x - β * x * y]\n\nplot(sol)","category":"section"},{"location":"tutorials/initialization/#Summary-of-Initialization-API","page":"Initialization of Systems","title":"Summary of Initialization API","text":"","category":"section"},{"location":"basics/Events/#events","page":"Event Handling and Callback Functions","title":"Event Handling and Callback Functions","text":"ModelingToolkit provides several ways to represent system events, which enable system state or parameters to be changed when certain conditions are satisfied, or can be used to detect discontinuities. These events are ultimately converted into DifferentialEquations.jl ContinuousCallbacks or DiscreteCallbacks, or into more specialized callback types from the DiffEqCallbacks.jl library.\n\nSystems and SDESystems accept keyword arguments continuous_events and discrete_events to symbolically encode continuous or discrete callbacks. JumpSystems currently support only discrete_events. Continuous events are applied when a given condition becomes zero, with root finding used to determine the time at which a zero crossing occurred. Discrete events are applied when a condition tested after each timestep evaluates to true. See the DifferentialEquations docs for more detail.\n\nEvents involve both a condition function (for the zero crossing or truth test), and an affect function (for determining how to update the system when the event occurs). These can both be specified symbolically, but a more general functional affect representation is also allowed, as described below.","category":"section"},{"location":"basics/Events/#Symbolic-Callback-Semantics","page":"Event Handling and Callback Functions","title":"Symbolic Callback Semantics","text":"In callbacks, there is a distinction between values of the unknowns and parameters before the callback, and the desired values after the callback. In MTK, this is provided by the Pre operator. For example, if we would like to add 1 to an unknown x in a callback, the equation would look like the following:\n\nx ~ Pre(x) + 1\n\nNon Pre-d values will be interpreted as values after the callback. As such, writing\n\nx ~ x + 1\n\nwill be interpreted as an algebraic equation to be satisfied after the callback. Since this equation obviously cannot be satisfied, an error will result.\n\nCallbacks must maintain the consistency of DAEs, meaning that they must satisfy all the algebraic equations of the system after their update. However, the affect equations often do not fully specify which unknowns/parameters should be modified to maintain consistency. To make this clear, MTK uses the following rules:\n\nAll unknowns are treated as modifiable by the callback. In order to enforce that an unknown x remains the same, one can add x ~ Pre(x) to the affect equations.\nAll parameters are treated as un-modifiable, unless they are declared as discrete_parameters to the callback. In order to be a discrete parameter, the parameter must be time-dependent (the terminology discretes here means discrete variables).\n\nFor example, consider the following system.\n\n@variables x(t) y(t)\n@parameters p(t)\n@mtkcompile sys = System([x * y ~ p, D(x) ~ 0], t)\nevent = [t == 1] => [x ~ Pre(x) + 1]\n\nBy default what will happen is that x will increase by 1, p will remain constant, and y will change in order to compensate the increase in x. But what if we wanted to keep y constant and change p instead? We could use the callback constructor as follows:\n\nevent = SymbolicDiscreteCallback(\n    [t == 1] => [x ~ Pre(x) + 1, y ~ Pre(y)], discrete_parameters = [p])\n\nThis way, we enforce that y will remain the same, and p will change.\n\nwarning: Warning\nSymbolic affects come with the guarantee that the state after the callback will be consistent. However, when using general functional affects or imperative affects one must be more careful. In particular, one can pass in reinitializealg as a keyword arg to the callback constructor to re-initialize the system. This will default to SciMLBase.NoInit() in the case of symbolic affects and SciMLBase.CheckInit() in the case of functional affects. This keyword should not be provided if the affect is purely symbolic.","category":"section"},{"location":"basics/Events/#Continuous-Events","page":"Event Handling and Callback Functions","title":"Continuous Events","text":"The basic purely symbolic continuous event interface to encode one continuous event is\n\nAbstractSystem(eqs, _...; continuous_events::Vector{Equation})\nAbstractSystem(eqs, _...; continuous_events::Pair{Vector{Equation}, Vector{Equation}})\n\nIn the former, equations that evaluate to 0 will represent conditions that should be detected by the integrator, for example to force stepping to times of discontinuities. The latter allow modeling of events that have an effect on the state, where the first entry in the Pair is a vector of equations describing event conditions, and the second vector of equations describes the effect on the state. Each affect equation must be of the form\n\nsingle_unknown_variable ~ expression_involving_any_variables_or_parameters\n\nor\n\nsingle_parameter ~ expression_involving_any_variables_or_parameters\n\nIn this basic interface, multiple variables can be changed in one event, or multiple parameters, but not a mix of parameters and variables. The latter can be handled via more general functional affects.\n\nFinally, multiple events can be encoded via a Vector{Pair{Vector{Equation}, Vector{Equation}}}.","category":"section"},{"location":"basics/Events/#Example:-Friction","page":"Event Handling and Callback Functions","title":"Example: Friction","text":"The system below illustrates how continuous events can be used to model Coulomb friction\n\nusing ModelingToolkit, OrdinaryDiffEq, Plots\nusing ModelingToolkit: t_nounits as t, D_nounits as D\n\nfunction UnitMassWithFriction(k; name)\n    @variables x(t)=0 v(t)=0\n    eqs = [D(x) ~ v\n           D(v) ~ sin(t) - k * sign(v)]\n    System(eqs, t; continuous_events = [v ~ 0], name) # when v = 0 there is a discontinuity\nend\n@mtkcompile m = UnitMassWithFriction(0.7)\nprob = ODEProblem(m, Pair[], (0, 10pi))\nsol = solve(prob, Tsit5())\nplot(sol)","category":"section"},{"location":"basics/Events/#Example:-Bouncing-ball","page":"Event Handling and Callback Functions","title":"Example: Bouncing ball","text":"In the documentation for DifferentialEquations, we have an example where a bouncing ball is simulated using callbacks which have an affect! on the state. We can model the same system using ModelingToolkit like this\n\n@variables x(t)=1 v(t)=0\n\nroot_eqs = [x ~ 0]  # the event happens at the ground x(t) = 0\naffect = [v ~ -Pre(v)] # the effect is that the velocity changes sign\n\n@mtkcompile ball = System(\n    [D(x) ~ v\n     D(v) ~ -9.8], t; continuous_events = root_eqs => affect) # equation => affect\n\ntspan = (0.0, 5.0)\nprob = ODEProblem(ball, Pair[], tspan)\nsol = solve(prob, Tsit5())\n@assert 0 <= minimum(sol[x]) <= 1e-10 # the ball never went through the floor but got very close\nplot(sol)","category":"section"},{"location":"basics/Events/#Test-bouncing-ball-in-2D-with-walls","page":"Event Handling and Callback Functions","title":"Test bouncing ball in 2D with walls","text":"Multiple events? No problem! This example models a bouncing ball in 2D that is enclosed by two walls at y = pm 15.\n\n@variables x(t)=1 y(t)=0 vx(t)=0 vy(t)=2\n\ncontinuous_events = [[x ~ 0] => [vx ~ -Pre(vx)]\n                     [y ~ -1.5, y ~ 1.5] => [vy ~ -Pre(vy)]]\n\n@mtkcompile ball = System(\n    [\n        D(x) ~ vx,\n        D(y) ~ vy,\n        D(vx) ~ -9.8 - 0.1vx, # gravity + some small air resistance\n        D(vy) ~ -0.1vy\n    ], t; continuous_events)\n\ntspan = (0.0, 10.0)\nprob = ODEProblem(ball, Pair[], tspan)\n\nsol = solve(prob, Tsit5())\n@assert 0 <= minimum(sol[x]) <= 1e-10 # the ball never went through the floor but got very close\n@assert minimum(sol[y]) >= -1.5 # check wall conditions\n@assert maximum(sol[y]) <= 1.5  # check wall conditions\n\ntv = sort([LinRange(0, 10, 200); sol.t])\nplot(sol(tv)[y], sol(tv)[x], line_z = tv)\nvline!([-1.5, 1.5], l = (:black, 5), primary = false)\nhline!([0], l = (:black, 5), primary = false)","category":"section"},{"location":"basics/Events/#func_affects","page":"Event Handling and Callback Functions","title":"Generalized functional affect support","text":"In some instances, a more flexible response to events is needed, which cannot be encapsulated by symbolic equations. For example, a component may implement complex behavior that is inconvenient or impossible to represent symbolically. ModelingToolkit therefore supports regular Julia functions as affects: instead of one or more equations, an affect is defined as a tuple:\n\n[x ~ 0] => (affect!, [v, x], [p, q], [discretes...], ctx)\n\nwhere, affect! is a Julia function with the signature: affect!(integ, u, p, ctx); [u,v] and [p,q] are the symbolic unknowns (variables) and parameters that are accessed by affect!, respectively; discretes are the parameters modified by affect!, if any; and ctx is any context that is passed to affect! as the ctx argument.\n\naffect! receives a DifferentialEquations.jl integrator as its first argument, which can then be used to access unknowns and parameters that are provided in the u and p arguments (implemented as NamedTuples). The integrator can also be manipulated more generally to control solution behavior, see the integrator interface documentation. In affect functions, we have that\n\nfunction affect!(integ, u, p, ctx)\n    # integ.t is the current time\n    # integ.u[u.v] is the value of the unknown `v` above\n    # integ.ps[p.q] is the value of the parameter `q` above\nend\n\nWhen accessing variables of a sub-system, it can be useful to rename them (alternatively, an affect function may be reused in different contexts):\n\n[x ~ 0] => (affect!, [resistor₊v => :v, x], [p, q => :p2], [], ctx)\n\nHere, the symbolic variable resistor₊v is passed as v while the symbolic parameter q has been renamed p2.\n\nAs an example, here is the bouncing ball example from above using the functional affect interface:\n\nsts = @variables x(t), v(t)\npar = @parameters g = 9.8\nbb_eqs = [D(x) ~ v\n          D(v) ~ -g]\n\nfunction bb_affect!(mod, obs, integ, ctx)\n    return (; v = -mod.v)\nend\n\nreflect = [x ~ 0] => (bb_affect!, (; v))\n\n@mtkcompile bb_sys = System(bb_eqs, t, sts, par,\n    continuous_events = reflect)\n\nu0 = [v => 0.0, x => 1.0]\n\nbb_prob = ODEProblem(bb_sys, u0, (0, 5.0))\nbb_sol = solve(bb_prob, Tsit5())\n\nplot(bb_sol)","category":"section"},{"location":"basics/Events/#Discrete-Events","page":"Event Handling and Callback Functions","title":"Discrete Events","text":"In addition to continuous events, discrete events are also supported. The general interface to represent a collection of discrete events is\n\nAbstractSystem(eqs, _...; discrete_events = [condition1 => affect1, condition2 => affect2])\n\nwhere conditions are symbolic expressions that should evaluate to true when an individual affect should be executed. Here affect1 and affect2 are each either a vector of one or more symbolic equations, or a functional affect, just as for continuous events. As before, for any one event the symbolic affect equations can either all change unknowns (i.e. variables) or all change parameters, but one cannot currently mix unknown variable and parameter changes within one individual event.","category":"section"},{"location":"basics/Events/#Example:-Injecting-cells-into-a-population","page":"Event Handling and Callback Functions","title":"Example: Injecting cells into a population","text":"Suppose we have a population of N(t) cells that can grow and die, and at time t1 we want to inject M more cells into the population. We can model this by\n\n@parameters M tinject\n@discretes α(t)\n@variables N(t)\nDₜ = Differential(t)\neqs = [Dₜ(N) ~ α - N]\n\n# at time tinject we inject M cells\ninjection = (t == tinject) => [N ~ Pre(N) + M]\n\nu0 = [N => 0.0]\ntspan = (0.0, 20.0)\np = [α => 100.0, tinject => 10.0, M => 50]\n@mtkcompile osys = System(eqs, t, [N], [α, M, tinject]; discrete_events = injection)\noprob = ODEProblem(osys, u0, tspan, p)\nsol = solve(oprob, Tsit5(); tstops = 10.0)\nplot(sol)\n\nNotice, with generic discrete events that we want to occur at one or more fixed times, we need to also set the tstops keyword argument to solve to ensure the integrator stops at that time. In the next section, we show how one can avoid this by using a preset-time callback.\n\nNote that more general logical expressions can be built, for example, suppose we want the event to occur at that time only if the solution is smaller than 50% of its steady-state value (which is 100). We can encode this by modifying the event to\n\ninjection = ((t == tinject) & (N < 50)) => [N ~ Pre(N) + M]\n\n@mtkcompile osys = System(eqs, t, [N], [M, tinject, α]; discrete_events = injection)\noprob = ODEProblem(osys, u0, tspan, p)\nsol = solve(oprob, Tsit5(); tstops = 10.0)\nplot(sol)\n\nSince the solution is not smaller than half its steady-state value at the event time, the event condition now returns false. Here we used logical and, &, instead of the short-circuiting logical and, &&, as currently the latter cannot be used within symbolic expressions.\n\nLet's now also add a drug at time tkill that turns off production of new cells, modeled by setting α = 0.0. Since this is a parameter we must explicitly set it as discrete_parameters.\n\n@parameters tkill\n\n# we reset the first event to just occur at tinject\ninjection = (t == tinject) => [N ~ Pre(N) + M]\n\n# at time tkill we turn off production of cells\nkilling = ModelingToolkit.SymbolicDiscreteCallback(\n    (t == tkill) => [α ~ 0.0]; discrete_parameters = α, iv = t)\n\ntspan = (0.0, 30.0)\np = [α => 100.0, tinject => 10.0, M => 50, tkill => 20.0]\n@mtkcompile osys = System(eqs, t, [N], [α, M, tinject, tkill];\n    discrete_events = [injection, killing])\noprob = ODEProblem(osys, u0, tspan, p)\nsol = solve(oprob, Tsit5(); tstops = [10.0, 20.0])\nplot(sol)","category":"section"},{"location":"basics/Events/#Periodic-and-preset-time-events","page":"Event Handling and Callback Functions","title":"Periodic and preset-time events","text":"Two important subclasses of discrete events are periodic and preset-time events.\n\nA preset-time event is triggered at specific set times, which can be passed in a vector like\n\ndiscrete_events = [[1.0, 4.0] => [v ~ -Pre(v)]]\n\nThis will change the sign of v only at t = 1.0 and t = 4.0.\n\nAs such, our last example with treatment and killing could instead be modeled by\n\ninjection = [10.0] => [N ~ Pre(N) + M]\nkilling = ModelingToolkit.SymbolicDiscreteCallback(\n    [20.0] => [α ~ 0.0], discrete_parameters = α, iv = t)\n\np = [α => 100.0, M => 50]\n@mtkcompile osys = System(eqs, t, [N], [α, M];\n    discrete_events = [injection, killing])\noprob = ODEProblem(osys, u0, tspan, p)\nsol = solve(oprob, Tsit5())\nplot(sol)\n\nNotice, one advantage of using a preset-time event is that one does not need to also specify tstops in the call to solve.\n\nA periodic event is triggered at fixed intervals (e.g. every Δt seconds). To specify a periodic interval, pass the interval as the condition for the event. For example,\n\ndiscrete_events = [1.0 => [v ~ -Pre(v)]]\n\nwill change the sign of v at t = 1.0, 2.0, ...\n\nFinally, we note that to specify an event at precisely one time, say 2.0 below, one must still use a vector\n\ndiscrete_events = [[2.0] => [v ~ -Pre(v)]]","category":"section"},{"location":"basics/Events/#save_discretes","page":"Event Handling and Callback Functions","title":"Saving discrete values","text":"Time-dependent parameters which are updated in callbacks are termed as discrete variables. ModelingToolkit enables automatically saving the timeseries of these discrete variables, and indexing the solution object to obtain the saved timeseries. Consider the following example:\n\n@variables x(t)\n@discretes c(t)\n\nev = ModelingToolkit.SymbolicDiscreteCallback(\n    1.0 => [c ~ Pre(c) + 1], discrete_parameters = c, iv = t)\n@mtkcompile sys = System(\n    D(x) ~ c * cos(x), t, [x], [c]; discrete_events = [ev])\n\nprob = ODEProblem(sys, [x => 0.0, c => 1.0], (0.0, 2pi))\nsol = solve(prob, Tsit5())\nsol[c]\n\nThe solution object can also be interpolated with the discrete variables\n\nsol([1.0, 2.0], idxs = [c, c * cos(x)])\n\nNote that only time-dependent parameters that are explicitly passed as discrete_parameters will be saved. The discrete_parameters argument is also required for the callback to compile successfully - omitting it will result in an error because the equation modifying the discrete would have no unknowns/observables.","category":"section"},{"location":"basics/Events/#imp_affects","page":"Event Handling and Callback Functions","title":"(Experimental) Imperative affects","text":"The ImperativeAffect can be used as an alternative to the aforementioned functional affect form. Note that ImperativeAffect is still experimental; to emphasize this, we do not export it and it should be included as ModelingToolkit.ImperativeAffect. ImperativeAffect aims to simplify the manipulation of system state.\n\nWe will use two examples to describe ImperativeAffect: a simple heater and a quadrature encoder. These examples will also demonstrate advanced usage of ModelingToolkit.SymbolicContinuousCallback, the low-level interface of the tuple form converts into that allows control over the SciMLBase-level event that is generated for a continuous event.","category":"section"},{"location":"basics/Events/#heater_events","page":"Event Handling and Callback Functions","title":"Heater","text":"Bang-bang control of a heater connected to a leaky plant requires hysteresis in order to prevent rapid control oscillation.\n\n@variables temp(t)\n@parameters furnace_on_threshold=0.5 furnace_off_threshold=0.7 furnace_power=1.0 leakage=0.1\n@discretes furnace_on(t)::Bool = false\nparams = [furnace_on_threshold, furnace_off_threshold, furnace_power, leakage, furnace_on]\neqs = [\n    D(temp) ~ furnace_on * furnace_power - temp^2 * leakage\n]\n\nOur plant is simple. We have a heater that's turned on and off by the time-indexed parameter furnace_on which adds furnace_power forcing to the system when enabled. We then leak heat proportional to leakage as a function of the square of the current temperature.\n\nWe need a controller with hysteresis to control the plant. We wish the furnace to turn on when the temperature is below furnace_on_threshold and off when above furnace_off_threshold, while maintaining its current state in between. To do this, we create two continuous callbacks:\n\nusing Setfield\nfurnace_disable = ModelingToolkit.SymbolicContinuousCallback(\n    [temp ~ furnace_off_threshold],\n    ModelingToolkit.ImperativeAffect(modified = (; furnace_on)) do x, o, c, i\n        @set! x.furnace_on = false\n    end)\nfurnace_enable = ModelingToolkit.SymbolicContinuousCallback(\n    [temp ~ furnace_on_threshold],\n    ModelingToolkit.ImperativeAffect(modified = (; furnace_on)) do x, o, c, i\n        @set! x.furnace_on = true\n    end)\n\nWe're using the explicit form of SymbolicContinuousCallback here, though so far we aren't using anything that's not possible with the implicit interface. You can also write\n\n[temp ~\n furnace_off_threshold] => ModelingToolkit.ImperativeAffect(modified = (;\n    furnace_on)) do x, o, i, c\n    @set! x.furnace_on = false\nend\n\nand it would work the same.\n\nThe ImperativeAffect is the larger change in this example. ImperativeAffect has the constructor signature\n\nImperativeAffect(f::Function; modified::NamedTuple, observed::NamedTuple, ctx)\n\nthat accepts the function to call, a named tuple of both the names of and symbolic values representing values in the system to be modified, a named tuple of the values that are merely observed (that is, used from the system but not modified), and a context that's passed to the affect function.\n\nIn our example, each event merely changes whether the furnace is on or off. Accordingly, we pass a modified tuple (; furnace_on) (creating a NamedTuple equivalent to (furnace_on = furnace_on)). ImperativeAffect will then evaluate this before calling our function to fill out all of the numerical values, then apply them back to the system once our affect function returns. Furthermore, it will check that it is possible to do this assignment.\n\nThe function given to ImperativeAffect needs to have the signature:\n\nf(modified::NamedTuple, observed::NamedTuple, ctx, integrator)::NamedTuple\n\nThe function f will be called with observed and modified NamedTuples that are derived from their respective NamedTuple definitions. In our example, if furnace_on is false, then the value of the x that's passed in as modified will be (furnace_on = false). The modified values should be passed out in the same format: to set furnace_on to true we need to return a tuple (furnace_on = true). The examples does this with Setfield, recreating the result tuple before returning it; the returned tuple may optionally be missing values as well, in which case those values will not be written back to the problem.\n\nAccordingly, we can now interpret the ImperativeAffect definitions to mean that when temp = furnace_off_threshold we will write furnace_on = false back to the system, and when temp = furnace_on_threshold we will write furnace_on = true back to the system.\n\n@named sys = System(\n    eqs, t, [temp], params; continuous_events = [furnace_disable, furnace_enable])\nss = mtkcompile(sys)\nprob = ODEProblem(ss, [temp => 0.0, furnace_on => true], (0.0, 10.0))\nsol = solve(prob, Tsit5())\nplot(sol)\nhline!([sol.ps[furnace_off_threshold], sol.ps[furnace_on_threshold]],\n    l = (:black, 1), primary = false)\n\nHere we see exactly the desired hysteresis. The heater starts on until the temperature hits furnace_off_threshold. The temperature then bleeds away until furnace_on_threshold at which point the furnace turns on again until furnace_off_threshold and so on and so forth. The controller is effectively regulating the temperature of the plant.","category":"section"},{"location":"basics/Events/#quadrature","page":"Event Handling and Callback Functions","title":"Quadrature Encoder","text":"For a more complex application we'll look at modeling a quadrature encoder attached to a shaft spinning at a constant speed. Traditionally, a quadrature encoder is built out of a code wheel that interrupts the sensors at constant intervals and two sensors slightly out of phase with one another. A state machine can take the pattern of pulses produced by the two sensors and determine the number of steps that the shaft has spun. The state machine takes the new value from each sensor and the old values and decodes them into the direction that the wheel has spun in this step.\n\n@variables theta(t) omega(t)\nparams = @parameters qA=0 qB=0 hA=0 hB=0 cnt::Int=0\neqs = [D(theta) ~ omega\n       omega ~ 1.0]\n\nOur continuous-time system is extremely simple. We have two unknown variables theta for the angle of the shaft and omega for the rate at which it's spinning. We then have parameters for the state machine qA, qB, hA, hB (corresponding to the current quadrature of the A/B sensors and the historical ones) and a step count cnt.\n\nWe'll then implement the decoder as a simple Julia function.\n\nfunction decoder(oldA, oldB, newA, newB)\n    state = (oldA, oldB, newA, newB)\n    if state == (0, 0, 1, 0) || state == (1, 0, 1, 1) || state == (1, 1, 0, 1) ||\n       state == (0, 1, 0, 0)\n        return 1\n    elseif state == (0, 0, 0, 1) || state == (0, 1, 1, 1) || state == (1, 1, 1, 0) ||\n           state == (1, 0, 0, 0)\n        return -1\n    elseif state == (0, 0, 0, 0) || state == (0, 1, 0, 1) || state == (1, 0, 1, 0) ||\n           state == (1, 1, 1, 1)\n        return 0\n    else\n        return 0 # err is interpreted as no movement\n    end\nend\n\nBased on the current and old state, this function will return 1 if the wheel spun in the positive direction, -1 if in the negative, and 0 otherwise.\n\nThe encoder state advances when the occlusion begins or ends. We model the code wheel as simply detecting when cos(100*theta) is 0; if we're at a positive edge of the 0 crossing, then we interpret that as occlusion (so the discrete qA goes to 1). Otherwise, if cos is going negative, we interpret that as lack of occlusion (so the discrete goes to 0). The decoder function is then invoked to update the count with this new information.\n\nWe can implement this in one of two ways: using edge sign detection or right root finding. For exposition, we will implement each sensor differently.\n\nFor sensor A, we're using the edge detection method. By providing a different affect to SymbolicContinuousCallback's affect_neg argument, we can specify different behaviour for the negative crossing vs. the positive crossing of the root. In our encoder, we interpret this as occlusion or nonocclusion of the sensor, update the internal state, and tick the decoder.\n\nqAevt = ModelingToolkit.SymbolicContinuousCallback([cos(100 * theta) ~ 0],\n    ModelingToolkit.ImperativeAffect((; qA, hA, hB, cnt), (; qB)) do x, o, c, i\n        @set! x.hA = x.qA\n        @set! x.hB = o.qB\n        @set! x.qA = 1\n        @set! x.cnt += decoder(x.hA, x.hB, x.qA, o.qB)\n        x\n    end,\n    affect_neg = ModelingToolkit.ImperativeAffect(\n        (; qA, hA, hB, cnt), (; qB)) do x, o, c, i\n        @set! x.hA = x.qA\n        @set! x.hB = o.qB\n        @set! x.qA = 0\n        @set! x.cnt += decoder(x.hA, x.hB, x.qA, o.qB)\n        x\n    end)\n\nThe other way we can implement a sensor is by changing the root find. Normally, we use left root finding; the affect will be invoked instantaneously before the root is crossed. This makes it trickier to figure out what the new state is. Instead, we can use right root finding:\n\nqBevt = ModelingToolkit.SymbolicContinuousCallback([cos(100 * theta - π / 2) ~ 0],\n    ModelingToolkit.ImperativeAffect((; qB, hA, hB, cnt), (; qA, theta)) do x, o, c, i\n        @set! x.hA = o.qA\n        @set! x.hB = x.qB\n        @set! x.qB = clamp(sign(cos(100 * o.theta - π / 2)), 0.0, 1.0)\n        @set! x.cnt += decoder(x.hA, x.hB, o.qA, x.qB)\n        x\n    end; rootfind = SciMLBase.RightRootFind)\n\nHere, sensor B is located π / 2 behind sensor A in angular space, so we're adjusting our trigger function accordingly. We here ask for right root finding on the callback, so we know that the value of said function will have the \"new\" sign rather than the old one. Thus, we can determine the new state of the sensor from the sign of the indicator function evaluated at the affect activation point, with -1 mapped to 0.\n\nWe can now simulate the encoder.\n\n@named sys = System(\n    eqs, t, [theta, omega], params; continuous_events = [qAevt, qBevt])\nss = mtkcompile(sys)\nprob = ODEProblem(ss, [theta => 0.0], (0.0, pi))\nsol = solve(prob, Tsit5(); dtmax = 0.01)\nsol.ps[cnt]\n\ncos(100*theta) will have 200 crossings in the half rotation we've gone through, so the encoder would notionally count 200 steps. Our encoder counts 198 steps (it loses one step to initialization and one step due to the final state falling squarely on an edge).","category":"section"},{"location":"examples/higher_order/#Automatic-Transformation-of-Nth-Order-ODEs-to-1st-Order-ODEs","page":"Automatic Transformation of Nth Order ODEs to 1st Order ODEs","title":"Automatic Transformation of Nth Order ODEs to 1st Order ODEs","text":"ModelingToolkit has a system for transformations of mathematical systems. These transformations allow for symbolically changing the representation of the model to problems that are easier to numerically solve. One simple to demonstrate transformation, is mtkcompile, which does a lot of tricks, one being the transformation that turns an Nth order ODE into N coupled 1st order ODEs.\n\nTo see this, let's define a second order riff on the Lorenz equations. We utilize the derivative operator twice here to define the second order:\n\nusing ModelingToolkit, OrdinaryDiffEq\nusing ModelingToolkit: t_nounits as t, D_nounits as D\n\n@parameters σ = 28.0 ρ = 10.0 β = 8 / 3\n@variables x(t) = 1.0 y(t) = 0.0 z(t) = 0.0\neqs = [\n    D(D(x)) ~ σ * (y - x)\n    D(y) ~ x * (ρ - z) - y\n    D(z) ~ x * y - β * z\n]\n\n@named sys_model = System(eqs, t)\nsys = mtkcompile(sys_model)\n\nThe second order ODE has been automatically transformed to two first order ODEs.\n\nNote that we could've used an alternative syntax for 2nd order, i.e. D = Differential(t)^2 and then D(x) would be the second derivative, and this syntax extends to N-th order. Also, we can use * or ∘ to compose Differentials, like Differential(t) * Differential(x).\n\nNow let's transform this into the System of first order components. We do this by calling mtkcompile:\n\nNow we can directly numerically solve the lowered system. Note that, following the original problem, the solution requires knowing the initial condition for both x and D(x). The former already got assigned a default value, but we still have to provide a value for the latter.\n\nu0 = [D(sys.x) => 2.0]\ntspan = (0.0, 100.0)\nprob = ODEProblem(sys, u0, tspan, jac = true)\nsol = solve(prob, Tsit5())\nusing Plots\nplot(sol, idxs = (sys.x, sys.y))","category":"section"},{"location":"internals/bipartite_graph/#Bipartite-Graphs","page":"Bipartite Graphs","title":"Bipartite Graphs","text":"warning: Internal API\nThe functions documented on this page are internal implementation details of ModelingToolkit. They are not part of the public API and may change or be removed without notice in non-breaking releases. This documentation is provided to help contributors understand the codebase.\n\nModelingToolkit uses bipartite graphs to represent relationships between equations and variables in systems. These functions provide tools for working with and analyzing these graphs.","category":"section"},{"location":"internals/bipartite_graph/#Graph-Types","page":"Bipartite Graphs","title":"Graph Types","text":"","category":"section"},{"location":"internals/bipartite_graph/#Vertex-Operations","page":"Bipartite Graphs","title":"Vertex Operations","text":"","category":"section"},{"location":"internals/bipartite_graph/#Neighbor-Operations","page":"Bipartite Graphs","title":"Neighbor Operations","text":"","category":"section"},{"location":"internals/bipartite_graph/#Edge-Operations","page":"Bipartite Graphs","title":"Edge Operations","text":"","category":"section"},{"location":"internals/bipartite_graph/#Graph-Views-and-Modifications","page":"Bipartite Graphs","title":"Graph Views and Modifications","text":"","category":"section"},{"location":"internals/bipartite_graph/#Matching-Algorithms","page":"Bipartite Graphs","title":"Matching Algorithms","text":"","category":"section"},{"location":"internals/bipartite_graph/#Dependency-Analysis","page":"Bipartite Graphs","title":"Dependency Analysis","text":"","category":"section"},{"location":"internals/bipartite_graph/#Graph-Conversion","page":"Bipartite Graphs","title":"Graph Conversion","text":"","category":"section"},{"location":"internals/bipartite_graph/#Constants","page":"Bipartite Graphs","title":"Constants","text":"","category":"section"},{"location":"basics/Linearization/#linearization","page":"Linearization","title":"Linearization","text":"A nonlinear dynamical system with state (differential and algebraic) x and input signals u\n\nM dot x = f(x u)\n\ncan be linearized using the function linearize to produce a linear statespace system on the form\n\nbeginaligned\ndot x = Ax + Bu\ny = Cx + Du\nendaligned\n\nThe linearize function expects the user to specify the inputs u and the outputs y using the syntax shown in the example below. The system model is not supposed to be simplified before calling linearize:","category":"section"},{"location":"basics/Linearization/#Example","page":"Linearization","title":"Example","text":"using ModelingToolkit\nusing ModelingToolkit: t_nounits as t, D_nounits as D\n@variables x(t)=0 y(t) u(t) r(t)=0\n@parameters kp = 1\n\neqs = [u ~ kp * (r - y) # P controller\n       D(x) ~ -x + u    # First-order plant\n       y ~ x]           # Output equation\n\n@named sys = System(eqs, t) # Do not call @mtkcompile when linearizing\nmatrices, simplified_sys = linearize(sys, [r], [y]) # Linearize from r to y\nmatrices\n\nThe named tuple matrices contains the matrices of the linear statespace representation, while simplified_sys is an System that, among other things, indicates the unknown variable order in the linear system through\n\nusing ModelingToolkit: inputs, outputs\n[unknowns(simplified_sys); inputs(simplified_sys); outputs(simplified_sys)]\n\nnote: Inputs must be unconnected\nThe model above has 4 variables but only three equations, there is no equation specifying the value of r since r is an input. This means that only unbalanced models can be linearized, or in other words, models that are balanced and can be simulated cannot be linearized. To learn more about this, see How to linearize a ModelingToolkit model (YouTube). Also see ModelingToolkitStandardLibrary: Linear analysis for utilities that make linearization of completed models easier.\n\nnote: Un-simplified system\nLinearization expects sys to be un-simplified, i.e., mtkcompile or @mtkcompile should not be called on the system before linearizing.","category":"section"},{"location":"basics/Linearization/#Operating-point","page":"Linearization","title":"Operating point","text":"The operating point to linearize around can be specified with the keyword argument op like this: op = Dict(x => 1, r => 2). The operating point may include specification of unknown variables, input variables and parameters. For variables that are not specified in op, the default value specified in the model will be used if available, if no value is specified, an error is thrown.","category":"section"},{"location":"basics/Linearization/#Batch-linearization-and-algebraic-variables","page":"Linearization","title":"Batch linearization and algebraic variables","text":"If linearization is to be performed around multiple operating points, the simplification of the system has to be carried out a single time only. To facilitate this, the lower-level function ModelingToolkit.linearization_function is available. This function further allows you to obtain separate Jacobians for the differential and algebraic parts of the model. For ODE models without algebraic equations, the statespace representation above is available from the output of linearization_function as A, B, C, D = f_x, f_u, h_x, h_u.\n\nAll variables that will be fixed by an operating point must be provided in the operating point to linearization_function. For example, if the operating points fix the value of x, y and z then an operating point with constant values for these variables (e.g. Dict(x => 1.0, y => 1.0, z => 1.0)) must be provided. The constant values themselves do not matter and can be changed by subsequent operating points.\n\nOne approach to batch linearization would be to call linearize in a loop, providing a different operating point each time. For example:\n\nusing ModelingToolkitStandardLibrary\nusing ModelingToolkitStandardLibrary.Blocks\n\n@parameters k=10 k3=2 c=1\n@variables x(t)=0 [bounds = (-0.5, 1.5)]\n@variables v(t) = 0\n\n@named y = Blocks.RealOutput()\n@named u = Blocks.RealInput()\n\neqs = [D(x) ~ v\n       D(v) ~ -k * x - k3 * x^3 - c * v + 10u.u\n       y.u ~ x]\n\n@named duffing = System(eqs, t, systems = [y, u], initial_conditions = [u.u => 0])\n\n# pass a constant value for `x`, since it is the variable we will change in operating points\nlinfun, simplified_sys = linearization_function(duffing, [u.u], [y.u]; op = Dict(x => NaN));\n\nprintln(linearize(simplified_sys, linfun; op = Dict(x => 1.0)))\nprintln(linearize(simplified_sys, linfun; op = Dict(x => 0.0)))\n\n@time linearize(simplified_sys, linfun; op = Dict(x => 0.0))\n\nnothing # hide\n\nHowever, this route is still expensive since it has to repeatedly process the symbolic map provided to op. linearize is simply a wrapper for creating and solving a ModelingToolkit.LinearizationProblem. This object is symbolically indexable, and can thus integrate with SymbolicIndexingInterface.jl for fast updates.\n\nusing SymbolicIndexingInterface\n\n# The second argument is the value of the independent variable `t`.\nlinprob = LinearizationProblem(linfun, 1.0)\n# It can be mutated\nlinprob.t = 0.0\n# create a setter function to update `x` efficiently\nsetter! = setu(linprob, x)\n\nfunction fast_linearize!(problem, setter!, value)\n    setter!(problem, value)\n    solve(problem)\nend\n\nprintln(fast_linearize!(linprob, setter!, 1.0))\nprintln(fast_linearize!(linprob, setter!, 0.0))\n\n@time fast_linearize!(linprob, setter!, 1.0)\n\nnothing # hide\n\nNote that linprob above can be interacted with similar to a normal ODEProblem.\n\nprob[x]\nprob[x] = 1.5\nprob[x]","category":"section"},{"location":"basics/Linearization/#Symbolic-linearization","page":"Linearization","title":"Symbolic linearization","text":"The function ModelingToolkit.linearize_symbolic works similar to ModelingToolkit.linearize but returns symbolic rather than numeric Jacobians. Symbolic linearization have several limitations and no all systems that can be linearized numerically can be linearized symbolically.","category":"section"},{"location":"basics/Linearization/#Input-derivatives","page":"Linearization","title":"Input derivatives","text":"Physical systems are always proper, i.e., they do not differentiate causal inputs. However, ModelingToolkit allows you to model non-proper systems, such as inverse models, and may sometimes fail to find a realization of a proper system on proper form. In these situations, linearize may throw an error mentioning\n\nInput derivatives appeared in expressions (-g_z\\g_u != 0)\n\nThis means that to simulate this system, some order of derivatives of the input is required. To allow linearize to proceed in this situation, one may pass the keyword argument allow_input_derivatives = true, in which case the resulting model will have twice as many inputs, 2n_u, where the last n_u inputs correspond to dot u.\n\nIf the modeled system is actually proper (but MTK failed to find a proper realization), further numerical simplification can be applied to the resulting statespace system to obtain a proper form. Such simplification is currently available in the package ControlSystemsMTK.","category":"section"},{"location":"basics/Linearization/#Tools-for-linear-analysis","page":"Linearization","title":"Tools for linear analysis","text":"ModelingToolkit contains a set of tools for more advanced linear analysis. These can be used to make it easier to work with and analyze causal models, such as control and signal-processing systems.\n\nAlso see ControlSystemsMTK.jl for an interface to ControlSystems.jl that contains tools for linear analysis and frequency-domain analysis.","category":"section"},{"location":"basics/Linearization/#Docstrings","page":"Linearization","title":"Docstrings","text":"Pages = [\"Linearization.md\"]","category":"section"},{"location":"basics/Linearization/#ModelingToolkit.linearize-basics-Linearization","page":"Linearization","title":"ModelingToolkit.linearize","text":"(; A, B, C, D), simplified_sys, extras = linearize(sys, inputs, outputs;    t=0.0, op = Dict(), allow_input_derivatives = false, zero_dummy_der=false, kwargs...)\n(; A, B, C, D), extras                 = linearize(simplified_sys, lin_fun; t=0.0, op = Dict(), allow_input_derivatives = false, zero_dummy_der=false)\n\nLinearize sys between inputs and outputs, both vectors of variables. Return a NamedTuple with the matrices of a linear statespace representation on the form\n\nbeginaligned\nx = Ax + Bu\ny = Cx + Du\nendaligned\n\nThe first signature automatically calls linearization_function internally, while the second signature expects the outputs of linearization_function as input.\n\nop denotes the operating point around which to linearize. If none is provided, the default values of sys are used.\n\nIf allow_input_derivatives = false, an error will be thrown if input derivatives (u) appear as inputs in the linearized equations. If input derivatives are allowed, the returned B matrix will be of double width, corresponding to the input [u; u̇].\n\nzero_dummy_der can be set to automatically set the operating point to zero for all dummy derivatives.\n\nThe return value extras is a NamedTuple (; x, p, t) containing the result of the initialization problem that was solved to determine the operating point.\n\nSee also linearization_function which provides a lower-level interface, linearize_symbolic and ModelingToolkit.reorder_unknowns.\n\nSee extended help for an example.\n\nThe implementation and notation follows that of \"Linear Analysis Approach for Modelica Models\", Allain et al. 2009\n\nExtended help\n\nThis example builds the following feedback interconnection and linearizes it from the input of F to the output of P.\n\n\n  r ┌─────┐       ┌─────┐     ┌─────┐\n───►│     ├──────►│     │  u  │     │\n    │  F  │       │  C  ├────►│  P  │ y\n    └─────┘     ┌►│     │     │     ├─┬─►\n                │ └─────┘     └─────┘ │\n                │                     │\n                └─────────────────────┘\n\nusing ModelingToolkit\nusing ModelingToolkit: t_nounits as t, D_nounits as D\nfunction plant(; name)\n    @variables x(t) = 1\n    @variables u(t)=0 y(t)=0\n    eqs = [D(x) ~ -x + u\n           y ~ x]\n    System(eqs, t; name = name)\nend\n\nfunction ref_filt(; name)\n    @variables x(t)=0 y(t)=0\n    @variables u(t)=0 [input = true]\n    eqs = [D(x) ~ -2 * x + u\n           y ~ x]\n    System(eqs, t, name = name)\nend\n\nfunction controller(kp; name)\n    @variables y(t)=0 r(t)=0 u(t)=0\n    @parameters kp = kp\n    eqs = [\n        u ~ kp * (r - y),\n    ]\n    System(eqs, t; name = name)\nend\n\n@named f = ref_filt()\n@named c = controller(1)\n@named p = plant()\n\nconnections = [f.y ~ c.r # filtered reference to controller reference\n               c.u ~ p.u # controller output to plant input\n               p.y ~ c.y]\n\n@named cl = System(connections, t, systems = [f, c, p])\n\nlsys0, ssys = linearize(cl, [f.u], [p.x])\ndesired_order = [f.x, p.x]\nlsys = ModelingToolkit.reorder_unknowns(lsys0, unknowns(ssys), desired_order)\n\n@assert lsys.A == [-2 0; 1 -2]\n@assert lsys.B == [1; 0;;]\n@assert lsys.C == [0 1]\n@assert lsys.D[] == 0\n\n## Symbolic linearization\nlsys_sym, _ = ModelingToolkit.linearize_symbolic(cl, [f.u], [p.x])\n\n@assert substitute(lsys_sym.A, ModelingToolkit.defaults(cl)) == lsys.A\n\n\n\n\n\n","category":"function"},{"location":"basics/Linearization/#ModelingToolkit.linearize_symbolic-basics-Linearization","page":"Linearization","title":"ModelingToolkit.linearize_symbolic","text":"(; A, B, C, D), simplified_sys = linearize_symbolic(sys::AbstractSystem, inputs, outputs; simplify = false, allow_input_derivatives = false, kwargs...)\n\nSimilar to linearize, but returns symbolic matrices A,B,C,D rather than numeric. While linearize uses ForwardDiff to perform the linearization, this function uses Symbolics.jacobian.\n\nSee linearize for a description of the arguments.\n\nExtended help\n\nThe named tuple returned as the first argument additionally contains the jacobians f_x, f_z, g_x, g_z, f_u, g_u, h_x, h_z, h_u of\n\nbeginaligned\nx = f(x z u) \n0 = g(x z u) \ny = h(x z u)\nendaligned\n\nwhere x are differential unknown variables, z algebraic variables, u inputs and y outputs.\n\n\n\n\n\n","category":"function"},{"location":"basics/Linearization/#ModelingToolkit.linearization_function-basics-Linearization","page":"Linearization","title":"ModelingToolkit.linearization_function","text":"lin_fun, simplified_sys = linearization_function(sys::AbstractSystem, inputs, outputs; simplify = false, initialize = true, initialization_solver_alg = nothing, kwargs...)\n\nReturn a function that linearizes the system sys. The function linearize provides a higher-level and easier to use interface.\n\nlin_fun is a function (variables, p, t) -> (; f_x, f_z, g_x, g_z, f_u, g_u, h_x, h_z, h_u), i.e., it returns a NamedTuple with the Jacobians of f,g,h for the nonlinear sys (technically for simplified_sys) on the form\n\nbeginaligned\nx = f(x z u) \n0 = g(x z u) \ny = h(x z u)\nendaligned\n\nwhere x are differential unknown variables, z algebraic variables, u inputs and y outputs. To obtain a linear statespace representation, see linearize. The input argument variables is a vector defining the operating point, corresponding to unknowns(simplified_sys) and p is a vector corresponding to the parameters of simplified_sys. Note: all variables in inputs have been converted to parameters in simplified_sys.\n\nThe simplified_sys has undergone mtkcompile and had any occurring input or output variables replaced with the variables provided in arguments inputs and outputs. The unknowns of this system also indicate the order of the unknowns that holds for the linearized matrices.\n\nArguments:\n\nsys: A System of ODEs. This function will automatically apply simplification passes on sys and return the resulting simplified_sys.\ninputs: A vector of variables that indicate the inputs of the linearized input-output model.\noutputs: A vector of variables that indicate the outputs of the linearized input-output model.\nsimplify: Apply simplification in tearing.\ninitialize: If true, a check is performed to ensure that the operating point is consistent (satisfies algebraic equations). If the op is not consistent, initialization is performed.\ninitialization_solver_alg: A NonlinearSolve algorithm to use for solving for a feasible set of state and algebraic variables that satisfies the specified operating point.\nautodiff: An ADType supported by DifferentiationInterface.jl to use for calculating the necessary jacobians. Defaults to using AutoForwardDiff()\nkwargs: Are passed on to find_solvables!\n\nSee also linearize which provides a higher-level interface.\n\n\n\n\n\n","category":"function"},{"location":"basics/Linearization/#ModelingToolkit.LinearizationProblem-basics-Linearization","page":"Linearization","title":"ModelingToolkit.LinearizationProblem","text":"mutable struct LinearizationProblem{F<:ModelingToolkit.LinearizationFunction, T}\n\nA struct representing a linearization operation to be performed. Can be symbolically indexed to efficiently update the operating point for multiple linearizations in a loop. The value of the independent variable can be set by mutating the .t field of this struct.\n\n\n\n\n\n","category":"type"},{"location":"basics/DependencyGraphs/#Dependency-Graphs","page":"Dependency Graphs","title":"Dependency Graphs","text":"","category":"section"},{"location":"basics/DependencyGraphs/#Types","page":"Dependency Graphs","title":"Types","text":"","category":"section"},{"location":"basics/DependencyGraphs/#Utility-functions-for-BiPartiteGraphs","page":"Dependency Graphs","title":"Utility functions for BiPartiteGraphs","text":"","category":"section"},{"location":"basics/DependencyGraphs/#Functions-for-calculating-dependency-graphs","page":"Dependency Graphs","title":"Functions for calculating dependency graphs","text":"","category":"section"},{"location":"basics/DependencyGraphs/#Miscellaneous","page":"Dependency Graphs","title":"Miscellaneous","text":"","category":"section"},{"location":"basics/DependencyGraphs/#ModelingToolkit.map_variables_to_equations","page":"Dependency Graphs","title":"ModelingToolkit.map_variables_to_equations","text":"map_variables_to_equations(\n    sys::ModelingToolkitBase.AbstractSystem;\n    rename_dummy_derivatives\n) -> Dict{Union{Num, SymbolicUtils.BasicSymbolicImpl.var\"typeof(BasicSymbolicImpl)\"{T} where T}, Equation}\n\n\nGiven a system that has been simplified via mtkcompile, return a Dict mapping variables of the system to equations that are used to solve for them. This includes observed variables.\n\nKeyword Arguments\n\nrename_dummy_derivatives: Whether to rename dummy derivative variable keys into their Differential forms. For example, this would turn the key yˍt(t) into Differential(t)(y(t)).\n\n\n\n\n\n","category":"function"},{"location":"getting_started/odes/#getting_started_ode","page":"Building ODEs and DAEs with ModelingToolkit.jl","title":"Building ODEs and DAEs with ModelingToolkit.jl","text":"This is an introductory tutorial for ModelingToolkit.jl (MTK). We will demonstrate the basics of the package by demontrating how to build systems of Ordinary Differential Equations (ODEs) and Differential-Algebraic Equations (DAEs).","category":"section"},{"location":"getting_started/odes/#Installing-ModelingToolkit","page":"Building ODEs and DAEs with ModelingToolkit.jl","title":"Installing ModelingToolkit","text":"To install ModelingToolkit, use the Julia package manager. This can be done as follows:\n\nusing Pkg\nPkg.add(\"ModelingToolkit\")","category":"section"},{"location":"getting_started/odes/#The-end-goal","page":"Building ODEs and DAEs with ModelingToolkit.jl","title":"The end goal","text":"TODO","category":"section"},{"location":"getting_started/odes/#Basics-of-MTK","page":"Building ODEs and DAEs with ModelingToolkit.jl","title":"Basics of MTK","text":"ModelingToolkit.jl is a symbolic-numeric system. This means it allows specifying a model (such as an ODE) in a similar way to how it would be written on paper. Let's start with a simple example. The system to be modeled is a first-order lag element:\n\ndotx = fracf(t) - x(t)tau\n\nHere, t is the independent variable (time), x(t) is the (scalar) unknown variable, f(t) is an external forcing function, and tau is a parameter.\n\nFor simplicity, we will start off by setting the forcing function to a constant 1. Every ODE has a single independent variable. MTK has a common definition for time t and the derivative with respect to it.\n\nusing ModelingToolkit\nusing ModelingToolkit: t_nounits as t, D_nounits as D\n\nNext, we declare the (dependent) variables and the parameters of our model:\n\n@variables x(t)\n@parameters τ\n\nNote the syntax x(t). We must declare that the variable x is a function of the independent variable t. Next, we define the equations of the system:\n\neqs = [D(x) ~ (1 - x) / τ]\n\nSince = is reserved as the assignment operator, MTK uses ~ to denote equality between expressions. Now we must consolidate all of this information about our system of ODEs into ModelingToolkit's System type.\n\nsys = System(eqs, t, [x], [τ]; name = :sys)\n\nThe System constructor accepts a Vector{Equation} as the first argument, followed by the independent variable, a list of dependent variables, and a list of parameters. Every system must be given a name via the name keyword argument. Most of the time, we want to name our system the same as the variable it is assigned to. The @named macro helps with this:\n\n@named sys = System(eqs, t, [x], [τ])\n\nAdditionally, it may become inconvenient to specify all variables and parameters every time a system is created. MTK allows omitting these arguments, and will automatically infer them from the equations.\n\n@named sys = System(eqs, t)\n\nOur system is not quite ready for simulation yet. First, we must use the mtkcompile function which transforms the system into a form that MTK can handle. For our trivial system, this does not do much.\n\nsimp_sys = mtkcompile(sys)\n\nSince building and simplifying a system is a common workflow, MTK provides the @mtkcompile macro for convenience.\n\n@mtkcompile sys = System(eqs, t)\n\nWe can now build an ODEProblem from the system. ModelingToolkit generates the necessary code for numerical ODE solvers to solve this system. We need to provide an initial value for the variable x and a value for the parameter p, as well as the time span for which to simulate the system.\n\nprob = ODEProblem(sys, [x => 0.0, τ => 3.0], (0.0, 10.0))\n\nHere, we are saying that x should start at 0.0, τ should be 3.0 and the system should be simulated from t = 0.0 to t = 10.0. To solve the system, we must import a solver.\n\nusing OrdinaryDiffEq\n\nsol = solve(prob)\n\nOrdinaryDiffEq.jl contains a large number of numerical solvers. It also comes with a default solver which is used when calling solve(prob) and is capable of handling a large variety of systems.\n\nWe can obtain the timeseries of x by indexing the solution with the symbolic variable:\n\nsol[x]\n\nWe can even obtain timeseries of complicated expressions involving the symbolic variables in the model\n\nsol[(1 - x) / τ]\n\nPerhaps more interesting is a plot of the solution. This can easily be achieved using Plots.jl.\n\nusing Plots\n\nplot(sol)\n\nSimilarly, we can plot different expressions:\n\nplot(sol; idxs = (1 - x) / τ)","category":"section"},{"location":"tutorials/acausal_components/#acausal","page":"Acausal Component-Based Modeling","title":"Acausal Component-Based Modeling","text":"In this tutorial, we will build a hierarchical acausal component-based model of the RC circuit. The RC circuit is a simple example where we connect a resistor and a capacitor. Kirchhoff's laws are then applied to state equalities between currents and voltages. This specifies a differential-algebraic equation (DAE) system, where the algebraic equations are given by the constraints and equalities between different component variables. We then simplify this to an ODE by eliminating the equalities before solving. Let's see this in action.\n\nnote: Note\nThis tutorial teaches how to build the entire RC circuit from scratch. However, to simulate electric components with more ease, check out the ModelingToolkitStandardLibrary.jl which includes a tutorial for simulating RC circuits with pre-built components","category":"section"},{"location":"tutorials/acausal_components/#Copy-Paste-Example","page":"Acausal Component-Based Modeling","title":"Copy-Paste Example","text":"using ModelingToolkit, Plots, OrdinaryDiffEq, Setfield\nusing ModelingToolkit: t_nounits as t, D_nounits as D\n\n# Define the Pin connector\nfunction Pin(; name)\n    @variables v(t) i(t) [connect = Flow]\n    sys = System(Equation[], t, [v, i], []; name)\n    sys = @set sys.connector_type = ModelingToolkit.connector_type(sys)\n    return sys\nend\n\n# Define Ground component\nfunction Ground(; name)\n    @named g = Pin()\n    eqs = [g.v ~ 0]\n    System(eqs, t, [], []; systems = [g], name)\nend\n\n# Define OnePort base component\nfunction OnePort(; name)\n    @named p = Pin()\n    @named n = Pin()\n    @variables v(t) i(t)\n    eqs = [\n        v ~ p.v - n.v\n        0 ~ p.i + n.i\n        i ~ p.i\n    ]\n    System(eqs, t, [v, i], []; systems = [p, n], name)\nend\n\n# Define Resistor component\nfunction Resistor(; name, R = 1.0)\n    @named oneport = OnePort()\n    @unpack v, i = oneport\n    @parameters R = R # Sets the default resistance\n    eqs = [v ~ i * R]\n    extend(System(eqs, t, [], [R]; name), oneport)\nend\n\n# Define Capacitor component\nfunction Capacitor(; name, C = 1.0)\n    @named oneport = OnePort()\n    @unpack v, i = oneport\n    @parameters C = C\n    eqs = [D(v) ~ i / C]\n    extend(System(eqs, t, [], [C]; name), oneport)\nend\n\n# Define ConstantVoltage source\nfunction ConstantVoltage(; name, V = 1.0)\n    @named oneport = OnePort()\n    @unpack v = oneport\n    @parameters V = V\n    eqs = [V ~ v]\n    extend(System(eqs, t, [], [V]; name), oneport)\nend\n\n# Build the RC circuit\n@named resistor = Resistor(R = 2.0)\n@named capacitor = Capacitor(C = 1.0)\n@named source = ConstantVoltage(V = 1.0)\n@named ground = Ground()\n\nrc_eqs = [\n    connect(source.p, resistor.p)\n    connect(resistor.n, capacitor.p)\n    connect(capacitor.n, source.n)\n    connect(capacitor.n, ground.g)\n]\n\n@named rc_model = System(rc_eqs, t; systems = [resistor, capacitor, source, ground])\nrc_model = mtkcompile(rc_model)\n\nu0 = [\n    rc_model.capacitor.v => 0.0\n]\nprob = ODEProblem(rc_model, u0, (0, 10.0))\nsol = solve(prob)\nplot(sol)","category":"section"},{"location":"tutorials/acausal_components/#Explanation","page":"Acausal Component-Based Modeling","title":"Explanation","text":"We wish to build the following RC circuit by building individual components and connecting the pins:\n\n(Image: )","category":"section"},{"location":"tutorials/acausal_components/#Building-the-Component-Library","page":"Acausal Component-Based Modeling","title":"Building the Component Library","text":"For each of our components, we define a function that returns a System. At the top, we start with defining the fundamental qualities of an electric circuit component. At every input and output pin, a circuit component has two values: the current at the pin and the voltage. Thus we define the Pin connector to simply be the values there. Whenever two Pins in a circuit are connected together, the system satisfies Kirchhoff's laws, i.e. that currents sum to zero and voltages across the pins are equal. [connect = Flow] informs MTK that currents ought to sum to zero, and by default, variables are equal in a connection.\n\nfunction Pin(; name)\n    @variables v(t) i(t) [connect = Flow]\n    sys = System(Equation[], t, [v, i], []; name)\n    sys = @set sys.connector_type = ModelingToolkit.connector_type(sys)\n    return sys\nend\n\nNote that this is an incompletely specified System: it cannot be simulated on its own because the equations for v(t) and i(t) are unknown. Instead, this just gives a common syntax for receiving this pair with some default values. One can then construct a Pin using the @named helper macro:\n\n@named mypin1 = Pin()\n\nNext, we build our ground node. A ground node is just a pin that is connected to a constant voltage reservoir, typically taken to be V = 0. Thus to define this component, we generate a System with a Pin subcomponent and specify that the voltage in such a Pin is equal to zero. This gives:\n\nfunction Ground(; name)\n    @named g = Pin()\n    eqs = [g.v ~ 0]\n    System(eqs, t, [], []; systems = [g], name)\nend\n\nNext we build a OnePort: an abstraction for all simple electric component with two pins. The voltage difference between the positive pin and the negative pin is the voltage of the component, the current between two pins must sum to zero, and the current of the component equals to the current of the positive pin.\n\nfunction OnePort(; name)\n    @named p = Pin()\n    @named n = Pin()\n    @variables v(t) i(t)\n    eqs = [\n        v ~ p.v - n.v\n        0 ~ p.i + n.i\n        i ~ p.i\n    ]\n    System(eqs, t, [v, i], []; systems = [p, n], name)\nend\n\nNext we build a resistor. A resistor is an object that has two Pins, the positive and the negative pins, and follows Ohm's law: v = i*r. The voltage of the resistor is given as the voltage difference across the two pins, while by conservation of charge we know that the current in must equal the current out, which means (no matter the direction of the current flow) the sum of the currents must be zero. This leads to our resistor equations:\n\nfunction Resistor(; name, R = 1.0)\n    @named oneport = OnePort()\n    @unpack v, i = oneport\n    @parameters R = R # Sets the default resistance\n    eqs = [v ~ i * R]\n    extend(System(eqs, t, [], [R]; name), oneport)\nend\n\nNotice that we have created this system with a default parameter R for the resistor's resistance. By doing so, if the resistance of this resistor is not overridden by a higher level default or overridden at ODEProblem construction time, this will be the value of the resistance. Also, note the use of extend. For the Resistor, we want to simply inherit OnePort's equations and unknowns and extend them with a new equation. Note that v, i are unpacked from oneport using @unpack.\n\nUsing our knowledge of circuits, we similarly construct the Capacitor:\n\nfunction Capacitor(; name, C = 1.0)\n    @named oneport = OnePort()\n    @unpack v, i = oneport\n    @parameters C = C\n    eqs = [D(v) ~ i / C]\n    extend(System(eqs, t, [], [C]; name), oneport)\nend\n\nNow we want to build a constant voltage electric source term. We can think of this as similarly being a two pin object, where the object itself is kept at a constant voltage, essentially generating the electric current. We would then model this as:\n\nfunction ConstantVoltage(; name, V = 1.0)\n    @named oneport = OnePort()\n    @unpack v = oneport\n    @parameters V = V\n    eqs = [V ~ v]\n    extend(System(eqs, t, [], [V]; name), oneport)\nend","category":"section"},{"location":"tutorials/acausal_components/#Connecting-and-Simulating-Our-Electric-Circuit","page":"Acausal Component-Based Modeling","title":"Connecting and Simulating Our Electric Circuit","text":"Now we are ready to simulate our circuit. Let's build our four components: a resistor, capacitor, source, and ground term. For simplicity, we will make all of our parameter values 1.0, except the resistor which we set to 2.0.\n\n@named resistor = Resistor(R = 2.0)\n@named capacitor = Capacitor(C = 1.0)\n@named source = ConstantVoltage(V = 1.0)\n@named ground = Ground()\n\nrc_eqs = [\n    connect(source.p, resistor.p)\n    connect(resistor.n, capacitor.p)\n    connect(capacitor.n, source.n)\n    connect(capacitor.n, ground.g)\n]\n\n@named rc_model = System(rc_eqs, t; systems = [resistor, capacitor, source, ground])\nrc_model = mtkcompile(rc_model)\n\nThis model is acausal because we have not specified anything about the causality of the model. We have simply specified what is true about each of the variables. This forms a system of differential-algebraic equations (DAEs) which define the evolution of each unknown of the system. The equations are:\n\nequations(expand_connections(rc_model))\n\nthe unknowns are:\n\nunknowns(rc_model)\n\nand the parameters are:\n\nparameters(rc_model)\n\nThe observed equations are:\n\nobserved(rc_model)","category":"section"},{"location":"tutorials/acausal_components/#Solving-this-System","page":"Acausal Component-Based Modeling","title":"Solving this System","text":"We are left with a system of only two equations with two unknown variables. One of the equations is a differential equation, while the other is an algebraic equation. We can then give the values for the initial conditions of our unknowns, and solve the system by converting it to an ODEProblem in mass matrix form and solving it with an ODEProblem mass matrix DAE solver. This is done as follows:\n\nu0 = [rc_model.capacitor.v => 0.0]\n\nprob = ODEProblem(rc_model, u0, (0, 10.0))\nsol = solve(prob)\nplot(sol)\n\nBy default, this plots only the unknown variables that had to be solved for. However, what if we wanted to plot the timeseries of a different variable? Do not worry, that information was not thrown away! Instead, transformations like mtkcompile simply change unknown variables into observables which are defined by observed equations.\n\nobserved(rc_model)\n\nThese are explicit algebraic equations which can then be used to reconstruct the required variables on the fly. This leads to dramatic computational savings because implicitly solving an ODE scales like O(n^3), so making there be as few unknowns as possible is good!\n\nThe solution object can be accessed via its symbols. For example, let's retrieve the voltage of the resistor over time:\n\nsol[rc_model.resistor.v]\n\nor we can plot the timeseries of the resistor's voltage:\n\nplot(sol, idxs = [rc_model.resistor.v])\n\nAlthough it may be more confusing than helpful here, we can of course also plot all unknown and observed variables together:\n\nplot(sol, idxs = [unknowns(rc_model); observables(rc_model)])","category":"section"},{"location":"tutorials/parameter_identifiability/#Parameter-Identifiability-in-ODE-Models","page":"Parameter Identifiability in ODE Models","title":"Parameter Identifiability in ODE Models","text":"Ordinary differential equations are commonly used for modeling real-world processes. The problem of parameter identifiability is one of the key design challenges for mathematical models. A parameter is said to be identifiable if one can recover its value from experimental data. Structural identifiability is a theoretical property of a model that answers this question. In this tutorial, we will show how to use StructuralIdentifiability.jl with ModelingToolkit.jl to assess identifiability of parameters in ODE models. The theory behind StructuralIdentifiability.jl is presented in paper [4].\n\nWe will start by illustrating local identifiability in which a parameter is known up to finitely many values, and then proceed to determining global identifiability, that is, which parameters can be identified uniquely.\n\nThe package has a standalone data structure for ordinary differential equations, but is also compatible with System type from ModelingToolkit.jl.","category":"section"},{"location":"tutorials/parameter_identifiability/#Local-Identifiability","page":"Parameter Identifiability in ODE Models","title":"Local Identifiability","text":"","category":"section"},{"location":"tutorials/parameter_identifiability/#Input-System","page":"Parameter Identifiability in ODE Models","title":"Input System","text":"We will consider the following model:\n\nbegincases\nfracdx_4dt = - frack_5 x_4k_6 + x_4\nfracdx_5dt = frack_5 x_4k_6 + x_4 - frack_7 x_5(k_8 + x_5 + x_6)\nfracdx_6dt = frack_7 x_5(k_8 + x_5 + x_6) - frack_9  x_6  (k_10 - x_6) k_10\nfracdx_7dt = frack_9  x_6  (k_10 - x_6) k_10\ny_1 = x_4\ny_2 = x_5endcases\n\nThis model describes the biohydrogenation[1] process[2] with unknown initial conditions.","category":"section"},{"location":"tutorials/parameter_identifiability/#Using-the-System-object","page":"Parameter Identifiability in ODE Models","title":"Using the System object","text":"To define the ode system in Julia, we use ModelingToolkit.jl.\n\nWe first define the parameters, variables, differential equations and the output equations.\n\nusing StructuralIdentifiability, ModelingToolkit\nusing ModelingToolkit: t_nounits as t, D_nounits as D\n\n@variables x4(t) x5(t) x6(t) x7(t) y1(t) [output = true] y2(t) [output = true]\n@parameters k5 k6 k7 k8 k9 k10\n\neqs = [\n    D(x4) ~ -k5 * x4 / (k6 + x4)\n    D(x5) ~ k5 * x4 / (k6 + x4) - k7 * x5 / (k8 + x5 + x6)\n    D(x6) ~ k7 * x5 / (k8 + x5 + x6) - k9 * x6 * (k10 - x6) / k10\n    D(x7) ~ k9 * x6 * (k10 - x6) / k10\n    y1 ~ x4\n    y2 ~ x5\n]\n\n@named de_model = System(eqs, t)\nde = mtkcompile(de_model)\n\nAfter that, we are ready to check the system for local identifiability:\n\n# query local identifiability\n# we pass the ode-system\nlocal_id_all = assess_local_identifiability(de, prob_threshold = 0.99)\n\nWe can see that all unknowns (except x_7) and all parameters are locally identifiable with probability 0.99.\n\nLet's try to check specific parameters and their combinations\n\nto_check = [de.k5, de.k7, de.k10 / de.k9, de.k5 + de.k6]\nlocal_id_some = assess_local_identifiability(\n    de, funcs_to_check = to_check, prob_threshold = 0.99)\n\nNotice that in this case, everything (except the unknown variable x_7) is locally identifiable, including combinations such as k_10k_9 k_5+k_6","category":"section"},{"location":"tutorials/parameter_identifiability/#Global-Identifiability","page":"Parameter Identifiability in ODE Models","title":"Global Identifiability","text":"In this part tutorial, let us cover an example problem of querying the ODE for globally identifiable parameters.","category":"section"},{"location":"tutorials/parameter_identifiability/#Input-System-2","page":"Parameter Identifiability in ODE Models","title":"Input System","text":"Let us consider the following four-dimensional model with two outputs:\n\nbegincases\nx_1(t) = -b  x_1(t) + frac1  c + x_4(t)\nx_2(t) = alpha  x_1(t) - beta  x_2(t)\nx_3(t) = gamma  x_2(t) - delta  x_3(t)\nx_4(t) = sigma  x_4(t)  frac(gamma x_2(t) - delta x_3(t)) x_3(t)\ny(t) = x_1(t)\nendcases\n\nWe will run a global identifiability check on this enzyme dynamics[3] model. We will use the default settings: the probability of correctness will be p=0.99 and we are interested in identifiability of all possible parameters.\n\nGlobal identifiability needs information about local identifiability first, but the function we chose here will take care of that extra step for us.\n\nusing StructuralIdentifiability, ModelingToolkit\nusing ModelingToolkit: t_nounits as t, D_nounits as D\n\n@parameters b c α β γ δ σ\n@variables x1(t) x2(t) x3(t) x4(t) y(t) [output = true] y2(t) [output = true]\n\neqs = [\n    D(x1) ~ -b * x1 + 1 / (c + x4)\n    D(x2) ~ α * x1 - β * x2\n    D(x3) ~ γ * x2 - δ * x3\n    D(x4) ~ σ * x4 * (γ * x2 - δ * x3) / x3\n    y ~ x1 + x2\n    y2 ~ x2\n]\n\n@named ode = System(eqs, t)\n\nglobal_id = assess_identifiability(ode)\n\nWe can see that only parameters a, g are unidentifiable, and everything else can be uniquely recovered.\n\nLet us consider the same system but with two inputs, and we will find out identifiability with probability 0.9 for parameters c and b:\n\nusing StructuralIdentifiability, ModelingToolkit\nusing ModelingToolkit: t_nounits as t, D_nounits as D\n\n@parameters b c α β γ δ σ\n@variables x1(t) x2(t) x3(t) x4(t) y(t) [output = true] y2(t) [output = true] u1(t) [input = true] u2(t) [input = true]\n\neqs = [\n    D(x1) ~ -b * x1 + 1 / (c + x4)\n    D(x2) ~ α * x1 - β * x2 - u1\n    D(x3) ~ γ * x2 - δ * x3 + u2\n    D(x4) ~ σ * x4 * (γ * x2 - δ * x3) / x3\n    y ~ x1 + x2\n    y2 ~ x2\n]\n\n@named ode_model = System(eqs, t)\node = mtkcompile(ode_model)\n\n# check only 2 parameters\nto_check = [ode.b, ode.c]\n\nglobal_id = assess_identifiability(ode, funcs_to_check = to_check, prob_threshold = 0.9)\n\nBoth parameters b, c are globally identifiable with probability 0.9 in this case.\n\n[1]: R. Munoz-Tamayo, L. Puillet, J.B. Daniel, D. Sauvant, O. Martin, M. Taghipoor, P. Blavy Review: To be or not to be an identifiable model. Is this a relevant question in animal science modelling?, Animal, Vol 12 (4), 701-712, 2018. The model is the ODE system (3) in Supplementary Material 2, initial conditions are assumed to be unknown.\n\n[2]: Moate P.J., Boston R.C., Jenkins T.C. and Lean I.J., Kinetics of Ruminal Lipolysis of Triacylglycerol and Biohydrogenationof Long-Chain Fatty Acids: New Insights from Old Data, Journal of Dairy Science 91, 731–742, 2008\n\n[3]: Goodwin, B.C. Oscillatory behavior in enzymatic control processes, Advances in Enzyme Regulation, Vol 3 (C), 425-437, 1965\n\n[4]: Dong, R., Goodbrake, C., Harrington, H. A., & Pogudin, G. Computing input-output projections of dynamical models with applications to structural identifiability. arXiv preprint arXiv:2111.00991.","category":"section"},{"location":"basics/Validation/#units","page":"Model Validation and Units","title":"Model Validation and Units","text":"ModelingToolkit.jl provides extensive functionality for model validation and unit checking. This is done by providing metadata to the variable types and then running the validation functions which identify malformed systems and non-physical equations. This approach provides high performance and compatibility with numerical solvers.","category":"section"},{"location":"basics/Validation/#Assigning-Units","page":"Model Validation and Units","title":"Assigning Units","text":"Units may be assigned with the following syntax.\n\nusing ModelingToolkit, DynamicQuantities\n@independent_variables t [unit = u\"s\"]\n@variables x(t) [unit = u\"m\"] g(t) w(t) [unit = u\"Hz\"]\n\n@parameters(t, [unit = u\"s\"])\n@variables(x(t), [unit = u\"m\"], g(t), w(t), [unit = u\"Hz\"])\n\n@parameters begin\n    t, [unit = u\"s\"]\nend\n@variables(begin\n    x(t), [unit = u\"m\"],\n    g(t),\n    w(t), [unit = u\"Hz\"]\nend)\n\n# Simultaneously set default value (use plain numbers, not quantities)\n@variables x=10 [unit = u\"m\"]\n\n# Symbolic array: unit applies to all elements\n@variables x[1:3] [unit = u\"m\"]\n\nDo not use quantities such as  1u\"s\", 1/u\"s\" or u\"1/s\" as these will result in errors; instead use u\"s\", u\"s^-1\", or u\"s\"^-1.","category":"section"},{"location":"basics/Validation/#Unit-Validation-and-Inspection","page":"Model Validation and Units","title":"Unit Validation & Inspection","text":"Unit validation of equations happens automatically when creating a system. However, for debugging purposes, one may wish to validate the equations directly using validate.\n\nInside, validate uses get_unit, which may be directly applied to any term. Note that validate will not throw an error in the event of incompatible units, but get_unit will. If you would rather receive a warning instead of an error, use safe_get_unit which will yield nothing in the event of an error. Unit agreement is tested with ModelingToolkit.equivalent(u1,u2).\n\nExample usage below. Note that ModelingToolkit does not force unit conversions to preferred units in the event of nonstandard combinations – it merely checks that the equations are consistent.\n\nusing ModelingToolkit, DynamicQuantities\n@independent_variables t [unit = u\"ms\"]\n@parameters τ [unit = u\"ms\"]\n@variables E(t) [unit = u\"kJ\"] P(t) [unit = u\"MW\"]\nD = Differential(t)\neqs = [D(E) ~ P - E / τ,\n    0 ~ P]\nModelingToolkit.validate(eqs)\n\nModelingToolkit.validate(eqs[1])\n\ntry\n    ModelingToolkit.get_unit(eqs[1].rhs)\ncatch e\n    showerror(stdout, e)\nend\n\nAn example of an inconsistent system: at present, ModelingToolkit requires that the units of all terms in an equation or sum to be equal-valued (ModelingToolkit.equivalent(u1,u2)), rather than simply dimensionally consistent. In the future, the validation stage may be upgraded to support the insertion of conversion factors into the equations.\n\nusing ModelingToolkit, DynamicQuantities\n@independent_variables t [unit = u\"ms\"]\n@parameters τ [unit = u\"ms\"]\n@variables E(t) [unit = u\"J\"] P(t) [unit = u\"MW\"]\nD = Differential(t)\neqs = [D(E) ~ P - E / τ,\n    0 ~ P]\nModelingToolkit.validate(eqs) #Returns false while displaying a warning message","category":"section"},{"location":"basics/Validation/#User-Defined-Registered-Functions-and-Types","page":"Model Validation and Units","title":"User-Defined Registered Functions and Types","text":"In order to validate user-defined types and registered functions, specialize get_unit.  Single-parameter calls to get_unit expect an object type, while two-parameter calls expect a function type as the first argument, and a vector of arguments as the second argument.\n\nusing ModelingToolkit, DynamicQuantities\nusing ModelingToolkit: t_nounits as t, D_nounits as D\n# Composite type parameter in registered function\nstruct NewType\n    f::Any\nend\n@register_symbolic dummycomplex(complex::Num, scalar)\ndummycomplex(complex, scalar) = complex.f - scalar\n\nc = NewType(1)\nModelingToolkit.get_unit(x::NewType) = ModelingToolkit.get_unit(x.f)\nfunction ModelingToolkit.get_unit(op::typeof(dummycomplex), args)\n    argunits = ModelingToolkit.get_unit.(args)\n    ModelingToolkit.get_unit(-, args)\nend\n\nsts = @variables a(t)=0 [unit = u\"cm\"]\nps = @parameters s=-1 [unit=u\"cm\"] c=c [unit=u\"cm\"]\neqs = [D(a) ~ dummycomplex(c, s);]\nsys = System(\n    eqs, t, [sts...;], [ps...;], name = :sys, checks = ~ModelingToolkit.CheckUnits)\nsys_simple = mtkcompile(sys)","category":"section"},{"location":"basics/Validation/#DynamicQuantities-Literals","page":"Model Validation and Units","title":"DynamicQuantities Literals","text":"In order for a function to work correctly during both validation & execution, the function must be unit-agnostic. That is, no unitful literals may be used. Any unitful quantity must either be a parameter or variable. For example, these equations will not validate successfully.\n\nusing ModelingToolkit, DynamicQuantities\n@independent_variables t [unit = u\"ms\"]\n@variables E(t) [unit = u\"J\"] P(t) [unit = u\"MW\"]\nD = Differential(t)\neqs = [D(E) ~ P - E / 1u\"ms\"]\nModelingToolkit.validate(eqs) #Returns false while displaying a warning message\n\nmyfunc(E) = E / 1u\"ms\"\neqs = [D(E) ~ P - myfunc(E)]\nModelingToolkit.validate(eqs) #Returns false while displaying a warning message\n\nInstead, they should be parameterized:\n\nusing ModelingToolkit, DynamicQuantities\n@independent_variables t [unit = u\"ms\"]\n@parameters τ [unit = u\"ms\"]\n@variables E(t) [unit = u\"kJ\"] P(t) [unit = u\"MW\"]\nD = Differential(t)\neqs = [D(E) ~ P - E / τ]\nModelingToolkit.validate(eqs) #Returns true\n\nmyfunc(E, τ) = E / τ\neqs = [D(E) ~ P - myfunc(E, τ)]\nModelingToolkit.validate(eqs) #Returns true\n\nIt is recommended not to circumvent unit validation by specializing user-defined functions on DynamicQuantities arguments vs. Numbers. This both fails to take advantage of validate for ensuring correctness, and may cause in errors in the future when ModelingToolkit is extended to support eliminating DynamicQuantities literals from functions.","category":"section"},{"location":"basics/Validation/#Other-Restrictions","page":"Model Validation and Units","title":"Other Restrictions","text":"DynamicQuantities provides non-scalar units such as °C, etc. At this time, ModelingToolkit only supports scalar quantities. Additionally, angular degrees (°) are not supported because trigonometric functions will treat plain numerical values as radians, which would lead systems validated using degrees to behave erroneously when being solved.","category":"section"},{"location":"basics/Validation/#Troubleshooting-and-Gotchas","page":"Model Validation and Units","title":"Troubleshooting & Gotchas","text":"If a system fails to validate due to unit issues, at least one warning message will appear, including a line number as well as the unit types and expressions that were in conflict. Some system constructors re-order equations before the unit checking can be done, in which case the equation numbers may be inaccurate. The printed expression that the problem resides in is always correctly shown.\n\nSymbolic exponents for unitful variables are supported (ex: P^γ in thermodynamics). However, this means that ModelingToolkit cannot reduce such expressions to DynamicQuantities.Quantity subtypes at validation time because the exponent value is not available. In this case ModelingToolkit.get_unit is type-unstable, yielding a symbolic result, which can still be checked for symbolic equality with ModelingToolkit.equivalent.","category":"section"},{"location":"basics/Validation/#Parameter-and-Initial-Condition-Values","page":"Model Validation and Units","title":"Parameter & Initial Condition Values","text":"Parameter and initial condition values are supplied to problem constructors as plain numbers, with the understanding that they have been converted to the appropriate units. This is done for simplicity of interfacing with optimization solvers. Some helper function for dealing with value maps:\n\nfunction remove_units(p::Dict)\n    Dict(k => DynamicQuantities.ustrip(ModelingToolkit.get_unit(k), v) for (k, v) in p)\nend\nadd_units(p::Dict) = Dict(k => v * ModelingToolkit.get_unit(k) for (k, v) in p)\n\nRecommended usage:\n\npars = @parameters τ [unit = u\"ms\"]\np = Dict(τ => 1u\"ms\")\nODEProblem(sys, remove_units(u0), tspan, remove_units(p))","category":"section"},{"location":"tutorials/bifurcation_diagram_computation/#bifurcation_diagrams","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"Bifurcation diagrams describes how, for a dynamic system, the quantity and quality of its steady states changes with a parameter's value. These can be computed through the BifurcationKit.jl package. ModelingToolkit provides a simple interface for creating BifurcationKit compatible BifurcationProblems from NonlinearSystems and Systems. All the features provided by BifurcationKit can then be applied to these systems. This tutorial provides a brief introduction for these features, with BifurcationKit.jl providing a more extensive documentation.","category":"section"},{"location":"tutorials/bifurcation_diagram_computation/#Creating-a-BifurcationProblem","page":"Bifurcation Diagrams","title":"Creating a BifurcationProblem","text":"Let us first consider a simple NonlinearSystem:\n\nusing ModelingToolkit\nusing ModelingToolkit: t_nounits as t, D_nounits as D\n\n@variables x(t) y(t)\n@parameters μ α\neqs = [0 ~ μ * x - x^3 + α * y,\n    0 ~ -y]\n@mtkcompile nsys = System(eqs, [x, y], [μ, α])\n\nwe wish to compute a bifurcation diagram for this system as we vary the parameter μ. For this, we need to provide the following information:\n\nThe system for which we wish to compute the bifurcation diagram (nsys).\nThe parameter which we wish to vary (μ).\nThe parameter set for which we want to compute the bifurcation diagram.\nAn initial guess of the state of the system for which there is a steady state at our provided parameter value.\nThe variable which value we wish to plot in the bifurcation diagram (this argument is optional, if not provided, BifurcationKit default plot functions are used).\n\nWe declare this additional information:\n\nbif_par = μ\np_start = [μ => -1.0, α => 1.0]\nu0_guess = [x => 1.0, y => 1.0]\nplot_var = x;\n\nFor the initial state guess (u0_guess), typically any value can be provided, however, read BifurcatioKit's documentation for more details.\n\nWe can now create our BifurcationProblem, which can be provided as input to BifurcationKit's various functions.\n\nusing BifurcationKit\nbprob = BifurcationProblem(nsys,\n    u0_guess,\n    p_start,\n    bif_par;\n    plot_var = plot_var,\n    jac = false)\n\nHere, the jac argument (by default set to true) sets whenever to provide BifurcationKit with a Jacobian or not.","category":"section"},{"location":"tutorials/bifurcation_diagram_computation/#Computing-a-bifurcation-diagram","page":"Bifurcation Diagrams","title":"Computing a bifurcation diagram","text":"Let us consider the BifurcationProblem from the last section. If we wish to compute the corresponding bifurcation diagram we must first declare various settings used by BifurcationKit to compute the diagram. These are stored in a ContinuationPar structure (which also contain a NewtonPar structure).\n\np_span = (-4.0, 6.0)\nopts_br = ContinuationPar(nev = 2,\n    p_min = p_span[1],\n    p_max = p_span[2])\n\nHere, p_span sets the interval over which we wish to compute the diagram.\n\nNext, we can use this as input to our bifurcation diagram, and then plot it.\n\nbf = bifurcationdiagram(bprob, PALC(), 2, (args...) -> opts_br; bothside = true)\n\nHere, the value 2 sets how sub-branches of the diagram that BifurcationKit should compute. Generally, for bifurcation diagrams, it is recommended to use the bothside=true argument.\n\nusing Plots\nplot(bf;\n    putspecialptlegend = false,\n    markersize = 2,\n    plotfold = false,\n    xguide = \"μ\",\n    yguide = \"x\")\n\nHere, the system exhibits a pitchfork bifurcation at μ=0.0.","category":"section"},{"location":"tutorials/bifurcation_diagram_computation/#Using-System-inputs","page":"Bifurcation Diagrams","title":"Using System inputs","text":"It is also possible to use Systems (rather than NonlinearSystems) as input to BifurcationProblem. Here follows a brief such example.\n\nusing BifurcationKit, ModelingToolkit, Plots\nusing ModelingToolkit: t_nounits as t, D_nounits as D\n\n@variables x(t) y(t)\n@parameters μ\neqs = [D(x) ~ μ * x - y - x * (x^2 + y^2),\n    D(y) ~ x + μ * y - y * (x^2 + y^2)]\n@mtkcompile osys = System(eqs, t)\n\nbif_par = μ\nplot_var = x\np_start = [μ => 1.0]\nu0_guess = [x => 0.0, y => 0.0]\n\nbprob = BifurcationProblem(osys,\n    u0_guess,\n    p_start,\n    bif_par;\n    plot_var = plot_var,\n    jac = false)\n\np_span = (-3.0, 3.0)\nopts_br = ContinuationPar(nev = 2,\n    p_max = p_span[2], p_min = p_span[1])\n\nbf = bifurcationdiagram(bprob, PALC(), 2, (args...) -> opts_br; bothside = true)\nusing Plots\nplot(bf;\n    putspecialptlegend = false,\n    markersize = 2,\n    plotfold = false,\n    xguide = \"μ\",\n    yguide = \"x\")\n\nHere, the value of x in the steady state does not change, however, at μ=0 a Hopf bifurcation occur and the steady state turn unstable.\n\nWe compute the branch of periodic orbits which is nearby the Hopf Bifurcation. We thus provide the branch bf.γ, the index of the Hopf point we want to branch from: 2 in this case and a method PeriodicOrbitOCollProblem(20, 5) to compute periodic orbits.\n\nbr_po = continuation(bf.γ, 2, opts_br,\n    PeriodicOrbitOCollProblem(20, 5);)\n\nplot(bf; putspecialptlegend = false,\n    markersize = 2,\n    plotfold = false,\n    xguide = \"μ\",\n    yguide = \"x\")\nplot!(br_po, xguide = \"μ\", yguide = \"x\", label = \"Maximum of periodic orbit\")\n\nLet's see how to plot the periodic solution we just computed:\n\nsol = get_periodic_orbit(br_po, 10)\nplot(sol.t, sol[1, :], yguide = \"x\", xguide = \"time\", label = \"\")","category":"section"},{"location":"basics/MTKLanguage/#mtk_language","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","text":"","category":"section"},{"location":"basics/MTKLanguage/#MTK-Model","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"MTK Model","text":"MTK represents components and connectors with Model.","category":"section"},{"location":"basics/MTKLanguage/#Components","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"Components","text":"Components are models from various domains. These models contain unknowns and their equations.","category":"section"},{"location":"basics/MTKLanguage/#mtkmodel","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"Defining components with @mtkmodel","text":"@mtkmodel is a convenience macro to define components. It returns ModelingToolkit.Model, which includes a system constructor (System by default), a structure dictionary with metadata, and flag isconnector which is set to false.","category":"section"},{"location":"basics/MTKLanguage/#What-can-an-MTK-Model-definition-have?","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"What can an MTK-Model definition have?","text":"@mtkmodel definition contains begin blocks of\n\n@description: for describing the whole system with a human-readable string\n@components: for listing sub-components of the system\n@constants: for declaring constants\n@defaults: for passing defaults to the system\n@equations: for the list of equations\n@extend: for extending a base system and unpacking its unknowns\n@icon : for embedding the model icon\n@metadata: for assigning key-value pairs as model level metadata\n@parameters: for specifying the symbolic parameters\n@structural_parameters: for specifying non-symbolic parameters\n@variables: for specifying the unknowns\n@continuous_events: for specifying a list of continuous events\n@discrete_events: for specifying a list of discrete events\n\nLet's explore these in more detail with the following example:\n\nusing ModelingToolkit\nusing ModelingToolkit: t\nusing SciCompDSL\n\n@mtkmodel ModelA begin\n    @description \"A component with parameters `k` and `k_array`.\"\n    @parameters begin\n        k\n        k_array[1:2]\n    end\nend\n\n@mtkmodel ModelB begin\n    @description \"A component with parameters `p1` and `p2`.\"\n    @parameters begin\n        p1 = 1.0, [description = \"Parameter of ModelB\"]\n        p2 = 1.0, [description = \"Parameter of ModelB\"]\n    end\nend\n\n@mtkmodel ModelC begin\n    @description \"A bigger system that contains many more things.\"\n    @icon \"https://github.com/SciML/SciMLDocs/blob/main/docs/src/assets/logo.png\"\n    @constants begin\n        c::Int = 1, [description = \"Example constant.\"]\n    end\n    @structural_parameters begin\n        f = sin\n        N = 2\n        M = 3\n    end\n    begin\n        v_var = 1.0\n    end\n    @variables begin\n        v(t) = v_var\n        v_array(t)[1:N, 1:M]\n        v_for_defaults(t)\n    end\n    @extend ModelB(p1 = 1)\n    @components begin\n        model_a = ModelA(; k_array)\n        model_array_a = [ModelA(; k = i) for i in 1:N]\n        model_array_b = for i in 1:N\n            k = i^2\n            ModelA(; k)\n        end\n    end\n    @equations begin\n        model_a.k ~ f(v)\n    end\n    @defaults begin\n        v_for_defaults => 2.0\n    end\nend\n\nstruct Author end\nstruct ModelVersion end\n@mtkmodel ModelD begin\n    @description \"A component with some metadata.\"\n    @metadata begin\n        Author = \"Test Author\"\n        ModelVersion = \"1.0.0\"\n    end\nend","category":"section"},{"location":"basics/MTKLanguage/#@description","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"@description","text":"A documenting String that summarizes and explains what the model is.","category":"section"},{"location":"basics/MTKLanguage/#@icon","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"@icon","text":"An icon can be embedded in 3 ways:\n\nURI\nPath to a valid image-file.<br> It can be an absolute path. Or, a path relative to an icon directory; which is DEPOT_PATH[1]/mtk_icons by default and can be changed by setting ENV[\"MTK_ICONS_DIR\"].<br> Internally, it is saved in the File URI scheme.\n\n@mtkmodel WithPathtoIcon begin\n    @icon \"/home/user/.julia/dev/mtk_icons/icon.png\"\n    # Rest of the model definition\nend\n\nInlined SVG.\n\n@mtkmodel WithInlinedSVGIcon begin\n    @icon \"\"\"<svg height=\"100\" width=\"100\">\n    <circle cx=\"50\" cy=\"50\" r=\"40\" stroke=\"green\" fill=\"none\" stroke-width=\"3\"/>\n    </svg>\n    \"\"\"\n    # Rest of the model definition\nend","category":"section"},{"location":"basics/MTKLanguage/#@structural_parameters-begin-block","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"@structural_parameters begin block","text":"This block is for non symbolic input arguments. These are for inputs that usually are not meant to be part of components; but influence how they are defined. One can list inputs like boolean flags, functions etc... here.\nWhenever default values are specified, unlike parameters/variables, they are reflected in the keyword argument list.","category":"section"},{"location":"basics/MTKLanguage/#@constants-begin-block","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"@constants begin block","text":"Declare constants in the model definition.\nThe values of these can't be changed by the user.\nThis works similar to symbolic constants described here","category":"section"},{"location":"basics/MTKLanguage/#@parameters-and-@variables-begin-block","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"@parameters and @variables begin block","text":"Parameters and variables are declared with respective begin blocks.\nVariables must be functions of an independent variable.\nOptionally, initial guess and metadata can be specified for these parameters and variables. See ModelB in the above example.\nAlong with creating parameters and variables, keyword arguments of same name with default value nothing are created.\nWhenever a parameter or variable has initial value, for example v(t) = 0.0, a symbolic variable named v with initial value 0.0 and a keyword argument v, with default value nothing are created. <br> This way, users can optionally pass new value of v while creating a component.\n\njulia> @mtkcompile model_c1 = ModelC(; v = 2.0);\n\njulia> ModelingToolkit.getdefault(model_c1.v)\n2.0","category":"section"},{"location":"basics/MTKLanguage/#@extend-statement","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"@extend statement","text":"One or more partial systems can be extended in a higher system with @extend statements. This can be done in two ways:\n\n@extend PartialSystem(var1 = value1)\nThis is the recommended way of extending a base system.\nThe default values for the arguments of the base system can be declared in the @extend statement.\nNote that all keyword arguments of the base system are added as the keyword arguments of the main system.\n@extend var_to_unpack1, var_to_unpack2 = partial_sys = PartialSystem(var1 = value1)\nIn this method: explicitly list the variables that should be unpacked, provide a name for the partial system and declare the base system.\nNote that only the arguments listed out in the declaration of the base system (here: var1) are added as the keyword arguments of the higher system.","category":"section"},{"location":"basics/MTKLanguage/#@components-begin-block","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"@components begin block","text":"Declare the subcomponents within @components begin block.\nArray of components can be declared with a for loop or a list comprehension.\nThe arguments in these subcomponents are promoted as keyword arguments as subcomponent_name__argname with nothing as default value.\nWhenever components are created with @named macro, these can be accessed with . operator as subcomponent_name.argname\nIn the above example, as k of model_a isn't listed while defining the sub-component in ModelC, its default value can't be modified by users. While k_array can be set as:\n\nusing ModelingToolkit: getdefault\n\n@mtkcompile model_c3 = ModelC(; model_a.k_array = [1.0, 2.0])\n\ngetdefault(model_c3.model_a.k_array[1])\n# 1.0\ngetdefault(model_c3.model_a.k_array[2])\n# 2.0","category":"section"},{"location":"basics/MTKLanguage/#@equations-begin-block","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"@equations begin block","text":"List all the equations here","category":"section"},{"location":"basics/MTKLanguage/#@defaults-begin-block","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"@defaults begin block","text":"Default values can be passed as pairs.\nThis is equivalent to passing defaults argument to the system.","category":"section"},{"location":"basics/MTKLanguage/#@continuous_events-begin-block","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"@continuous_events begin block","text":"Defining continuous events as described here.\nIf this block is not defined in the model, no continuous events will be added.\nDiscrete parameters and other keyword arguments should be specified in a vector, as seen below.\n\nusing ModelingToolkit\nusing ModelingToolkit: t\n\n@mtkmodel M begin\n    @parameters begin\n        k(t)\n    end\n    @variables begin\n        x(t)\n        y(t)\n    end\n    @equations begin\n        x ~ k * D(x)\n        D(y) ~ -k\n    end\n    @continuous_events begin\n        [x ~ 1.5] => [x ~ 5, y ~ 5]\n        [t ~ 4] => [x ~ 10]\n        [t ~ 5] => [k ~ 3], [discrete_parameters = k]\n    end\nend","category":"section"},{"location":"basics/MTKLanguage/#@discrete_events-begin-block","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"@discrete_events begin block","text":"Defining discrete events as described here.\nIf this block is not defined in the model, no discrete events will be added.\nDiscrete parameters and other keyword arguments should be specified in a vector, as seen below.\n\nusing ModelingToolkit\n\n@mtkmodel M begin\n    @parameters begin\n        k(t)\n    end\n    @variables begin\n        x(t)\n        y(t)\n    end\n    @equations begin\n        x ~ k * D(x)\n        D(y) ~ -k\n    end\n    @discrete_events begin\n        (t == 1.5) => [x ~ Pre(x) + 5, y ~ 5]\n        (t == 2.5) => [k ~ Pre(k) * 2], [discrete_parameters = k]\n    end\nend","category":"section"},{"location":"basics/MTKLanguage/#@metadata-begin-block","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"@metadata begin block","text":"Assign key-value pairs as model level metadata.\nThe keys must be DataType to avoid any key collisions.\nAssignments can be made using either = or =>.\nMetadata can be retrieved using getmetadata.\nMetadata can be set using setmetadata.\n\nusing ModelingToolkit\n\nstruct Author end\nstruct ModelVersion end\n\n@mtkmodel MetadataModel begin\n    @metadata begin\n        Author = \"Test Author\"\n        ModelVersion => \"1.0.0\"\n    end\nend\n@named model = MetadataModel()\ngetmetadata(model, Author, nothing) == \"Test Author\"","category":"section"},{"location":"basics/MTKLanguage/#A-begin-block","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"A begin block","text":"Any other Julia operations can be included with dedicated begin blocks.","category":"section"},{"location":"basics/MTKLanguage/#Setting-the-type-of-system:","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"Setting the type of system:","text":"By default @mtkmodel returns an System. Different types of system can be defined with the following syntax:\n\n@mtkmodel ModelName::SystemType begin\n    ...\nend\n","category":"section"},{"location":"basics/MTKLanguage/#Connectors","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"Connectors","text":"Connectors are special models that can be used to connect different components together. MTK provides 3 distinct connectors:\n\nDomainConnector: A connector which has only one unknown which is of Flow type, specified by [connect = Flow].\nStreamConnector: A connector which has atleast one stream variable, specified by [connect = Stream]. A StreamConnector must have exactly one flow variable.\nRegularConnector: Connectors that don't fall under above categories.","category":"section"},{"location":"basics/MTKLanguage/#connector","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"Defining connectors with @connector","text":"@connector returns ModelingToolkit.Model. It includes a constructor that returns a connector system (System by default), a structure dictionary with metadata, and flag isconnector which is set to true.\n\nA simple connector can be defined with syntax similar to following example:\n\nusing ModelingToolkit\nusing ModelingToolkit: t\nusing SciCompDSL\n\n@connector Pin begin\n    v(t) = 0.0, [description = \"Voltage\"]\n    i(t), [connect = Flow]\nend\n\nVariables (as functions of independent variable) are listed out in the definition. These variables can optionally have initial values and metadata like description, connect and so on. For more details on setting metadata, check out Symbolic Metadata.\n\nSimilar to @mtkmodel, @connector accepts begin blocks of @components, @equations, @extend, @parameters, @structural_parameters, @variables. These keywords mean the same as described above for @mtkmodel. For example, the following HydraulicFluid connector is defined with parameters, variables and equations.\n\n@connector HydraulicFluid begin\n    @parameters begin\n        ρ = 997\n        β = 2.09e9\n        μ = 0.0010016\n        n = 1\n        let_gas = 1\n        ρ_gas = 0.0073955\n        p_gas = -1000\n    end\n    @variables begin\n        dm(t) = 0.0, [connect = Flow]\n    end\n    @equations begin\n        dm ~ 0\n    end\nend\n\nnote: Note\nFor more examples of usage, checkout ModelingToolkitStandardLibrary.jl","category":"section"},{"location":"basics/MTKLanguage/#model_structure","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"More on Model.structure","text":"structure stores metadata that describes composition of a model. It includes:\n\n:components: The list of sub-components in the form of [[name, subcomponentname],...].\n:constants: Dictionary of constants mapped to its metadata.\n:defaults: Dictionary of variables and default values specified in the @defaults.\n:extend: The list of extended unknowns, parameters and components, name given to the base system, and name of the base system. When multiple extend statements are present, latter two are returned as lists.\n:structural_parameters: Dictionary of structural parameters mapped to their metadata.\n:parameters: Dictionary of symbolic parameters mapped to their metadata. For parameter arrays, length is added to the metadata as :size.\n:variables: Dictionary of symbolic variables mapped to their metadata. For variable arrays, length is added to the metadata as :size.\n:kwargs: Dictionary of keyword arguments mapped to their metadata.\n:independent_variable: Independent variable, which is added while generating the Model.\n:equations: List of equations (represented as strings).\n\nFor example, the structure of ModelC is:\n\njulia> ModelC.structure\nDict{Symbol, Any} with 10 entries:\n  :components            => Any[Union{Expr, Symbol}[:model_a, :ModelA], Union{Expr, Symbol}[:model_array_a, :ModelA, :(1:N)], Union{Expr, Symbol}[:model_array_b, :ModelA, :(1:N)]]\n  :variables             => Dict{Symbol, Dict{Symbol, Any}}(:v=>Dict(:default=>:v_var, :type=>Real), :v_array=>Dict(:value=>nothing, :type=>Real, :size=>(:N, :M)), :v_for_defaults=>Dict(:type=>Real))\n  :icon                  => URI(\"https://github.com/SciML/SciMLDocs/blob/main/docs/src/assets/logo.png\")\n  :kwargs                => Dict{Symbol, Dict}(:f=>Dict(:value=>:sin), :p2=>Dict(:value=>NoValue()), :N=>Dict(:value=>2), :M=>Dict(:value=>3), :v=>Dict{Symbol, Any}(:value=>:v_var, :type=>Real), :v_array=>Dict{Symbol, Any}(:value=>nothing, :type=>Real, :size=>(:N, :M)), :v_for_defaults=>Dict{Symbol, Union{Nothing, DataType}}(:value=>nothing, :type=>Real), :p1=>Dict(:value=>1))\n  :structural_parameters => Dict{Symbol, Dict}(:f=>Dict(:value=>:sin), :N=>Dict(:value=>2), :M=>Dict(:value=>3))\n  :independent_variable  => :t\n  :constants             => Dict{Symbol, Dict}(:c=>Dict{Symbol, Any}(:value=>1, :type=>Int64, :description=>\"Example constant.\"))\n  :extend                => Any[[:p2, :p1], Symbol(\"#mtkmodel__anonymous__ModelB\"), :ModelB]\n  :defaults              => Dict{Symbol, Any}(:v_for_defaults=>2.0)\n  :equations             => Any[\"model_a.k ~ f(v)\"]","category":"section"},{"location":"basics/MTKLanguage/#Different-ways-to-define-symbolics-arrays:","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"Different ways to define symbolics arrays:","text":"@mtkmodel supports symbolics arrays in both @parameters and @variables. Using a structural parameters, symbolic arrays of arbitrary lengths can be defined. Refer the following example for different ways to define symbolic arrays.\n\n@mtkmodel ModelWithArrays begin\n    @structural_parameters begin\n        N = 2\n        M = 3\n    end\n    @parameters begin\n        p1[1:4]\n        p2[1:N]\n        p3[1:N,\n        1:M] = 10,\n        [description = \"A multi-dimensional array of arbitrary length with description\"]\n        (p4[1:N, 1:M] = 10),\n        [description = \"An alternate syntax for p3 to match the syntax of vanilla parameters macro\"]\n    end\n    @variables begin\n        v1(t)[1:2] = 10, [description = \"An array of variable `v1`\"]\n        v2(t)[1:3] = [1, 2, 3]\n    end\nend\n\nThe size of symbolic array can be accessed via :size key, along with other metadata (refer More on Model.structure) of the symbolic variable.\n\njulia> ModelWithArrays.structure\nDict{Symbol, Any} with 5 entries:\n    :variables => Dict{Symbol, Dict{Symbol, Any}}(:v2 => Dict(:value => :([1, 2, 3]), :type => Real, :size => (3,)), :v1 => Dict(:value => :v1, :type => Real, :description => \"An array of variable `v1`\", :size => (2,)))\n    :kwargs => Dict{Symbol, Dict}(:p2 => Dict{Symbol, Any}(:value => nothing, :type => Real, :size => (:N,)), :v1 => Dict{Symbol, Any}(:value => :v1, :type => Real, :description => \"An array of variable `v1`\", :size => (2,)), :N => Dict(:value => 2), :M => Dict(:value => 3), :p4 => Dict{Symbol, Any}(:value => 10, :type => Real, :description => \"An alternate syntax for p3 to match the syntax of vanilla parameters macro\", :size => (:N, :M)), :v2 => Dict{Symbol, Any}(:value => :([1, 2, 3]), :type => Real, :size => (3,)), :p1 => Dict{Symbol, Any}(:value => nothing, :type => Real, :size => (4,)), :p3 => Dict{Symbol, Any}(:value => :p3, :type => Real, :description => \"A multi-dimensional array of arbitrary length with description\", :size => (:N, :M)))\n    :structural_parameters => Dict{Symbol, Dict}(:N => Dict(:value => 2), :M => Dict(:value => 3))\n    :independent_variable => :t\n    :parameters => Dict{Symbol, Dict{Symbol, Any}}(:p2 => Dict(:value => nothing, :type => Real, :size => (:N,)), :p4 => Dict(:value => 10, :type => Real, :description => \"An alternate syntax for p3 to match the syntax of vanilla parameters macro\", :size => (:N, :M)), :p1 => Dict(:value => nothing, :type => Real, :size => (4,)), :p3 => Dict(:value => :p3, :type => Real, :description => \"A multi-dimensional array of arbitrary length with description\", :size => (:N, :M)))), false)","category":"section"},{"location":"basics/MTKLanguage/#Using-conditional-statements","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"Using conditional statements","text":"","category":"section"},{"location":"basics/MTKLanguage/#Conditional-elements-of-the-system","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"Conditional elements of the system","text":"Both @mtkmodel and @connector support conditionally defining parameters, variables, equations, and components.\n\nThe if-elseif-else statements can be used inside @equations, @parameters, @variables, @components.\n\nusing ModelingToolkit\nusing ModelingToolkit: t\nusing SciCompDSL\n\n@mtkmodel C begin end\n\n@mtkmodel BranchInsideTheBlock begin\n    @structural_parameters begin\n        flag = true\n    end\n    @parameters begin\n        if flag\n            a1\n        else\n            a2\n        end\n    end\n    @components begin\n        if flag\n            sys1 = C()\n        else\n            sys2 = C()\n        end\n    end\nend\n\nAlternatively, the @equations, @parameters, @variables, @components can be used inside the if-elseif-else statements.\n\n@mtkmodel BranchOutsideTheBlock begin\n    @structural_parameters begin\n        flag = true\n    end\n    if flag\n        @parameters begin\n            a1\n        end\n        @components begin\n            sys1 = C()\n        end\n        @equations begin\n            a1 ~ 0\n        end\n    else\n        @parameters begin\n            a2\n        end\n        @equations begin\n            a2 ~ 0\n        end\n    end\n    @defaults begin\n        a1 => 10\n    end\nend\n\nThe conditional parts are reflected in the structure. For BranchOutsideTheBlock, the metadata is:\n\njulia> BranchOutsideTheBlock.structure\nDict{Symbol, Any} with 7 entries:\n  :components            => Any[(:if, :flag, Vector{Union{Expr, Symbol}}[[:sys1, :C]], Any[])]\n  :kwargs                => Dict{Symbol, Dict}(:flag=>Dict{Symbol, Bool}(:value=>1))\n  :structural_parameters => Dict{Symbol, Dict}(:flag=>Dict{Symbol, Bool}(:value=>1))\n  :independent_variable  => t\n  :parameters            => Dict{Symbol, Dict{Symbol, Any}}(:a2 => Dict(:type=>AbstractArray{Real}, :condition=>(:if, :flag, Dict{Symbol, Any}(:kwargs=>Dict{Any, Any}(:a1=>Dict{Symbol, Union{Nothing, DataType}}(:value=>nothing, :type=>Real)), :parameters=>Any[Dict{Symbol, Dict{Symbol, Any}}(:a1=>Dict(:type=>AbstractArray{Real}))]), Dict{Symbol, Any}(:variables=>Any[Dict{Symbol, Dict{Symbol, Any}}()], :kwargs=>Dict{Any, Any}(:a2=>Dict{Symbol, Union{Nothing, DataType}}(:value=>nothing, :type=>Real)), :parameters=>Any[Dict{Symbol, Dict{Symbol, Any}}(:a2=>Dict(:type=>AbstractArray{Real}))]))), :a1 => Dict(:type=>AbstractArray{Real}, :condition=>(:if, :flag, Dict{Symbol, Any}(:kwargs=>Dict{Any, Any}(:a1=>Dict{Symbol, Union{Nothing, DataType}}(:value=>nothing, :type=>Real)), :parameters=>Any[Dict{Symbol, Dict{Symbol, Any}}(:a1=>Dict(:type=>AbstractArray{Real}))]), Dict{Symbol, Any}(:variables=>Any[Dict{Symbol, Dict{Symbol, Any}}()], :kwargs=>Dict{Any, Any}(:a2=>Dict{Symbol, Union{Nothing, DataType}}(:value=>nothing, :type=>Real)), :parameters=>Any[Dict{Symbol, Dict{Symbol, Any}}(:a2=>Dict(:type=>AbstractArray{Real}))]))))\n  :defaults              => Dict{Symbol, Any}(:a1=>10)\n  :equations             => Any[(:if, :flag, [\"a1 ~ 0\"], [\"a2 ~ 0\"])]\n\nConditional entries are entered in the format of (branch, condition, [case when it is true], [case when it is false]); where branch is either :if or :elseif.<br> The [case when it is false] is either an empty vector or nothing when only if branch is present; it is a vector or dictionary whenever else branch is present; it is a conditional tuple whenever elseif branches are present.\n\nFor the conditional components and equations these condition tuples are added directly, while for parameters and variables these are added as :condition metadata.","category":"section"},{"location":"basics/MTKLanguage/#Conditional-initial-guess-of-symbolic-variables","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"Conditional initial guess of symbolic variables","text":"Using ternary operator or if-elseif-else statement, conditional initial guesses can be assigned to parameters and variables.\n\n@mtkmodel DefaultValues begin\n    @structural_parameters begin\n        flag = true\n    end\n    @parameters begin\n        p = flag ? 1 : 2\n    end\nend","category":"section"},{"location":"basics/MTKLanguage/#Build-structurally-simplified-models:","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"Build structurally simplified models:","text":"@mtkcompile builds an instance of a component and returns a structurally simplied system.\n\n@mtkcompile sys = CustomModel()\n\nThis is equivalent to:\n\n@named model = CustomModel()\nsys = mtkcompile(model)\n\nPass keyword arguments to mtkcompile using the following syntax:\n\n@mtkcompile sys=CustomModel() fully_determined=false\n\nThis is equivalent to:\n\n@named model = CustomModel()\nsys = mtkcompile(model; fully_determined = false)","category":"section"}]
}
