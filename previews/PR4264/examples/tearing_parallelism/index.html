<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Exposing More Parallelism By Tearing Algebraic Equations in Systems · ModelingToolkit.jl</title><meta name="title" content="Exposing More Parallelism By Tearing Algebraic Equations in Systems · ModelingToolkit.jl"/><meta property="og:title" content="Exposing More Parallelism By Tearing Algebraic Equations in Systems · ModelingToolkit.jl"/><meta property="twitter:title" content="Exposing More Parallelism By Tearing Algebraic Equations in Systems · ModelingToolkit.jl"/><meta name="description" content="Documentation for ModelingToolkit.jl."/><meta property="og:description" content="Documentation for ModelingToolkit.jl."/><meta property="twitter:description" content="Documentation for ModelingToolkit.jl."/><meta property="og:url" content="https://docs.sciml.ai/ModelingToolkit/stable/examples/tearing_parallelism/"/><meta property="twitter:url" content="https://docs.sciml.ai/ModelingToolkit/stable/examples/tearing_parallelism/"/><link rel="canonical" href="https://docs.sciml.ai/ModelingToolkit/stable/examples/tearing_parallelism/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="ModelingToolkit.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">ModelingToolkit.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../tutorials/ode_modeling/">Getting Started with ModelingToolkit.jl</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/acausal_components/">Acausal Component-Based Modeling</a></li><li><a class="tocitem" href="../../tutorials/nonlinear/">Modeling Nonlinear Systems</a></li><li><a class="tocitem" href="../../tutorials/initialization/">Initialization of Systems</a></li><li><a class="tocitem" href="../../tutorials/optimization/">Modeling Optimization Problems</a></li><li><a class="tocitem" href="../../tutorials/modelingtoolkitize/">Modelingtoolkitize: Automatically Translating Numerical to Symbolic Code</a></li><li><a class="tocitem" href="../../tutorials/programmatically_generating/">Programmatically Generating and Scripting Systems</a></li><li><a class="tocitem" href="../../tutorials/stochastic_diffeq/">Modeling with Stochasticity</a></li><li><a class="tocitem" href="../../tutorials/dynamic_optimization/">Solving Dynamic Optimization Problems</a></li><li><a class="tocitem" href="../../tutorials/discrete_system/">(Experimental) Modeling Discrete Systems</a></li><li><a class="tocitem" href="../../tutorials/parameter_identifiability/">Parameter Identifiability in ODE Models</a></li><li><a class="tocitem" href="../../tutorials/change_independent_variable/">Changing the independent variable of ODEs</a></li><li><a class="tocitem" href="../../tutorials/bifurcation_diagram_computation/">Bifurcation Diagrams</a></li><li><a class="tocitem" href="../../tutorials/attractors/">Multi- and Nonlocal- Continuation</a></li><li><a class="tocitem" href="../../tutorials/SampledData/">Clocks and Sampled-Data Systems</a></li><li><a class="tocitem" href="../../tutorials/domain_connections/">Domains</a></li><li><a class="tocitem" href="../../tutorials/callable_params/">Callable parameters and interpolating data</a></li><li><a class="tocitem" href="../../tutorials/linear_analysis/">Linear Analysis</a></li><li><a class="tocitem" href="../../tutorials/disturbance_modeling/">Disturbance and input modeling modeling</a></li><li><a class="tocitem" href="../../tutorials/fmi/">Importing FMUs</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><input class="collapse-toggle" id="menuitem-4-1" type="checkbox"/><label class="tocitem" for="menuitem-4-1"><span class="docs-label">Basic Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../higher_order/">Automatic Transformation of Nth Order ODEs to 1st Order ODEs</a></li><li><a class="tocitem" href="../spring_mass/">Component-Based Modeling of a Spring-Mass System</a></li><li><a class="tocitem" href="../modelingtoolkitize_index_reduction/">Automated Index Reduction of DAEs</a></li><li><a class="tocitem" href="../remake/">Optimizing through an ODE solve and re-creating MTK Problems</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-2" type="checkbox" checked/><label class="tocitem" for="menuitem-4-2"><span class="docs-label">Advanced Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li class="is-active"><a class="tocitem" href>Exposing More Parallelism By Tearing Algebraic Equations in Systems</a><ul class="internal"><li><a class="tocitem" href="#The-Component-Library"><span>The Component Library</span></a></li><li><a class="tocitem" href="#The-Model"><span>The Model</span></a></li><li><a class="tocitem" href="#What-Happened?"><span>What Happened?</span></a></li></ul></li><li><a class="tocitem" href="../sparse_jacobians/">Automated Sparse Analytical Jacobians</a></li><li><a class="tocitem" href="../perturbation/">Symbolic-Numeric Perturbation Theory for ODEs</a></li></ul></li></ul></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../../API/System/">The <code>System</code> type</a></li><li><a class="tocitem" href="../../API/variables/">Symbolic variables and variable metadata</a></li><li><a class="tocitem" href="../../API/model_building/">Model building reference</a></li><li><a class="tocitem" href="../../API/problems/">Building and solving numerical problems</a></li><li><a class="tocitem" href="../../API/dynamic_opt/">Dynamic Optimization Solvers</a></li><li><a class="tocitem" href="../../API/codegen/">Code generation utilities</a></li><li><a class="tocitem" href="../../API/PDESystem/">PDESystem</a></li></ul></li><li><span class="tocitem">Basics</span><ul><li><a class="tocitem" href="../../basics/Composition/">Composing Models and Building Reusable Components</a></li><li><a class="tocitem" href="../../basics/Events/">Event Handling and Callback Functions</a></li><li><a class="tocitem" href="../../basics/Linearization/">Linearization</a></li><li><a class="tocitem" href="../../basics/InputOutput/">Input output</a></li><li><a class="tocitem" href="../../basics/MTKLanguage/">ModelingToolkit Language: Modeling with <code>@mtkmodel</code>, <code>@connectors</code> and <code>@mtkcompile</code></a></li><li><a class="tocitem" href="../../basics/Validation/">Model Validation and Units</a></li><li><a class="tocitem" href="../../basics/Debugging/">Debugging</a></li><li><a class="tocitem" href="../../basics/DependencyGraphs/">Dependency Graphs</a></li><li><a class="tocitem" href="../../basics/Precompilation/">Working with Precompilation and Binary Building</a></li><li><a class="tocitem" href="../../basics/FAQ/">Frequently Asked Questions</a></li></ul></li><li><a class="tocitem" href="../../comparison/">Comparison of ModelingToolkit vs Equation-Based and Block Modeling Languages</a></li><li><span class="tocitem">Internal Details</span><ul><li><a class="tocitem" href="../../internals/">Internal Details</a></li><li><a class="tocitem" href="../../internals/structural_transformation/">Structural Transformation</a></li><li><a class="tocitem" href="../../internals/bipartite_graph/">Bipartite Graphs</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li><a class="is-disabled">Advanced Examples</a></li><li class="is-active"><a href>Exposing More Parallelism By Tearing Algebraic Equations in Systems</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Exposing More Parallelism By Tearing Algebraic Equations in Systems</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SciML/ModelingToolkit.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SciML/ModelingToolkit.jl/blob/master/docs/src/examples/tearing_parallelism.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Exposing-More-Parallelism-By-Tearing-Algebraic-Equations-in-Systems"><a class="docs-heading-anchor" href="#Exposing-More-Parallelism-By-Tearing-Algebraic-Equations-in-Systems">Exposing More Parallelism By Tearing Algebraic Equations in Systems</a><a id="Exposing-More-Parallelism-By-Tearing-Algebraic-Equations-in-Systems-1"></a><a class="docs-heading-anchor-permalink" href="#Exposing-More-Parallelism-By-Tearing-Algebraic-Equations-in-Systems" title="Permalink"></a></h1><p>Sometimes it can be very non-trivial to parallelize a system. In this tutorial, we will demonstrate how to make use of <code>mtkcompile</code> to expose more parallelism in the solution process and parallelize the resulting simulation.</p><h2 id="The-Component-Library"><a class="docs-heading-anchor" href="#The-Component-Library">The Component Library</a><a id="The-Component-Library-1"></a><a class="docs-heading-anchor-permalink" href="#The-Component-Library" title="Permalink"></a></h2><p>The following tutorial will use the following set of components describing electrical circuits:</p><pre><code class="language-julia hljs">using ModelingToolkit, OrdinaryDiffEq
using ModelingToolkit: t_nounits as t, D_nounits as D

# Basic electric components
@connector function Pin(; name)
    @variables v(t)=1.0 i(t)=1.0 [connect=Flow]
    System(Equation[], t, [v, i], [], name = name)
end

function Ground(; name)
    @named g = Pin()
    eqs = [g.v ~ 0]
    compose(System(eqs, t, [], [], name = name), g)
end

function ConstantVoltage(; name, V = 1.0)
    val = V
    @named p = Pin()
    @named n = Pin()
    @parameters V = V
    eqs = [V ~ p.v - n.v
           0 ~ p.i + n.i]
    compose(System(eqs, t, [], [V], name = name), p, n)
end

@connector function HeatPort(; name)
    @variables T(t)=293.15 Q_flow(t)=0.0 [connect=Flow]
    System(Equation[], t, [T, Q_flow], [], name = name)
end

function HeatingResistor(; name, R = 1.0, TAmbient = 293.15, alpha = 1.0)
    @named p = Pin()
    @named n = Pin()
    @named h = HeatPort()
    @variables v(t) RTherm(t)
    @parameters R=R TAmbient=TAmbient alpha=alpha
    eqs = [RTherm ~ R * (1 + alpha * (h.T - TAmbient))
           v ~ p.i * RTherm
           h.Q_flow ~ -v * p.i # -LossPower
           v ~ p.v - n.v
           0 ~ p.i + n.i]
    compose(System(eqs, t, [v, RTherm], [R, TAmbient, alpha],
            name = name), p, n, h)
end

function HeatCapacitor(; name, rho = 8050, V = 1, cp = 460, TAmbient = 293.15)
    @parameters rho=rho V=V cp=cp
    C = rho * V * cp
    @named h = HeatPort()
    eqs = [
        D(h.T) ~ h.Q_flow / C
    ]
    compose(System(eqs, t, [], [rho, V, cp],
            name = name), h)
end

function Capacitor(; name, C = 1.0)
    @named p = Pin()
    @named n = Pin()
    @variables v(t) = 0.0
    @parameters C = C
    eqs = [v ~ p.v - n.v
           0 ~ p.i + n.i
           D(v) ~ p.i / C]
    compose(System(eqs, t, [v], [C],
            name = name), p, n)
end

function parallel_rc_model(i; name, source, ground, R, C)
    resistor = HeatingResistor(name = Symbol(:resistor, i), R = R)
    capacitor = Capacitor(name = Symbol(:capacitor, i), C = C)
    heat_capacitor = HeatCapacitor(name = Symbol(:heat_capacitor, i))

    rc_eqs = [connect(source.p, resistor.p)
              connect(resistor.n, capacitor.p)
              connect(capacitor.n, source.n, ground.g)
              connect(resistor.h, heat_capacitor.h)]

    compose(System(rc_eqs, t, name = Symbol(name, i)),
        [resistor, capacitor, source, ground, heat_capacitor])
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">parallel_rc_model (generic function with 1 method)</code></pre><h2 id="The-Model"><a class="docs-heading-anchor" href="#The-Model">The Model</a><a id="The-Model-1"></a><a class="docs-heading-anchor-permalink" href="#The-Model" title="Permalink"></a></h2><p>Assuming that the components are defined, our model is 50 resistors and capacitors connected in parallel. Thus following the <a href="../../tutorials/acausal_components/#acausal">acausal components tutorial</a>, we can connect a bunch of RC components as follows:</p><pre><code class="language-julia hljs">V = 2.0
@named source = ConstantVoltage(V = V)
@named ground = Ground()
N = 50
Rs = 10 .^ range(0, stop = -4, length = N)
Cs = 10 .^ range(-3, stop = 0, length = N)
rc_systems = map(1:N) do i
    parallel_rc_model(i; name = :rc, source = source, ground = ground, R = Rs[i], C = Cs[i])
end;
@variables E(t) = 0.0
eqs = [
    D(E) ~ sum(((i, sys),) -&gt; getproperty(sys, Symbol(:resistor, i)).h.Q_flow,
    enumerate(rc_systems))
]
@named _big_rc = System(eqs, t, [E], [])
@named big_rc = compose(_big_rc, rc_systems)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr1">Model big_rc:</span>
<span class="sgr1">Subsystems (50):</span> see hierarchy(big_rc)
  rc1
  rc2
  rc3
  rc4
  ⋮
<span class="sgr1">Equations (1251):</span>
  801 standard: see equations(big_rc)
  450 connecting: see equations(expand_connections(big_rc))
<span class="sgr1">Unknowns (1051):</span> see unknowns(big_rc)
  E(t)
  rc1₊resistor1₊v(t)
  rc1₊resistor1₊RTherm(t)
  rc1₊resistor1₊p₊v(t)
  ⋮
<span class="sgr1">Parameters (400):</span> see parameters(big_rc)
  rc1₊resistor1₊R
  rc1₊resistor1₊TAmbient
  rc1₊resistor1₊alpha
  rc1₊capacitor1₊C
  ⋮</code></pre><p>Now let&#39;s say we want to expose a bit more parallelism via running tearing. How do we do that?</p><pre><code class="language-julia hljs">sys = mtkcompile(big_rc)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr1">Model big_rc:</span>
<span class="sgr1">Equations (151):</span>
  151 standard: see equations(big_rc)
<span class="sgr1">Unknowns (151):</span> see unknowns(big_rc)
  rc1₊resistor1₊p₊i(t)
  rc2₊resistor2₊p₊i(t)
  rc3₊resistor3₊p₊i(t)
  rc4₊resistor4₊p₊i(t)
  ⋮
<span class="sgr1">Parameters (400):</span> see parameters(big_rc)
  rc1₊resistor1₊R
  rc1₊resistor1₊TAmbient
  rc1₊resistor1₊alpha
  rc1₊capacitor1₊C
  ⋮
<span class="sgr1">Observed (900):</span> see observed(big_rc)</code></pre><p>Done, that&#39;s it. There&#39;s no more to it.</p><h2 id="What-Happened?"><a class="docs-heading-anchor" href="#What-Happened?">What Happened?</a><a id="What-Happened?-1"></a><a class="docs-heading-anchor-permalink" href="#What-Happened?" title="Permalink"></a></h2><p>Yes, that&#39;s a good question! Let&#39;s investigate a little bit more what had happened. If you look at the system we defined:</p><pre><code class="language-julia hljs">length(equations(big_rc))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">801</code></pre><p>You see, it started as a massive 1051 set of equations. However, after eliminating redundancies, we arrive at 151 equations:</p><pre><code class="language-julia hljs">equations(sys)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">151-element Vector{Equation}:
 <span class="sgr34">0</span> ~ -rc50₊resistor50₊v(t) + rc50₊resistor50₊RTherm(t)*rc50₊resistor50₊p₊i(t)
 <span class="sgr34">0</span> ~ -rc49₊resistor49₊v(t) + rc49₊resistor49₊RTherm(t)*rc49₊resistor49₊p₊i(t)
 <span class="sgr34">0</span> ~ -rc48₊resistor48₊v(t) + rc48₊resistor48₊p₊i(t)*rc48₊resistor48₊RTherm(t)
 <span class="sgr34">0</span> ~ -rc47₊resistor47₊v(t) + rc47₊resistor47₊p₊i(t)*rc47₊resistor47₊RTherm(t)
 <span class="sgr34">0</span> ~ -rc46₊resistor46₊v(t) + rc46₊resistor46₊RTherm(t)*rc46₊resistor46₊p₊i(t)
 <span class="sgr34">0</span> ~ -rc45₊resistor45₊v(t) + rc45₊resistor45₊p₊i(t)*rc45₊resistor45₊RTherm(t)
 <span class="sgr34">0</span> ~ -rc44₊resistor44₊v(t) + rc44₊resistor44₊RTherm(t)*rc44₊resistor44₊p₊i(t)
 <span class="sgr34">0</span> ~ -rc43₊resistor43₊v(t) + rc43₊resistor43₊p₊i(t)*rc43₊resistor43₊RTherm(t)
 <span class="sgr34">0</span> ~ -rc42₊resistor42₊v(t) + rc42₊resistor42₊p₊i(t)*rc42₊resistor42₊RTherm(t)
 <span class="sgr34">0</span> ~ -rc41₊resistor41₊v(t) + rc41₊resistor41₊RTherm(t)*rc41₊resistor41₊p₊i(t)
 ⋮
 Differential(t, 1)(rc4₊heat_capacitor4₊h₊T(t)) ~ rc4₊heat_capacitor4₊h₊Q_flow(t) / (rc4₊heat_capacitor4₊V*rc4₊heat_capacitor4₊cp*rc4₊heat_capacitor4₊rho)
 Differential(t, 1)(rc4₊capacitor4₊v(t)) ~ rc4₊capacitor4₊p₊i(t) / rc4₊capacitor4₊C
 Differential(t, 1)(rc3₊heat_capacitor3₊h₊T(t)) ~ rc3₊heat_capacitor3₊h₊Q_flow(t) / (rc3₊heat_capacitor3₊V*rc3₊heat_capacitor3₊cp*rc3₊heat_capacitor3₊rho)
 Differential(t, 1)(rc3₊capacitor3₊v(t)) ~ rc3₊capacitor3₊p₊i(t) / rc3₊capacitor3₊C
 Differential(t, 1)(rc2₊heat_capacitor2₊h₊T(t)) ~ rc2₊heat_capacitor2₊h₊Q_flow(t) / (rc2₊heat_capacitor2₊V*rc2₊heat_capacitor2₊cp*rc2₊heat_capacitor2₊rho)
 Differential(t, 1)(rc2₊capacitor2₊v(t)) ~ rc2₊capacitor2₊p₊i(t) / rc2₊capacitor2₊C
 Differential(t, 1)(rc1₊heat_capacitor1₊h₊T(t)) ~ rc1₊heat_capacitor1₊h₊Q_flow(t) / (rc1₊heat_capacitor1₊V*rc1₊heat_capacitor1₊cp*rc1₊heat_capacitor1₊rho)
 Differential(t, 1)(rc1₊capacitor1₊v(t)) ~ rc1₊capacitor1₊p₊i(t) / rc1₊capacitor1₊C
 Differential(t, 1)(E(t)) ~ -rc49₊heat_capacitor49₊h₊Q_flow(t) - rc16₊heat_capacitor16₊h₊Q_flow(t) - rc27₊heat_capacitor27₊h₊Q_flow(t) - rc28₊heat_capacitor28₊h₊Q_flow(t) - rc32₊heat_capacitor32₊h₊Q_flow(t) - rc37₊heat_capacitor37₊h₊Q_flow(t) - rc43₊heat_capacitor43₊h₊Q_flow(t) - rc1₊heat_capacitor1₊h₊Q_flow(t) - rc4₊heat_capacitor4₊h₊Q_flow(t) - rc29₊heat_capacitor29₊h₊Q_flow(t) - rc13₊heat_capacitor13₊h₊Q_flow(t) - rc10₊heat_capacitor10₊h₊Q_flow(t) - rc36₊heat_capacitor36₊h₊Q_flow(t) - rc22₊heat_capacitor22₊h₊Q_flow(t) - rc46₊heat_capacitor46₊h₊Q_flow(t) - rc5₊heat_capacitor5₊h₊Q_flow(t) - rc38₊heat_capacitor38₊h₊Q_flow(t) - rc8₊heat_capacitor8₊h₊Q_flow(t) - rc25₊heat_capacitor25₊h₊Q_flow(t) - rc20₊heat_capacitor20₊h₊Q_flow(t) - rc48₊heat_capacitor48₊h₊Q_flow(t) - rc18₊heat_capacitor18₊h₊Q_flow(t) - rc12₊heat_capacitor12₊h₊Q_flow(t) - rc17₊heat_capacitor17₊h₊Q_flow(t) - rc26₊heat_capacitor26₊h₊Q_flow(t) - rc45₊heat_capacitor45₊h₊Q_flow(t) - rc3₊heat_capacitor3₊h₊Q_flow(t) - rc35₊heat_capacitor35₊h₊Q_flow(t) - rc15₊heat_capacitor15₊h₊Q_flow(t) - rc34₊heat_capacitor34₊h₊Q_flow(t) - rc7₊heat_capacitor7₊h₊Q_flow(t) - rc39₊heat_capacitor39₊h₊Q_flow(t) - rc33₊heat_capacitor33₊h₊Q_flow(t) - rc30₊heat_capacitor30₊h₊Q_flow(t) - rc24₊heat_capacitor24₊h₊Q_flow(t) - rc47₊heat_capacitor47₊h₊Q_flow(t) - rc21₊heat_capacitor21₊h₊Q_flow(t) - rc40₊heat_capacitor40₊h₊Q_flow(t) - rc42₊heat_capacitor42₊h₊Q_flow(t) - rc2₊heat_capacitor2₊h₊Q_flow(t) - rc11₊heat_capacitor11₊h₊Q_flow(t) - rc31₊heat_capacitor31₊h₊Q_flow(t) - rc23₊heat_capacitor23₊h₊Q_flow(t) - rc19₊heat_capacitor19₊h₊Q_flow(t) - rc50₊heat_capacitor50₊h₊Q_flow(t) - rc44₊heat_capacitor44₊h₊Q_flow(t) - rc9₊heat_capacitor9₊h₊Q_flow(t) - rc14₊heat_capacitor14₊h₊Q_flow(t) - rc41₊heat_capacitor41₊h₊Q_flow(t) - rc6₊heat_capacitor6₊h₊Q_flow(t)</code></pre><p>That&#39;s not all though. In addition, the tearing process has turned the sets of nonlinear equations into separate blocks and constructed a DAG for the dependencies between the blocks. We can use the bipartite graph functionality to dig in and investigate what this means:</p><pre><code class="language-julia hljs">using ModelingToolkit.BipartiteGraphs
ts = TearingState(expand_connections(big_rc))
inc_org = BipartiteGraphs.incidence_matrix(ts.structure.graph)
# Note: sorted_incidence_matrix requires the system and matrix dimensions to match
# blt_reduced = StructuralTransformations.sorted_incidence_matrix(sys)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1051×1152 SparseArrays.SparseMatrixCSC{Bool, Int64} with 2351 stored entries:
⎡⠀⠀⠀⠀⢳⠀⠀⢰⠃⠀⠀⠀⠀⠀⠛⠶⣄⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎤
⎢⠀⠀⠀⢀⠸⡀⠀⢠⣪⡄⠀⠀⠀⠀⠀⠀⠀⠙⠳⢦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠀⠀⢆⠀⠑⡅⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠉⠻⠦⣄⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠐⠀⢸⠀⠆⢑⠒⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠻⢦⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥
⎢⠀⠀⠀⢀⠀⠀⠇⢰⠡⠀⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⠳⢦⣀⠀⠀⠀⠀⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠈⠀⠀⢱⠔⡡⠀⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠓⠦⣄⣀⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠠⡀⠀⠘⡣⢐⠀⠠⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠳⣦⠀⠀⎥
⎢⠀⠀⠀⠀⢆⠀⠀⢋⠆⠀⠀⠈⠙⠲⢦⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡄⠀⎥
⎢⠀⠀⠀⠀⢸⡀⠀⢈⢔⠀⠀⠀⠀⠀⠀⠈⠙⠳⢦⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢱⠀⎥
⎢⠀⠀⠀⠈⠀⡆⠀⢔⠝⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠲⣤⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢹⠀⎥
⎢⠀⠀⠀⠀⠀⢣⠀⡀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⠓⢦⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠸⠀⎥
⎢⠀⠀⠀⠀⠀⢰⠀⠆⢨⠈⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⠶⣤⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠁⡇⎥
⎢⠀⠀⠀⠀⠀⠀⡃⢸⠡⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⠳⢦⣄⠀⠀⠀⠀⠀⠀⠀⡇⎥
⎢⠀⠀⠀⠀⠀⠀⢳⡰⢁⠀⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⠳⣤⣀⠀⠀⠀⠁⠧⎥
⎢⠀⠀⠀⢀⠀⠀⠐⣆⠡⠀⢀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠳⢦⡄⡀⠸⎥
⎢⠀⠀⠀⠀⡆⠀⠀⡥⠘⠀⠈⠳⣦⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⡇⠈⎥
⎢⡍⢢⡀⠀⠀⠀⠀⠉⠉⢄⡀⠀⠀⠈⠉⠓⠒⠒⠒⠢⠤⠤⠤⣄⣀⣀⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠁⠀⎥
⎣⢦⠀⠙⠦⠀⠀⠀⠀⠀⠀⠲⠤⣀⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠉⠉⠉⠑⠒⠒⠒⠤⠤⠤⠄⠀⎦</code></pre><p><img src="https://user-images.githubusercontent.com/1814174/110589027-d4ec9b00-8143-11eb-8880-651da986504d.PNG" alt/></p><p>The figure on the left is the original incidence matrix of the algebraic equations. Notice that the original formulation of the model has dependencies between different equations, and so the full set of equations must be solved together. That exposes no parallelism. However, the Block Lower Triangular (BLT) transformation exposes independent blocks. This is then further improved by the tearing process, which removes 90% of the equations and transforms the nonlinear equations into 50 independent blocks, <em>which can now all be solved in parallel</em>. The conclusion is that, your attempts to parallelize are neigh: performing parallelism after structural simplification greatly improves the problem that can be parallelized, so this is better than trying to do it by hand.</p><p>After performing this, you can construct the <code>ODEProblem</code> and set <code>parallel_form</code> to use the exposed parallelism in multithreaded function constructions, but this showcases why <code>mtkcompile</code> is so important to that process.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../remake/">« Optimizing through an ODE solve and re-creating MTK Problems</a><a class="docs-footer-nextpage" href="../sparse_jacobians/">Automated Sparse Analytical Jacobians »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Monday 9 February 2026 07:44">Monday 9 February 2026</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
