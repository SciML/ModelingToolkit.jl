<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>High Level API · ModelingToolkit.jl</title><link rel="canonical" href="https://mtk.sciml.ai/stable/highlevel/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="ModelingToolkit.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">ModelingToolkit.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorials/symbolic_functions/">Symbolic Calculations and Building Fast Parallel Functions</a></li><li><a class="tocitem" href="../tutorials/ode_modeling/">Component-Based Modeling with Ordinary Differential Equations</a></li><li><a class="tocitem" href="../tutorials/higher_order/">Automatic Transformation of Nth Order ODEs to 1st Order ODEs</a></li><li><a class="tocitem" href="../tutorials/nonlinear/">Solving Nonlinear Systems with NLsolve</a></li><li><a class="tocitem" href="../tutorials/modelingtoolkitize/">Symbolic Extensions to ODEProblem via Modelingtoolkize</a></li><li><a class="tocitem" href="../tutorials/auto_parallel/">Automated Sparse Parallelism of ODEs via Tracing</a></li></ul></li><li><span class="tocitem">Systems</span><ul><li><a class="tocitem" href="../systems/AbstractSystem/">The AbstractSystem Interface</a></li><li><a class="tocitem" href="../systems/ODESystem/">ODESystem</a></li><li><a class="tocitem" href="../systems/SDESystem/">SDESystem</a></li><li><a class="tocitem" href="../systems/JumpSystem/">JumpSystem</a></li><li><a class="tocitem" href="../systems/NonlinearSystem/">NonlinearSystem</a></li><li><a class="tocitem" href="../systems/OptimizationSystem/">OptimizationSystem</a></li><li><a class="tocitem" href="../systems/ReactionSystem/">ReactionSystem</a></li><li><a class="tocitem" href="../systems/PDESystem/">PDESystem</a></li><li><a class="tocitem" href="../systems/DependencyGraphs/">Dependency Graphs</a></li></ul></li><li><a class="tocitem" href="../comparison/">Comparison Against SymPy</a></li><li class="is-active"><a class="tocitem" href>High Level API</a><ul class="internal"><li><a class="tocitem" href="#High-Level-API-Documentation-1"><span>High-Level API Documentation</span></a></li><li><a class="tocitem" href="#Differentiation-Functions-1"><span>Differentiation Functions</span></a></li><li><a class="tocitem" href="#Sparsity-Detection-1"><span>Sparsity Detection</span></a></li><li><a class="tocitem" href="#Latexification-1"><span>Latexification</span></a></li><li><a class="tocitem" href="#The-Auto-Detecting-System-Constructors-1"><span>The Auto-Detecting System Constructors</span></a></li><li><a class="tocitem" href="#Direct-Tracing-1"><span>Direct Tracing</span></a></li><li><a class="tocitem" href="#Intermediate-Calculations-1"><span>Intermediate Calculations</span></a></li><li><a class="tocitem" href="#I/O-and-Saving-1"><span>I/O and Saving</span></a></li></ul></li><li><a class="tocitem" href="../IR/">ModelingToolkit IR</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>High Level API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>High Level API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/SciML/ModelingToolkit.jl/blob/master/docs/src/highlevel.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="High-Level-API-1"><a class="docs-heading-anchor" href="#High-Level-API-1">High Level API</a><a class="docs-heading-anchor-permalink" href="#High-Level-API-1" title="Permalink"></a></h1><p>The high-level API allows modelers to interactively build models in a symbolic manner. It is designed as a semi-DSL for easily building large complex models and manipulating the models to generate optimal forms to be used in numerical methods.</p><h2 id="High-Level-API-Documentation-1"><a class="docs-heading-anchor" href="#High-Level-API-Documentation-1">High-Level API Documentation</a><a class="docs-heading-anchor-permalink" href="#High-Level-API-Documentation-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ModelingToolkit.@parameters" href="#ModelingToolkit.@parameters"><code>ModelingToolkit.@parameters</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>Define one or more known variables.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/edaa2dc7139bef7097394f2388ddadafb3d9b6f5/src/context_dsl.jl#L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelingToolkit.@variables" href="#ModelingToolkit.@variables"><code>ModelingToolkit.@variables</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>Define one or more unknown variables.</p><pre><code class="language-julia">@parameters t α σ(..) β[1:2]
@variables w(..) x(t) y() z(t, α, x)

expr = β₁* x + y^α + σ(3) * (z - t) - β₂ * w(t - 1)</code></pre><p>Note that <code>@parameters</code> and <code>@variables</code> implicitly add <code>()</code> to values that are not given a call. The former specifies the values as known, while the latter specifies it as unknown. <code>(..)</code> signifies that the value should be left uncalled.</p><p>Sometimes it is convenient to define arrays of variables to model things like <code>x₁,…,x₃</code>. The <code>@variables</code> and <code>@parameters</code> macros support this with the following syntax:</p><pre><code class="language-julia">@variables x[1:3];
x

3-element Array{Operation,1}:
 x₁()
 x₂()
 x₃()

# support for arbitrary ranges and tensors
@variables y[2:3,1:5:6];
y

2×2 Array{Operation,2}:
    y₂̒₁() y₂̒₆()
    y₃̒₁() y₃̒₆()

# also works for dependent variables
@parameters t; @variables z[1:3](t);
z

3-element Array{Operation,1}:
 z₁(t())
 z₂(t())
 z₃(t())</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/edaa2dc7139bef7097394f2388ddadafb3d9b6f5/src/variables.jl#L177">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelingToolkit.@derivatives" href="#ModelingToolkit.@derivatives"><code>ModelingToolkit.@derivatives</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>Define one or more differentials.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using ModelingToolkit

julia&gt; @variables x y z;

julia&gt; @derivatives Dx&#39;~x Dy&#39;~y  # Create differentials wrt. x and y
((D&#39;~x()), (D&#39;~y()))

julia&gt; Dx(z)  # Differentiate z wrt. x
(D&#39;~x())(z())

julia&gt; Dy(z)  # Differentiate z wrt. y
(D&#39;~y())(z())</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/edaa2dc7139bef7097394f2388ddadafb3d9b6f5/src/differentials.jl#L228">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:~-Tuple{Expression,Expression}" href="#Base.:~-Tuple{Expression,Expression}"><code>Base.:~</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">~(lhs::Expression, rhs::Expression) -&gt; Equation
</code></pre><p>Create an <a href="../IR/#ModelingToolkit.Equation"><code>Equation</code></a> out of two <a href="../IR/#ModelingToolkit.Expression"><code>Expression</code></a> instances, or an <code>Expression</code> and a <code>Number</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using ModelingToolkit

julia&gt; @variables x y;

julia&gt; x ~ y
Equation(x(), y())

julia&gt; x - y ~ 0
Equation(x() - y(), ModelingToolkit.Constant(0))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/edaa2dc7139bef7097394f2388ddadafb3d9b6f5/src/equations.jl#L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelingToolkit.modelingtoolkitize" href="#ModelingToolkit.modelingtoolkitize"><code>ModelingToolkit.modelingtoolkitize</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">modelingtoolkitize(prob::ODEProblem) -&gt; Union{Tuple{Any,Any,Any}, ODESystem}
</code></pre><p>Generate <code>ODESystem</code>, dependent variables, and parameters from an <code>ODEProblem</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/edaa2dc7139bef7097394f2388ddadafb3d9b6f5/src/systems/diffeqs/modelingtoolkitize.jl#L1">source</a></section></article><h2 id="Differentiation-Functions-1"><a class="docs-heading-anchor" href="#Differentiation-Functions-1">Differentiation Functions</a><a class="docs-heading-anchor-permalink" href="#Differentiation-Functions-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ModelingToolkit.gradient" href="#ModelingToolkit.gradient"><code>ModelingToolkit.gradient</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">gradient(O::Expression, vars::AbstractVector{&lt;:Expression}; simplify = true)</code></pre><p>A helper function for computing the gradient of an expression with respect to an array of variable expressions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/edaa2dc7139bef7097394f2388ddadafb3d9b6f5/src/direct.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelingToolkit.jacobian" href="#ModelingToolkit.jacobian"><code>ModelingToolkit.jacobian</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">jacobian(ops::AbstractVector{&lt;:Expression}, vars::AbstractVector{&lt;:Expression}; simplify = true)</code></pre><p>A helper function for computing the Jacobian of an array of expressions with respect to an array of variable expressions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/edaa2dc7139bef7097394f2388ddadafb3d9b6f5/src/direct.jl#L13-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelingToolkit.sparsejacobian" href="#ModelingToolkit.sparsejacobian"><code>ModelingToolkit.sparsejacobian</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">sparsejacobian(ops::AbstractVector{&lt;:Expression}, vars::AbstractVector{&lt;:Expression}; simplify = true)</code></pre><p>A helper function for computing the sparse Jacobian of an array of expressions with respect to an array of variable expressions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/edaa2dc7139bef7097394f2388ddadafb3d9b6f5/src/direct.jl#L25-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelingToolkit.hessian" href="#ModelingToolkit.hessian"><code>ModelingToolkit.hessian</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">hessian(O::Expression, vars::AbstractVector{&lt;:Expression}; simplify = true)</code></pre><p>A helper function for computing the Hessian of an expression with respect to an array of variable expressions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/edaa2dc7139bef7097394f2388ddadafb3d9b6f5/src/direct.jl#L80-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelingToolkit.sparsehessian" href="#ModelingToolkit.sparsehessian"><code>ModelingToolkit.sparsehessian</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">sparsehessian(O::Expression, vars::AbstractVector{&lt;:Expression}; simplify = true)</code></pre><p>A helper function for computing the sparse Hessian of an expression with respect to an array of variable expressions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/edaa2dc7139bef7097394f2388ddadafb3d9b6f5/src/direct.jl#L156-L163">source</a></section></article><h2 id="Sparsity-Detection-1"><a class="docs-heading-anchor" href="#Sparsity-Detection-1">Sparsity Detection</a><a class="docs-heading-anchor-permalink" href="#Sparsity-Detection-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ModelingToolkit.jacobian_sparsity" href="#ModelingToolkit.jacobian_sparsity"><code>ModelingToolkit.jacobian_sparsity</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">jacobian_sparsity(ops::AbstractVector{&lt;:Expression}, vars::AbstractVector{&lt;:Expression})</code></pre><p>Return the sparsity pattern of the Jacobian of an array of expressions with respect to an array of variable expressions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/edaa2dc7139bef7097394f2388ddadafb3d9b6f5/src/direct.jl#L49-L56">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>ModelingToolkit.hessian_sparsity</code>. Check Documenter&#39;s build log for details.</p></div></div><h2 id="Latexification-1"><a class="docs-heading-anchor" href="#Latexification-1">Latexification</a><a class="docs-heading-anchor-permalink" href="#Latexification-1" title="Permalink"></a></h2><p>ModelingToolkit.jl&#39;s expressions support Latexify.jl, and thus</p><pre><code class="language-julia">using Latexify
latexify(ex)</code></pre><p>will produce LaTeX output from ModelingToolkit models and expressions. This works on basics like <code>Operation</code> all the way to higher primitives like <code>ODESystem</code> and <code>ReactionSystem</code>.</p><h2 id="The-Auto-Detecting-System-Constructors-1"><a class="docs-heading-anchor" href="#The-Auto-Detecting-System-Constructors-1">The Auto-Detecting System Constructors</a><a class="docs-heading-anchor-permalink" href="#The-Auto-Detecting-System-Constructors-1" title="Permalink"></a></h2><p>For the high-level interface, the system constructors, such as <code>ODESystem</code>, have high-level constructors, which just take in the required equations and automatically parse the expressions to figure out the states and parameters of the system. The following high-level constructors exist:</p><pre><code class="language-julia">ODESystem(eqs)
NonlinearSystem(eqs)</code></pre><h2 id="Direct-Tracing-1"><a class="docs-heading-anchor" href="#Direct-Tracing-1">Direct Tracing</a><a class="docs-heading-anchor-permalink" href="#Direct-Tracing-1" title="Permalink"></a></h2><p>Because ModelingToolkit expressions respect Julia semantics, one way to generate symbolic expressions is to simply place ModelingToolkit variables as inputs into existing Julia code. For example, the following uses the standard Julia function for the Lorenz equations to generate the symbolic expression for the Lorenz equations:</p><pre><code class="language-julia">function lorenz(du,u,p,t)
 du[1] = 10.0(u[2]-u[1])
 du[2] = u[1]*(28.0-u[3]) - u[2]
 du[3] = u[1]*u[2] - (8/3)*u[3]
end
@variables t u[1:3](t) du[1:3](t)
@parameters p[1:3]
lorenz(du,u,p,t)
du</code></pre><pre><code class="language-julia">3-element Array{Operation,1}:
                 10.0 * (u₂(t) - u₁(t))
         u₁(t) * (28.0 - u₃(t)) - u₂(t)
u₁(t) * u₂(t) - 2.6666666666666665 * u₃(t)</code></pre><p>Or similarly:</p><pre><code class="language-julia">@variables t x(t) y(t) z(t) dx(t) dy(t) dz(t)
@parameters σ ρ β
du = [dx,dy,dz]
u = [x,y,z]
p = [σ,ρ,β]
lorenz(du,u,p,t)
du</code></pre><pre><code class="language-julia">3-element Array{Operation,1}:
                10.0 * (y(t) - x(t))
         x(t) * (28.0 - z(t)) - y(t)
x(t) * y(t) - 2.6666666666666665 * z(t)</code></pre><h2 id="Intermediate-Calculations-1"><a class="docs-heading-anchor" href="#Intermediate-Calculations-1">Intermediate Calculations</a><a class="docs-heading-anchor-permalink" href="#Intermediate-Calculations-1" title="Permalink"></a></h2><p>The system building functions can handle intermediate calculations by simply defining and using an <code>Operation</code> of <code>Variable</code>s. For example:</p><pre><code class="language-julia">@variables x y z
@parameters σ ρ β
a = y - x
eqs = [0 ~ σ*a,
       0 ~ x*(ρ-z)-y,
       0 ~ x*y - β*z]
ns = NonlinearSystem(eqs, [x,y,z], [σ,ρ,β])
nlsys_func = generate_function(ns)[2] # second is the inplace version</code></pre><p>expands to:</p><pre><code class="language-julia">:((var&quot;##MTIIPVar#368&quot;, var&quot;##MTKArg#365&quot;, var&quot;##MTKArg#366&quot;)-&gt;begin
          @inbounds begin
                  let (x, y, z, σ, ρ, β) = (var&quot;##MTKArg#365&quot;[1], var&quot;##MTKArg#365&quot;[2], var&quot;##MTKArg#365&quot;[3], var&quot;##MTKArg#366&quot;[1], var&quot;##MTKArg#366&quot;[2], var&quot;##MTKArg#366&quot;[3])
                      var&quot;##MTIIPVar#368&quot;[1] = (*)(σ, (-)(y, x))
                      var&quot;##MTIIPVar#368&quot;[2] = (-)((*)(x, (-)(ρ, z)), y)
                      var&quot;##MTIIPVar#368&quot;[3] = (-)((*)(x, y), (*)(β, z))
                  end
              end
          nothing
      end)</code></pre><p>In addition, the Jacobian calculations take into account intermediate variables to appropriately handle them.</p><h2 id="I/O-and-Saving-1"><a class="docs-heading-anchor" href="#I/O-and-Saving-1">I/O and Saving</a><a class="docs-heading-anchor-permalink" href="#I/O-and-Saving-1" title="Permalink"></a></h2><p>Note that Julia&#39;s standard I/O functionality can be used to save ModelingToolkit expressions out to files. For example, here we will generate an in-place version of <code>f</code> and save the anonymous function to a <code>.jl</code> file:</p><pre><code class="language-julia">using ModelingToolkit
@variables u[1:3]
function f(u)
  [u[1]-u[3],u[1]^2-u[2],u[3]+u[2]]
end
ex1, ex2 = build_function(f(u),u)
write(&quot;function.jl&quot;, string(ex2))</code></pre><p>Now we can do something like:</p><pre><code class="language-julia">f = include(&quot;function.jl&quot;)</code></pre><p>and that will load the function back in. Note that this can be done to save the transformation results of ModelingToolkit.jl so that they can be stored and used in a precompiled Julia package.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../comparison/">« Comparison Against SymPy</a><a class="docs-footer-nextpage" href="../IR/">ModelingToolkit IR »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Saturday 11 July 2020 00:53">Saturday 11 July 2020</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
