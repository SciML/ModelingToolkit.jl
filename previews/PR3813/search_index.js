var documenterSearchIndex = {"docs":
[{"location":"tutorials/ode_modeling/#getting_started","page":"Getting Started with ModelingToolkit.jl","title":"Getting Started with ModelingToolkit.jl","text":"","category":"section"},{"location":"tutorials/ode_modeling/","page":"Getting Started with ModelingToolkit.jl","title":"Getting Started with ModelingToolkit.jl","text":"This is an introductory tutorial for ModelingToolkit (MTK). We will demonstrate the basics of the package by demonstrating how to define and simulate simple Ordinary Differential Equation (ODE) systems.","category":"page"},{"location":"tutorials/ode_modeling/#Installing-ModelingToolkit","page":"Getting Started with ModelingToolkit.jl","title":"Installing ModelingToolkit","text":"","category":"section"},{"location":"tutorials/ode_modeling/","page":"Getting Started with ModelingToolkit.jl","title":"Getting Started with ModelingToolkit.jl","text":"To install ModelingToolkit, use the Julia package manager. This can be done as follows:","category":"page"},{"location":"tutorials/ode_modeling/","page":"Getting Started with ModelingToolkit.jl","title":"Getting Started with ModelingToolkit.jl","text":"using Pkg\nPkg.add(\"ModelingToolkit\")","category":"page"},{"location":"tutorials/ode_modeling/#Copy-Pastable-Simplified-Example","page":"Getting Started with ModelingToolkit.jl","title":"Copy-Pastable Simplified Example","text":"","category":"section"},{"location":"tutorials/ode_modeling/","page":"Getting Started with ModelingToolkit.jl","title":"Getting Started with ModelingToolkit.jl","text":"A much deeper tutorial with forcing functions and sparse Jacobians is below. But if you want to just see some code and run it, here's an example:","category":"page"},{"location":"tutorials/ode_modeling/","page":"Getting Started with ModelingToolkit.jl","title":"Getting Started with ModelingToolkit.jl","text":"using ModelingToolkit\nusing ModelingToolkit: t_nounits as t, D_nounits as D\n\n@mtkmodel FOL begin\n    @parameters begin\n        τ = 3.0 # parameters\n    end\n    @variables begin\n        x(t) = 0.0 # dependent variables\n    end\n    @equations begin\n        D(x) ~ (1 - x) / τ\n    end\nend\n\nusing OrdinaryDiffEq\n@mtkcompile fol = FOL()\nprob = ODEProblem(fol, [], (0.0, 10.0), [])\nsol = solve(prob)\n\nusing Plots\nplot(sol)","category":"page"},{"location":"tutorials/ode_modeling/","page":"Getting Started with ModelingToolkit.jl","title":"Getting Started with ModelingToolkit.jl","text":"Now let's start digging into MTK!","category":"page"},{"location":"tutorials/ode_modeling/#Your-very-first-ODE","page":"Getting Started with ModelingToolkit.jl","title":"Your very first ODE","text":"","category":"section"},{"location":"tutorials/ode_modeling/","page":"Getting Started with ModelingToolkit.jl","title":"Getting Started with ModelingToolkit.jl","text":"Let us start with a minimal example. The system to be modelled is a first-order lag element:","category":"page"},{"location":"tutorials/ode_modeling/","page":"Getting Started with ModelingToolkit.jl","title":"Getting Started with ModelingToolkit.jl","text":"dotx = fracf(t) - x(t)tau","category":"page"},{"location":"tutorials/ode_modeling/","page":"Getting Started with ModelingToolkit.jl","title":"Getting Started with ModelingToolkit.jl","text":"Here, t is the independent variable (time), x(t) is the (scalar) unknown variable, f(t) is an external forcing function, and tau is a parameter. In MTK, this system can be modelled as follows. For simplicity, we first set the forcing function to a time-independent value 1. And the independent variable t is automatically added by @mtkmodel.","category":"page"},{"location":"tutorials/ode_modeling/","page":"Getting Started with ModelingToolkit.jl","title":"Getting Started with ModelingToolkit.jl","text":"using ModelingToolkit\nusing ModelingToolkit: t_nounits as t, D_nounits as D\n\n@mtkmodel FOL begin\n    @parameters begin\n        τ = 3.0 # parameters and their values\n    end\n    @variables begin\n        x(t) = 0.0 # dependent variables and their initial conditions\n    end\n    @equations begin\n        D(x) ~ (1 - x) / τ\n    end\nend\n\n@mtkcompile fol = FOL()","category":"page"},{"location":"tutorials/ode_modeling/","page":"Getting Started with ModelingToolkit.jl","title":"Getting Started with ModelingToolkit.jl","text":"Note that equations in MTK use the tilde character (~) as equality sign.","category":"page"},{"location":"tutorials/ode_modeling/","page":"Getting Started with ModelingToolkit.jl","title":"Getting Started with ModelingToolkit.jl","text":"@mtkcompile creates an instance of FOL named as fol.","category":"page"},{"location":"tutorials/ode_modeling/","page":"Getting Started with ModelingToolkit.jl","title":"Getting Started with ModelingToolkit.jl","text":"After construction of the ODE, you can solve it using OrdinaryDiffEq.jl:","category":"page"},{"location":"tutorials/ode_modeling/","page":"Getting Started with ModelingToolkit.jl","title":"Getting Started with ModelingToolkit.jl","text":"using OrdinaryDiffEq\nusing Plots\n\nprob = ODEProblem(fol, [], (0.0, 10.0))\nplot(solve(prob))","category":"page"},{"location":"tutorials/ode_modeling/","page":"Getting Started with ModelingToolkit.jl","title":"Getting Started with ModelingToolkit.jl","text":"The parameter values are determined using the right hand side of the expressions in the @parameters block, and similarly initial conditions are determined using the right hand side of the expressions in the @variables block.","category":"page"},{"location":"tutorials/ode_modeling/#Using-different-values-for-parameters-and-initial-conditions","page":"Getting Started with ModelingToolkit.jl","title":"Using different values for parameters and initial conditions","text":"","category":"section"},{"location":"tutorials/ode_modeling/","page":"Getting Started with ModelingToolkit.jl","title":"Getting Started with ModelingToolkit.jl","text":"If you want to simulate the same model, but with different values for the parameters and initial conditions than the default values, you likely do not want to write an entirely new @mtkmodel. ModelingToolkit supports overwriting the default values:","category":"page"},{"location":"tutorials/ode_modeling/","page":"Getting Started with ModelingToolkit.jl","title":"Getting Started with ModelingToolkit.jl","text":"@mtkcompile fol_different_values = FOL(; τ = 1 / 3, x = 0.5)\nprob = ODEProblem(fol_different_values, [], (0.0, 10.0))\nplot(solve(prob))","category":"page"},{"location":"tutorials/ode_modeling/","page":"Getting Started with ModelingToolkit.jl","title":"Getting Started with ModelingToolkit.jl","text":"Alternatively, this overwriting could also have occurred at the ODEProblem level.","category":"page"},{"location":"tutorials/ode_modeling/","page":"Getting Started with ModelingToolkit.jl","title":"Getting Started with ModelingToolkit.jl","text":"prob = ODEProblem(fol, [fol.x => 0.5, fol.τ => 1 / 3], (0.0, 10.0))\nplot(solve(prob))","category":"page"},{"location":"tutorials/ode_modeling/","page":"Getting Started with ModelingToolkit.jl","title":"Getting Started with ModelingToolkit.jl","text":"Here, the second argument of ODEProblem is an array of Pairs. The left hand side of each Pair is the parameter you want to overwrite, and the right hand side is the value to overwrite it with. Similarly, the initial conditions are overwritten in the fourth argument. One important difference with the previous method is that the parameter has to be referred to as fol.τ instead of just τ.","category":"page"},{"location":"tutorials/ode_modeling/#Algebraic-relations-and-structural-simplification","page":"Getting Started with ModelingToolkit.jl","title":"Algebraic relations and structural simplification","text":"","category":"section"},{"location":"tutorials/ode_modeling/","page":"Getting Started with ModelingToolkit.jl","title":"Getting Started with ModelingToolkit.jl","text":"You could separate the calculation of the right-hand side, by introducing an intermediate variable RHS:","category":"page"},{"location":"tutorials/ode_modeling/","page":"Getting Started with ModelingToolkit.jl","title":"Getting Started with ModelingToolkit.jl","text":"using ModelingToolkit\nusing ModelingToolkit: t_nounits as t, D_nounits as D\n\n@mtkmodel FOL begin\n    @parameters begin\n        τ = 3.0 # parameters and their values\n    end\n    @variables begin\n        x(t) = 0.0 # dependent variables and their initial conditions\n        RHS(t)\n    end\n    @equations begin\n        RHS ~ (1 - x) / τ\n        D(x) ~ RHS\n    end\nend\n\n@mtkcompile fol = FOL()","category":"page"},{"location":"tutorials/ode_modeling/","page":"Getting Started with ModelingToolkit.jl","title":"Getting Started with ModelingToolkit.jl","text":"If you copy this block of code to your REPL, you will not see the above LaTeX equations. Instead, you can look at the equations by using the equations function:","category":"page"},{"location":"tutorials/ode_modeling/","page":"Getting Started with ModelingToolkit.jl","title":"Getting Started with ModelingToolkit.jl","text":"equations(fol)","category":"page"},{"location":"tutorials/ode_modeling/","page":"Getting Started with ModelingToolkit.jl","title":"Getting Started with ModelingToolkit.jl","text":"Notice that there is only one equation in this system, Differential(t)(x(t)) ~ RHS(t). The other equation was removed from the system and was transformed into an observed variable. Observed equations are variables that can be computed on-demand but are not necessary for the solution of the system, and thus MTK tracks them separately. For this reason, we also did not need to specify an initial condition for RHS. You can check the observed equations via the observed function:","category":"page"},{"location":"tutorials/ode_modeling/","page":"Getting Started with ModelingToolkit.jl","title":"Getting Started with ModelingToolkit.jl","text":"observed(fol)","category":"page"},{"location":"tutorials/ode_modeling/","page":"Getting Started with ModelingToolkit.jl","title":"Getting Started with ModelingToolkit.jl","text":"For more information on this process, see Observables and Variable Elimination.","category":"page"},{"location":"tutorials/ode_modeling/","page":"Getting Started with ModelingToolkit.jl","title":"Getting Started with ModelingToolkit.jl","text":"MTK still knows how to calculate them out of the information available in a simulation result. The intermediate variable RHS therefore can be plotted along with the unknown variable. Note that this has to be requested explicitly:","category":"page"},{"location":"tutorials/ode_modeling/","page":"Getting Started with ModelingToolkit.jl","title":"Getting Started with ModelingToolkit.jl","text":"prob = ODEProblem(fol, [], (0.0, 10.0))\nsol = solve(prob)\nplot(sol, idxs = [fol.x, fol.RHS])","category":"page"},{"location":"tutorials/ode_modeling/#Named-Indexing-of-Solutions","page":"Getting Started with ModelingToolkit.jl","title":"Named Indexing of Solutions","text":"","category":"section"},{"location":"tutorials/ode_modeling/","page":"Getting Started with ModelingToolkit.jl","title":"Getting Started with ModelingToolkit.jl","text":"Note that the indexing of the solution also works via the symbol, and so to get the time series for x, you would do:","category":"page"},{"location":"tutorials/ode_modeling/","page":"Getting Started with ModelingToolkit.jl","title":"Getting Started with ModelingToolkit.jl","text":"sol[fol.x]","category":"page"},{"location":"tutorials/ode_modeling/","page":"Getting Started with ModelingToolkit.jl","title":"Getting Started with ModelingToolkit.jl","text":"or to get the second value in the time series for x:","category":"page"},{"location":"tutorials/ode_modeling/","page":"Getting Started with ModelingToolkit.jl","title":"Getting Started with ModelingToolkit.jl","text":"sol[fol.x, 2]","category":"page"},{"location":"tutorials/ode_modeling/","page":"Getting Started with ModelingToolkit.jl","title":"Getting Started with ModelingToolkit.jl","text":"Similarly, the time series for RHS can be retrieved using the same symbolic indexing:","category":"page"},{"location":"tutorials/ode_modeling/","page":"Getting Started with ModelingToolkit.jl","title":"Getting Started with ModelingToolkit.jl","text":"sol[fol.RHS]","category":"page"},{"location":"tutorials/ode_modeling/#Specifying-a-time-variable-forcing-function","page":"Getting Started with ModelingToolkit.jl","title":"Specifying a time-variable forcing function","text":"","category":"section"},{"location":"tutorials/ode_modeling/","page":"Getting Started with ModelingToolkit.jl","title":"Getting Started with ModelingToolkit.jl","text":"What if the forcing function (the “external input”) f(t) is not constant? Obviously, one could use an explicit, symbolic function of time:","category":"page"},{"location":"tutorials/ode_modeling/","page":"Getting Started with ModelingToolkit.jl","title":"Getting Started with ModelingToolkit.jl","text":"@mtkmodel FOL begin\n    @parameters begin\n        τ = 3.0 # parameters and their values\n    end\n    @variables begin\n        x(t) = 0.0 # dependent variables and their initial conditions\n        f(t)\n    end\n    @equations begin\n        f ~ sin(t)\n        D(x) ~ (f - x) / τ\n    end\nend\n\n@mtkcompile fol_variable_f = FOL()","category":"page"},{"location":"tutorials/ode_modeling/","page":"Getting Started with ModelingToolkit.jl","title":"Getting Started with ModelingToolkit.jl","text":"However, this function might not be available in an explicit form. Instead, the function might be provided as time-series data. MTK handles this situation by allowing us to “register” arbitrary Julia functions, which are excluded from symbolic transformations and thus used as-is. For example, you could interpolate given the time-series using DataInterpolations.jl. Here, we illustrate this option with a simple lookup (\"zero-order hold\") of a vector of random values:","category":"page"},{"location":"tutorials/ode_modeling/","page":"Getting Started with ModelingToolkit.jl","title":"Getting Started with ModelingToolkit.jl","text":"value_vector = randn(10)\nf_fun(t) = t >= 10 ? value_vector[end] : value_vector[Int(floor(t)) + 1]\n@register_symbolic f_fun(t)\n\n@mtkmodel FOLExternalFunction begin\n    @parameters begin\n        τ = 0.75 # parameters and their values\n    end\n    @variables begin\n        x(t) = 0.0 # dependent variables and their initial conditions\n        f(t)\n    end\n    @equations begin\n        f ~ f_fun(t)\n        D(x) ~ (f - x) / τ\n    end\nend\n\n@mtkcompile fol_external_f = FOLExternalFunction()","category":"page"},{"location":"tutorials/ode_modeling/","page":"Getting Started with ModelingToolkit.jl","title":"Getting Started with ModelingToolkit.jl","text":"prob = ODEProblem(fol_external_f, [], (0.0, 10.0))\nsol = solve(prob)\nplot(sol, idxs = [fol_external_f.x, fol_external_f.f])","category":"page"},{"location":"tutorials/ode_modeling/#Building-component-based,-hierarchical-models","page":"Getting Started with ModelingToolkit.jl","title":"Building component-based, hierarchical models","text":"","category":"section"},{"location":"tutorials/ode_modeling/","page":"Getting Started with ModelingToolkit.jl","title":"Getting Started with ModelingToolkit.jl","text":"Working with simple one-equation systems is already fun, but composing more complex systems from simple ones is even more fun. The best practice for such a “modeling framework” is to use the @components block in the @mtkmodel macro:","category":"page"},{"location":"tutorials/ode_modeling/","page":"Getting Started with ModelingToolkit.jl","title":"Getting Started with ModelingToolkit.jl","text":"@mtkmodel FOLUnconnectedFunction begin\n    @parameters begin\n        τ # parameters\n    end\n    @variables begin\n        x(t) # dependent variables\n        f(t)\n        RHS(t)\n    end\n    @equations begin\n        RHS ~ f\n        D(x) ~ (RHS - x) / τ\n    end\nend\n@mtkmodel FOLConnected begin\n    @components begin\n        fol_1 = FOLUnconnectedFunction(; τ = 2.0, x = -0.5)\n        fol_2 = FOLUnconnectedFunction(; τ = 4.0, x = 1.0)\n    end\n    @equations begin\n        fol_1.f ~ 1.5\n        fol_2.f ~ fol_1.x\n    end\nend\n@mtkcompile connected = FOLConnected()","category":"page"},{"location":"tutorials/ode_modeling/","page":"Getting Started with ModelingToolkit.jl","title":"Getting Started with ModelingToolkit.jl","text":"Here the total model consists of two of the same submodels (components), but with a different input function, parameter values and initial conditions. The first model has a constant input, and the second model uses the state x of the first system as an input. To avoid having to type the same differential equation multiple times, we define the submodel in a separate @mtkmodel. We then reuse this submodel twice in the total model @components block. The inputs of two submodels then still have to be specified in the @equations block.","category":"page"},{"location":"tutorials/ode_modeling/","page":"Getting Started with ModelingToolkit.jl","title":"Getting Started with ModelingToolkit.jl","text":"All equations, variables, and parameters are collected, but the structure of the hierarchical model is still preserved. This means you can still get information about fol_1 by addressing it by connected.fol_1, or its parameter by connected.fol_1.τ.","category":"page"},{"location":"tutorials/ode_modeling/","page":"Getting Started with ModelingToolkit.jl","title":"Getting Started with ModelingToolkit.jl","text":"As expected, only the two equations with the derivatives of unknowns remain, as if you had manually eliminated as many variables as possible from the equations. Some observed variables are not expanded unless full_equations is used. As mentioned above, the hierarchical structure is preserved. So, the initial unknown and the parameter values can be specified accordingly when building the ODEProblem:","category":"page"},{"location":"tutorials/ode_modeling/","page":"Getting Started with ModelingToolkit.jl","title":"Getting Started with ModelingToolkit.jl","text":"prob = ODEProblem(connected, [], (0.0, 10.0))\nplot(solve(prob))","category":"page"},{"location":"tutorials/ode_modeling/","page":"Getting Started with ModelingToolkit.jl","title":"Getting Started with ModelingToolkit.jl","text":"More on this topic may be found in Composing Models and Building Reusable Components.","category":"page"},{"location":"tutorials/ode_modeling/#Symbolic-and-sparse-derivatives","page":"Getting Started with ModelingToolkit.jl","title":"Symbolic and sparse derivatives","text":"","category":"section"},{"location":"tutorials/ode_modeling/","page":"Getting Started with ModelingToolkit.jl","title":"Getting Started with ModelingToolkit.jl","text":"One advantage of a symbolic toolkit is that derivatives can be calculated explicitly, and that the incidence matrix of partial derivatives (the “sparsity pattern”) can also be explicitly derived. These two facts lead to a substantial speedup of all model calculations, e.g. when simulating a model over time using an ODE solver.","category":"page"},{"location":"tutorials/ode_modeling/","page":"Getting Started with ModelingToolkit.jl","title":"Getting Started with ModelingToolkit.jl","text":"By default, analytical derivatives and sparse matrices, e.g. for the Jacobian, the matrix of first partial derivatives, are not used. Let's benchmark this (prob still is the problem using the connected system above):","category":"page"},{"location":"tutorials/ode_modeling/","page":"Getting Started with ModelingToolkit.jl","title":"Getting Started with ModelingToolkit.jl","text":"using BenchmarkTools\n@btime solve(prob, Rodas4());\nnothing # hide","category":"page"},{"location":"tutorials/ode_modeling/","page":"Getting Started with ModelingToolkit.jl","title":"Getting Started with ModelingToolkit.jl","text":"Now have MTK provide sparse, analytical derivatives to the solver. This has to be specified during the construction of the ODEProblem:","category":"page"},{"location":"tutorials/ode_modeling/","page":"Getting Started with ModelingToolkit.jl","title":"Getting Started with ModelingToolkit.jl","text":"prob_an = ODEProblem(connected, [], (0.0, 10.0); jac = true)\n@btime solve(prob_an, Rodas4());\nnothing # hide","category":"page"},{"location":"tutorials/ode_modeling/","page":"Getting Started with ModelingToolkit.jl","title":"Getting Started with ModelingToolkit.jl","text":"prob_sparse = ODEProblem(connected, [], (0.0, 10.0); jac = true, sparse = true)\n@btime solve(prob_sparse, Rodas4());\nnothing # hide","category":"page"},{"location":"tutorials/ode_modeling/","page":"Getting Started with ModelingToolkit.jl","title":"Getting Started with ModelingToolkit.jl","text":"The speedup using the analytical Jacobian is significant. For this small dense model (3 of 4 entries populated), using sparse matrices is counterproductive in terms of required memory allocations. For large, hierarchically built models, which tend to be sparse, speedup and the reduction of memory allocation can also be expected to be substantial. In addition, these problem builders allow for automatic parallelism by exploiting the structural information. For more information, see the System page.","category":"page"},{"location":"tutorials/ode_modeling/#Notes-and-pointers-how-to-go-on","page":"Getting Started with ModelingToolkit.jl","title":"Notes and pointers how to go on","text":"","category":"section"},{"location":"tutorials/ode_modeling/","page":"Getting Started with ModelingToolkit.jl","title":"Getting Started with ModelingToolkit.jl","text":"Here are some notes that may be helpful during your initial steps with MTK:","category":"page"},{"location":"tutorials/ode_modeling/","page":"Getting Started with ModelingToolkit.jl","title":"Getting Started with ModelingToolkit.jl","text":"The @mtkmodel macro is for high-level usage of MTK. However, in many cases you may need to programmatically generate Systems. If that's the case, check out the Programmatically Generating and Scripting Systems Tutorial.\nVector-valued parameters and variables are possible. A cleaner, more consistent treatment of these is still a work in progress, however. Once finished, this introductory tutorial will also cover this feature.","category":"page"},{"location":"tutorials/ode_modeling/","page":"Getting Started with ModelingToolkit.jl","title":"Getting Started with ModelingToolkit.jl","text":"Where to go next?","category":"page"},{"location":"tutorials/ode_modeling/","page":"Getting Started with ModelingToolkit.jl","title":"Getting Started with ModelingToolkit.jl","text":"Not sure how MTK relates to similar tools and packages? Read Comparison of ModelingToolkit vs Equation-Based and Block Modeling Languages.\nFor a more detailed explanation of @mtkmodel checkout Defining components with @mtkmodel and connectors with @connectors\nDepending on what you want to do with MTK, have a look at some of the other Symbolic Modeling Tutorials.\nIf you want to automatically convert an existing function to a symbolic representation, you might go through the ModelingToolkitize Tutorials.\nTo learn more about the inner workings of MTK, consider the sections under Basics and System Types.","category":"page"},{"location":"examples/remake/#Optimizing-through-an-ODE-solve-and-re-creating-MTK-Problems","page":"Optimizing through an ODE solve and re-creating MTK Problems","title":"Optimizing through an ODE solve and re-creating MTK Problems","text":"","category":"section"},{"location":"examples/remake/","page":"Optimizing through an ODE solve and re-creating MTK Problems","title":"Optimizing through an ODE solve and re-creating MTK Problems","text":"Solving an ODE as part of an OptimizationProblem's loss function is a common scenario. In this example, we will go through an efficient way to model such scenarios using ModelingToolkit.jl.","category":"page"},{"location":"examples/remake/","page":"Optimizing through an ODE solve and re-creating MTK Problems","title":"Optimizing through an ODE solve and re-creating MTK Problems","text":"First, we build the ODE to be solved. For this example, we will use a Lotka-Volterra model:","category":"page"},{"location":"examples/remake/","page":"Optimizing through an ODE solve and re-creating MTK Problems","title":"Optimizing through an ODE solve and re-creating MTK Problems","text":"using ModelingToolkit\nusing ModelingToolkit: t_nounits as t, D_nounits as D\n\n@parameters α β γ δ\n@variables x(t) y(t)\neqs = [D(x) ~ (α - β * y) * x\n       D(y) ~ (δ * x - γ) * y]\n@mtkcompile odesys = System(eqs, t)","category":"page"},{"location":"examples/remake/","page":"Optimizing through an ODE solve and re-creating MTK Problems","title":"Optimizing through an ODE solve and re-creating MTK Problems","text":"To create the \"data\" for optimization, we will solve the system with a known set of parameters.","category":"page"},{"location":"examples/remake/","page":"Optimizing through an ODE solve and re-creating MTK Problems","title":"Optimizing through an ODE solve and re-creating MTK Problems","text":"using OrdinaryDiffEq\n\nodeprob = ODEProblem(\n    odesys, [x => 1.0, y => 1.0, α => 1.5, β => 1.0, γ => 3.0, δ => 1.0], (0.0, 10.0))\ntimesteps = 0.0:0.1:10.0\nsol = solve(odeprob, Tsit5(); saveat = timesteps)\ndata = Array(sol)\n# add some random noise\ndata = data + 0.01 * randn(size(data))","category":"page"},{"location":"examples/remake/","page":"Optimizing through an ODE solve and re-creating MTK Problems","title":"Optimizing through an ODE solve and re-creating MTK Problems","text":"Now we will create the loss function for the Optimization solve. This will require creating an ODEProblem with the parameter values passed to the loss function. Creating a new ODEProblem is expensive and requires differentiating through the code generation process. This can be bug-prone and is unnecessary. Instead, we will leverage the remake function. This allows creating a copy of an existing problem with updating state/parameter values. It should be noted that the types of the values passed to the loss function may not agree with the types stored in the existing ODEProblem. Thus, we cannot use setp to modify the problem in-place. Here, we will use the replace function from SciMLStructures.jl since it allows updating the entire Tunable portion of the parameter object which contains the parameters to optimize.","category":"page"},{"location":"examples/remake/","page":"Optimizing through an ODE solve and re-creating MTK Problems","title":"Optimizing through an ODE solve and re-creating MTK Problems","text":"using SymbolicIndexingInterface: parameter_values, state_values\nusing SciMLStructures: Tunable, canonicalize, replace, replace!\nusing PreallocationTools\n\nfunction loss(x, p)\n    odeprob = p[1] # ODEProblem stored as parameters to avoid using global variables\n    ps = parameter_values(odeprob) # obtain the parameter object from the problem\n    diffcache = p[5]\n    # get an appropriately typed preallocated buffer to store the `x` values in\n    buffer = get_tmp(diffcache, x)\n    # copy the current values to this buffer\n    copyto!(buffer, canonicalize(Tunable(), ps)[1])\n    # create a copy of the parameter object with the buffer\n    ps = replace(Tunable(), ps, buffer)\n    # set the updated values in the parameter object\n    setter = p[4]\n    setter(ps, x)\n    # remake the problem, passing in our new parameter object\n    newprob = remake(odeprob; p = ps)\n    timesteps = p[2]\n    sol = solve(newprob, AutoTsit5(Rosenbrock23()); saveat = timesteps)\n    truth = p[3]\n    data = Array(sol)\n    return sum((truth .- data) .^ 2) / length(truth)\nend","category":"page"},{"location":"examples/remake/","page":"Optimizing through an ODE solve and re-creating MTK Problems","title":"Optimizing through an ODE solve and re-creating MTK Problems","text":"Note how the problem, timesteps and true data are stored as model parameters. This helps avoid referencing global variables in the function, which would slow it down significantly.","category":"page"},{"location":"examples/remake/","page":"Optimizing through an ODE solve and re-creating MTK Problems","title":"Optimizing through an ODE solve and re-creating MTK Problems","text":"We could have done the same thing by passing remake a map of parameter values. For example, let us enforce that the order of ODE parameters in x is [α β γ δ]. Then, we could have done:","category":"page"},{"location":"examples/remake/","page":"Optimizing through an ODE solve and re-creating MTK Problems","title":"Optimizing through an ODE solve and re-creating MTK Problems","text":"remake(odeprob; p = [α => x[1], β => x[2], γ => x[3], δ => x[4]])","category":"page"},{"location":"examples/remake/","page":"Optimizing through an ODE solve and re-creating MTK Problems","title":"Optimizing through an ODE solve and re-creating MTK Problems","text":"However, passing a symbolic map to remake is significantly slower than passing it a parameter object directly. Thus, we use replace to speed up the process. In general, remake is the most flexible method, but the flexibility comes at a cost of performance.","category":"page"},{"location":"examples/remake/","page":"Optimizing through an ODE solve and re-creating MTK Problems","title":"Optimizing through an ODE solve and re-creating MTK Problems","text":"We can perform the optimization as below:","category":"page"},{"location":"examples/remake/","page":"Optimizing through an ODE solve and re-creating MTK Problems","title":"Optimizing through an ODE solve and re-creating MTK Problems","text":"using Optimization\nusing OptimizationOptimJL\nusing SymbolicIndexingInterface\n\n# manually create an OptimizationFunction to ensure usage of `ForwardDiff`, which will\n# require changing the types of parameters from `Float64` to `ForwardDiff.Dual`\noptfn = OptimizationFunction(loss, Optimization.AutoForwardDiff())\n# function to set the parameters we are optimizing\nsetter = setp(odeprob, [α, β, γ, δ])\n# `DiffCache` to avoid allocations.\n# `copy` prevents the buffer stored by `DiffCache` from aliasing the one in\n# `parameter_values(odeprob)`.\ndiffcache = DiffCache(copy(canonicalize(Tunable(), parameter_values(odeprob))[1]))\n# parameter object is a tuple, to store differently typed objects together\noptprob = OptimizationProblem(\n    optfn, rand(4), (odeprob, timesteps, data, setter, diffcache),\n    lb = 0.1zeros(4), ub = 3ones(4))\nsol = solve(optprob, BFGS())","category":"page"},{"location":"examples/remake/#Re-creating-the-problem","page":"Optimizing through an ODE solve and re-creating MTK Problems","title":"Re-creating the problem","text":"","category":"section"},{"location":"examples/remake/","page":"Optimizing through an ODE solve and re-creating MTK Problems","title":"Optimizing through an ODE solve and re-creating MTK Problems","text":"There are multiple ways to re-create a problem with new state/parameter values. We will go over the various methods, listing their use cases.","category":"page"},{"location":"examples/remake/#Pure-remake","page":"Optimizing through an ODE solve and re-creating MTK Problems","title":"Pure remake","text":"","category":"section"},{"location":"examples/remake/","page":"Optimizing through an ODE solve and re-creating MTK Problems","title":"Optimizing through an ODE solve and re-creating MTK Problems","text":"This method is the most generic. It can handle symbolic maps, initializations of parameters/states dependent on each other and partial updates. However, this comes at the cost of performance. remake is also not always inferable.","category":"page"},{"location":"examples/remake/#remake-and-setp/setu","page":"Optimizing through an ODE solve and re-creating MTK Problems","title":"remake and setp/setu","text":"","category":"section"},{"location":"examples/remake/","page":"Optimizing through an ODE solve and re-creating MTK Problems","title":"Optimizing through an ODE solve and re-creating MTK Problems","text":"Calling remake(prob) creates a copy of the existing problem. This new problem has the exact same types as the original one, and the remake call is fully inferred. State/parameter values can be modified after the copy by using setp and/or setu. This is most appropriate when the types of state/parameter values does not need to be changed, only their values.","category":"page"},{"location":"examples/remake/#replace-and-remake","page":"Optimizing through an ODE solve and re-creating MTK Problems","title":"replace and remake","text":"","category":"section"},{"location":"examples/remake/","page":"Optimizing through an ODE solve and re-creating MTK Problems","title":"Optimizing through an ODE solve and re-creating MTK Problems","text":"replace returns a copy of a parameter object, with the appropriate portion replaced by new values. This is useful for changing the type of an entire portion, such as during the optimization process described above. remake is used in this case to create a copy of the problem with updated state/unknown values.","category":"page"},{"location":"examples/remake/#remake-and-replace!","page":"Optimizing through an ODE solve and re-creating MTK Problems","title":"remake and replace!","text":"","category":"section"},{"location":"examples/remake/","page":"Optimizing through an ODE solve and re-creating MTK Problems","title":"Optimizing through an ODE solve and re-creating MTK Problems","text":"replace! is similar to replace, except that it operates in-place. This means that the parameter values must be of the same types. This is useful for cases where bulk parameter replacement is required without needing to change types. For example, optimization methods where the gradient is not computed using dual numbers (as demonstrated above).","category":"page"},{"location":"API/PDESystem/#PDESystem","page":"PDESystem","title":"PDESystem","text":"","category":"section"},{"location":"API/PDESystem/","page":"PDESystem","title":"PDESystem","text":"PDESystem is the common symbolic PDE specification for the SciML ecosystem. It is currently being built as a component of the ModelingToolkit ecosystem,","category":"page"},{"location":"API/PDESystem/#Vision","page":"PDESystem","title":"Vision","text":"","category":"section"},{"location":"API/PDESystem/","page":"PDESystem","title":"PDESystem","text":"The vision for the common PDE interface is that a user should only have to specify their PDE once, mathematically, and have instant access to everything as simple as a finite difference method with constant grid spacing, to something as complex as a distributed multi-GPU discontinuous Galerkin method.","category":"page"},{"location":"API/PDESystem/","page":"PDESystem","title":"PDESystem","text":"The key to the common PDE interface is a separation of the symbolic handling from the numerical world. All the discretizers should not “solve” the PDE, but instead be a conversion of the mathematical specification to a numerical problem. Preferably, the transformation should be to another ModelingToolkit.jl AbstractSystem, but in some cases this cannot be done or will not be performant, so a SciMLProblem is the other choice.","category":"page"},{"location":"API/PDESystem/","page":"PDESystem","title":"PDESystem","text":"These elementary problems, such as solving linear systems Ax=b, solving nonlinear systems f(x)=0, ODEs, etc. are all defined by SciMLBase.jl, which then numerical solvers can all target these common forms. Thus, someone who works on linear solvers doesn't necessarily need to be working on a discontinuous Galerkin or finite element library, but instead \"linear solvers that are good for matrices A with properties ...\" which are then accessible by every other discretization method in the common PDE interface.","category":"page"},{"location":"API/PDESystem/","page":"PDESystem","title":"PDESystem","text":"Similar to the rest of the AbstractSystem types, transformation, and analysis functions will allow for simplifying the PDE before solving it, and constructing block symbolic functions like Jacobians.","category":"page"},{"location":"API/PDESystem/#Constructors","page":"PDESystem","title":"Constructors","text":"","category":"section"},{"location":"API/PDESystem/#ModelingToolkit.PDESystem","page":"PDESystem","title":"ModelingToolkit.PDESystem","text":"struct PDESystem <: ModelingToolkit.AbstractSystem\n\nA system of partial differential equations.\n\nFields\n\neqs: The equations which define the PDE.\nbcs: The boundary conditions.\ndomain: The domain for the independent variables.\nivs: The independent variables.\ndvs: The dependent variables.\nps: The parameters.\ndefaults: The default values to use when initial conditions and/or parameters are not supplied in ODEProblem.\n\nconnector_type: Type of the system.\n\nsystems: The internal systems. These are required to have unique names.\n\nanalytic: A vector of explicit symbolic expressions for the analytic solutions of each dependent variable. e.g. analytic = [u(t, x) ~ a*sin(c*t) * cos(k*x)].\n\nanalytic_func: A vector of functions for the analytic solutions of each dependent variable. Will be generated from analytic if not provided. Should have the same argument signature as the variable, and a ps argument as the last argument, which takes an indexable of parameter values in the order you specified them in ps. e.g. analytic_func = [u(t, x) => (ps, t, x) -> ps[1]*sin(ps[2]*t) * cos(ps[3]*x)].\n\nname: The name of the system.\n\ndescription: A description of the system.\n\nmetadata: Metadata for the system, to be used by downstream packages.\n\ngui_metadata: Metadata for MTK GUI.\n\nExample\n\nusing ModelingToolkit\n\n@parameters x t\n@variables u(..)\nDxx = Differential(x)^2\nDtt = Differential(t)^2\nDt = Differential(t)\n\n#2D PDE\nC=1\neq  = Dtt(u(t,x)) ~ C^2*Dxx(u(t,x))\n\n# Initial and boundary conditions\nbcs = [u(t,0) ~ 0.,# for all t > 0\n       u(t,1) ~ 0.,# for all t > 0\n       u(0,x) ~ x*(1. - x), #for all 0 < x < 1\n       Dt(u(0,x)) ~ 0. ] #for all  0 < x < 1]\n\n# Space and time domains\ndomains = [t ∈ (0.0,1.0),\n           x ∈ (0.0,1.0)]\n\n@named pde_system = PDESystem(eq,bcs,domains,[t,x],[u])\n\n\n\n\n\n","category":"type"},{"location":"API/PDESystem/#Domains-(WIP)","page":"PDESystem","title":"Domains (WIP)","text":"","category":"section"},{"location":"API/PDESystem/","page":"PDESystem","title":"PDESystem","text":"Domains are specifying by saying indepvar in domain, where indepvar is a single or a collection of independent variables, and domain is the chosen domain type. A 2-tuple can be used to indicate an Interval. Thus forms for the indepvar can be like:","category":"page"},{"location":"API/PDESystem/","page":"PDESystem","title":"PDESystem","text":"t ∈ (0.0, 1.0)\n(t, x) ∈ UnitDisk()\n[v, w, x, y, z] ∈ VectorUnitBall(5)","category":"page"},{"location":"API/PDESystem/#Domain-Types-(WIP)","page":"PDESystem","title":"Domain Types (WIP)","text":"","category":"section"},{"location":"API/PDESystem/","page":"PDESystem","title":"PDESystem","text":"Interval(a,b): Defines the domain of an interval from a to b (requires explicit import from DomainSets.jl, but a 2-tuple can be used instead)","category":"page"},{"location":"API/PDESystem/#discretize-and-symbolic_discretize","page":"PDESystem","title":"discretize and symbolic_discretize","text":"","category":"section"},{"location":"API/PDESystem/","page":"PDESystem","title":"PDESystem","text":"The only functions which act on a PDESystem are the following:","category":"page"},{"location":"API/PDESystem/","page":"PDESystem","title":"PDESystem","text":"discretize(sys,discretizer): produces the outputted AbstractSystem or SciMLProblem.\nsymbolic_discretize(sys,discretizer): produces a debugging symbolic description of the discretized problem.","category":"page"},{"location":"API/PDESystem/#Boundary-Conditions-(WIP)","page":"PDESystem","title":"Boundary Conditions (WIP)","text":"","category":"section"},{"location":"API/PDESystem/#Transformations","page":"PDESystem","title":"Transformations","text":"","category":"section"},{"location":"API/PDESystem/#Analyses","page":"PDESystem","title":"Analyses","text":"","category":"section"},{"location":"API/PDESystem/#Discretizer-Ecosystem","page":"PDESystem","title":"Discretizer Ecosystem","text":"","category":"section"},{"location":"API/PDESystem/#NeuralPDE.jl:-PhysicsInformedNN","page":"PDESystem","title":"NeuralPDE.jl: PhysicsInformedNN","text":"","category":"section"},{"location":"API/PDESystem/","page":"PDESystem","title":"PDESystem","text":"NeuralPDE.jl defines the PhysicsInformedNN discretizer which uses a DiffEqFlux.jl neural network to solve the differential equation.","category":"page"},{"location":"API/PDESystem/#MethodOfLines.jl:-MOLFiniteDifference","page":"PDESystem","title":"MethodOfLines.jl: MOLFiniteDifference","text":"","category":"section"},{"location":"API/PDESystem/","page":"PDESystem","title":"PDESystem","text":"MethodOfLines.jl defines the MOLFiniteDifference discretizer which performs a finite difference discretization. Includes support for higher approximation order stencils and nonuniform grids.","category":"page"},{"location":"basics/FAQ/#Frequently-Asked-Questions","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"","category":"section"},{"location":"basics/FAQ/#Why-are-my-parameters-some-obscure-object?","page":"Frequently Asked Questions","title":"Why are my parameters some obscure object?","text":"","category":"section"},{"location":"basics/FAQ/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"In ModelingToolkit.jl version 9, the parameter vector was replaced with a custom MTKParameters object, whose internals are intentionally undocumented and subject to change without a breaking release. This enables us to efficiently store and generate code for parameters of multiple types. To obtain parameter values use SymbolicIndexingInterface.jl or SciMLStructures.jl. For example:","category":"page"},{"location":"basics/FAQ/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"prob.ps[lorenz.β] # obtains the value of parameter `β`. Note the `.ps` instead of `.p`\ngetβ = getp(prob, lorenz.β) # returns a function that can fetch the value of `β`\ngetβ(sol) # can be used on any object that is based off of the same system\ngetβ(prob)","category":"page"},{"location":"basics/FAQ/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"Indexes into the MTKParameters object take the form of ParameterIndex objects, which are similarly undocumented. Following is the list of behaviors that should be relied on for MTKParameters:","category":"page"},{"location":"basics/FAQ/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"It implements the SciMLStructures interface.\nIt can be queried for parameters using functions returned from SymbolicIndexingInterface.getp.\ngetindex(::MTKParameters, ::ParameterIndex) can be used to obtain the value of a parameter with the given index.\nsetindex!(::MTKParameters, value, ::ParameterIndex) can be used to set the value of a parameter with the given index.\nparameter_index(sys, sym) will return a ParameterIndex object if sys has been completed (through mtkcompile, complete or @mtkcompile).\ncopy(::MTKParameters) is defined and duplicates the parameter object, including the memory used by the underlying buffers.","category":"page"},{"location":"basics/FAQ/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"Any other behavior of MTKParameters (other getindex/setindex! methods, etc.) is an undocumented internal and should not be relied upon.","category":"page"},{"location":"basics/FAQ/#How-do-I-use-non-numeric/array-valued-parameters?","page":"Frequently Asked Questions","title":"How do I use non-numeric/array-valued parameters?","text":"","category":"section"},{"location":"basics/FAQ/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"In ModelingToolkit.jl version 9, parameters are required to have a symtype matching the type of their values. For example, this will error during problem construction:","category":"page"},{"location":"basics/FAQ/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"@parameters p = [1, 2, 3]","category":"page"},{"location":"basics/FAQ/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"Since by default parameters have a symtype of Real (which is interpreted as Float64) but the default value given to it is a Vector{Int}. For array-valued parameters, use the following syntax:","category":"page"},{"location":"basics/FAQ/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"@parameters p[1:n, 1:m]::T # `T` is the `eltype` of the parameter array\n@parameters p::T # `T` is the type of the array","category":"page"},{"location":"basics/FAQ/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"The former approach is preferred, since the size of the array is known. If the array is not a Base.Array or the size is not known during model construction, the second syntax is required.","category":"page"},{"location":"basics/FAQ/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"The same principle applies to any parameter type that is not Float64.","category":"page"},{"location":"basics/FAQ/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"@parameters p1::Int # integer-valued\n@parameters p2::Bool # boolean-valued\n@parameters p3::MyCustomStructType # non-numeric\n@parameters p4::ComponentArray{_...} # non-standard array","category":"page"},{"location":"basics/FAQ/#Getting-the-index-for-a-symbol","page":"Frequently Asked Questions","title":"Getting the index for a symbol","text":"","category":"section"},{"location":"basics/FAQ/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"Ordering of symbols is not guaranteed after symbolic transformations, and parameters are now stored in a custom MTKParameters object instead of a vector. Thus, values should be referred to by their name. For example sol[lorenz.x]. To obtain the index, use the following functions from SymbolicIndexingInterface.jl:","category":"page"},{"location":"basics/FAQ/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"variable_index(sys, sym)\nparameter_index(sys, sym)","category":"page"},{"location":"basics/FAQ/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"Note that while the variable index will be an integer, the parameter index is a struct of type ParameterIndex whose internals should not be relied upon.","category":"page"},{"location":"basics/FAQ/#Can-I-index-with-strings?","page":"Frequently Asked Questions","title":"Can I index with strings?","text":"","category":"section"},{"location":"basics/FAQ/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"Strings are not considered symbolic variables, and thus cannot directly be used for symbolic indexing. However, ModelingToolkit does provide a method to parse the string representation of a variable, given the system in which that variable exists.","category":"page"},{"location":"basics/FAQ/#ModelingToolkit.parse_variable-basics-FAQ","page":"Frequently Asked Questions","title":"ModelingToolkit.parse_variable","text":"parse_variable(\n    sys::ModelingToolkit.AbstractSystem,\n    str::AbstractString\n) -> Any\n\n\nReturn the variable in sys referred to by its string representation str. Roughly supports the following CFG:\n\nvarname                  = \"D(\" varname \")\" | \"Differential(\" iv \")(\" varname \")\" | arrvar | maybe_dummy_var\narrvar                   = maybe_dummy_var \"[idxs...]\"\nidxs                     = int | int \",\" idxs\nmaybe_dummy_var          = namespacedvar | namespacedvar \"(\" iv \")\" |\n                           namespacedvar \"(\" iv \")\" \"ˍ\" ts | namespacedvar \"ˍ\" ts |\n                           namespacedvar \"ˍ\" ts \"(\" iv \")\"\nts                       = iv | iv ts\nnamespacedvar            = ident \"₊\" namespacedvar | ident \".\" namespacedvar | ident\n\nWhere iv is the independent variable, int is an integer and ident is an identifier.\n\n\n\n\n\n","category":"function"},{"location":"basics/FAQ/#Transforming-value-maps-to-arrays","page":"Frequently Asked Questions","title":"Transforming value maps to arrays","text":"","category":"section"},{"location":"basics/FAQ/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"ModelingToolkit.jl allows (and recommends) input maps like [x => 2.0, y => 3.0] because symbol ordering is not guaranteed. However, what if you want to get the lowered array? You can use the internal function varmap_to_vars for unknowns. and the MTKParameters constructor for parameters. For example:","category":"page"},{"location":"basics/FAQ/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"unew = varmap_to_vars([x => 1.0, y => 2.0, z => 3.0], unknowns(sys))\npnew = ModelingToolkit.MTKParameters(sys, [β => 3.0, c => 10.0, γ => 2.0], unew)","category":"page"},{"location":"basics/FAQ/#How-do-I-handle-if-statements-in-my-symbolic-forms?","page":"Frequently Asked Questions","title":"How do I handle if statements in my symbolic forms?","text":"","category":"section"},{"location":"basics/FAQ/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"For statements that are in the if then else form, use Base.ifelse from the to represent the code in a functional form. For handling direct if statements, you can use equivalent boolean mathematical expressions. For example, if x > 0 ... can be implemented as just (x > 0) *, where if x <= 0 then the boolean will evaluate to 0 and thus the term will be excluded from the model.","category":"page"},{"location":"basics/FAQ/#ERROR:-TypeError:-non-boolean-(Num)-used-in-boolean-context?","page":"Frequently Asked Questions","title":"ERROR: TypeError: non-boolean (Num) used in boolean context?","text":"","category":"section"},{"location":"basics/FAQ/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"If you see the error:","category":"page"},{"location":"basics/FAQ/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"ERROR: TypeError: non-boolean (Num) used in boolean context","category":"page"},{"location":"basics/FAQ/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"then it's likely you are trying to trace through a function which cannot be directly represented in Julia symbols. The techniques to handle this problem, such as @register_symbolic, are described in detail in the Symbolics.jl documentation.","category":"page"},{"location":"basics/FAQ/#Using-ModelingToolkit-with-Optimization-/-Automatic-Differentiation","page":"Frequently Asked Questions","title":"Using ModelingToolkit with Optimization / Automatic Differentiation","text":"","category":"section"},{"location":"basics/FAQ/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"If you are using ModelingToolkit inside a loss function and are having issues with mixing MTK with automatic differentiation, getting performance, etc… don't! Instead, use MTK outside the loss function to generate the code, and then use the generated code inside the loss function.","category":"page"},{"location":"basics/FAQ/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"For example, let's say you were building ODEProblems in the loss function like:","category":"page"},{"location":"basics/FAQ/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"function loss(p)\n    prob = ODEProblem(sys, [], [p1 => p[1], p2 => p[2]])\n    sol = solve(prob, Tsit5())\n    sum(abs2, sol)\nend","category":"page"},{"location":"basics/FAQ/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"Since ODEProblem on a MTK sys will have to generate code, this will be slower than caching the generated code, and will require automatic differentiation to go through the code generation process itself. All of this is unnecessary. Instead, generate the problem once outside the loss function, and update the parameter values inside the loss function:","category":"page"},{"location":"basics/FAQ/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"prob = ODEProblem(sys, [], [p1 => p[1], p2 => p[2]])\nfunction loss(p)\n    # update parameters\n    sol = solve(prob, Tsit5())\n    sum(abs2, sol)\nend","category":"page"},{"location":"basics/FAQ/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"If a subset of the parameters are optimized, setp from SymbolicIndexingInterface.jl should be used to generate an efficient function for setting parameter values. For example:","category":"page"},{"location":"basics/FAQ/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"using SymbolicIndexingInterface\n\nprob = ODEProblem(sys, [], [p1 => p[1], p2 => p[2]])\nsetter! = setp(sys, [p1, p2])\nfunction loss(p)\n    setter!(prob, p)\n    sol = solve(prob, Tsit5())\n    sum(abs2, sol)\nend","category":"page"},{"location":"basics/FAQ/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"SciMLStructures.jl can be leveraged to obtain all the parameters for optimization using the Tunable portion. By default, all numeric or numeric array parameters are marked as tunable, unless explicitly marked as tunable = false in the variable metadata.","category":"page"},{"location":"basics/FAQ/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"using SciMLStructures: replace!, Tunable\n\nprob = ODEProblem(sys, [], [p1 => p[1], p2 => p[2]])\nfunction loss(p)\n    replace!(Tunable(), prob.p, p)\n    sol = solve(prob, Tsit5())\n    sum(abs2, sol)\nend\n\np, replace, alias = SciMLStructures.canonicalize(Tunable(), prob.p)\n# p is an `AbstractVector` which can be optimized\n# if `alias == true`, then `p` aliases the memory used by `prob.p`, so\n# changes to the array will be reflected in parameter values","category":"page"},{"location":"basics/FAQ/#ERROR:-ArgumentError:-SymbolicUtils.BasicSymbolic{Real}[xˍt(t)]-are-missing-from-the-variable-map.","page":"Frequently Asked Questions","title":"ERROR: ArgumentError: SymbolicUtils.BasicSymbolic{Real}[xˍt(t)] are missing from the variable map.","text":"","category":"section"},{"location":"basics/FAQ/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"This error can come up after running mtkcompile on a system that generates dummy derivatives (i.e. variables with ˍt).  For example, here even though all the variables are defined with initial values, the ODEProblem generation will throw an error that defaults are missing from the variable map.","category":"page"},{"location":"basics/FAQ/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"using ModelingToolkit\nusing ModelingToolkit: t_nounits as t, D_nounits as D\n\nsts = @variables x1(t)=0.0 x2(t)=0.0 x3(t)=0.0 x4(t)=0.0\neqs = [x1 + x2 + 1 ~ 0\n       x1 + x2 + x3 + 2 ~ 0\n       x1 + D(x3) + x4 + 3 ~ 0\n       2 * D(D(x1)) + D(D(x2)) + D(D(x3)) + D(x4) + 4 ~ 0]\n@named sys = System(eqs, t)\nsys = mtkcompile(sys)\nprob = ODEProblem(sys, [], (0, 1))","category":"page"},{"location":"basics/FAQ/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"We can solve this problem by using the missing_variable_defaults() function","category":"page"},{"location":"basics/FAQ/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"prob = ODEProblem(sys, ModelingToolkit.missing_variable_defaults(sys), (0, 1))","category":"page"},{"location":"basics/FAQ/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"This function provides 0 for the default values, which is a safe assumption for dummy derivatives of most models.  However, the 2nd argument allows for a different default value or values to be used if needed.","category":"page"},{"location":"basics/FAQ/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"julia> ModelingToolkit.missing_variable_defaults(sys, [1,2,3])\n3-element Vector{Pair}:\n  x1ˍt(t) => 1\n x2ˍtt(t) => 2\n x3ˍtt(t) => 3","category":"page"},{"location":"basics/FAQ/#Change-the-unknown-variable-vector-type","page":"Frequently Asked Questions","title":"Change the unknown variable vector type","text":"","category":"section"},{"location":"basics/FAQ/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"Use the u0_constructor keyword argument to map an array to the desired container type. For example:","category":"page"},{"location":"basics/FAQ/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"using ModelingToolkit, StaticArrays\nusing ModelingToolkit: t_nounits as t, D_nounits as D\n\nsts = @variables x1(t) = 0.0\neqs = [D(x1) ~ 1.1 * x1]\n@mtkcompile sys = System(eqs, t)\nprob = ODEProblem{false}(sys, [], (0, 1); u0_constructor = x -> SVector(x...))","category":"page"},{"location":"basics/FAQ/#Using-a-custom-independent-variable","page":"Frequently Asked Questions","title":"Using a custom independent variable","text":"","category":"section"},{"location":"basics/FAQ/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"When possible, we recommend using ModelingToolkit: t_nounits as t, D_nounits as D as the independent variable and its derivative. However, if you want to use your own, you can do so:","category":"page"},{"location":"basics/FAQ/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"using ModelingToolkit\n\n@independent_variables x\nD = Differential(x)\n@variables y(x)\n@named sys = System([D(y) ~ x], x)","category":"page"},{"location":"basics/FAQ/#Ordering-of-tunable-parameters","page":"Frequently Asked Questions","title":"Ordering of tunable parameters","text":"","category":"section"},{"location":"basics/FAQ/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"Tunable parameters are floating point parameters, not used in callbacks and not marked with tunable = false in their metadata. These are expected to be used with AD and optimization libraries. As such, they are stored together in one Vector{T}. To obtain the ordering of tunable parameters in this buffer, use:","category":"page"},{"location":"basics/FAQ/#ModelingToolkit.tunable_parameters-basics-FAQ","page":"Frequently Asked Questions","title":"ModelingToolkit.tunable_parameters","text":"tunable_parameters(sys, p = parameters(sys; initial_parameters = true); default=true)\n\nGet all parameters of sys that are marked as tunable.\n\nKeyword argument default indicates whether variables without tunable metadata are to be considered tunable or not.\n\nCreate a tunable parameter by\n\n@parameters u [tunable=true]\n\nFor systems created with split = true (the default) and default = true passed to this function, the order of parameters returned is the order in which they are stored in the tunables portion of MTKParameters. Note that array variables will not be scalarized. To obtain the flattened representation of the tunables portion, call Symbolics.scalarize(tunable_parameters(sys)) and concatenate the resulting arrays.\n\nSee also getbounds, istunable, MTKParameters, complete\n\n\n\n\n\n","category":"function"},{"location":"basics/FAQ/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"If you have an array in which a particular dimension is in the order of tunable parameters (e.g. the jacobian with respect to tunables) then that dimension of the array can be reordered into the required permutation using the symbolic variables:","category":"page"},{"location":"basics/FAQ/#ModelingToolkit.reorder_dimension_by_tunables!-basics-FAQ","page":"Frequently Asked Questions","title":"ModelingToolkit.reorder_dimension_by_tunables!","text":"reorder_dimension_by_tunables!(dest::AbstractArray, sys::AbstractSystem, arr::AbstractArray, syms; dim = 1)\n\nAssuming the order of values in dimension dim of arr correspond to the order of tunable parameters in the system, reorder them according to the order described in syms. syms must be a permutation of tunable_parameters(sys). The result is written to dest. The size of dest and arr must be equal. Return dest.\n\nSee also: MTKParameters, tunable_parameters, reorder_dimension_by_tunables.\n\n\n\n\n\n","category":"function"},{"location":"basics/FAQ/#ModelingToolkit.reorder_dimension_by_tunables-basics-FAQ","page":"Frequently Asked Questions","title":"ModelingToolkit.reorder_dimension_by_tunables","text":"reorder_dimension_by_tunables(sys::AbstractSystem, arr::AbstractArray, syms; dim = 1)\n\nOut-of-place version of reorder_dimension_by_tunables!.\n\n\n\n\n\n","category":"function"},{"location":"basics/FAQ/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"For example:","category":"page"},{"location":"basics/FAQ/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"using ModelingToolkit\n\n@parameters p q[1:3] r[1:2, 1:2]\n\n@named sys = System(Equation[], ModelingToolkit.t_nounits, [], [p, q, r])\nsys = complete(sys)","category":"page"},{"location":"basics/FAQ/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"The canonicalized tunables portion of MTKParameters will be in the order of tunables:","category":"page"},{"location":"basics/FAQ/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"using SciMLStructures: canonicalize, Tunable\n\nps = MTKParameters(sys, [p => 1.0, q => [2.0, 3.0, 4.0], r => [5.0 6.0; 7.0 8.0]])\narr = canonicalize(Tunable(), ps)[1]","category":"page"},{"location":"basics/FAQ/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"We can reorder this to contain the value for p, then all values for q, then for r using:","category":"page"},{"location":"basics/FAQ/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"reorder_dimension_by_tunables(sys, arr, [p, q, r])","category":"page"},{"location":"basics/FAQ/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"This also works with interleaved subarrays of symbolics:","category":"page"},{"location":"basics/FAQ/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"reorder_dimension_by_tunables(sys, arr, [q[1], r[1, :], q[2], r[2, :], q[3], p])","category":"page"},{"location":"basics/FAQ/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"And arbitrary dimensions of higher dimensional arrays:","category":"page"},{"location":"basics/FAQ/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"highdimarr = stack([i * arr for i in 1:5]; dims = 1)","category":"page"},{"location":"basics/FAQ/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"reorder_dimension_by_tunables(sys, highdimarr, [q[1:2], r[1, :], q[3], r[2, :], p]; dim = 2)","category":"page"},{"location":"basics/Composition/#components","page":"Composing Models and Building Reusable Components","title":"Composing Models and Building Reusable Components","text":"","category":"section"},{"location":"basics/Composition/","page":"Composing Models and Building Reusable Components","title":"Composing Models and Building Reusable Components","text":"The symbolic models of ModelingToolkit can be composed together to easily build large models. The composition is lazy and only instantiated at the time of conversion to numerical models, allowing a more performant way in terms of computation time and memory.","category":"page"},{"location":"basics/Composition/#Simple-Model-Composition-Example","page":"Composing Models and Building Reusable Components","title":"Simple Model Composition Example","text":"","category":"section"},{"location":"basics/Composition/","page":"Composing Models and Building Reusable Components","title":"Composing Models and Building Reusable Components","text":"The following is an example of building a model in a library with an optional forcing function, and allowing the user to specify the forcing later. Here, the library author defines a component named decay. The user then builds two decay components and connects them, saying the forcing term of decay1 is a constant while the forcing term of decay2 is the value of the unknown variable x.","category":"page"},{"location":"basics/Composition/","page":"Composing Models and Building Reusable Components","title":"Composing Models and Building Reusable Components","text":"using ModelingToolkit\nusing ModelingToolkit: t_nounits as t, D_nounits as D\n\nfunction decay(; name)\n    @parameters a\n    @variables x(t) f(t)\n    System([\n            D(x) ~ -a * x + f\n        ], t;\n        name = name)\nend\n\n@named decay1 = decay()\n@named decay2 = decay()\n\nconnected = compose(\n    System([decay2.f ~ decay1.x\n            D(decay1.f) ~ 0], t; name = :connected), decay1, decay2)\n\nequations(connected)\n\n#4-element Vector{Equation}:\n# Differential(t)(decay1₊f(t)) ~ 0\n# decay2₊f(t) ~ decay1₊x(t)\n# Differential(t)(decay1₊x(t)) ~ decay1₊f(t) - (decay1₊a*(decay1₊x(t)))\n# Differential(t)(decay2₊x(t)) ~ decay2₊f(t) - (decay2₊a*(decay2₊x(t)))\n\nsimplified_sys = mtkcompile(connected)\n\nequations(simplified_sys)","category":"page"},{"location":"basics/Composition/","page":"Composing Models and Building Reusable Components","title":"Composing Models and Building Reusable Components","text":"Now we can solve the system:","category":"page"},{"location":"basics/Composition/","page":"Composing Models and Building Reusable Components","title":"Composing Models and Building Reusable Components","text":"x0 = [decay1.x => 1.0\n      decay1.f => 0.0\n      decay2.x => 1.0]\np = [decay1.a => 0.1\n     decay2.a => 0.2]\n\nusing OrdinaryDiffEq\nprob = ODEProblem(simplified_sys, x0, (0.0, 100.0), p)\nsol = solve(prob, Tsit5())\nsol[decay2.f]","category":"page"},{"location":"basics/Composition/#Basics-of-Model-Composition","page":"Composing Models and Building Reusable Components","title":"Basics of Model Composition","text":"","category":"section"},{"location":"basics/Composition/","page":"Composing Models and Building Reusable Components","title":"Composing Models and Building Reusable Components","text":"Every AbstractSystem has a system keyword argument for specifying subsystems. A model is the composition of itself and its subsystems. For example, if we have:","category":"page"},{"location":"basics/Composition/","page":"Composing Models and Building Reusable Components","title":"Composing Models and Building Reusable Components","text":"@named sys = compose(System(eqs, indepvar, unknowns, ps), subsys)","category":"page"},{"location":"basics/Composition/","page":"Composing Models and Building Reusable Components","title":"Composing Models and Building Reusable Components","text":"the equations of sys is the concatenation of get_eqs(sys) and equations(subsys), the unknowns are the concatenation of their unknowns, etc. When the ODEProblem or ODEFunction is generated from this system, it will build and compile the functions associated with this composition.","category":"page"},{"location":"basics/Composition/","page":"Composing Models and Building Reusable Components","title":"Composing Models and Building Reusable Components","text":"The new equations within the higher level system can access the variables in the lower level system by namespacing via the nameof(subsys). For example, let's say there is a variable x in unknowns and a variable x in subsys. We can declare that these two variables are the same by specifying their equality: x ~ subsys.x in the eqs for sys. This algebraic relationship can then be simplified by transformations like mtkcompile which will be described later.","category":"page"},{"location":"basics/Composition/#Numerics-with-Composed-Models","page":"Composing Models and Building Reusable Components","title":"Numerics with Composed Models","text":"","category":"section"},{"location":"basics/Composition/","page":"Composing Models and Building Reusable Components","title":"Composing Models and Building Reusable Components","text":"These composed models can then be directly transformed into their associated SciMLProblem type using the standard constructors. When this is done, the initial conditions and parameters must be specified in their namespaced form. For example:","category":"page"},{"location":"basics/Composition/","page":"Composing Models and Building Reusable Components","title":"Composing Models and Building Reusable Components","text":"u0 = [x => 2.0\n      subsys.x => 2.0]","category":"page"},{"location":"basics/Composition/","page":"Composing Models and Building Reusable Components","title":"Composing Models and Building Reusable Components","text":"Note that any default values within the given subcomponent will be used if no override is provided at construction time. If any values for initial conditions or parameters are unspecified, an error will be thrown.","category":"page"},{"location":"basics/Composition/","page":"Composing Models and Building Reusable Components","title":"Composing Models and Building Reusable Components","text":"When the model is numerically solved, the solution can be accessed via its symbolic values. For example, if sol is the ODESolution, one can use sol[x] and sol[subsys.x] to access the respective timeseries in the solution. All other indexing rules stay the same, so sol[x,1:5] accesses the first through fifth values of x. Note that this can be done even if the variable x is eliminated from the system from transformations like alias_elimination or tearing: the variable will be lazily reconstructed on demand.","category":"page"},{"location":"basics/Composition/#Variable-scope-and-parameter-expressions","page":"Composing Models and Building Reusable Components","title":"Variable scope and parameter expressions","text":"","category":"section"},{"location":"basics/Composition/","page":"Composing Models and Building Reusable Components","title":"Composing Models and Building Reusable Components","text":"In some scenarios, it could be useful for model parameters to be expressed in terms of other parameters, or shared between common subsystems. To facilitate this, ModelingToolkit supports symbolic expressions in default values, and scoped variables.","category":"page"},{"location":"basics/Composition/","page":"Composing Models and Building Reusable Components","title":"Composing Models and Building Reusable Components","text":"With symbolic parameters, it is possible to set the default value of a parameter or initial condition to an expression of other variables.","category":"page"},{"location":"basics/Composition/","page":"Composing Models and Building Reusable Components","title":"Composing Models and Building Reusable Components","text":"# ...\nsys = System(\n# ...\n# directly in the defaults argument\n    defaults = Pair{Num, Any}[x => u,\n    y => σ,\n    z => u - 0.1])\n# by assigning to the parameter\nsys.y = u * 1.1","category":"page"},{"location":"basics/Composition/","page":"Composing Models and Building Reusable Components","title":"Composing Models and Building Reusable Components","text":"In a hierarchical system, variables of the subsystem get namespaced by the name of the system they are in. This prevents naming clashes, but also enforces that every unknown and parameter is local to the subsystem it is used in. In some cases it might be desirable to have variables and parameters that are shared between subsystems, or even global. This can be accomplished as follows.","category":"page"},{"location":"basics/Composition/","page":"Composing Models and Building Reusable Components","title":"Composing Models and Building Reusable Components","text":"@parameters a b c d\n\n# a is a local variable\nb = ParentScope(b) # b is a variable that belongs to one level up in the hierarchy\nc = ParentScope(ParentScope(c)) # ParentScope can be nested\nd = GlobalScope(d)\n\np = [a, b, c, d]\n\nlevel0 = System(Equation[], t, [], p; name = :level0)\nlevel1 = System(Equation[], t, [], []; name = :level1) ∘ level0\nparameters(level1)\n#level0₊a\n#b\n#c\n#d\nlevel2 = System(Equation[], t, [], []; name = :level2) ∘ level1\nparameters(level2)\n#level1₊level0₊a\n#level1₊b\n#c\n#d\nlevel3 = System(Equation[], t, [], []; name = :level3) ∘ level2\nparameters(level3)\n#level2₊level1₊level0₊a\n#level2₊level1₊b\n#level2₊c\n#d","category":"page"},{"location":"basics/Composition/#Structural-Simplify","page":"Composing Models and Building Reusable Components","title":"Structural Simplify","text":"","category":"section"},{"location":"basics/Composition/","page":"Composing Models and Building Reusable Components","title":"Composing Models and Building Reusable Components","text":"In many cases, the nicest way to build a model may leave a lot of unnecessary variables. Thus one may want to remove these equations before numerically solving. The mtkcompile function removes these trivial equality relationships and trivial singularity equations, i.e. equations which result in 0~0 expressions, in over-specified systems.","category":"page"},{"location":"basics/Composition/#Inheritance-and-Combine","page":"Composing Models and Building Reusable Components","title":"Inheritance and Combine","text":"","category":"section"},{"location":"basics/Composition/","page":"Composing Models and Building Reusable Components","title":"Composing Models and Building Reusable Components","text":"Model inheritance can be done in two ways: implicitly or explicitly. First, one can use the extend function to extend a base model with another set of equations, unknowns, and parameters. An example can be found in the acausal components tutorial.","category":"page"},{"location":"basics/Composition/","page":"Composing Models and Building Reusable Components","title":"Composing Models and Building Reusable Components","text":"The explicit way is to shadow variables with equality expressions. For example, let's assume we have three separate systems which we want to compose to a single one. This is how one could explicitly forward all unknowns and parameters to the higher level system:","category":"page"},{"location":"basics/Composition/","page":"Composing Models and Building Reusable Components","title":"Composing Models and Building Reusable Components","text":"using ModelingToolkit, OrdinaryDiffEq, Plots\nusing ModelingToolkit: t_nounits as t, D_nounits as D\n\n## Library code\n@variables S(t), I(t), R(t)\nN = S + I + R\n@parameters β, γ\n\n@named seqn = System([D(S) ~ -β * S * I / N], t)\n@named ieqn = System([D(I) ~ β * S * I / N - γ * I], t)\n@named reqn = System([D(R) ~ γ * I], t)\n\nsir = compose(\n    System(\n        [\n            S ~ ieqn.S,\n            I ~ seqn.I,\n            R ~ ieqn.R,\n            ieqn.S ~ seqn.S,\n            seqn.I ~ ieqn.I,\n            seqn.R ~ reqn.R,\n            ieqn.R ~ reqn.R,\n            reqn.I ~ ieqn.I],\n        t,\n        [S, I, R],\n        [β, γ],\n        defaults = [seqn.β => β\n                    ieqn.β => β\n                    ieqn.γ => γ\n                    reqn.γ => γ], name = :sir),\n    seqn,\n    ieqn,\n    reqn)","category":"page"},{"location":"basics/Composition/","page":"Composing Models and Building Reusable Components","title":"Composing Models and Building Reusable Components","text":"Note that the unknowns are forwarded by an equality relationship, while the parameters are forwarded through a relationship in their default values. The user of this model can then solve this model simply by specifying the values at the highest level:","category":"page"},{"location":"basics/Composition/","page":"Composing Models and Building Reusable Components","title":"Composing Models and Building Reusable Components","text":"sireqn_simple = mtkcompile(sir)\n\nequations(sireqn_simple)","category":"page"},{"location":"basics/Composition/","page":"Composing Models and Building Reusable Components","title":"Composing Models and Building Reusable Components","text":"## User Code\n\nu0 = [seqn.S => 990.0,\n    ieqn.I => 10.0,\n    reqn.R => 0.0]\n\np = [β => 0.5\n     γ => 0.25]\n\ntspan = (0.0, 40.0)\nprob = ODEProblem(sireqn_simple, u0, tspan, p, jac = true)\nsol = solve(prob, Tsit5())\nsol[reqn.R]","category":"page"},{"location":"basics/Composition/#Tearing-Problem-Construction","page":"Composing Models and Building Reusable Components","title":"Tearing Problem Construction","text":"","category":"section"},{"location":"basics/Composition/","page":"Composing Models and Building Reusable Components","title":"Composing Models and Building Reusable Components","text":"Some system types (specifically NonlinearSystem) can be further reduced if mtkcompile has already been applied to them. This is done by using the alternative problem constructors (BlockNonlinearProblem). In these cases, the constructor uses the knowledge of the strongly connected components calculated during the process of simplification as the basis for building pre-simplified nonlinear systems in the implicit solving. In summary: these problems are structurally modified, but could be more efficient and more stable.","category":"page"},{"location":"basics/Composition/#Components-with-discontinuous-dynamics","page":"Composing Models and Building Reusable Components","title":"Components with discontinuous dynamics","text":"","category":"section"},{"location":"basics/Composition/","page":"Composing Models and Building Reusable Components","title":"Composing Models and Building Reusable Components","text":"When modeling, e.g., impacts, saturations or Coulomb friction, the dynamic equations are discontinuous in either the unknown or one of its derivatives. This causes the solver to take very small steps around the discontinuity, and sometimes leads to early stopping due to dt <= dt_min. The correct way to handle such dynamics is to tell the solver about the discontinuity by a root-finding equation, which can be modeling using System's event support. Please see the tutorial on Callbacks and Events for details and examples.","category":"page"},{"location":"tutorials/dynamic_optimization/#Solving-Dynamic-Optimization-Problems","page":"Solving Dynamic Optimization Problems","title":"Solving Dynamic Optimization Problems","text":"","category":"section"},{"location":"tutorials/dynamic_optimization/","page":"Solving Dynamic Optimization Problems","title":"Solving Dynamic Optimization Problems","text":"Systems in ModelingToolkit.jl can be directly converted to dynamic optimization or optimal control problems. In such systems, one has one or more input variables that are externally controlled to control the dynamics of the system. A dynamic optimization solves for the optimal time trajectory of the input variables in order to maximize or minimize a desired objective function. For example, a car driver might like to know how to step on the accelerator if the goal is to finish a race while using the least gas.","category":"page"},{"location":"tutorials/dynamic_optimization/","page":"Solving Dynamic Optimization Problems","title":"Solving Dynamic Optimization Problems","text":"To begin, let us take a rocket launch example. The input variable here is the thrust exerted by the engine. The rocket state is described by its current height, mass, and velocity. The mass decreases as the rocket loses fuel while thrusting.","category":"page"},{"location":"tutorials/dynamic_optimization/","page":"Solving Dynamic Optimization Problems","title":"Solving Dynamic Optimization Problems","text":"using ModelingToolkit\nt = ModelingToolkit.t_nounits\nD = ModelingToolkit.D_nounits\n\n@parameters h_c m₀ h₀ g₀ D_c c Tₘ m_c\n@variables begin\n    h(..)\n    v(..)\n    m(..), [bounds = (m_c, 1)]\n    T(..), [input = true, bounds = (0, Tₘ)]\nend\n\ndrag(h, v) = D_c * v^2 * exp(-h_c * (h - h₀) / h₀)\ngravity(h) = g₀ * (h₀ / h)\n\neqs = [D(h(t)) ~ v(t),\n    D(v(t)) ~ (T(t) - drag(h(t), v(t))) / m(t) - gravity(h(t)),\n    D(m(t)) ~ -T(t) / c]\n\n(ts, te) = (0.0, 0.2)\ncosts = [-h(te)]\ncons = [T(te) ~ 0, m(te) ~ m_c]\n\n@named rocket = System(eqs, t; costs, constraints = cons)\nrocket = mtkcompile(rocket, inputs = [T(t)])\n\nu0map = [h(t) => h₀, m(t) => m₀, v(t) => 0]\npmap = [\n    g₀ => 1, m₀ => 1.0, h_c => 500, c => 0.5 * √(g₀ * h₀), D_c => 0.5 * 620 * m₀ / g₀,\n    Tₘ => 3.5 * g₀ * m₀, T(t) => 0.0, h₀ => 1, m_c => 0.6]","category":"page"},{"location":"tutorials/dynamic_optimization/","page":"Solving Dynamic Optimization Problems","title":"Solving Dynamic Optimization Problems","text":"What we would like to optimize here is the final height of the rocket. We do this by providing a vector of expressions corresponding to the costs. By default, the sense of the optimization is to minimize the provided cost. So to maximize the rocket height at the final time, we write -h(te) as the cost.","category":"page"},{"location":"tutorials/dynamic_optimization/","page":"Solving Dynamic Optimization Problems","title":"Solving Dynamic Optimization Problems","text":"Now we can construct a problem and solve it. Let us use JuMP as our backend here. Note that the package trigger is actually InfiniteOpt, and not JuMP - this package includes JuMP but is designed for optimization on function spaces. Additionally we need to load the solver package - we will use Ipopt here (a good choice in general).","category":"page"},{"location":"tutorials/dynamic_optimization/","page":"Solving Dynamic Optimization Problems","title":"Solving Dynamic Optimization Problems","text":"Here we have also loaded DiffEqDevTools because we will need to construct the ODE tableau. This is only needed if one desires a custom ODE tableau for the collocation - by default the solver will use RadauIIA5.","category":"page"},{"location":"tutorials/dynamic_optimization/","page":"Solving Dynamic Optimization Problems","title":"Solving Dynamic Optimization Problems","text":"using InfiniteOpt, Ipopt, DiffEqDevTools\njprob = JuMPDynamicOptProblem(rocket, [u0map; pmap], (ts, te); dt = 0.001)\njsol = solve(jprob, JuMPCollocation(Ipopt.Optimizer, constructRadauIIA5()));","category":"page"},{"location":"tutorials/dynamic_optimization/","page":"Solving Dynamic Optimization Problems","title":"Solving Dynamic Optimization Problems","text":"The solution has three fields: jsol.sol is the ODE solution for the states, jsol.input_sol is the ODE solution for the inputs, and jsol.model is the wrapped model that we can use to query things like objective and constraint residuals.","category":"page"},{"location":"tutorials/dynamic_optimization/","page":"Solving Dynamic Optimization Problems","title":"Solving Dynamic Optimization Problems","text":"Let's plot the final solution and the controller here:","category":"page"},{"location":"tutorials/dynamic_optimization/","page":"Solving Dynamic Optimization Problems","title":"Solving Dynamic Optimization Problems","text":"using CairoMakie\nfig = Figure(resolution = (800, 400))\nax1 = Axis(fig[1, 1], title = \"Rocket trajectory\", xlabel = \"Time\")\nax2 = Axis(fig[1, 2], title = \"Control trajectory\", xlabel = \"Time\")\n\nfor u in unknowns(rocket)\n    lines!(ax1, jsol.sol.t, jsol.sol[u], label = string(u))\nend\nlines!(ax2, jsol.input_sol, label = \"Thrust\")\naxislegend(ax1)\naxislegend(ax2)\nfig","category":"page"},{"location":"tutorials/dynamic_optimization/#Free-final-time-problems","page":"Solving Dynamic Optimization Problems","title":"Free final time problems","text":"","category":"section"},{"location":"tutorials/dynamic_optimization/","page":"Solving Dynamic Optimization Problems","title":"Solving Dynamic Optimization Problems","text":"There are additionally a class of dynamic optimization problems where we would like to know how to control our system to achieve something in the least time. Such problems are called free final time problems, since the final time is unknown. To model these problems in ModelingToolkit, we declare the final time as a parameter.","category":"page"},{"location":"tutorials/dynamic_optimization/","page":"Solving Dynamic Optimization Problems","title":"Solving Dynamic Optimization Problems","text":"Below we have a model system called the double integrator. We control the acceleration of a block in order to reach a desired destination in the least time.","category":"page"},{"location":"tutorials/dynamic_optimization/","page":"Solving Dynamic Optimization Problems","title":"Solving Dynamic Optimization Problems","text":"@variables begin\n    x(..)\n    v(..)\n    u(..), [bounds = (-1.0, 1.0), input = true]\nend\n\n@parameters tf\n\nconstr = [v(tf) ~ 0, x(tf) ~ 0]\ncost = [tf] # Minimize time\n\n@named block = System(\n    [D(x(t)) ~ v(t), D(v(t)) ~ u(t)], t; costs = cost, constraints = constr)\n\nblock = mtkcompile(block; inputs = [u(t)])\n\nu0map = [x(t) => 1.0, v(t) => 0.0]\ntspan = (0.0, tf)\nparammap = [u(t) => 0.0, tf => 1.0]","category":"page"},{"location":"tutorials/dynamic_optimization/","page":"Solving Dynamic Optimization Problems","title":"Solving Dynamic Optimization Problems","text":"The tf mapping in the parameter map is treated as an initial guess.","category":"page"},{"location":"tutorials/dynamic_optimization/","page":"Solving Dynamic Optimization Problems","title":"Solving Dynamic Optimization Problems","text":"Please note that, at the moment, free final time problems cannot support constraints defined at definite time values, like x(3) ~ 2.","category":"page"},{"location":"tutorials/dynamic_optimization/","page":"Solving Dynamic Optimization Problems","title":"Solving Dynamic Optimization Problems","text":"warning: Warning\nThe Pyomo collocation methods (LagrangeRadau, LagrangeLegendre) currently are bugged for free final time problems. Strongly suggest using BackwardEuler() for such problems when using Pyomo as the backend.","category":"page"},{"location":"tutorials/dynamic_optimization/","page":"Solving Dynamic Optimization Problems","title":"Solving Dynamic Optimization Problems","text":"When declaring the problem in this case we need to provide the number of steps, since dt can't be known in advanced. Let's solve plot our final solution and the controller for the block, using InfiniteOpt as the backend:","category":"page"},{"location":"tutorials/dynamic_optimization/","page":"Solving Dynamic Optimization Problems","title":"Solving Dynamic Optimization Problems","text":"iprob = InfiniteOptDynamicOptProblem(block, [u0map; parammap], tspan; steps = 100)\nisol = solve(iprob, InfiniteOptCollocation(Ipopt.Optimizer));","category":"page"},{"location":"tutorials/dynamic_optimization/","page":"Solving Dynamic Optimization Problems","title":"Solving Dynamic Optimization Problems","text":"Let's plot the final solution and the controller here:","category":"page"},{"location":"tutorials/dynamic_optimization/","page":"Solving Dynamic Optimization Problems","title":"Solving Dynamic Optimization Problems","text":"fig = Figure(resolution = (800, 400))\nax1 = Axis(fig[1, 1], title = \"Block trajectory\", xlabel = \"Time\")\nax2 = Axis(fig[1, 2], title = \"Control trajectory\", xlabel = \"Time\")\n\nfor u in unknowns(block)\n    lines!(ax1, isol.sol.t, isol.sol[u], label = string(u))\nend\nlines!(ax2, isol.input_sol, label = \"Acceleration\")\naxislegend(ax1)\naxislegend(ax2)\nfig","category":"page"},{"location":"tutorials/callable_params/#Callable-parameters-and-interpolating-data","page":"Callable parameters and interpolating data","title":"Callable parameters and interpolating data","text":"","category":"section"},{"location":"tutorials/callable_params/","page":"Callable parameters and interpolating data","title":"Callable parameters and interpolating data","text":"ModelingToolkit.jl allows creating parameters that represent functions to be called. This is especially useful for including interpolants and/or lookup tables inside ODEs. In this tutorial we will create an System which employs callable parameters to interpolate data inside an ODE and go over the various syntax options and their implications.","category":"page"},{"location":"tutorials/callable_params/#Callable-parameter-syntax","page":"Callable parameters and interpolating data","title":"Callable parameter syntax","text":"","category":"section"},{"location":"tutorials/callable_params/","page":"Callable parameters and interpolating data","title":"Callable parameters and interpolating data","text":"The syntax for callable parameters declared via @parameters must be one of the following","category":"page"},{"location":"tutorials/callable_params/","page":"Callable parameters and interpolating data","title":"Callable parameters and interpolating data","text":"(fn::FType)(..)\nfn(::argType1, ::argType2, ...)","category":"page"},{"location":"tutorials/callable_params/","page":"Callable parameters and interpolating data","title":"Callable parameters and interpolating data","text":"In the first case, the parameter is callable with any number/combination of arguments, and has a type of FType (the callable must be a subtype of FType). In the second case, the parameter is callable with as many arguments as declared, and all must match the declared types.","category":"page"},{"location":"tutorials/callable_params/","page":"Callable parameters and interpolating data","title":"Callable parameters and interpolating data","text":"By default, the return type of the callable symbolic is inferred to be Real. To change this, a ::retType annotation can be added at the end.","category":"page"},{"location":"tutorials/callable_params/","page":"Callable parameters and interpolating data","title":"Callable parameters and interpolating data","text":"To declare a function that returns an array of values, the same array syntax can be used as for normal variables:","category":"page"},{"location":"tutorials/callable_params/","page":"Callable parameters and interpolating data","title":"Callable parameters and interpolating data","text":"@parameters (foo::FType)(..)[1:3]::retType\n@parameters foo(::argType1, ::argType2)[1:3]::retType","category":"page"},{"location":"tutorials/callable_params/","page":"Callable parameters and interpolating data","title":"Callable parameters and interpolating data","text":"retType here is the eltype of the returned array.","category":"page"},{"location":"tutorials/callable_params/#Storage-of-callable-parameters","page":"Callable parameters and interpolating data","title":"Storage of callable parameters","text":"","category":"section"},{"location":"tutorials/callable_params/","page":"Callable parameters and interpolating data","title":"Callable parameters and interpolating data","text":"Callable parameters declared with the ::FType syntax will be stored in a Vector{FType}. Thus, if FType is non-concrete, the buffer will also be non-concrete. This is sometimes necessary to allow the value of the callable to be switched out for a different type without rebuilding the model. Typically this syntax is preferable when FType is concrete or a small union.","category":"page"},{"location":"tutorials/callable_params/","page":"Callable parameters and interpolating data","title":"Callable parameters and interpolating data","text":"Callable parameters declared with the ::argType1, ... syntax will be stored in a Vector{FunctionWrappers.FunctionWrapper{retType, Tuple{argType1, ...}}}. This suffers the small overhead of a FunctionWrapper and restricts the signature of the callable, symbolic, but allows storing the parameter in a type-stable manner and swapping it out. This is preferable when the values that the callable can take do not share a common subtype. For example, when a callable can represent the activation of a neural network and can be tanh, sigmoid, etc. which have a common ancestor of Function.","category":"page"},{"location":"tutorials/callable_params/","page":"Callable parameters and interpolating data","title":"Callable parameters and interpolating data","text":"If both ::FType and ::argTypes are specified, ::FType takes priority. For example,","category":"page"},{"location":"tutorials/callable_params/","page":"Callable parameters and interpolating data","title":"Callable parameters and interpolating data","text":"@parameters (p::LinearInterpolation)(::Real)","category":"page"},{"location":"tutorials/callable_params/","page":"Callable parameters and interpolating data","title":"Callable parameters and interpolating data","text":"p will be stored in a Vector{LinearInterpolation}. If ::LinearInterpolation was not specified, it would be stored in a Vector{FunctionWrapper{Real, Tuple{Real}}}.","category":"page"},{"location":"tutorials/callable_params/#Example-using-interpolations","page":"Callable parameters and interpolating data","title":"Example using interpolations","text":"","category":"section"},{"location":"tutorials/callable_params/","page":"Callable parameters and interpolating data","title":"Callable parameters and interpolating data","text":"using ModelingToolkit\nusing OrdinaryDiffEq\nusing DataInterpolations\nusing ModelingToolkit: t_nounits as t, D_nounits as D\n\nts = collect(0.0:0.1:10.0)\nspline = LinearInterpolation(ts .^ 2, ts)\nTspline = typeof(spline)\n@variables x(t)\n@parameters (interp::Tspline)(..)\n\n@mtkcompile sys = System(D(x) ~ interp(t), t)","category":"page"},{"location":"tutorials/callable_params/","page":"Callable parameters and interpolating data","title":"Callable parameters and interpolating data","text":"The derivative of x is obtained via an interpolation from DataInterpolations.jl. Note the parameter syntax. The (..) marks the parameter as callable. (interp::Tspline) indicates that the parameter is of type Tspline.","category":"page"},{"location":"tutorials/callable_params/","page":"Callable parameters and interpolating data","title":"Callable parameters and interpolating data","text":"prob = ODEProblem(sys, [x => 0.0, interp => spline], (0.0, 1.0))\nsolve(prob)","category":"page"},{"location":"tutorials/callable_params/","page":"Callable parameters and interpolating data","title":"Callable parameters and interpolating data","text":"Note that the the following will not work:","category":"page"},{"location":"tutorials/callable_params/","page":"Callable parameters and interpolating data","title":"Callable parameters and interpolating data","text":"ODEProblem(\n    sys; [x => 0.0, interp => LinearInterpolation(0.0:0.1:1.0, 0.0:0.1:1.0)], (0.0, 1.0))","category":"page"},{"location":"tutorials/callable_params/","page":"Callable parameters and interpolating data","title":"Callable parameters and interpolating data","text":"Since the type of the spline doesn't match.","category":"page"},{"location":"API/dynamic_opt/#dynamic_opt_api","page":"Dynamic Optimization Solvers","title":"Dynamic Optimization Solvers","text":"","category":"section"},{"location":"API/dynamic_opt/","page":"Dynamic Optimization Solvers","title":"Dynamic Optimization Solvers","text":"Currently 4 backends are exposed for solving dynamic optimization problems using collocation: JuMP, InfiniteOpt, CasADi, and Pyomo.","category":"page"},{"location":"API/dynamic_opt/","page":"Dynamic Optimization Solvers","title":"Dynamic Optimization Solvers","text":"Please note that there are differences in how to construct the collocation solver for the different cases. For example, the Python based ones, CasADi and Pyomo, expect the solver to be passed in as a string (CasADi and Pyomo come pre-loaded with Ipopt, but other solvers may need to be manually installed using pip or conda), while JuMP/InfiniteOpt expect the optimizer object to be passed in directly:","category":"page"},{"location":"API/dynamic_opt/","page":"Dynamic Optimization Solvers","title":"Dynamic Optimization Solvers","text":"JuMPCollocation(Ipopt.Optimizer, constructRK4())\nCasADiCollocation(\"ipopt\", constructRK4())","category":"page"},{"location":"API/dynamic_opt/","page":"Dynamic Optimization Solvers","title":"Dynamic Optimization Solvers","text":"JuMP and CasADi collocation require an ODE tableau to be passed in. These can be constructed by calling the constructX() functions from DiffEqDevTools. The list of tableaus can be found here. If none is passed in, both solvers will default to using Radau second-order with five collocation points.","category":"page"},{"location":"API/dynamic_opt/","page":"Dynamic Optimization Solvers","title":"Dynamic Optimization Solvers","text":"Pyomo and InfiniteOpt each have their own built-in collocation methods.","category":"page"},{"location":"API/dynamic_opt/","page":"Dynamic Optimization Solvers","title":"Dynamic Optimization Solvers","text":"InfiniteOpt: The list of InfiniteOpt collocation methods can be found in the table on this page. If none is passed in, the solver defaults to FiniteDifference(Backward()), which is effectively implicit Euler.\nPyomo: The list of Pyomo collocation methods can be found at the bottom of this page. If none is passed in, the solver defaults to a LagrangeRadau(3).","category":"page"},{"location":"API/dynamic_opt/","page":"Dynamic Optimization Solvers","title":"Dynamic Optimization Solvers","text":"Some examples of the latter two collocations:","category":"page"},{"location":"API/dynamic_opt/","page":"Dynamic Optimization Solvers","title":"Dynamic Optimization Solvers","text":"PyomoCollocation(\"ipopt\", LagrangeRadau(2))\nInfiniteOptCollocation(Ipopt.Optimizer, OrthogonalCollocation(3))","category":"page"},{"location":"API/dynamic_opt/#ModelingToolkit.JuMPCollocation-API-dynamic_opt","page":"Dynamic Optimization Solvers","title":"ModelingToolkit.JuMPCollocation","text":"JuMP Collocation solver. Takes two arguments:\n\nsolver: a optimization solver such as Ipopt\ntableau: An ODE RK tableau. Load a tableau by calling a function like constructRK4 and may be found at https://docs.sciml.ai/DiffEqDevDocs/stable/internals/tableaus/. If this argument is not passed in, the solver will default to Radau second order.\n\n\n\n\n\n","category":"function"},{"location":"API/dynamic_opt/#ModelingToolkit.InfiniteOptCollocation-API-dynamic_opt","page":"Dynamic Optimization Solvers","title":"ModelingToolkit.InfiniteOptCollocation","text":"InfiniteOpt Collocation solver.\n\nsolver: an optimization solver such as Ipopt\nderivative_method: the method used by InfiniteOpt to compute derivatives. The list of possible options can be found at https://infiniteopt.github.io/InfiniteOpt.jl/stable/guide/derivative/. Defaults to FiniteDifference(Backward()).\n\n\n\n\n\n","category":"function"},{"location":"API/dynamic_opt/#ModelingToolkit.CasADiCollocation-API-dynamic_opt","page":"Dynamic Optimization Solvers","title":"ModelingToolkit.CasADiCollocation","text":"CasADi Collocation solver.\n\nsolver: an optimization solver such as Ipopt. Should be given as a string or symbol in all lowercase, e.g. \"ipopt\"\ntableau: An ODE RK tableau. Load a tableau by calling a function like constructRK4 and may be found at https://docs.sciml.ai/DiffEqDevDocs/stable/internals/tableaus/. If this argument is not passed in, the solver will default to Radau second order.\n\n\n\n\n\n","category":"function"},{"location":"API/dynamic_opt/#ModelingToolkit.PyomoCollocation-API-dynamic_opt","page":"Dynamic Optimization Solvers","title":"ModelingToolkit.PyomoCollocation","text":"Pyomo Collocation solver.\n\nsolver: an optimization solver such as Ipopt. Should be given as a string or symbol in all lowercase, e.g. \"ipopt\"\nderivative_method: a derivative method from Pyomo. The choices here are ForwardEuler, BackwardEuler, MidpointEuler, LagrangeRadau, or LagrangeLegendre. The last two should additionally have a number indicating the number of collocation points per timestep, e.g. PyomoCollocation(\"ipopt\", LagrangeRadau(3)). Defaults to LagrangeRadau(5).\n\n\n\n\n\n","category":"function"},{"location":"API/dynamic_opt/#Problem-constructors","page":"Dynamic Optimization Solvers","title":"Problem constructors","text":"","category":"section"},{"location":"API/dynamic_opt/#ModelingToolkit.JuMPDynamicOptProblem-API-dynamic_opt","page":"Dynamic Optimization Solvers","title":"ModelingToolkit.JuMPDynamicOptProblem","text":"JuMPDynamicOptProblem(sys::System, op, tspan; dt, steps, guesses, kwargs...)\n\nConvert an System representing an optimal control system into a JuMP model for solving using optimization. Must provide either dt, the timestep between collocation  points (which, along with the timespan, determines the number of points), or directly  provide the number of points as steps.\n\nTo construct the problem, please load InfiniteOpt along with ModelingToolkit.\n\n\n\n\n\n","category":"function"},{"location":"API/dynamic_opt/#ModelingToolkit.InfiniteOptDynamicOptProblem-API-dynamic_opt","page":"Dynamic Optimization Solvers","title":"ModelingToolkit.InfiniteOptDynamicOptProblem","text":"InfiniteOptDynamicOptProblem(sys::System, op, tspan; dt)\n\nConvert an System representing an optimal control system into a InfiniteOpt model for solving using optimization. Must provide dt for determining the length  of the interpolation arrays.\n\nRelated to JuMPDynamicOptProblem, but directly adds the differential equations of the system as derivative constraints, rather than using a solver tableau.\n\nTo construct the problem, please load InfiniteOpt along with ModelingToolkit.\n\n\n\n\n\n","category":"function"},{"location":"API/dynamic_opt/#ModelingToolkit.CasADiDynamicOptProblem-API-dynamic_opt","page":"Dynamic Optimization Solvers","title":"ModelingToolkit.CasADiDynamicOptProblem","text":"CasADiDynamicOptProblem(sys::System, op, tspan; dt, steps, guesses, kwargs...)\n\nConvert an System representing an optimal control system into a CasADi model for solving using optimization. Must provide either dt, the timestep between collocation  points (which, along with the timespan, determines the number of points), or directly  provide the number of points as steps.\n\nTo construct the problem, please load CasADi along with ModelingToolkit.\n\n\n\n\n\n","category":"function"},{"location":"API/dynamic_opt/#ModelingToolkit.PyomoDynamicOptProblem-API-dynamic_opt","page":"Dynamic Optimization Solvers","title":"ModelingToolkit.PyomoDynamicOptProblem","text":"PyomoDynamicOptProblem(sys::System, op, tspan; dt, steps)\n\nConvert an System representing an optimal control system into a Pyomo model for solving using optimization. Must provide either dt, the timestep between collocation  points (which, along with the timespan, determines the number of points), or directly  provide the number of points as steps.\n\nTo construct the problem, please load Pyomo along with ModelingToolkit.\n\n\n\n\n\n","category":"function"},{"location":"tutorials/fmi/#Importing-FMUs","page":"Importing FMUs","title":"Importing FMUs","text":"","category":"section"},{"location":"tutorials/fmi/","page":"Importing FMUs","title":"Importing FMUs","text":"ModelingToolkit is able to import FMUs following the FMI Standard versions 2 and 3. This integration is done through FMI.jl and requires importing it to enable the relevant functionality. Currently Model Exchange (ME) and CoSimulation (CS) FMUs are supported. Events, non-floating-point variables and array variables are not supported. Additionally, calculating the time derivatives of FMU states/outputs is not supported.","category":"page"},{"location":"tutorials/fmi/","page":"Importing FMUs","title":"Importing FMUs","text":"danger: Experimental\nThis functionality is currently experimental and subject to change without a breaking release of ModelingToolkit.jl.","category":"page"},{"location":"tutorials/fmi/#FMUs-of-full-models","page":"Importing FMUs","title":"FMUs of full models","text":"","category":"section"},{"location":"tutorials/fmi/","page":"Importing FMUs","title":"Importing FMUs","text":"Here, we will demonstrate the usage of an FMU of an entire model (as opposed to a single component). First, the required libraries must be imported and the FMU loaded using FMI.jl.","category":"page"},{"location":"tutorials/fmi/","page":"Importing FMUs","title":"Importing FMUs","text":"using ModelingToolkit, FMI, FMIZoo, OrdinaryDiffEq\nusing ModelingToolkit: t_nounits as t, D_nounits as D\n\n# This is a spring-pendulum FMU from FMIZoo.jl. It is a v2 FMU\n# and we are importing it in ModelExchange format.\nfmu = loadFMU(\"SpringPendulum1D\", \"Dymola\", \"2022x\"; type = :ME)","category":"page"},{"location":"tutorials/fmi/","page":"Importing FMUs","title":"Importing FMUs","text":"Following are the variables in the FMU (both states and parameters):","category":"page"},{"location":"tutorials/fmi/","page":"Importing FMUs","title":"Importing FMUs","text":"fmu.modelDescription.modelVariables","category":"page"},{"location":"tutorials/fmi/","page":"Importing FMUs","title":"Importing FMUs","text":"Next, FMIComponent is used to import the FMU as an MTK component. We provide the FMI major version as a Val to the constructor, along with the loaded FMU and the type as keyword arguments.","category":"page"},{"location":"tutorials/fmi/","page":"Importing FMUs","title":"Importing FMUs","text":"@named model = ModelingToolkit.FMIComponent(Val(2); fmu, type = :ME)","category":"page"},{"location":"tutorials/fmi/","page":"Importing FMUs","title":"Importing FMUs","text":"Note how hierarchical names in the FMU (e.g. mass.m or spring.f) are turned into flattened names, with __ being the namespace separator (mass__m and spring__f).","category":"page"},{"location":"tutorials/fmi/","page":"Importing FMUs","title":"Importing FMUs","text":"note: Note\nEventually we plan to reconstruct a hierarchical system structure mirroring the one indicated by the variables in the FMU. This would allow accessing the above mentioned variables as model.mass.m and model.spring.f instead of model.mass__m and model.spring__f respectively.","category":"page"},{"location":"tutorials/fmi/","page":"Importing FMUs","title":"Importing FMUs","text":"Derivative variables such as der(mass.v) use the dummy derivative notation, and are hence transformed into a form similar to mass__vˍt. However, they can still be referred to as D(model.mass__v).","category":"page"},{"location":"tutorials/fmi/","page":"Importing FMUs","title":"Importing FMUs","text":"equations(model)","category":"page"},{"location":"tutorials/fmi/","page":"Importing FMUs","title":"Importing FMUs","text":"Since the FMI spec allows multiple names to alias the same quantity, ModelingToolkit.jl creates equations to alias them. For example, it can be seen above that der(mass.v) and mass.a have the same reference, and hence refer to the same quantity. Correspondingly, there is an equation mass__vˍt(t) ~ mass__a(t) in the system.","category":"page"},{"location":"tutorials/fmi/","page":"Importing FMUs","title":"Importing FMUs","text":"note: Note\nAny variables and/or parameters that are not part of the FMU should be ignored, as ModelingToolkit creates them to manage the FMU. Unexpected usage of these variables/parameters can lead to errors.","category":"page"},{"location":"tutorials/fmi/","page":"Importing FMUs","title":"Importing FMUs","text":"defaults(model)","category":"page"},{"location":"tutorials/fmi/","page":"Importing FMUs","title":"Importing FMUs","text":"All parameters in the FMU are given a default equal to their start value, if present. Unknowns are not assigned defaults even if a start value is present, as this would conflict with ModelingToolkit's own initialization semantics.","category":"page"},{"location":"tutorials/fmi/","page":"Importing FMUs","title":"Importing FMUs","text":"We can simulate this model like any other ModelingToolkit system.","category":"page"},{"location":"tutorials/fmi/","page":"Importing FMUs","title":"Importing FMUs","text":"sys = mtkcompile(model)\nprob = ODEProblem(sys, [sys.mass__s => 0.5, sys.mass__v => 0.0], (0.0, 5.0))\nsol = solve(prob, Tsit5())","category":"page"},{"location":"tutorials/fmi/","page":"Importing FMUs","title":"Importing FMUs","text":"We can interpolate the solution object to obtain values at arbitrary time points in the solved interval, just like a normal solution.","category":"page"},{"location":"tutorials/fmi/","page":"Importing FMUs","title":"Importing FMUs","text":"sol(0.0:0.1:1.0; idxs = sys.mass__a)","category":"page"},{"location":"tutorials/fmi/","page":"Importing FMUs","title":"Importing FMUs","text":"FMUs following version 3 of the specification can be simulated with almost the same process. This time, we will create a model from a CoSimulation FMU.","category":"page"},{"location":"tutorials/fmi/","page":"Importing FMUs","title":"Importing FMUs","text":"fmu = loadFMU(\"SpringPendulum1D\", \"Dymola\", \"2023x\", \"3.0\"; type = :CS)\n@named inner = ModelingToolkit.FMIComponent(\n    Val(3); fmu, communication_step_size = 0.001, type = :CS,\n    reinitializealg = BrownFullBasicInit())","category":"page"},{"location":"tutorials/fmi/","page":"Importing FMUs","title":"Importing FMUs","text":"This FMU has fewer equations, partly due to missing aliasing variables and partly due to being a CS FMU. CoSimulation FMUs are bundled with an integrator. As such, they do not function like ME FMUs. Instead, a callback steps the FMU at periodic intervals in time and obtains the updated state. This state is held constant until the next time the callback triggers. The periodic interval must be specified through the communication_step_size keyword argument. A smaller step size typically leads to less error but is more computationally expensive.","category":"page"},{"location":"tutorials/fmi/","page":"Importing FMUs","title":"Importing FMUs","text":"This model alone does not have any differential variables, and calling mtkcompile will lead to an System with no unknowns.","category":"page"},{"location":"tutorials/fmi/","page":"Importing FMUs","title":"Importing FMUs","text":"mtkcompile(inner)","category":"page"},{"location":"tutorials/fmi/","page":"Importing FMUs","title":"Importing FMUs","text":"Simulating this model will cause the OrdinaryDiffEq integrator to immediately finish, and will not trigger the callback. Thus, we wrap this system in a trivial system with a differential variable.","category":"page"},{"location":"tutorials/fmi/","page":"Importing FMUs","title":"Importing FMUs","text":"@variables x(t) = 1.0\n@mtkcompile sys = System([D(x) ~ x], t; systems = [inner])","category":"page"},{"location":"tutorials/fmi/","page":"Importing FMUs","title":"Importing FMUs","text":"We can now simulate sys.","category":"page"},{"location":"tutorials/fmi/","page":"Importing FMUs","title":"Importing FMUs","text":"prob = ODEProblem(sys, [sys.inner.mass__s => 0.5, sys.inner.mass__v => 0.0], (0.0, 5.0))\nsol = solve(prob, Tsit5())","category":"page"},{"location":"tutorials/fmi/","page":"Importing FMUs","title":"Importing FMUs","text":"The variables of the FMU are discrete, and their timeseries can be obtained at intervals of communication_step_size.","category":"page"},{"location":"tutorials/fmi/","page":"Importing FMUs","title":"Importing FMUs","text":"sol[sys.inner.mass__s]","category":"page"},{"location":"tutorials/fmi/#FMUs-of-components","page":"Importing FMUs","title":"FMUs of components","text":"","category":"section"},{"location":"tutorials/fmi/","page":"Importing FMUs","title":"Importing FMUs","text":"FMUs can also be imported as individual components. For this example, we will use custom FMUs used in the test suite of ModelingToolkit.jl.","category":"page"},{"location":"tutorials/fmi/","page":"Importing FMUs","title":"Importing FMUs","text":"fmu = loadFMU(\n    joinpath(@__DIR__, \"..\", \"..\", \"..\", \"test\", \"fmi\", \"fmus\", \"SimpleAdder.fmu\");\n    type = :ME)\nfmu.modelDescription.modelVariables","category":"page"},{"location":"tutorials/fmi/","page":"Importing FMUs","title":"Importing FMUs","text":"This FMU is equivalent to the following model:","category":"page"},{"location":"tutorials/fmi/","page":"Importing FMUs","title":"Importing FMUs","text":"@mtkmodel SimpleAdder begin\n    @variables begin\n        a(t)\n        b(t)\n        c(t)\n        out(t)\n        out2(t)\n    end\n    @parameters begin\n        value = 1.0\n    end\n    @equations begin\n        out ~ a + b + value\n        D(c) ~ out\n        out2 ~ 2c\n    end\nend","category":"page"},{"location":"tutorials/fmi/","page":"Importing FMUs","title":"Importing FMUs","text":"a and b are inputs, c is a state, and out and out2 are outputs of the component.","category":"page"},{"location":"tutorials/fmi/","page":"Importing FMUs","title":"Importing FMUs","text":"@named adder = ModelingToolkit.FMIComponent(\n    Val(2); fmu, type = :ME, reinitializealg = BrownFullBasicInit());\nisinput(adder.a)\nisinput(adder.b)\nisoutput(adder.out)\nisoutput(adder.out2)","category":"page"},{"location":"tutorials/fmi/","page":"Importing FMUs","title":"Importing FMUs","text":"ModelingToolkit recognizes input and output variables of the component, and attaches the appropriate metadata. We can now use this component as a subcomponent of a larger system.","category":"page"},{"location":"tutorials/fmi/","page":"Importing FMUs","title":"Importing FMUs","text":"@variables a(t) b(t) c(t) [guess = 1.0];\n@mtkcompile sys = System(\n    [adder.a ~ a, adder.b ~ b, D(a) ~ t,\n        D(b) ~ adder.out + adder.c, c^2 ~ adder.out + adder.value],\n    t;\n    systems = [adder])\nequations(sys)","category":"page"},{"location":"tutorials/fmi/","page":"Importing FMUs","title":"Importing FMUs","text":"Note how the output adder.out is used in an algebraic equation of the system. We have also given sys.c a guess, expecting it to be solved for by initialization. ModelingToolkit is able to use FMUs in initialization to solve for initial states. As mentioned earlier, we cannot differentiate through an FMU. Thus, automatic differentiation has to be disabled for the solver.","category":"page"},{"location":"tutorials/fmi/","page":"Importing FMUs","title":"Importing FMUs","text":"prob = ODEProblem(\n    sys, [sys.adder.c => 2.0, sys.a => 1.0, sys.b => 1.0, sys.adder.value => 2.0],\n    (0.0, 1.0))\nsolve(prob, Rodas5P(autodiff = false))","category":"page"},{"location":"tutorials/fmi/","page":"Importing FMUs","title":"Importing FMUs","text":"CoSimulation FMUs follow a nearly identical process. Since CoSimulation FMUs operate using callbacks, after triggering the callbacks and altering the discrete state the algebraic equations may no longer be satisfied. To resolve for the values of algebraic variables, we use the reinitializealg keyword of FMIComponent. This is a DAE initialization algorithm to use at the end of every callback. Since CoSimulation FMUs are not directly involved in the RHS of the system - instead operating through callbacks - we can use a solver with automatic differentiation.","category":"page"},{"location":"tutorials/fmi/","page":"Importing FMUs","title":"Importing FMUs","text":"fmu = loadFMU(\n    joinpath(@__DIR__, \"..\", \"..\", \"..\", \"test\", \"fmi\", \"fmus\", \"SimpleAdder.fmu\");\n    type = :CS)\n@named adder = ModelingToolkit.FMIComponent(\n    Val(2); fmu, type = :CS, communication_step_size = 1e-3,\n    reinitializealg = BrownFullBasicInit())\n@mtkcompile sys = System(\n    [adder.a ~ a, adder.b ~ b, D(a) ~ t,\n        D(b) ~ adder.out + adder.c, c^2 ~ adder.out + adder.value],\n    t;\n    systems = [adder])\nprob = ODEProblem(\n    sys, [sys.adder.c => 2.0, sys.a => 1.0, sys.b => 1.0, sys.adder.value => 2.0],\n    (0.0, 1.0))\nsolve(prob, Rodas5P())","category":"page"},{"location":"basics/InputOutput/#inputoutput","page":"Input output","title":"Input output","text":"","category":"section"},{"location":"basics/InputOutput/","page":"Input output","title":"Input output","text":"An input-output system is a system on the form","category":"page"},{"location":"basics/InputOutput/","page":"Input output","title":"Input output","text":"beginaligned\nM dot x = f(x u p t) \ny = g(x u p t)\nendaligned","category":"page"},{"location":"basics/InputOutput/","page":"Input output","title":"Input output","text":"where x is the state, u is the input and y is an output (in some contexts called an observed variables in MTK).","category":"page"},{"location":"basics/InputOutput/","page":"Input output","title":"Input output","text":"While many uses of ModelingToolkit for simulation do not require the user to think about inputs and outputs (IO), there are certain situations in which handling IO explicitly may be important, such as","category":"page"},{"location":"basics/InputOutput/","page":"Input output","title":"Input output","text":"Linearization\nControl design\nSystem identification\nFMU export\nReal-time simulation with external data inputs\nCustom interfacing with other simulation tools","category":"page"},{"location":"basics/InputOutput/","page":"Input output","title":"Input output","text":"This documentation page lists utilities that are useful for working with inputs and outputs in ModelingToolkit.","category":"page"},{"location":"basics/InputOutput/#Generating-a-dynamics-function-with-inputs,-f","page":"Input output","title":"Generating a dynamics function with inputs, f","text":"","category":"section"},{"location":"basics/InputOutput/","page":"Input output","title":"Input output","text":"ModelingToolkit can generate the dynamics of a system, the function Mdot x = f(x u p t) above, such that the user can pass not only the state x and parameters p but also an external input u. To this end, the function ModelingToolkit.generate_control_function exists.","category":"page"},{"location":"basics/InputOutput/","page":"Input output","title":"Input output","text":"This function takes a vector of variables that are to be considered inputs, i.e., part of the vector u. Alongside returning the function f, ModelingToolkit.generate_control_function also returns the chosen state realization of the system after simplification. This vector specifies the order of the state variables x, while the user-specified vector u specifies the order of the input variables u.","category":"page"},{"location":"basics/InputOutput/","page":"Input output","title":"Input output","text":"note: Un-simplified system\nThis function expects sys to be un-simplified, i.e., mtkcompile or @mtkcompile should not be called on the system before passing it into this function. generate_control_function calls a special version of mtkcompile internally.","category":"page"},{"location":"basics/InputOutput/#Example:","page":"Input output","title":"Example:","text":"","category":"section"},{"location":"basics/InputOutput/","page":"Input output","title":"Input output","text":"The following example implements a simple first-order system with an input u and state x. The function f is generated using generate_control_function, and the function f is then tested with random input and state values.","category":"page"},{"location":"basics/InputOutput/","page":"Input output","title":"Input output","text":"using ModelingToolkit\nimport ModelingToolkit: t_nounits as t, D_nounits as D\n@variables x(t)=0 u(t)=0 y(t)\n@parameters k = 1\neqs = [D(x) ~ -k * (x + u)\n       y ~ x]\n\n@named sys = System(eqs, t)\nf, x_sym, ps = ModelingToolkit.generate_control_function(sys, [u], simplify = true);\nnothing # hide","category":"page"},{"location":"basics/InputOutput/","page":"Input output","title":"Input output","text":"We can inspect the state realization chosen by MTK","category":"page"},{"location":"basics/InputOutput/","page":"Input output","title":"Input output","text":"x_sym","category":"page"},{"location":"basics/InputOutput/","page":"Input output","title":"Input output","text":"as expected, x is chosen as the state variable.","category":"page"},{"location":"basics/InputOutput/","page":"Input output","title":"Input output","text":"using Test # hide\n@test isequal(x_sym[], x) # hide\n@test isequal(ps, [k]) # hide\nnothing  # hide","category":"page"},{"location":"basics/InputOutput/","page":"Input output","title":"Input output","text":"Now we can test the generated function f with random input and state values","category":"page"},{"location":"basics/InputOutput/","page":"Input output","title":"Input output","text":"p = [1]\nx = [rand()]\nu = [rand()]\n@test f[1](x, u, p, 1) ≈ -p[] * (x + u) # Test that the function computes what we expect D(x) = -k*(x + u)","category":"page"},{"location":"basics/InputOutput/#Generating-an-output-function,-g","page":"Input output","title":"Generating an output function, g","text":"","category":"section"},{"location":"basics/InputOutput/","page":"Input output","title":"Input output","text":"ModelingToolkit can also generate a function that computes a specified output of a system, the function y = g(x u p t) above. This is done using the function ModelingToolkit.build_explicit_observed_function. When generating an output function, the user must specify the output variable(s) of interest, as well as any inputs if inputs are relevant to compute the output.","category":"page"},{"location":"basics/InputOutput/","page":"Input output","title":"Input output","text":"The order of the user-specified output variables determines the order of the output vector y.","category":"page"},{"location":"basics/InputOutput/#Input-output-variable-metadata","page":"Input output","title":"Input-output variable metadata","text":"","category":"section"},{"location":"basics/InputOutput/","page":"Input output","title":"Input output","text":"See Symbolic Metadata. Metadata specified when creating variables is not directly used by any of the functions above, but the user can use the accessor functions ModelingToolkit.inputs(sys) and ModelingToolkit.outputs(sys) to obtain all variables with such metadata for passing to the functions above. The presence of this metadata is not required for any IO functionality and may be omitted.","category":"page"},{"location":"basics/InputOutput/#Linearization","page":"Input output","title":"Linearization","text":"","category":"section"},{"location":"basics/InputOutput/","page":"Input output","title":"Input output","text":"See Linearization.","category":"page"},{"location":"basics/InputOutput/#Docstrings","page":"Input output","title":"Docstrings","text":"","category":"section"},{"location":"basics/InputOutput/","page":"Input output","title":"Input output","text":"Pages = [\"InputOutput.md\"]","category":"page"},{"location":"basics/InputOutput/#ModelingToolkit.generate_control_function-basics-InputOutput","page":"Input output","title":"ModelingToolkit.generate_control_function","text":"generate_control_function(sys::ModelingToolkit.AbstractSystem, input_ap_name::Union{Symbol, Vector{Symbol}, AnalysisPoint, Vector{AnalysisPoint}}, dist_ap_name::Union{Symbol, Vector{Symbol}, AnalysisPoint, Vector{AnalysisPoint}}; system_modifier = identity, kwargs)\n\nWhen called with analysis points as input arguments, we assume that all analysis points corresponds to connections that should be opened (broken). The use case for this is to get rid of input signal blocks, such as Step or Sine, since these are useful for simulation but are not needed when using the plant model in a controller or state estimator.\n\n\n\n\n\n(f_oop, f_ip), x_sym, p_sym, io_sys = generate_control_function(\n        sys::System,\n        inputs             = unbound_inputs(sys),\n        disturbance_inputs = disturbances(sys);\n        implicit_dae       = false,\n        simplify           = false,\n    )\n\nFor a system sys with inputs (as determined by unbound_inputs or user specified), generate functions with additional input argument u\n\nThe returned functions are the out-of-place (f_oop) and in-place (f_ip) forms:\n\nf_oop : (x,u,p,t)      -> rhs\nf_ip  : (xout,x,u,p,t) -> nothing\n\nThe return values also include the chosen state-realization (the remaining unknowns) x_sym and parameters, in the order they appear as arguments to f.\n\nIf disturbance_inputs is an array of variables, the generated dynamics function will preserve any state and dynamics associated with disturbance inputs, but the disturbance inputs themselves will (by default) not be included as inputs to the generated function. The use case for this is to generate dynamics for state observers that estimate the influence of unmeasured disturbances, and thus require unknown variables for the disturbance model, but without disturbance inputs since the disturbances are not available for measurement. To add an input argument corresponding to the disturbance inputs, either include the disturbance inputs among the control inputs, or set disturbance_argument=true, in which case an additional input argument w is added to the generated function (x,u,p,t,w)->rhs.\n\nExample\n\nusing ModelingToolkit: generate_control_function, varmap_to_vars, defaults\nf, x_sym, ps = generate_control_function(sys, expression=Val{false}, simplify=false)\np = varmap_to_vars(defaults(sys), ps)\nx = varmap_to_vars(defaults(sys), x_sym)\nt = 0\nf[1](x, inputs, p, t)\n\n\n\n\n\n","category":"function"},{"location":"basics/InputOutput/#ModelingToolkit.build_explicit_observed_function-basics-InputOutput","page":"Input output","title":"ModelingToolkit.build_explicit_observed_function","text":"build_explicit_observed_function(sys, ts; kwargs...) -> Function(s)\n\nGenerates a function that computes the observed value(s) ts in the system sys, while making the assumption that there are no cycles in the equations.\n\nArguments\n\nsys: The system for which to generate the function\nts: The symbolic observed values whose value should be computed\n\nKeywords\n\nreturn_inplace = false: If true and the observed value is a vector, then return both the in place and out of place methods.\nexpression = false: Generates a Julia Exprcomputing the observed value ifexpression` is true\neval_expression = false: If true and expression = false, evaluates the returned function in the module eval_module\noutput_type = Array the type of the array generated by a out-of-place vector-valued function\nparam_only = false if true, only allow the generated function to access system parameters\ninputs = nothing additinoal symbolic variables that should be provided to the generated function\ncheckbounds = true checks bounds if true when destructuring parameters\nop = Operator sets the recursion terminator for the walk done by vars to identify the variables that appear in ts. See the documentation for vars for more detail.\nthrow = true if true, throw an error when generating a function for ts that reference variables that do not exist.\nmkarray: only used if the output is an array (that is, !isscalar(ts)  and ts is not a tuple, in which case the result will always be a tuple). Called as mkarray(ts, output_type) where ts are the expressions to put in the array and output_type is the argument of the same name passed to buildexplicitobserved_function.\ncse = true: Whether to use Common Subexpression Elimination (CSE) to generate a more efficient function.\nwrap_delays = is_dde(sys): Whether to add an argument for the history function and use it to calculate all delayed variables.\n\nReturns\n\nThe return value will be either:\n\na single function f_oop if the input is a scalar or if the input is a Vector but return_inplace is false\nthe out of place and in-place functions (f_ip, f_oop) if return_inplace is true and the input is a Vector\n\nThe function(s) f_oop (and potentially f_ip) will be:\n\nRuntimeGeneratedFunctions by default,\nA Julia Expr if expression is true,\nA directly evaluated Julia function in the module eval_module if eval_expression is true and expression is false.\n\nThe signatures will be of the form g(...) with arguments:\n\noutput for in-place functions\nunknowns if param_only is false\ninputs if inputs is an array of symbolic inputs that should be available in ts \np... unconditionally; note that in the case of MTKParameters more than one parameters argument may be present, so it must be splatted\nt if the system is time-dependent; for example systems of nonlinear equations will not have t\n\nFor example, a function g(op, unknowns, p..., inputs, t) will be the in-place function generated if return_inplace is true, ts is a vector,  an array of inputs inputs is given, and param_only is false for a time-dependent system.\n\n\n\n\n\n","category":"function"},{"location":"tutorials/nonlinear/#Modeling-Nonlinear-Systems","page":"Modeling Nonlinear Systems","title":"Modeling Nonlinear Systems","text":"","category":"section"},{"location":"tutorials/nonlinear/","page":"Modeling Nonlinear Systems","title":"Modeling Nonlinear Systems","text":"ModelingToolkit.jl is not only useful for generating initial value problems (ODEProblem). The package can also build nonlinear systems. This is, for example, useful for finding the steady state of an ODE. This steady state is reached when the nonlinear system of differential equations equals zero.","category":"page"},{"location":"tutorials/nonlinear/","page":"Modeling Nonlinear Systems","title":"Modeling Nonlinear Systems","text":"note: Note\nThe high level @mtkmodel macro used in the getting started tutorial is not yet compatible with NonlinearSystem. We thus have to use a lower level interface to define nonlinear systems. For an introduction to this interface, read the programmatically generating Systems tutorial.","category":"page"},{"location":"tutorials/nonlinear/","page":"Modeling Nonlinear Systems","title":"Modeling Nonlinear Systems","text":"using ModelingToolkit, NonlinearSolve\n\n# Define a nonlinear system\n@variables x y z\n@parameters σ ρ β\neqs = [0 ~ σ * (y - x)\n       0 ~ x * (ρ - z) - y\n       0 ~ x * y - β * z]\n@mtkcompile ns = System(eqs)\n\nguesses = [x => 1.0, y => 0.0, z => 0.0]\nps = [σ => 10.0, ρ => 26.0, β => 8 / 3]\n\nprob = NonlinearProblem(ns, vcat(guesses, ps))\nsol = solve(prob, NewtonRaphson())","category":"page"},{"location":"tutorials/nonlinear/","page":"Modeling Nonlinear Systems","title":"Modeling Nonlinear Systems","text":"We found the x, y and z for which the right hand sides of eqs are all equal to zero.","category":"page"},{"location":"tutorials/nonlinear/","page":"Modeling Nonlinear Systems","title":"Modeling Nonlinear Systems","text":"Just like with ODEProblems we can generate the NonlinearProblem with its analytical Jacobian function:","category":"page"},{"location":"tutorials/nonlinear/","page":"Modeling Nonlinear Systems","title":"Modeling Nonlinear Systems","text":"prob = NonlinearProblem(ns, vcat(guesses, ps), jac = true)\nsol = solve(prob, NewtonRaphson())","category":"page"},{"location":"tutorials/discrete_system/#(Experimental)-Modeling-Discrete-Systems","page":"(Experimental) Modeling Discrete Systems","title":"(Experimental) Modeling Discrete Systems","text":"","category":"section"},{"location":"tutorials/discrete_system/","page":"(Experimental) Modeling Discrete Systems","title":"(Experimental) Modeling Discrete Systems","text":"In this example, we will use the System API to create an SIR model.","category":"page"},{"location":"tutorials/discrete_system/","page":"(Experimental) Modeling Discrete Systems","title":"(Experimental) Modeling Discrete Systems","text":"using ModelingToolkit\nusing ModelingToolkit: t_nounits as t\nusing OrdinaryDiffEq: solve, FunctionMap\n\n@inline function rate_to_proportion(r, t)\n    1 - exp(-r * t)\nend\n@parameters c δt β γ\n@constants h = 1\n@variables S(t) I(t) R(t)\nk = ShiftIndex(t)\ninfection = rate_to_proportion(\n    β * c * I(k - 1) / (S(k - 1) * h + I(k - 1) + R(k - 1)), δt * h) * S(k - 1)\nrecovery = rate_to_proportion(γ * h, δt) * I(k - 1)\n\n# Equations\neqs = [S(k) ~ S(k - 1) - infection * h,\n    I(k) ~ I(k - 1) + infection - recovery,\n    R(k) ~ R(k - 1) + recovery]\n@mtkcompile sys = System(eqs, t)\n\nu0 = [S(k - 1) => 990.0, I(k - 1) => 10.0, R(k - 1) => 0.0]\np = [β => 0.05, c => 10.0, γ => 0.25, δt => 0.1]\ntspan = (0.0, 100.0)\nprob = DiscreteProblem(sys, vcat(u0, p), tspan)\nsol = solve(prob, FunctionMap())","category":"page"},{"location":"tutorials/discrete_system/","page":"(Experimental) Modeling Discrete Systems","title":"(Experimental) Modeling Discrete Systems","text":"All shifts must be non-positive, i.e., discrete-time variables may only be indexed at index k, k-1, k-2, .... If default values are provided, they are treated as the value of the variable at the previous timestep. For example, consider the following system to generate the Fibonacci series:","category":"page"},{"location":"tutorials/discrete_system/","page":"(Experimental) Modeling Discrete Systems","title":"(Experimental) Modeling Discrete Systems","text":"@variables x(t) = 1.0\n@mtkcompile sys = System([x ~ x(k - 1) + x(k - 2)], t)","category":"page"},{"location":"tutorials/discrete_system/","page":"(Experimental) Modeling Discrete Systems","title":"(Experimental) Modeling Discrete Systems","text":"The \"default value\" here should be interpreted as the value of x at all past timesteps. For example, here x(k-1) and x(k-2) will be 1.0, and the initial value of x(k) will thus be 2.0. During problem construction, the past value of a variable should be provided. For example, providing [x => 1.0] while constructing this problem will error. Provide [x(k-1) => 1.0] instead. Note that values provided during problem construction do not apply to the entire history. Hence, if [x(k-1) => 2.0] is provided, the value of x(k-2) will still be 1.0.","category":"page"},{"location":"tutorials/disturbance_modeling/#Disturbance-and-input-modeling-modeling","page":"Disturbance and input modeling modeling","title":"Disturbance and input modeling modeling","text":"","category":"section"},{"location":"tutorials/disturbance_modeling/","page":"Disturbance and input modeling modeling","title":"Disturbance and input modeling modeling","text":"Disturbances are often seen as external factors that influence a system. Modeling and simulation of such external influences is common in order to ensure that the plant and or control system can adequately handle or suppress these disturbances. Disturbance modeling is also integral to the problem of state estimation, indeed, modeling how disturbances affect the evolution of the state of the system is crucial in order to accurately estimate this state.","category":"page"},{"location":"tutorials/disturbance_modeling/","page":"Disturbance and input modeling modeling","title":"Disturbance and input modeling modeling","text":"This tutorial will show how to model disturbances in ModelingToolkit as disturbance inputs. This involves demonstrating best practices that make it easy to use a single model to handle both disturbed and undisturbed systems, and making use of the model for both simulation and state estimation.","category":"page"},{"location":"tutorials/disturbance_modeling/#A-flexible-component-based-workflow","page":"Disturbance and input modeling modeling","title":"A flexible component-based workflow","text":"","category":"section"},{"location":"tutorials/disturbance_modeling/","page":"Disturbance and input modeling modeling","title":"Disturbance and input modeling modeling","text":"We will consider a simple system consisting of two inertias connected through a flexible shaft, such as a simple transmission system in a car. We start by modeling the plant without any input signals:","category":"page"},{"location":"tutorials/disturbance_modeling/","page":"Disturbance and input modeling modeling","title":"Disturbance and input modeling modeling","text":"using ModelingToolkit, OrdinaryDiffEq, LinearAlgebra, Test\nusing ModelingToolkitStandardLibrary.Mechanical.Rotational\nusing ModelingToolkitStandardLibrary.Blocks\nt = ModelingToolkit.t_nounits\nD = ModelingToolkit.D_nounits\n\n@mtkmodel SystemModel begin\n    @parameters begin\n        m1 = 1\n        m2 = 1\n        k = 10 # Spring stiffness\n        c = 3  # Damping coefficient\n    end\n    @components begin\n        inertia1 = Inertia(; J = m1, phi = 0, w = 0)\n        inertia2 = Inertia(; J = m2, phi = 0, w = 0)\n        spring = Spring(; c = k)\n        damper = Damper(; d = c)\n        torque = Torque(use_support = false)\n    end\n    @equations begin\n        connect(torque.flange, inertia1.flange_a)\n        connect(inertia1.flange_b, spring.flange_a, damper.flange_a)\n        connect(inertia2.flange_a, spring.flange_b, damper.flange_b)\n    end\nend","category":"page"},{"location":"tutorials/disturbance_modeling/","page":"Disturbance and input modeling modeling","title":"Disturbance and input modeling modeling","text":"Here, we have added a torque component that allows us to add a torque input to drive the system, but we have not connected any signal to it yet. We have not yet made any attempts at modeling disturbances, and this is deliberate, we will handle this later in order to make the plant model as generically useful as possible.","category":"page"},{"location":"tutorials/disturbance_modeling/","page":"Disturbance and input modeling modeling","title":"Disturbance and input modeling modeling","text":"In order to simulate this system in the presence of disturbances, we must 1. Reason about how disturbances may affect the system, and 2. attach disturbance inputs and disturbance signals to the model. We distinguish between an input and a signal here, where we by input mean an attachment point (connector) to which we may connect a signal, i.e., a time-varying function.","category":"page"},{"location":"tutorials/disturbance_modeling/","page":"Disturbance and input modeling modeling","title":"Disturbance and input modeling modeling","text":"We create a new model that includes disturbance inputs and signals, and attach those to the already defined plant model. We assume that each of the two inertias can be affected by a disturbance torque, such as due to friction or an unknown load on the output inertia.","category":"page"},{"location":"tutorials/disturbance_modeling/","page":"Disturbance and input modeling modeling","title":"Disturbance and input modeling modeling","text":"@mtkmodel ModelWithInputs begin\n    @components begin\n        input_signal = Blocks.Sine(frequency = 1, amplitude = 1)\n        disturbance_signal1 = Blocks.Step(height = -1, start_time = 2) # We add an input signal that equals zero by default so that it has no effect during normal simulation\n        disturbance_signal2 = Blocks.Step(height = 2, start_time = 4)\n        disturbance_torque1 = Torque(use_support = false)\n        disturbance_torque2 = Torque(use_support = false)\n        system_model = SystemModel()\n    end\n    @equations begin\n        connect(input_signal.output, :u, system_model.torque.tau)\n        connect(disturbance_signal1.output, :d1, disturbance_torque1.tau) # When we connect the input _signals_, we do so through an analysis point. This allows us to easily disconnect the input signals in situations when we do not need them. \n        connect(disturbance_signal2.output, :d2, disturbance_torque2.tau)\n        connect(disturbance_torque1.flange, system_model.inertia1.flange_b)\n        connect(disturbance_torque2.flange, system_model.inertia2.flange_b)\n    end\nend","category":"page"},{"location":"tutorials/disturbance_modeling/","page":"Disturbance and input modeling modeling","title":"Disturbance and input modeling modeling","text":"This outer model, ModelWithInputs, contains two disturbance inputs, both of type Torque. It also contains three signal specifications, one for the control input and two for the corresponding disturbance inputs. Note how we added the disturbance torque inputs at this level of the model, but the control input was added inside the system model. This is a design choice that is up to the modeler, here, we consider the driving torque to be a fundamental part of the model that is always required to make use of it, while the disturbance inputs may be of interest only in certain situations, and we thus add them when needed. Since we have added not only input connectors, but also connected input signals to them, this model is complete and ready for simulation, i.e., there are no unbound inputs.","category":"page"},{"location":"tutorials/disturbance_modeling/","page":"Disturbance and input modeling modeling","title":"Disturbance and input modeling modeling","text":"@named model = ModelWithInputs() # Model with load disturbance\nssys = mtkcompile(model)\nprob = ODEProblem(ssys, [], (0.0, 6.0))\nsol = solve(prob, Tsit5())\nusing Plots\nplot(sol)","category":"page"},{"location":"tutorials/disturbance_modeling/","page":"Disturbance and input modeling modeling","title":"Disturbance and input modeling modeling","text":"A thing to note in the specification of ModelWithInputs is the presence of three analysis points, :u, :d1, and :d2. When signals are connected through an analysis point, we may at any time linearize the model as if the signals were not connected, i.e., as if the corresponding inputs were unbound. We may also use this to generate a julia function for the dynamics on the form f(xuptw) where the input u and disturbance w may be provided as separate function arguments, as if the corresponding input signals were not present in the model. More details regarding this will be presented further below, here, we just demonstrate how we could linearize this system model from the inputs to the angular velocity of the inertias","category":"page"},{"location":"tutorials/disturbance_modeling/","page":"Disturbance and input modeling modeling","title":"Disturbance and input modeling modeling","text":"using ControlSystemsBase, ControlSystemsMTK # ControlSystemsMTK provides the high-level function named_ss and ControlSystemsBase provides the bodeplot function\nP = named_ss(model, [ssys.u, ssys.d1, ssys.d2],\n    [ssys.system_model.inertia1.w, ssys.system_model.inertia2.w])\nbodeplot(P, plotphase = false)","category":"page"},{"location":"tutorials/disturbance_modeling/","page":"Disturbance and input modeling modeling","title":"Disturbance and input modeling modeling","text":"It's worth noting at this point that the fact that we could connect disturbance outputs from outside of the plant-model definition was enabled by the fact that we used a component-based workflow, where the plant model had the appropriate connectors available. If the plant model had modeled the system using direct equations without connectors, this would not have been possible and the model would thus be significantly less flexible.","category":"page"},{"location":"tutorials/disturbance_modeling/","page":"Disturbance and input modeling modeling","title":"Disturbance and input modeling modeling","text":"We summarize the findings so far as a number of best practices:","category":"page"},{"location":"tutorials/disturbance_modeling/","page":"Disturbance and input modeling modeling","title":"Disturbance and input modeling modeling","text":"tip: Best practices\nUse a component-based workflow to model the plant\nIf possible, model the plant without explicit disturbance inputs to make it as generic as possible\nWhen disturbance inputs are needed, create a new model that includes the plant model and the disturbance inputs\nOnly add input signals at the top level of the model, this applies to both control inputs and disturbance inputs.\nUse analysis points to connect signals to inputs, this allows for easy disconnection of signals when needed, e.g., for linearization or function generation.","category":"page"},{"location":"tutorials/disturbance_modeling/#Modeling-for-state-estimation","page":"Disturbance and input modeling modeling","title":"Modeling for state estimation","text":"","category":"section"},{"location":"tutorials/disturbance_modeling/","page":"Disturbance and input modeling modeling","title":"Disturbance and input modeling modeling","text":"In the example above, we constructed a model for simulation of a disturbance affecting the system. When simulating, we connect an input signal of specified shape that simulates the disturbance, above, we used Blocks.Step as input signals. On the other hand, when performing state estimation, the exact shape of the disturbance is typically not known, we might only have some diffuse knowledge of the disturbance characteristics such as \"varies smoothly\", \"makes sudden step changes\" or \"is approximately periodic with 24hr period\". The encoding of such knowledge is commonly reasoned about in the frequency domain, where we specify a disturbance model as a dynamical system with a frequency response similar to the approximate spectrum of the disturbance. For more details around this, see the in-depth tutorial notebook \"How to tune a Kalman filter\". Most algorithms for state estimation, such as a Kalman-filter like estimators, assume that disturbances are independent and identically distributed (i.i.d.). While seemingly restrictive at first glance, when combined with an appropriate disturbance models encoded as dynamical systems, this assumption still allows for a wide range of non i.i.d. disturbances to be modeled.","category":"page"},{"location":"tutorials/disturbance_modeling/","page":"Disturbance and input modeling modeling","title":"Disturbance and input modeling modeling","text":"When modeling a system in MTK, we essentially (without considering algebraic equations for simplicity in exposition) construct a model of a dynamical system","category":"page"},{"location":"tutorials/disturbance_modeling/","page":"Disturbance and input modeling modeling","title":"Disturbance and input modeling modeling","text":"beginaligned\ndot x = f(x p t) \ny = g(x p t)\nendaligned","category":"page"},{"location":"tutorials/disturbance_modeling/","page":"Disturbance and input modeling modeling","title":"Disturbance and input modeling modeling","text":"where x is the state, y are observed variables, p are parameters, and t is time. When using MTK, which variables constitute x and which are considered part of the output, y, is up to the tool rather than the user, this choice is made by MTK during the call to @mtkcompile or the lower-level function mtkcompile.","category":"page"},{"location":"tutorials/disturbance_modeling/","page":"Disturbance and input modeling modeling","title":"Disturbance and input modeling modeling","text":"If we further consider external inputs to the system, such as controlled input signals u and disturbance inputs w, we can write the system as","category":"page"},{"location":"tutorials/disturbance_modeling/","page":"Disturbance and input modeling modeling","title":"Disturbance and input modeling modeling","text":"beginaligned\ndot x = f(x u p t w) \ny = g(x u p t)\nendaligned","category":"page"},{"location":"tutorials/disturbance_modeling/","page":"Disturbance and input modeling modeling","title":"Disturbance and input modeling modeling","text":"To make use of the model defined above for state estimation, we may want to generate a Julia function for the dynamics f and the output equations g that we can plug into, e.g., a nonlinear version of a Kalman filter or a particle filter, etc. MTK contains utilities to do this, namely, ModelingToolkit.generate_control_function and ModelingToolkit.build_explicit_observed_function (described in more details in \"Input output\"). These functions take keyword arguments disturbance_inputs and disturbance_argument, that indicate which variables in the model are considered part of w, and whether or not these variables are to be added as function arguments to f, i.e., whether we have f(x u p t) or f(x u p t w). If we do not include the disturbance inputs as function arguments, MTK will assume that the w variables are all zero, but any dynamics associated with these variables, such as disturbance models, will be included in the generated function. This allows a state estimator to estimate the state of the disturbance model, provided that this state is observable from the measured outputs of the system.","category":"page"},{"location":"tutorials/disturbance_modeling/","page":"Disturbance and input modeling modeling","title":"Disturbance and input modeling modeling","text":"Below, we demonstrate","category":"page"},{"location":"tutorials/disturbance_modeling/","page":"Disturbance and input modeling modeling","title":"Disturbance and input modeling modeling","text":"How to add an integrating disturbance model\nhow to generate the functions f and g for a typical nonlinear state estimator with explicit disturbance inputs","category":"page"},{"location":"tutorials/disturbance_modeling/","page":"Disturbance and input modeling modeling","title":"Disturbance and input modeling modeling","text":"@mtkmodel IntegratingDisturbance begin\n    @variables begin\n        x(t) = 0.0\n        w(t) = 0.0, [disturbance = true, input = true]\n    end\n    @components begin\n        input = RealInput()\n        output = RealOutput()\n    end\n    @equations begin\n        D(x) ~ w\n        w ~ input.u\n        output.u ~ x\n    end\nend\n\n@mtkmodel SystemModelWithDisturbanceModel begin\n    @components begin\n        input_signal = Blocks.Sine(frequency = 1, amplitude = 1)\n        disturbance_signal1 = Blocks.Constant(k = 0)\n        disturbance_signal2 = Blocks.Constant(k = 0)\n        disturbance_torque1 = Torque(use_support = false)\n        disturbance_torque2 = Torque(use_support = false)\n        disturbance_model = Blocks.Integrator()\n        system_model = SystemModel()\n    end\n    @equations begin\n        connect(input_signal.output, :u, system_model.torque.tau)\n        connect(disturbance_signal1.output, :d1, disturbance_model.input)\n        connect(disturbance_model.output, disturbance_torque1.tau)\n        connect(disturbance_signal2.output, :d2, disturbance_torque2.tau)\n        connect(disturbance_torque1.flange, system_model.inertia1.flange_b)\n        connect(disturbance_torque2.flange, system_model.inertia2.flange_b)\n    end\nend\n\n@named model_with_disturbance = SystemModelWithDisturbanceModel()","category":"page"},{"location":"tutorials/disturbance_modeling/","page":"Disturbance and input modeling modeling","title":"Disturbance and input modeling modeling","text":"We demonstrate that this model is complete and can be simulated:","category":"page"},{"location":"tutorials/disturbance_modeling/","page":"Disturbance and input modeling modeling","title":"Disturbance and input modeling modeling","text":"ssys = mtkcompile(model_with_disturbance)\nprob = ODEProblem(ssys, [], (0.0, 10.0))\nsol = solve(prob, Tsit5())\nusing Test\n@test SciMLBase.successful_retcode(sol)","category":"page"},{"location":"tutorials/disturbance_modeling/","page":"Disturbance and input modeling modeling","title":"Disturbance and input modeling modeling","text":"but we may also generate the functions f and g for state estimation:","category":"page"},{"location":"tutorials/disturbance_modeling/","page":"Disturbance and input modeling modeling","title":"Disturbance and input modeling modeling","text":"inputs = [ssys.u]\ndisturbance_inputs = [ssys.d1, ssys.d2]\nP = ssys.system_model\noutputs = [P.inertia1.phi, P.inertia2.phi, P.inertia1.w, P.inertia2.w]\n\n(f_oop, f_ip), x_sym,\np_sym,\nio_sys = ModelingToolkit.generate_control_function(\n    model_with_disturbance, inputs, disturbance_inputs; disturbance_argument = true)\n\ng = ModelingToolkit.build_explicit_observed_function(\n    io_sys, outputs; inputs)\n\nop = ModelingToolkit.inputs(io_sys) .=> 0\nx0 = ModelingToolkit.get_u0(io_sys, op)\np = MTKParameters(io_sys, op)\nu = zeros(1) # Control input\nw = zeros(length(disturbance_inputs)) # Disturbance input\n@test f_oop(x0, u, p, t, w) == zeros(5)\n@test g(x0, u, p, 0.0) == [0, 0, 0, 0]\n\n# Non-zero disturbance inputs should result in non-zero state derivatives. We call `sort` since we do not generally know the order of the state variables\nw = [1.0, 2.0]\n@test sort(f_oop(x0, u, p, t, w)) == [0, 0, 0, 1, 2]","category":"page"},{"location":"tutorials/disturbance_modeling/#Input-signal-library","page":"Disturbance and input modeling modeling","title":"Input signal library","text":"","category":"section"},{"location":"tutorials/disturbance_modeling/","page":"Disturbance and input modeling modeling","title":"Disturbance and input modeling modeling","text":"The Blocks module in ModelingToolkitStandardLibrary contains several predefined input signals, such as Sine, Step, Ramp, Constant etc., a few of which were used in the examples above. If you have an input signal represented as a sequence of samples, you may use an Interpolation block, e.g., as src = Interpolation(ConstantInterpolation, data, timepoints), see the docstring for a complete example.","category":"page"},{"location":"tutorials/disturbance_modeling/#Disturbance-model-library","page":"Disturbance and input modeling modeling","title":"Disturbance-model library","text":"","category":"section"},{"location":"tutorials/disturbance_modeling/","page":"Disturbance and input modeling modeling","title":"Disturbance and input modeling modeling","text":"There is no library explicitly constructed for disturbance modeling. Standard blocks from the Blocks module in ModelingToolkitStandardLibrary, such as Integrator, TransferFunction, StateSpace, can model any disturbance with rational spectrum. Examples of this includes disturbance models such as constants, piecewise constant, periodic, highpass, lowpass, and bandpass. For help with filter design, see ControlSystems.jl: Filter-design and the interface package ControlSystemsMTK.jl. In the example above, we made use of Blocks.Integrator, which is a disturbance model suitable for disturbances dominated by low-frequency components, such as piecewise constant signals or slowly drifting signals.","category":"page"},{"location":"tutorials/disturbance_modeling/#Further-reading","page":"Disturbance and input modeling modeling","title":"Further reading","text":"","category":"section"},{"location":"tutorials/disturbance_modeling/","page":"Disturbance and input modeling modeling","title":"Disturbance and input modeling modeling","text":"To see full examples that perform state estimation with ModelingToolkit models, see the following resources:","category":"page"},{"location":"tutorials/disturbance_modeling/","page":"Disturbance and input modeling modeling","title":"Disturbance and input modeling modeling","text":"C codegen considered unnecessary: go directly to binary, do not pass C. Compilation of Julia code for deployment in model-based engineering\nLowLevelParticleFiltersMTK.jl","category":"page"},{"location":"tutorials/disturbance_modeling/#Index","page":"Disturbance and input modeling modeling","title":"Index","text":"","category":"section"},{"location":"tutorials/disturbance_modeling/","page":"Disturbance and input modeling modeling","title":"Disturbance and input modeling modeling","text":"Pages = [\"disturbance_modeling.md\"]","category":"page"},{"location":"tutorials/disturbance_modeling/#ModelingToolkit.connect-Tuple{ModelingToolkit.AbstractSystem, Symbol, Any, Vararg{Any}}-tutorials-disturbance_modeling","page":"Disturbance and input modeling modeling","title":"ModelingToolkit.connect","text":"connect(output_connector, ap_name::Symbol, input_connector; verbose = true)\nconnect(output_connector, ap::AnalysisPoint, input_connector; verbose = true)\n\nConnect output_connector and input_connector with an AnalysisPoint inbetween. The incoming connection output_connector is expected to be an output connector (for example, ModelingToolkitStandardLibrary.Blocks.RealOutput), and vice versa.\n\nPLEASE NOTE: The connection is assumed to be causal, meaning that\n\n@named P = FirstOrder(k = 1, T = 1)\n@named C = Gain(; k = -1)\nconnect(C.output, :plant_input, P.input)\n\nis correct, whereas\n\nconnect(P.input, :plant_input, C.output)\n\ntypically is not (unless the model is an inverse model).\n\nArguments\n\noutput_connector: An output connector\ninput_connector: An input connector\nap: An explicitly created AnalysisPoint\nap_name: If a name is given, an AnalysisPoint with the given name will be created automatically.\n\nKeyword arguments\n\nverbose: Warn if an input is connected to an output (reverse causality). Silence this warning if you are analyzing an inverse model.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/disturbance_modeling/#ModelingToolkit.get_comp_sensitivity-tutorials-disturbance_modeling","page":"Disturbance and input modeling modeling","title":"ModelingToolkit.get_comp_sensitivity","text":"get_comp_sensitivity(sys, ap::AnalysisPoint; kwargs)\nget_comp_sensitivity(sys, ap_name::Symbol; kwargs)\n\nCompute the complementary sensitivity function in analysis point ap. The complementary sensitivity function is obtained by introducing an infinitesimal perturbation d at the output of ap, linearizing the system and computing the transfer function between d and the input of ap.\n\nArguments:\n\nkwargs: Are sent to ModelingToolkit.linearize\n\nSee also get_sensitivity, get_looptransfer.\n\n\n\n\n\n","category":"function"},{"location":"tutorials/disturbance_modeling/#ModelingToolkit.get_comp_sensitivity_function-Tuple{ModelingToolkit.AbstractSystem, Any}-tutorials-disturbance_modeling","page":"Disturbance and input modeling modeling","title":"ModelingToolkit.get_comp_sensitivity_function","text":"get_comp_sensitivity_function(\n    sys::ModelingToolkit.AbstractSystem,\n    aps;\n    kwargs...\n) -> Tuple{ModelingToolkit.LinearizationFunction{DI, AI, _A, P, _B, _C, J1, J2, J3, J4, IA, @NamedTuple{abstol::Float64, reltol::Float64, nlsolve_alg::NonlinearSolveFirstOrder.GeneralizedFirstOrderAlgorithm{Missing, NonlinearSolveFirstOrder.GenericTrustRegionScheme{NonlinearSolveFirstOrder.RadiusUpdateSchemes.__Simple, Rational{Int64}, Rational{Int64}, Rational{Int64}, Rational{Int64}, Rational{Int64}, Rational{Int64}, Rational{Int64}}, NonlinearSolveBase.Dogleg{NonlinearSolveBase.NewtonDescent{Nothing}, NonlinearSolveBase.SteepestDescent{Nothing}}, Nothing, Nothing, Nothing, Val{false}}}} where {DI<:AbstractVector{Int64}, AI<:AbstractVector{Int64}, _A, P<:ODEProblem, _B, _C, J1<:Union{Nothing, ModelingToolkit.PreparedJacobian{true, DifferentiationInterfaceForwardDiffExt.ForwardDiffTwoArgJacobianPrep{Nothing, C, Tuple{Nothing, Nothing}}, ModelingToolkit.var\"#uff#953\"{var\"#1488#fun\"}, _A, ADTypes.AutoForwardDiff{nothing, Nothing}} where {C<:(ForwardDiff.JacobianConfig{T, _A, _B, <:Tuple{Any, Any}} where {T<:(ForwardDiff.Tag{F} where F<:ModelingToolkit.var\"#uff#953\"), _A, _B}), var\"#1488#fun\", _A}}, J2<:Union{Nothing, ModelingToolkit.PreparedJacobian{true, DifferentiationInterfaceForwardDiffExt.ForwardDiffTwoArgJacobianPrep{Nothing, C, Tuple{Nothing, Nothing}}, _A, _B, ADTypes.AutoForwardDiff{nothing, Nothing}} where {C<:ForwardDiff.JacobianConfig, _A, _B}}, J3<:Union{Nothing, ModelingToolkit.PreparedJacobian{true, DifferentiationInterfaceForwardDiffExt.ForwardDiffTwoArgJacobianPrep{Nothing, C, Tuple{Nothing, Nothing, Nothing}}, ModelingToolkit.var\"#pff#954\"{var\"#1489#fun\", var\"#1490#setter\"}, _A, ADTypes.AutoForwardDiff{nothing, Nothing}} where {C<:(ForwardDiff.JacobianConfig{T, _A, _B, <:Tuple{Any, Any}} where {T<:(ForwardDiff.Tag{F} where F<:ModelingToolkit.var\"#pff#954\"), _A, _B}), var\"#1489#fun\", var\"#1490#setter\", _A}}, J4<:(ModelingToolkit.PreparedJacobian{true, DifferentiationInterfaceForwardDiffExt.ForwardDiffTwoArgJacobianPrep{Nothing, C, Tuple{Nothing, Nothing, Nothing}}, ModelingToolkit.var\"#hpf#952\"{fun, setter}, _A, ADTypes.AutoForwardDiff{nothing, Nothing}} where {C<:(ForwardDiff.JacobianConfig{T, _A, _B, <:Tuple{Any, Any}} where {T<:(ForwardDiff.Tag{F} where F<:ModelingToolkit.var\"#hpf#952\"), _A, _B}), fun, setter, _A}), IA<:Union{SciMLBase.NoInit, SciMLBase.OverrideInit{Nothing, Nothing, Nothing}}}, Any}\n\n\nReturn the complementary sensitivity function for the analysis point(s) aps, and the modified system simplified with the appropriate inputs and outputs.\n\nKeyword Arguments\n\n- `loop_openings`: A list of analysis points whose connections should be removed and\n  the outputs set to the input as a part of the linear analysis.\n\n- `system_modifier`: A function taking the transformed system and applying any\n  additional transformations, returning the modified system. The modified system\n  is passed to `linearization_function`.\n\nAll other keyword arguments are forwarded to linearization_function.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/disturbance_modeling/#ModelingToolkit.get_looptransfer-tutorials-disturbance_modeling","page":"Disturbance and input modeling modeling","title":"ModelingToolkit.get_looptransfer","text":"get_looptransfer(sys, ap::AnalysisPoint; kwargs)\nget_looptransfer(sys, ap_name::Symbol; kwargs)\n\nCompute the (linearized) loop-transfer function in analysis point ap, from ap.out to ap.in.\n\ninfo: Negative feedback\nFeedback loops often use negative feedback, and the computed loop-transfer function will in this case have the negative feedback included. Standard analysis tools often assume a loop-transfer function without the negative gain built in, and the result of this function may thus need negation before use.\n\nArguments:\n\nkwargs: Are sent to ModelingToolkit.linearize\n\nSee also get_sensitivity, get_comp_sensitivity, open_loop.\n\n\n\n\n\n","category":"function"},{"location":"tutorials/disturbance_modeling/#ModelingToolkit.get_looptransfer_function-Tuple{ModelingToolkit.AbstractSystem, Any}-tutorials-disturbance_modeling","page":"Disturbance and input modeling modeling","title":"ModelingToolkit.get_looptransfer_function","text":"get_looptransfer_function(\n    sys::ModelingToolkit.AbstractSystem,\n    aps;\n    kwargs...\n) -> Tuple{ModelingToolkit.LinearizationFunction{DI, AI, _A, P, _B, _C, J1, J2, J3, J4, IA, @NamedTuple{abstol::Float64, reltol::Float64, nlsolve_alg::NonlinearSolveFirstOrder.GeneralizedFirstOrderAlgorithm{Missing, NonlinearSolveFirstOrder.GenericTrustRegionScheme{NonlinearSolveFirstOrder.RadiusUpdateSchemes.__Simple, Rational{Int64}, Rational{Int64}, Rational{Int64}, Rational{Int64}, Rational{Int64}, Rational{Int64}, Rational{Int64}}, NonlinearSolveBase.Dogleg{NonlinearSolveBase.NewtonDescent{Nothing}, NonlinearSolveBase.SteepestDescent{Nothing}}, Nothing, Nothing, Nothing, Val{false}}}} where {DI<:AbstractVector{Int64}, AI<:AbstractVector{Int64}, _A, P<:ODEProblem, _B, _C, J1<:Union{Nothing, ModelingToolkit.PreparedJacobian{true, DifferentiationInterfaceForwardDiffExt.ForwardDiffTwoArgJacobianPrep{Nothing, C, Tuple{Nothing, Nothing}}, ModelingToolkit.var\"#uff#953\"{var\"#1488#fun\"}, _A, ADTypes.AutoForwardDiff{nothing, Nothing}} where {C<:(ForwardDiff.JacobianConfig{T, _A, _B, <:Tuple{Any, Any}} where {T<:(ForwardDiff.Tag{F} where F<:ModelingToolkit.var\"#uff#953\"), _A, _B}), var\"#1488#fun\", _A}}, J2<:Union{Nothing, ModelingToolkit.PreparedJacobian{true, DifferentiationInterfaceForwardDiffExt.ForwardDiffTwoArgJacobianPrep{Nothing, C, Tuple{Nothing, Nothing}}, _A, _B, ADTypes.AutoForwardDiff{nothing, Nothing}} where {C<:ForwardDiff.JacobianConfig, _A, _B}}, J3<:Union{Nothing, ModelingToolkit.PreparedJacobian{true, DifferentiationInterfaceForwardDiffExt.ForwardDiffTwoArgJacobianPrep{Nothing, C, Tuple{Nothing, Nothing, Nothing}}, ModelingToolkit.var\"#pff#954\"{var\"#1489#fun\", var\"#1490#setter\"}, _A, ADTypes.AutoForwardDiff{nothing, Nothing}} where {C<:(ForwardDiff.JacobianConfig{T, _A, _B, <:Tuple{Any, Any}} where {T<:(ForwardDiff.Tag{F} where F<:ModelingToolkit.var\"#pff#954\"), _A, _B}), var\"#1489#fun\", var\"#1490#setter\", _A}}, J4<:(ModelingToolkit.PreparedJacobian{true, DifferentiationInterfaceForwardDiffExt.ForwardDiffTwoArgJacobianPrep{Nothing, C, Tuple{Nothing, Nothing, Nothing}}, ModelingToolkit.var\"#hpf#952\"{fun, setter}, _A, ADTypes.AutoForwardDiff{nothing, Nothing}} where {C<:(ForwardDiff.JacobianConfig{T, _A, _B, <:Tuple{Any, Any}} where {T<:(ForwardDiff.Tag{F} where F<:ModelingToolkit.var\"#hpf#952\"), _A, _B}), fun, setter, _A}), IA<:Union{SciMLBase.NoInit, SciMLBase.OverrideInit{Nothing, Nothing, Nothing}}}, Any}\n\n\nReturn the loop-transfer function for the analysis point(s) aps, and the modified system simplified with the appropriate inputs and outputs.\n\nKeyword Arguments\n\n- `loop_openings`: A list of analysis points whose connections should be removed and\n  the outputs set to the input as a part of the linear analysis.\n\n- `system_modifier`: A function taking the transformed system and applying any\n  additional transformations, returning the modified system. The modified system\n  is passed to `linearization_function`.\n\nAll other keyword arguments are forwarded to linearization_function.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/disturbance_modeling/#ModelingToolkit.get_sensitivity-tutorials-disturbance_modeling","page":"Disturbance and input modeling modeling","title":"ModelingToolkit.get_sensitivity","text":"    get_sensitivity(sys, ap::AnalysisPoint; kwargs)\n    get_sensitivity(sys, ap_name::Symbol; kwargs)\n\nCompute the sensitivity function in analysis point ap. The sensitivity function is obtained by introducing an infinitesimal perturbation d at the input of ap, linearizing the system and computing the transfer function between d and the output of ap.\n\nArguments:\n\nkwargs: Are sent to ModelingToolkit.linearize\n\nSee also get_comp_sensitivity, get_looptransfer.\n\n\n\n\n\n","category":"function"},{"location":"tutorials/disturbance_modeling/#ModelingToolkit.get_sensitivity_function-Tuple{ModelingToolkit.AbstractSystem, Any}-tutorials-disturbance_modeling","page":"Disturbance and input modeling modeling","title":"ModelingToolkit.get_sensitivity_function","text":"get_sensitivity_function(\n    sys::ModelingToolkit.AbstractSystem,\n    aps;\n    kwargs...\n) -> Tuple{ModelingToolkit.LinearizationFunction{DI, AI, _A, P, _B, _C, J1, J2, J3, J4, IA, @NamedTuple{abstol::Float64, reltol::Float64, nlsolve_alg::NonlinearSolveFirstOrder.GeneralizedFirstOrderAlgorithm{Missing, NonlinearSolveFirstOrder.GenericTrustRegionScheme{NonlinearSolveFirstOrder.RadiusUpdateSchemes.__Simple, Rational{Int64}, Rational{Int64}, Rational{Int64}, Rational{Int64}, Rational{Int64}, Rational{Int64}, Rational{Int64}}, NonlinearSolveBase.Dogleg{NonlinearSolveBase.NewtonDescent{Nothing}, NonlinearSolveBase.SteepestDescent{Nothing}}, Nothing, Nothing, Nothing, Val{false}}}} where {DI<:AbstractVector{Int64}, AI<:AbstractVector{Int64}, _A, P<:ODEProblem, _B, _C, J1<:Union{Nothing, ModelingToolkit.PreparedJacobian{true, DifferentiationInterfaceForwardDiffExt.ForwardDiffTwoArgJacobianPrep{Nothing, C, Tuple{Nothing, Nothing}}, ModelingToolkit.var\"#uff#953\"{var\"#1488#fun\"}, _A, ADTypes.AutoForwardDiff{nothing, Nothing}} where {C<:(ForwardDiff.JacobianConfig{T, _A, _B, <:Tuple{Any, Any}} where {T<:(ForwardDiff.Tag{F} where F<:ModelingToolkit.var\"#uff#953\"), _A, _B}), var\"#1488#fun\", _A}}, J2<:Union{Nothing, ModelingToolkit.PreparedJacobian{true, DifferentiationInterfaceForwardDiffExt.ForwardDiffTwoArgJacobianPrep{Nothing, C, Tuple{Nothing, Nothing}}, _A, _B, ADTypes.AutoForwardDiff{nothing, Nothing}} where {C<:ForwardDiff.JacobianConfig, _A, _B}}, J3<:Union{Nothing, ModelingToolkit.PreparedJacobian{true, DifferentiationInterfaceForwardDiffExt.ForwardDiffTwoArgJacobianPrep{Nothing, C, Tuple{Nothing, Nothing, Nothing}}, ModelingToolkit.var\"#pff#954\"{var\"#1489#fun\", var\"#1490#setter\"}, _A, ADTypes.AutoForwardDiff{nothing, Nothing}} where {C<:(ForwardDiff.JacobianConfig{T, _A, _B, <:Tuple{Any, Any}} where {T<:(ForwardDiff.Tag{F} where F<:ModelingToolkit.var\"#pff#954\"), _A, _B}), var\"#1489#fun\", var\"#1490#setter\", _A}}, J4<:(ModelingToolkit.PreparedJacobian{true, DifferentiationInterfaceForwardDiffExt.ForwardDiffTwoArgJacobianPrep{Nothing, C, Tuple{Nothing, Nothing, Nothing}}, ModelingToolkit.var\"#hpf#952\"{fun, setter}, _A, ADTypes.AutoForwardDiff{nothing, Nothing}} where {C<:(ForwardDiff.JacobianConfig{T, _A, _B, <:Tuple{Any, Any}} where {T<:(ForwardDiff.Tag{F} where F<:ModelingToolkit.var\"#hpf#952\"), _A, _B}), fun, setter, _A}), IA<:Union{SciMLBase.NoInit, SciMLBase.OverrideInit{Nothing, Nothing, Nothing}}}, Any}\n\n\nReturn the sensitivity function for the analysis point(s) aps, and the modified system simplified with the appropriate inputs and outputs.\n\nKeyword Arguments\n\n- `loop_openings`: A list of analysis points whose connections should be removed and\n  the outputs set to the input as a part of the linear analysis.\n\n- `system_modifier`: A function taking the transformed system and applying any\n  additional transformations, returning the modified system. The modified system\n  is passed to `linearization_function`.\n\nAll other keyword arguments are forwarded to linearization_function.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/disturbance_modeling/#ModelingToolkit.linearization_ap_transform-Tuple{Any, Union{Vector{Symbol}, Vector{AnalysisPoint}, Symbol, AnalysisPoint}, Any, Any}-tutorials-disturbance_modeling","page":"Disturbance and input modeling modeling","title":"ModelingToolkit.linearization_ap_transform","text":"sys, input_vars, output_vars =\n\nlinearization_ap_transform(\n    sys,\n    inputs::Union{Vector{Symbol}, Vector{AnalysisPoint}, Symbol, AnalysisPoint},\n    outputs,\n    loop_openings\n) -> Tuple{Any, Vector{Any}, Vector{Any}}\n\n\nApply analysis-point transformations to prepare a system for linearization.\n\nReturns\n\nsys: The transformed system.\ninput_vars: A vector of input variables corresponding to the input analysis points.\noutput_vars: A vector of output variables corresponding to the output analysis points.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/disturbance_modeling/#ModelingToolkit.open_loop-Tuple{Any, Union{Symbol, AnalysisPoint}}-tutorials-disturbance_modeling","page":"Disturbance and input modeling modeling","title":"ModelingToolkit.open_loop","text":"open_loop(\n    sys,\n    ap::Union{Symbol, AnalysisPoint};\n    system_modifier\n) -> Tuple{Any, Tuple{Any, Any}}\n\n\nApply LoopTransferTransform to the analysis point ap and return the result of apply_transformation.\n\nKeyword Arguments\n\nsystem_modifier: a function which takes the modified system and returns a new system with any required further modifications performed.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/disturbance_modeling/#ModelingToolkit.AnalysisPoint-Tuple{Symbol}-tutorials-disturbance_modeling","page":"Disturbance and input modeling modeling","title":"ModelingToolkit.AnalysisPoint","text":"AnalysisPoint(name::Symbol) -> AnalysisPoint\n\n\nCreate an AnalysisPoint with the given name, with no input or outputs specified.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/disturbance_modeling/#ModelingToolkit.AnalysisPoint-tutorials-disturbance_modeling","page":"Disturbance and input modeling modeling","title":"ModelingToolkit.AnalysisPoint","text":"struct AnalysisPoint\n\nAnalysisPoint(input, name::Symbol, outputs::Vector)\n\nCreate an AnalysisPoint for linear analysis. Analysis points can be created by calling\n\nconnect(out, :ap_name, in...)\n\nWhere out is the output being connected to the inputs in.... All involved connectors (input and outputs) are required to either have an unknown named u or a single unknown, all of which should have the same size.\n\nSee also get_sensitivity, get_comp_sensitivity, get_looptransfer, open_loop\n\nFields\n\ninput::Any: The input to the connection. In the context of ModelingToolkitStandardLibrary.jl, this is a RealOutput connector.\n\nname::Symbol: The name of the analysis point.\n\noutputs::Union{Nothing, Vector{Any}}: The outputs of the connection. In the context of ModelingToolkitStandardLibrary.jl, these are all RealInput connectors.\n\nExample\n\nusing ModelingToolkit\nusing ModelingToolkitStandardLibrary.Blocks\nusing ModelingToolkit: t_nounits as t\n\n@named P = FirstOrder(k = 1, T = 1)\n@named C = Gain(; k = -1)\nt = ModelingToolkit.get_iv(P)\n\neqs = [connect(P.output, C.input)\n       connect(C.output, :plant_input, P.input)]\nsys = System(eqs, t, systems = [P, C], name = :feedback_system)\n\nmatrices_S, _ = get_sensitivity(sys, :plant_input) # Compute the matrices of a state-space representation of the (input) sensitivity function.\nmatrices_T, _ = get_comp_sensitivity(sys, :plant_input)\n\nContinued linear analysis and design can be performed using ControlSystemsBase.jl. Create ControlSystemsBase.StateSpace objects using\n\nusing ControlSystemsBase, Plots\nS = ss(matrices_S...)\nT = ss(matrices_T...)\nbodeplot([S, T], lab = [\"S\" \"T\"])\n\nThe sensitivity functions obtained this way should be equivalent to the ones obtained with the code below\n\nusing ControlSystemsBase\nP = tf(1.0, [1, 1])\nC = 1                      # Negative feedback assumed in ControlSystems\nS = sensitivity(P, C)      # or feedback(1, P*C)\nT = comp_sensitivity(P, C) # or feedback(P*C)\n\n\n\n\n\n","category":"type"},{"location":"tutorials/domain_connections/#domains","page":"Domains","title":"Domains","text":"","category":"section"},{"location":"tutorials/domain_connections/#Basics","page":"Domains","title":"Basics","text":"","category":"section"},{"location":"tutorials/domain_connections/","page":"Domains","title":"Domains","text":"A domain in ModelingToolkit.jl is a network of connected components that share properties of the medium in the network.  For example, a collection of hydraulic components connected together will have a fluid medium.  Using the domain feature, one only needs to define and set the fluid medium properties once, in one component, rather than at each component.  The way this works in ModelingToolkit.jl is by defining a connector (with Through/Flow and Across variables) with parameters defining the medium of the domain.  Then a second connector is defined, with the same parameters, and the same Through/Flow variable, which acts as the setter.  For example, a hydraulic domain may have a hydraulic connector, HydraulicPort, that defines a fluid medium with density (ρ), viscosity (μ), and a bulk modulus (β), a through/flow variable mass flow (dm) and an across variable pressure (p).","category":"page"},{"location":"tutorials/domain_connections/","page":"Domains","title":"Domains","text":"using ModelingToolkit\nusing ModelingToolkit: t_nounits as t, D_nounits as D\n\n@connector function HydraulicPort(; p_int, name)\n    pars = @parameters begin\n        ρ\n        β\n        μ\n    end\n\n    vars = @variables begin\n        p(t) = p_int\n        dm(t), [connect = Flow]\n    end\n\n    System(Equation[], t, vars, pars; name, defaults = [dm => 0])\nend\nnothing #hide","category":"page"},{"location":"tutorials/domain_connections/","page":"Domains","title":"Domains","text":"The fluid medium setter for HydralicPort may be defined as HydraulicFluid with the same parameters and through/flow variable.  But now, the parameters can be set through the function keywords.","category":"page"},{"location":"tutorials/domain_connections/","page":"Domains","title":"Domains","text":"@connector function HydraulicFluid(;\n        density = 997,\n        bulk_modulus = 2.09e9,\n        viscosity = 0.0010016,\n        name)\n    pars = @parameters begin\n        ρ = density\n        β = bulk_modulus\n        μ = viscosity\n    end\n\n    vars = @variables begin\n        dm(t), [connect = Flow]\n    end\n\n    eqs = [\n        dm ~ 0\n    ]\n\n    System(eqs, t, vars, pars; name, defaults = [dm => 0])\nend\nnothing #hide","category":"page"},{"location":"tutorials/domain_connections/","page":"Domains","title":"Domains","text":"Now, we can connect a HydraulicFluid component to any HydraulicPort connector, and the parameters of all HydraulicPort's in the network will be automatically set.  Let's consider a simple example, connecting a pressure source component to a volume component.  Note that we don't need to define density for the volume component, it's supplied by the HydraulicPort (port.ρ).","category":"page"},{"location":"tutorials/domain_connections/","page":"Domains","title":"Domains","text":"@component function FixedPressure(; p, name)\n    pars = @parameters p = p\n    systems = @named begin\n        port = HydraulicPort(; p_int = p)\n    end\n\n    eqs = [port.p ~ p]\n\n    System(eqs, t, [], pars; name, systems)\nend\n\n@component function FixedVolume(; vol, p_int, name)\n    pars = @parameters begin\n        p_int = p_int\n        vol = vol\n    end\n\n    systems = @named begin\n        port = HydraulicPort(; p_int)\n    end\n\n    vars = @variables begin\n        rho(t) = port.ρ\n        drho(t) = 0\n    end\n\n    # let\n    dm = port.dm\n    p = port.p\n\n    eqs = [D(rho) ~ drho\n           rho ~ port.ρ * (1 + p / port.β)\n           dm ~ drho * vol]\n\n    System(eqs, t, vars, pars; name, systems)\nend\nnothing #hide","category":"page"},{"location":"tutorials/domain_connections/","page":"Domains","title":"Domains","text":"When the system is defined we can generate a fluid component and connect it to the system.  Here fluid is connected to the src.port, but it could also be connected to vol.port, any connection in the network is fine.","category":"page"},{"location":"tutorials/domain_connections/","page":"Domains","title":"Domains","text":"@component function HydraulicSystem(; name)\n    systems = @named begin\n        src = FixedPressure(; p = 200e5)\n        vol = FixedVolume(; vol = 0.1, p_int = 200e5)\n\n        fluid = HydraulicFluid(; density = 876)\n    end\n\n    eqs = [connect(fluid, src.port)\n           connect(src.port, vol.port)]\n\n    System(eqs, t, [], []; systems, name)\nend\n\n@named odesys = HydraulicSystem()\nnothing #hide","category":"page"},{"location":"tutorials/domain_connections/","page":"Domains","title":"Domains","text":"To see how the domain works, we can examine the set parameter values for each of the ports src.port and vol.port.  First we assemble the system using mtkcompile() and then check the default value of vol.port.ρ, whichs points to the setter value fluid₊ρ.  Likewise, src.port.ρ, will also point to the setter value fluid₊ρ.  Therefore, there is now only 1 defined density value fluid₊ρ which sets the density for the connected network.","category":"page"},{"location":"tutorials/domain_connections/","page":"Domains","title":"Domains","text":"sys = mtkcompile(odesys)\nModelingToolkit.defaults(sys)[odesys.vol.port.ρ]","category":"page"},{"location":"tutorials/domain_connections/#Multiple-Domain-Networks","page":"Domains","title":"Multiple Domain Networks","text":"","category":"section"},{"location":"tutorials/domain_connections/","page":"Domains","title":"Domains","text":"If we have a more complicated system, for example a hydraulic actuator, with a separated fluid on both sides of the piston, it's possible we might have 2 separate domain networks.  In this case we can connect 2 separate fluids, or the same fluid, to both networks.  First a simple actuator is defined with 2 ports.","category":"page"},{"location":"tutorials/domain_connections/","page":"Domains","title":"Domains","text":"@component function Actuator(; p_int, mass, area, name)\n    pars = @parameters begin\n        p_int = p_int\n        mass = mass\n        area = area\n    end\n\n    systems = @named begin\n        port_a = HydraulicPort(; p_int)\n        port_b = HydraulicPort(; p_int)\n    end\n\n    vars = @variables begin\n        x(t) = 0\n        dx(t) = 0\n        ddx(t) = 0\n    end\n\n    eqs = [D(x) ~ dx\n           D(dx) ~ ddx\n           mass * ddx ~ (port_a.p - port_b.p) * area\n           port_a.dm ~ +(port_a.ρ) * dx * area\n           port_b.dm ~ -(port_b.ρ) * dx * area]\n\n    System(eqs, t, vars, pars; name, systems)\nend\nnothing #hide","category":"page"},{"location":"tutorials/domain_connections/","page":"Domains","title":"Domains","text":"A system with 2 different fluids is defined and connected to each separate domain network.","category":"page"},{"location":"tutorials/domain_connections/","page":"Domains","title":"Domains","text":"@component function ActuatorSystem2(; name)\n    systems = @named begin\n        src_a = FixedPressure(; p = 200e5)\n        src_b = FixedPressure(; p = 200e5)\n        act = Actuator(; p_int = 200e5, mass = 1000, area = 0.1)\n\n        fluid_a = HydraulicFluid(; density = 876)\n        fluid_b = HydraulicFluid(; density = 999)\n    end\n\n    eqs = [connect(fluid_a, src_a.port)\n           connect(fluid_b, src_b.port)\n           connect(src_a.port, act.port_a)\n           connect(src_b.port, act.port_b)]\n\n    System(eqs, t, [], []; systems, name)\nend\n\n@named actsys2 = ActuatorSystem2()\nnothing #hide","category":"page"},{"location":"tutorials/domain_connections/","page":"Domains","title":"Domains","text":"After running mtkcompile() on actsys2, the defaults will show that act.port_a.ρ points to fluid_a₊ρ and act.port_b.ρ points to fluid_b₊ρ.  This is a special case, in most cases a hydraulic system will have only 1 fluid, however this simple system has 2 separate domain networks.  Therefore, we can connect a single fluid to both networks.  This does not interfere with the mathematical equations of the system, since no unknown variables are connected.","category":"page"},{"location":"tutorials/domain_connections/","page":"Domains","title":"Domains","text":"@component function ActuatorSystem1(; name)\n    systems = @named begin\n        src_a = FixedPressure(; p = 200e5)\n        src_b = FixedPressure(; p = 200e5)\n        act = Actuator(; p_int = 200e5, mass = 1000, area = 0.1)\n\n        fluid = HydraulicFluid(; density = 876)\n    end\n\n    eqs = [connect(fluid, src_a.port)\n           connect(fluid, src_b.port)\n           connect(src_a.port, act.port_a)\n           connect(src_b.port, act.port_b)]\n\n    System(eqs, t, [], []; systems, name)\nend\n\n@named actsys1 = ActuatorSystem1()\nnothing #hide","category":"page"},{"location":"tutorials/domain_connections/#Special-Connection-Cases-(domain_connect())","page":"Domains","title":"Special Connection Cases (domain_connect())","text":"","category":"section"},{"location":"tutorials/domain_connections/","page":"Domains","title":"Domains","text":"In some cases a component will be defined with 2 connectors of the same domain, but they are not connected.  For example the Restrictor defined here gives equations to define the behavior of how the 2 connectors port_a and port_b are physically connected.","category":"page"},{"location":"tutorials/domain_connections/","page":"Domains","title":"Domains","text":"@component function Restrictor(; name, p_int)\n    pars = @parameters begin\n        K = 0.1\n        p_int = p_int\n    end\n\n    systems = @named begin\n        port_a = HydraulicPort(; p_int)\n        port_b = HydraulicPort(; p_int)\n    end\n\n    eqs = [port_a.dm ~ (port_a.p - port_b.p) * K\n           0 ~ port_a.dm + port_b.dm]\n\n    System(eqs, t, [], pars; systems, name)\nend\nnothing #hide","category":"page"},{"location":"tutorials/domain_connections/","page":"Domains","title":"Domains","text":"Adding the Restrictor to the original system example will cause a break in the domain network, since a connect(port_a, port_b) is not defined.","category":"page"},{"location":"tutorials/domain_connections/","page":"Domains","title":"Domains","text":"@component function RestrictorSystem(; name)\n    systems = @named begin\n        src = FixedPressure(; p = 200e5)\n        res = Restrictor(; p_int = 200e5)\n        vol = FixedVolume(; vol = 0.1, p_int = 200e5)\n\n        fluid = HydraulicFluid(; density = 876)\n    end\n\n    eqs = [connect(fluid, src.port)\n           connect(src.port, res.port_a)\n           connect(res.port_b, vol.port)]\n\n    System(eqs, t, [], []; systems, name)\nend\n\n@mtkcompile ressys = RestrictorSystem()\nnothing #hide","category":"page"},{"location":"tutorials/domain_connections/","page":"Domains","title":"Domains","text":"When mtkcompile() is applied to this system it can be seen that the defaults are missing for res.port_b and vol.port.","category":"page"},{"location":"tutorials/domain_connections/","page":"Domains","title":"Domains","text":"ModelingToolkit.defaults(ressys)[ressys.res.port_a.ρ]\nModelingToolkit.defaults(ressys)[ressys.res.port_b.ρ]\nModelingToolkit.defaults(ressys)[ressys.vol.port.ρ]","category":"page"},{"location":"tutorials/domain_connections/","page":"Domains","title":"Domains","text":"To ensure that the Restrictor component does not disrupt the domain network, the domain_connect() function can be used, which explicitly only connects the domain network and not the unknown variables.","category":"page"},{"location":"tutorials/domain_connections/","page":"Domains","title":"Domains","text":"@component function Restrictor(; name, p_int)\n    pars = @parameters begin\n        K = 0.1\n        p_int = p_int\n    end\n\n    systems = @named begin\n        port_a = HydraulicPort(; p_int)\n        port_b = HydraulicPort(; p_int)\n    end\n\n    eqs = [domain_connect(port_a, port_b) # <-- connect the domain network\n           port_a.dm ~ (port_a.p - port_b.p) * K\n           0 ~ port_a.dm + port_b.dm]\n\n    System(eqs, t, [], pars; systems, name)\nend\n\n@mtkcompile ressys = RestrictorSystem()\nnothing #hide","category":"page"},{"location":"tutorials/domain_connections/","page":"Domains","title":"Domains","text":"Now that the Restrictor component is properly defined using domain_connect(), the defaults for res.port_b and vol.port are properly defined.","category":"page"},{"location":"tutorials/domain_connections/","page":"Domains","title":"Domains","text":"ModelingToolkit.defaults(ressys)[ressys.res.port_a.ρ]\nModelingToolkit.defaults(ressys)[ressys.res.port_b.ρ]\nModelingToolkit.defaults(ressys)[ressys.vol.port.ρ]","category":"page"},{"location":"API/problems/#Building-and-solving-numerical-problems","page":"Building and solving numerical problems","title":"Building and solving numerical problems","text":"","category":"section"},{"location":"API/problems/","page":"Building and solving numerical problems","title":"Building and solving numerical problems","text":"Systems are numerically solved by building and solving the appropriate problem type. Numerical solvers expect to receive functions taking a predefeined set of arguments and returning specific values. This format of argument and return value depends on the function and the problem. ModelingToolkit is capable of compiling and generating code for a variety of such numerical problems.","category":"page"},{"location":"API/problems/#Dynamical-systems","page":"Building and solving numerical problems","title":"Dynamical systems","text":"","category":"section"},{"location":"API/problems/#SciMLBase.ODEFunction","page":"Building and solving numerical problems","title":"SciMLBase.ODEFunction","text":"SciMLBase.ODEFunction(sys::System; kwargs...)\nSciMLBase.ODEFunction{iip}(sys::System; kwargs...)\nSciMLBase.ODEFunction{iip, specialize}(sys::System; kwargs...)\n\nCreate a SciMLBase.ODEFunction from the given sys. iip is a boolean indicating whether the function should be in-place. specialization is a SciMLBase.AbstractSpecalize subtype indicating the level of specialization of the SciMLBase.ODEFunction.\n\nKeyword arguments\n\nu0: The u0 vector for the corresponding problem, if available. Can be obtained using ModelingToolkit.get_u0.\np: The parameter object for the corresponding problem, if available. Can be obtained using ModelingToolkit.get_p.\nt: The initial time for the corresponding problem, if available.\neval_expression: Whether to compile any functions via eval or RuntimeGeneratedFunctions.\neval_module: If eval_expression == true, the module to eval into. Otherwise, the module in which to generate the RuntimeGeneratedFunction.\ncheckbounds: Whether to enable bounds checking in the generated code.\nsimplify: Whether to simplify any symbolically computed jacobians/hessians/etc.\ncse: Whether to enable Common Subexpression Elimination (CSE) on the generated code. This typically improves performance of the generated code but reduces readability.\nsparse: Whether to generate jacobian/hessian/etc. functions that return/operate on sparse matrices. Also controls whether the mass matrix is sparse, wherever applicable.\ncheck_compatibility: Whether to check if the given system sys contains all the information necessary to create a SciMLBase.ODEFunction and no more. If disabled, assumes that sys at least contains the necessary information.\nexpression: Val{true} to return an Expr that constructs the corresponding problem instead of the problem itself. Val{false} otherwise.  Constructing the expression does not support callbacks\njac: Whether to symbolically compute and generate code for the jacobian function.\ntgrad: Whether to symbolically compute and generate code for the tgrad function.\nsparsity: Whether to provide symbolically compute and provide sparsity patterns for the jacobian/hessian/etc.\n\nAll other keyword arguments are forwarded to the SciMLBase.ODEFunction struct constructor.\n\n\n\n\n\n","category":"type"},{"location":"API/problems/#SciMLBase.ODEProblem","page":"Building and solving numerical problems","title":"SciMLBase.ODEProblem","text":"SciMLBase.SciMLBase.ODEProblem(sys::System, op, tspan::NTuple{2}; kwargs...)\nSciMLBase.SciMLBase.ODEProblem{iip}(sys::System, op, tspan::NTuple{2}; kwargs...)\nSciMLBase.SciMLBase.ODEProblem{iip, specialize}(sys::System, op, tspan::NTuple{2}; kwargs...)\n\nBuild a SciMLBase.ODEProblem given a system sys and operating point op  and timespan tspan. iip is a boolean indicating whether the problem should be in-place. specialization is a SciMLBase.AbstractSpecalize subtype indicating the level of specialization of the SciMLBase.ODEFunction. The operating point should be an iterable collection of key-value pairs mapping variables/parameters in the system to the (initial) values they should take in SciMLBase.ODEProblem. Any values not provided will fallback to the corresponding default (if present).\n\nModelingToolkit will build an initialization problem where all initial values for unknowns or observables of sys (either explicitly provided or in defaults) will be constraints. To remove an initial condition in the defaults (without providing a replacement) give the corresponding variable a value of nothing in the operating point. The initialization problem will also run parameter initialization. See the Initialization documentation for more information.\n\nKeyword arguments\n\neval_expression: Whether to compile any functions via eval or RuntimeGeneratedFunctions.\neval_module: If eval_expression == true, the module to eval into. Otherwise, the module in which to generate the RuntimeGeneratedFunction.\nguesses: The guesses for variables in the system, used as initial values for the initialization problem.\nwarn_initialize_determined: Warn if the initialization system is under/over-determined.\ninitialization_eqs: Extra equations to use in the initialization problem.\nfully_determined: Override whether the initialization system is fully determined.\nuse_scc: Whether to use SCCNonlinearProblem for initialization if the system is fully determined.\ncheck_initialization_units: Enable or disable unit checks when constructing the initialization problem.\ntofloat: Passed to varmap_to_vars when building the parameter vector of a non-split system.\nu0_eltype: The eltype of the u0 vector. If nothing, finds the promoted floating point type from op.\nu0_constructor: A function to apply to the u0 value returned from varmap_to_vars. to construct the final u0 value.\np_constructor: A function to apply to each array buffer created when constructing the parameter object.\nwarn_cyclic_dependency: Whether to emit a warning listing out cycles in initial conditions provided for unknowns and parameters.\ncircular_dependency_max_cycle_length: Maximum length of cycle to check for. Only applicable if warn_cyclic_dependency == true.\ncircular_dependency_max_cycles: Maximum number of cycles to check for. Only applicable if warn_cyclic_dependency == true.\nsubstitution_limit: The number times to substitute initial conditions into each other to attempt to arrive at a numeric value.\ncallback: An extra callback or CallbackSet to add to the problem, in addition to the ones defined symbolically in the system.\ncheck_compatibility: Whether to check if the given system sys contains all the information necessary to create a SciMLBase.ODEProblem and no more. If disabled, assumes that sys at least contains the necessary information.\nexpression: Val{true} to return an Expr that constructs the corresponding problem instead of the problem itself. Val{false} otherwise.  Constructing the expression does not support callbacks\n\nAll other keyword arguments are forwarded to the SciMLBase.ODEFunction constructor.\n\nExtended docs\n\nThe following API is internal and may change or be removed without notice. Its usage is highly discouraged.\n\nbuild_initializeprob: If false, avoids building the initialization problem.\ncheck_length: Whether to check the number of equations along with number of unknowns and length of u0 vector for consistency. If false, do not check with equations. This is forwarded to check_eqs_u0.\ntime_dependent_init: Whether to build a time-dependent initialization for the problem. A time-dependent initialization solves for a consistent u0, whereas a time-independent one only runs parameter initialization.\nalgebraic_only: Whether to build the initialization problem using only algebraic equations.\nallow_incomplete: Whether to allow incomplete initialization problems.\n\n\n\n\n\n","category":"type"},{"location":"API/problems/#SciMLBase.DAEFunction","page":"Building and solving numerical problems","title":"SciMLBase.DAEFunction","text":"SciMLBase.DAEFunction(sys::System; kwargs...)\nSciMLBase.DAEFunction{iip}(sys::System; kwargs...)\nSciMLBase.DAEFunction{iip, specialize}(sys::System; kwargs...)\n\nCreate a SciMLBase.DAEFunction from the given sys. iip is a boolean indicating whether the function should be in-place. specialization is a SciMLBase.AbstractSpecalize subtype indicating the level of specialization of the SciMLBase.DAEFunction.\n\nKeyword arguments\n\nu0: The u0 vector for the corresponding problem, if available. Can be obtained using ModelingToolkit.get_u0.\np: The parameter object for the corresponding problem, if available. Can be obtained using ModelingToolkit.get_p.\nt: The initial time for the corresponding problem, if available.\neval_expression: Whether to compile any functions via eval or RuntimeGeneratedFunctions.\neval_module: If eval_expression == true, the module to eval into. Otherwise, the module in which to generate the RuntimeGeneratedFunction.\ncheckbounds: Whether to enable bounds checking in the generated code.\nsimplify: Whether to simplify any symbolically computed jacobians/hessians/etc.\ncse: Whether to enable Common Subexpression Elimination (CSE) on the generated code. This typically improves performance of the generated code but reduces readability.\nsparse: Whether to generate jacobian/hessian/etc. functions that return/operate on sparse matrices. Also controls whether the mass matrix is sparse, wherever applicable.\ncheck_compatibility: Whether to check if the given system sys contains all the information necessary to create a SciMLBase.DAEFunction and no more. If disabled, assumes that sys at least contains the necessary information.\nexpression: Val{true} to return an Expr that constructs the corresponding problem instead of the problem itself. Val{false} otherwise.  Constructing the expression does not support callbacks\njac: Whether to symbolically compute and generate code for the jacobian function.\ntgrad: Whether to symbolically compute and generate code for the tgrad function.\nsparsity: Whether to provide symbolically compute and provide sparsity patterns for the jacobian/hessian/etc.\n\nAll other keyword arguments are forwarded to the SciMLBase.DAEFunction struct constructor.\n\n\n\n\n\n","category":"type"},{"location":"API/problems/#SciMLBase.DAEProblem","page":"Building and solving numerical problems","title":"SciMLBase.DAEProblem","text":"SciMLBase.SciMLBase.DAEProblem(sys::System, op, tspan::NTuple{2}; kwargs...)\nSciMLBase.SciMLBase.DAEProblem{iip}(sys::System, op, tspan::NTuple{2}; kwargs...)\nSciMLBase.SciMLBase.DAEProblem{iip, specialize}(sys::System, op, tspan::NTuple{2}; kwargs...)\n\nBuild a SciMLBase.DAEProblem given a system sys and operating point op  and timespan tspan. iip is a boolean indicating whether the problem should be in-place. specialization is a SciMLBase.AbstractSpecalize subtype indicating the level of specialization of the SciMLBase.DAEFunction. The operating point should be an iterable collection of key-value pairs mapping variables/parameters in the system to the (initial) values they should take in SciMLBase.DAEProblem. Any values not provided will fallback to the corresponding default (if present).\n\nModelingToolkit will build an initialization problem where all initial values for unknowns or observables of sys (either explicitly provided or in defaults) will be constraints. To remove an initial condition in the defaults (without providing a replacement) give the corresponding variable a value of nothing in the operating point. The initialization problem will also run parameter initialization. See the Initialization documentation for more information.\n\nKeyword arguments\n\neval_expression: Whether to compile any functions via eval or RuntimeGeneratedFunctions.\neval_module: If eval_expression == true, the module to eval into. Otherwise, the module in which to generate the RuntimeGeneratedFunction.\nguesses: The guesses for variables in the system, used as initial values for the initialization problem.\nwarn_initialize_determined: Warn if the initialization system is under/over-determined.\ninitialization_eqs: Extra equations to use in the initialization problem.\nfully_determined: Override whether the initialization system is fully determined.\nuse_scc: Whether to use SCCNonlinearProblem for initialization if the system is fully determined.\ncheck_initialization_units: Enable or disable unit checks when constructing the initialization problem.\ntofloat: Passed to varmap_to_vars when building the parameter vector of a non-split system.\nu0_eltype: The eltype of the u0 vector. If nothing, finds the promoted floating point type from op.\nu0_constructor: A function to apply to the u0 value returned from varmap_to_vars. to construct the final u0 value.\np_constructor: A function to apply to each array buffer created when constructing the parameter object.\nwarn_cyclic_dependency: Whether to emit a warning listing out cycles in initial conditions provided for unknowns and parameters.\ncircular_dependency_max_cycle_length: Maximum length of cycle to check for. Only applicable if warn_cyclic_dependency == true.\ncircular_dependency_max_cycles: Maximum number of cycles to check for. Only applicable if warn_cyclic_dependency == true.\nsubstitution_limit: The number times to substitute initial conditions into each other to attempt to arrive at a numeric value.\ncallback: An extra callback or CallbackSet to add to the problem, in addition to the ones defined symbolically in the system.\ncheck_compatibility: Whether to check if the given system sys contains all the information necessary to create a SciMLBase.DAEProblem and no more. If disabled, assumes that sys at least contains the necessary information.\nexpression: Val{true} to return an Expr that constructs the corresponding problem instead of the problem itself. Val{false} otherwise.  Constructing the expression does not support callbacks\n\nAll other keyword arguments are forwarded to the SciMLBase.DAEFunction constructor.\n\nExtended docs\n\nThe following API is internal and may change or be removed without notice. Its usage is highly discouraged.\n\nbuild_initializeprob: If false, avoids building the initialization problem.\ncheck_length: Whether to check the number of equations along with number of unknowns and length of u0 vector for consistency. If false, do not check with equations. This is forwarded to check_eqs_u0.\ntime_dependent_init: Whether to build a time-dependent initialization for the problem. A time-dependent initialization solves for a consistent u0, whereas a time-independent one only runs parameter initialization.\nalgebraic_only: Whether to build the initialization problem using only algebraic equations.\nallow_incomplete: Whether to allow incomplete initialization problems.\n\n\n\n\n\n","category":"type"},{"location":"API/problems/#SciMLBase.SDEFunction","page":"Building and solving numerical problems","title":"SciMLBase.SDEFunction","text":"SciMLBase.SDEFunction(sys::System; kwargs...)\nSciMLBase.SDEFunction{iip}(sys::System; kwargs...)\nSciMLBase.SDEFunction{iip, specialize}(sys::System; kwargs...)\n\nCreate a SciMLBase.SDEFunction from the given sys. iip is a boolean indicating whether the function should be in-place. specialization is a SciMLBase.AbstractSpecalize subtype indicating the level of specialization of the SciMLBase.SDEFunction.\n\nKeyword arguments\n\nu0: The u0 vector for the corresponding problem, if available. Can be obtained using ModelingToolkit.get_u0.\np: The parameter object for the corresponding problem, if available. Can be obtained using ModelingToolkit.get_p.\nt: The initial time for the corresponding problem, if available.\neval_expression: Whether to compile any functions via eval or RuntimeGeneratedFunctions.\neval_module: If eval_expression == true, the module to eval into. Otherwise, the module in which to generate the RuntimeGeneratedFunction.\ncheckbounds: Whether to enable bounds checking in the generated code.\nsimplify: Whether to simplify any symbolically computed jacobians/hessians/etc.\ncse: Whether to enable Common Subexpression Elimination (CSE) on the generated code. This typically improves performance of the generated code but reduces readability.\nsparse: Whether to generate jacobian/hessian/etc. functions that return/operate on sparse matrices. Also controls whether the mass matrix is sparse, wherever applicable.\ncheck_compatibility: Whether to check if the given system sys contains all the information necessary to create a SciMLBase.SDEFunction and no more. If disabled, assumes that sys at least contains the necessary information.\nexpression: Val{true} to return an Expr that constructs the corresponding problem instead of the problem itself. Val{false} otherwise.  Constructing the expression does not support callbacks\njac: Whether to symbolically compute and generate code for the jacobian function.\ntgrad: Whether to symbolically compute and generate code for the tgrad function.\nsparsity: Whether to provide symbolically compute and provide sparsity patterns for the jacobian/hessian/etc.\n\nAll other keyword arguments are forwarded to the SciMLBase.SDEFunction struct constructor.\n\n\n\n\n\n","category":"type"},{"location":"API/problems/#SciMLBase.SDEProblem","page":"Building and solving numerical problems","title":"SciMLBase.SDEProblem","text":"SciMLBase.SciMLBase.SDEProblem(sys::System, op, tspan::NTuple{2}; kwargs...)\nSciMLBase.SciMLBase.SDEProblem{iip}(sys::System, op, tspan::NTuple{2}; kwargs...)\nSciMLBase.SciMLBase.SDEProblem{iip, specialize}(sys::System, op, tspan::NTuple{2}; kwargs...)\n\nBuild a SciMLBase.SDEProblem given a system sys and operating point op  and timespan tspan. iip is a boolean indicating whether the problem should be in-place. specialization is a SciMLBase.AbstractSpecalize subtype indicating the level of specialization of the SciMLBase.SDEFunction. The operating point should be an iterable collection of key-value pairs mapping variables/parameters in the system to the (initial) values they should take in SciMLBase.SDEProblem. Any values not provided will fallback to the corresponding default (if present).\n\nModelingToolkit will build an initialization problem where all initial values for unknowns or observables of sys (either explicitly provided or in defaults) will be constraints. To remove an initial condition in the defaults (without providing a replacement) give the corresponding variable a value of nothing in the operating point. The initialization problem will also run parameter initialization. See the Initialization documentation for more information.\n\nKeyword arguments\n\neval_expression: Whether to compile any functions via eval or RuntimeGeneratedFunctions.\neval_module: If eval_expression == true, the module to eval into. Otherwise, the module in which to generate the RuntimeGeneratedFunction.\nguesses: The guesses for variables in the system, used as initial values for the initialization problem.\nwarn_initialize_determined: Warn if the initialization system is under/over-determined.\ninitialization_eqs: Extra equations to use in the initialization problem.\nfully_determined: Override whether the initialization system is fully determined.\nuse_scc: Whether to use SCCNonlinearProblem for initialization if the system is fully determined.\ncheck_initialization_units: Enable or disable unit checks when constructing the initialization problem.\ntofloat: Passed to varmap_to_vars when building the parameter vector of a non-split system.\nu0_eltype: The eltype of the u0 vector. If nothing, finds the promoted floating point type from op.\nu0_constructor: A function to apply to the u0 value returned from varmap_to_vars. to construct the final u0 value.\np_constructor: A function to apply to each array buffer created when constructing the parameter object.\nwarn_cyclic_dependency: Whether to emit a warning listing out cycles in initial conditions provided for unknowns and parameters.\ncircular_dependency_max_cycle_length: Maximum length of cycle to check for. Only applicable if warn_cyclic_dependency == true.\ncircular_dependency_max_cycles: Maximum number of cycles to check for. Only applicable if warn_cyclic_dependency == true.\nsubstitution_limit: The number times to substitute initial conditions into each other to attempt to arrive at a numeric value.\ncallback: An extra callback or CallbackSet to add to the problem, in addition to the ones defined symbolically in the system.\ncheck_compatibility: Whether to check if the given system sys contains all the information necessary to create a SciMLBase.SDEProblem and no more. If disabled, assumes that sys at least contains the necessary information.\nexpression: Val{true} to return an Expr that constructs the corresponding problem instead of the problem itself. Val{false} otherwise.  Constructing the expression does not support callbacks\n\nAll other keyword arguments are forwarded to the SciMLBase.SDEFunction constructor.\n\nExtended docs\n\nThe following API is internal and may change or be removed without notice. Its usage is highly discouraged.\n\nbuild_initializeprob: If false, avoids building the initialization problem.\ncheck_length: Whether to check the number of equations along with number of unknowns and length of u0 vector for consistency. If false, do not check with equations. This is forwarded to check_eqs_u0.\ntime_dependent_init: Whether to build a time-dependent initialization for the problem. A time-dependent initialization solves for a consistent u0, whereas a time-independent one only runs parameter initialization.\nalgebraic_only: Whether to build the initialization problem using only algebraic equations.\nallow_incomplete: Whether to allow incomplete initialization problems.\n\n\n\n\n\n","category":"type"},{"location":"API/problems/#SciMLBase.DDEFunction","page":"Building and solving numerical problems","title":"SciMLBase.DDEFunction","text":"SciMLBase.DDEFunction(sys::System; kwargs...)\nSciMLBase.DDEFunction{iip}(sys::System; kwargs...)\nSciMLBase.DDEFunction{iip, specialize}(sys::System; kwargs...)\n\nCreate a SciMLBase.DDEFunction from the given sys. iip is a boolean indicating whether the function should be in-place. specialization is a SciMLBase.AbstractSpecalize subtype indicating the level of specialization of the SciMLBase.DDEFunction.\n\nKeyword arguments\n\nu0: The u0 vector for the corresponding problem, if available. Can be obtained using ModelingToolkit.get_u0.\np: The parameter object for the corresponding problem, if available. Can be obtained using ModelingToolkit.get_p.\nt: The initial time for the corresponding problem, if available.\neval_expression: Whether to compile any functions via eval or RuntimeGeneratedFunctions.\neval_module: If eval_expression == true, the module to eval into. Otherwise, the module in which to generate the RuntimeGeneratedFunction.\ncheckbounds: Whether to enable bounds checking in the generated code.\nsimplify: Whether to simplify any symbolically computed jacobians/hessians/etc.\ncse: Whether to enable Common Subexpression Elimination (CSE) on the generated code. This typically improves performance of the generated code but reduces readability.\nsparse: Whether to generate jacobian/hessian/etc. functions that return/operate on sparse matrices. Also controls whether the mass matrix is sparse, wherever applicable.\ncheck_compatibility: Whether to check if the given system sys contains all the information necessary to create a SciMLBase.DDEFunction and no more. If disabled, assumes that sys at least contains the necessary information.\nexpression: Val{true} to return an Expr that constructs the corresponding problem instead of the problem itself. Val{false} otherwise.  Constructing the expression does not support callbacks\n\nAll other keyword arguments are forwarded to the SciMLBase.DDEFunction struct constructor.\n\n\n\n\n\n","category":"type"},{"location":"API/problems/#SciMLBase.DDEProblem","page":"Building and solving numerical problems","title":"SciMLBase.DDEProblem","text":"SciMLBase.SciMLBase.DDEProblem(sys::System, op, tspan::NTuple{2}; kwargs...)\nSciMLBase.SciMLBase.DDEProblem{iip}(sys::System, op, tspan::NTuple{2}; kwargs...)\nSciMLBase.SciMLBase.DDEProblem{iip, specialize}(sys::System, op, tspan::NTuple{2}; kwargs...)\n\nBuild a SciMLBase.DDEProblem given a system sys and operating point op  and timespan tspan. iip is a boolean indicating whether the problem should be in-place. specialization is a SciMLBase.AbstractSpecalize subtype indicating the level of specialization of the SciMLBase.DDEFunction. The operating point should be an iterable collection of key-value pairs mapping variables/parameters in the system to the (initial) values they should take in SciMLBase.DDEProblem. Any values not provided will fallback to the corresponding default (if present).\n\nModelingToolkit will build an initialization problem where all initial values for unknowns or observables of sys (either explicitly provided or in defaults) will be constraints. To remove an initial condition in the defaults (without providing a replacement) give the corresponding variable a value of nothing in the operating point. The initialization problem will also run parameter initialization. See the Initialization documentation for more information.\n\nKeyword arguments\n\neval_expression: Whether to compile any functions via eval or RuntimeGeneratedFunctions.\neval_module: If eval_expression == true, the module to eval into. Otherwise, the module in which to generate the RuntimeGeneratedFunction.\nguesses: The guesses for variables in the system, used as initial values for the initialization problem.\nwarn_initialize_determined: Warn if the initialization system is under/over-determined.\ninitialization_eqs: Extra equations to use in the initialization problem.\nfully_determined: Override whether the initialization system is fully determined.\nuse_scc: Whether to use SCCNonlinearProblem for initialization if the system is fully determined.\ncheck_initialization_units: Enable or disable unit checks when constructing the initialization problem.\ntofloat: Passed to varmap_to_vars when building the parameter vector of a non-split system.\nu0_eltype: The eltype of the u0 vector. If nothing, finds the promoted floating point type from op.\nu0_constructor: A function to apply to the u0 value returned from varmap_to_vars. to construct the final u0 value.\np_constructor: A function to apply to each array buffer created when constructing the parameter object.\nwarn_cyclic_dependency: Whether to emit a warning listing out cycles in initial conditions provided for unknowns and parameters.\ncircular_dependency_max_cycle_length: Maximum length of cycle to check for. Only applicable if warn_cyclic_dependency == true.\ncircular_dependency_max_cycles: Maximum number of cycles to check for. Only applicable if warn_cyclic_dependency == true.\nsubstitution_limit: The number times to substitute initial conditions into each other to attempt to arrive at a numeric value.\ncallback: An extra callback or CallbackSet to add to the problem, in addition to the ones defined symbolically in the system.\ncheck_compatibility: Whether to check if the given system sys contains all the information necessary to create a SciMLBase.DDEProblem and no more. If disabled, assumes that sys at least contains the necessary information.\nexpression: Val{true} to return an Expr that constructs the corresponding problem instead of the problem itself. Val{false} otherwise.  Constructing the expression does not support callbacks\n\nAll other keyword arguments are forwarded to the SciMLBase.DDEFunction constructor.\n\nExtended docs\n\nThe following API is internal and may change or be removed without notice. Its usage is highly discouraged.\n\nbuild_initializeprob: If false, avoids building the initialization problem.\ncheck_length: Whether to check the number of equations along with number of unknowns and length of u0 vector for consistency. If false, do not check with equations. This is forwarded to check_eqs_u0.\ntime_dependent_init: Whether to build a time-dependent initialization for the problem. A time-dependent initialization solves for a consistent u0, whereas a time-independent one only runs parameter initialization.\nalgebraic_only: Whether to build the initialization problem using only algebraic equations.\nallow_incomplete: Whether to allow incomplete initialization problems.\n\n\n\n\n\n","category":"type"},{"location":"API/problems/#SciMLBase.SDDEFunction","page":"Building and solving numerical problems","title":"SciMLBase.SDDEFunction","text":"SciMLBase.SDDEFunction(sys::System; kwargs...)\nSciMLBase.SDDEFunction{iip}(sys::System; kwargs...)\nSciMLBase.SDDEFunction{iip, specialize}(sys::System; kwargs...)\n\nCreate a SciMLBase.SDDEFunction from the given sys. iip is a boolean indicating whether the function should be in-place. specialization is a SciMLBase.AbstractSpecalize subtype indicating the level of specialization of the SciMLBase.SDDEFunction.\n\nKeyword arguments\n\nu0: The u0 vector for the corresponding problem, if available. Can be obtained using ModelingToolkit.get_u0.\np: The parameter object for the corresponding problem, if available. Can be obtained using ModelingToolkit.get_p.\nt: The initial time for the corresponding problem, if available.\neval_expression: Whether to compile any functions via eval or RuntimeGeneratedFunctions.\neval_module: If eval_expression == true, the module to eval into. Otherwise, the module in which to generate the RuntimeGeneratedFunction.\ncheckbounds: Whether to enable bounds checking in the generated code.\nsimplify: Whether to simplify any symbolically computed jacobians/hessians/etc.\ncse: Whether to enable Common Subexpression Elimination (CSE) on the generated code. This typically improves performance of the generated code but reduces readability.\nsparse: Whether to generate jacobian/hessian/etc. functions that return/operate on sparse matrices. Also controls whether the mass matrix is sparse, wherever applicable.\ncheck_compatibility: Whether to check if the given system sys contains all the information necessary to create a SciMLBase.SDDEFunction and no more. If disabled, assumes that sys at least contains the necessary information.\nexpression: Val{true} to return an Expr that constructs the corresponding problem instead of the problem itself. Val{false} otherwise.  Constructing the expression does not support callbacks\n\nAll other keyword arguments are forwarded to the SciMLBase.SDDEFunction struct constructor.\n\n\n\n\n\n","category":"type"},{"location":"API/problems/#SciMLBase.SDDEProblem","page":"Building and solving numerical problems","title":"SciMLBase.SDDEProblem","text":"SciMLBase.SciMLBase.SDDEProblem(sys::System, op, tspan::NTuple{2}; kwargs...)\nSciMLBase.SciMLBase.SDDEProblem{iip}(sys::System, op, tspan::NTuple{2}; kwargs...)\nSciMLBase.SciMLBase.SDDEProblem{iip, specialize}(sys::System, op, tspan::NTuple{2}; kwargs...)\n\nBuild a SciMLBase.SDDEProblem given a system sys and operating point op  and timespan tspan. iip is a boolean indicating whether the problem should be in-place. specialization is a SciMLBase.AbstractSpecalize subtype indicating the level of specialization of the SciMLBase.SDDEFunction. The operating point should be an iterable collection of key-value pairs mapping variables/parameters in the system to the (initial) values they should take in SciMLBase.SDDEProblem. Any values not provided will fallback to the corresponding default (if present).\n\nModelingToolkit will build an initialization problem where all initial values for unknowns or observables of sys (either explicitly provided or in defaults) will be constraints. To remove an initial condition in the defaults (without providing a replacement) give the corresponding variable a value of nothing in the operating point. The initialization problem will also run parameter initialization. See the Initialization documentation for more information.\n\nKeyword arguments\n\neval_expression: Whether to compile any functions via eval or RuntimeGeneratedFunctions.\neval_module: If eval_expression == true, the module to eval into. Otherwise, the module in which to generate the RuntimeGeneratedFunction.\nguesses: The guesses for variables in the system, used as initial values for the initialization problem.\nwarn_initialize_determined: Warn if the initialization system is under/over-determined.\ninitialization_eqs: Extra equations to use in the initialization problem.\nfully_determined: Override whether the initialization system is fully determined.\nuse_scc: Whether to use SCCNonlinearProblem for initialization if the system is fully determined.\ncheck_initialization_units: Enable or disable unit checks when constructing the initialization problem.\ntofloat: Passed to varmap_to_vars when building the parameter vector of a non-split system.\nu0_eltype: The eltype of the u0 vector. If nothing, finds the promoted floating point type from op.\nu0_constructor: A function to apply to the u0 value returned from varmap_to_vars. to construct the final u0 value.\np_constructor: A function to apply to each array buffer created when constructing the parameter object.\nwarn_cyclic_dependency: Whether to emit a warning listing out cycles in initial conditions provided for unknowns and parameters.\ncircular_dependency_max_cycle_length: Maximum length of cycle to check for. Only applicable if warn_cyclic_dependency == true.\ncircular_dependency_max_cycles: Maximum number of cycles to check for. Only applicable if warn_cyclic_dependency == true.\nsubstitution_limit: The number times to substitute initial conditions into each other to attempt to arrive at a numeric value.\ncallback: An extra callback or CallbackSet to add to the problem, in addition to the ones defined symbolically in the system.\ncheck_compatibility: Whether to check if the given system sys contains all the information necessary to create a SciMLBase.SDDEProblem and no more. If disabled, assumes that sys at least contains the necessary information.\nexpression: Val{true} to return an Expr that constructs the corresponding problem instead of the problem itself. Val{false} otherwise.  Constructing the expression does not support callbacks\n\nAll other keyword arguments are forwarded to the SciMLBase.SDDEFunction constructor.\n\nExtended docs\n\nThe following API is internal and may change or be removed without notice. Its usage is highly discouraged.\n\nbuild_initializeprob: If false, avoids building the initialization problem.\ncheck_length: Whether to check the number of equations along with number of unknowns and length of u0 vector for consistency. If false, do not check with equations. This is forwarded to check_eqs_u0.\ntime_dependent_init: Whether to build a time-dependent initialization for the problem. A time-dependent initialization solves for a consistent u0, whereas a time-independent one only runs parameter initialization.\nalgebraic_only: Whether to build the initialization problem using only algebraic equations.\nallow_incomplete: Whether to allow incomplete initialization problems.\n\n\n\n\n\n","category":"type"},{"location":"API/problems/#JumpProcesses.JumpProblem","page":"Building and solving numerical problems","title":"JumpProcesses.JumpProblem","text":"SciMLBase.JumpProcesses.JumpProblem(sys::System, op, tspan::NTuple{2}; kwargs...)\nSciMLBase.JumpProcesses.JumpProblem{iip}(sys::System, op, tspan::NTuple{2}; kwargs...)\nSciMLBase.JumpProcesses.JumpProblem{iip, specialize}(sys::System, op, tspan::NTuple{2}; kwargs...)\n\nBuild a JumpProcesses.JumpProblem given a system sys and operating point op  and timespan tspan. iip is a boolean indicating whether the problem should be in-place. specialization is a SciMLBase.AbstractSpecalize subtype indicating the level of specialization of the inner SciMLFunction. The operating point should be an iterable collection of key-value pairs mapping variables/parameters in the system to the (initial) values they should take in JumpProcesses.JumpProblem. Any values not provided will fallback to the corresponding default (if present).\n\nModelingToolkit will build an initialization problem where all initial values for unknowns or observables of sys (either explicitly provided or in defaults) will be constraints. To remove an initial condition in the defaults (without providing a replacement) give the corresponding variable a value of nothing in the operating point. The initialization problem will also run parameter initialization. See the Initialization documentation for more information.\n\nKeyword arguments\n\neval_expression: Whether to compile any functions via eval or RuntimeGeneratedFunctions.\neval_module: If eval_expression == true, the module to eval into. Otherwise, the module in which to generate the RuntimeGeneratedFunction.\nguesses: The guesses for variables in the system, used as initial values for the initialization problem.\nwarn_initialize_determined: Warn if the initialization system is under/over-determined.\ninitialization_eqs: Extra equations to use in the initialization problem.\nfully_determined: Override whether the initialization system is fully determined.\nuse_scc: Whether to use SCCNonlinearProblem for initialization if the system is fully determined.\ncheck_initialization_units: Enable or disable unit checks when constructing the initialization problem.\ntofloat: Passed to varmap_to_vars when building the parameter vector of a non-split system.\nu0_eltype: The eltype of the u0 vector. If nothing, finds the promoted floating point type from op.\nu0_constructor: A function to apply to the u0 value returned from varmap_to_vars. to construct the final u0 value.\np_constructor: A function to apply to each array buffer created when constructing the parameter object.\nwarn_cyclic_dependency: Whether to emit a warning listing out cycles in initial conditions provided for unknowns and parameters.\ncircular_dependency_max_cycle_length: Maximum length of cycle to check for. Only applicable if warn_cyclic_dependency == true.\ncircular_dependency_max_cycles: Maximum number of cycles to check for. Only applicable if warn_cyclic_dependency == true.\nsubstitution_limit: The number times to substitute initial conditions into each other to attempt to arrive at a numeric value.\ncallback: An extra callback or CallbackSet to add to the problem, in addition to the ones defined symbolically in the system.\ncheck_compatibility: Whether to check if the given system sys contains all the information necessary to create a JumpProcesses.JumpProblem and no more. If disabled, assumes that sys at least contains the necessary information.\nexpression: Val{true} to return an Expr that constructs the corresponding problem instead of the problem itself. Val{false} otherwise.  Constructing the expression does not support callbacks\n\nAll other keyword arguments are forwarded to the inner SciMLFunction constructor.\n\nExtended docs\n\nThe following API is internal and may change or be removed without notice. Its usage is highly discouraged.\n\nbuild_initializeprob: If false, avoids building the initialization problem.\ncheck_length: Whether to check the number of equations along with number of unknowns and length of u0 vector for consistency. If false, do not check with equations. This is forwarded to check_eqs_u0.\ntime_dependent_init: Whether to build a time-dependent initialization for the problem. A time-dependent initialization solves for a consistent u0, whereas a time-independent one only runs parameter initialization.\nalgebraic_only: Whether to build the initialization problem using only algebraic equations.\nallow_incomplete: Whether to allow incomplete initialization problems.\n\n\n\n\n\n","category":"type"},{"location":"API/problems/#SciMLBase.BVProblem","page":"Building and solving numerical problems","title":"SciMLBase.BVProblem","text":"SciMLBase.SciMLBase.BVProblem(sys::System, op, tspan::NTuple{2}; kwargs...)\nSciMLBase.SciMLBase.BVProblem{iip}(sys::System, op, tspan::NTuple{2}; kwargs...)\nSciMLBase.SciMLBase.BVProblem{iip, specialize}(sys::System, op, tspan::NTuple{2}; kwargs...)\n\nBuild a SciMLBase.BVProblem given a system sys and operating point op  and timespan tspan. iip is a boolean indicating whether the problem should be in-place. specialization is a SciMLBase.AbstractSpecalize subtype indicating the level of specialization of the SciMLBase.ODEFunction. The operating point should be an iterable collection of key-value pairs mapping variables/parameters in the system to the (initial) values they should take in SciMLBase.BVProblem. Any values not provided will fallback to the corresponding default (if present).\n\nModelingToolkit will build an initialization problem where all initial values for unknowns or observables of sys (either explicitly provided or in defaults) will be constraints. To remove an initial condition in the defaults (without providing a replacement) give the corresponding variable a value of nothing in the operating point. The initialization problem will also run parameter initialization. See the Initialization documentation for more information.\n\nKeyword arguments\n\neval_expression: Whether to compile any functions via eval or RuntimeGeneratedFunctions.\neval_module: If eval_expression == true, the module to eval into. Otherwise, the module in which to generate the RuntimeGeneratedFunction.\nguesses: The guesses for variables in the system, used as initial values for the initialization problem.\nwarn_initialize_determined: Warn if the initialization system is under/over-determined.\ninitialization_eqs: Extra equations to use in the initialization problem.\nfully_determined: Override whether the initialization system is fully determined.\nuse_scc: Whether to use SCCNonlinearProblem for initialization if the system is fully determined.\ncheck_initialization_units: Enable or disable unit checks when constructing the initialization problem.\ntofloat: Passed to varmap_to_vars when building the parameter vector of a non-split system.\nu0_eltype: The eltype of the u0 vector. If nothing, finds the promoted floating point type from op.\nu0_constructor: A function to apply to the u0 value returned from varmap_to_vars. to construct the final u0 value.\np_constructor: A function to apply to each array buffer created when constructing the parameter object.\nwarn_cyclic_dependency: Whether to emit a warning listing out cycles in initial conditions provided for unknowns and parameters.\ncircular_dependency_max_cycle_length: Maximum length of cycle to check for. Only applicable if warn_cyclic_dependency == true.\ncircular_dependency_max_cycles: Maximum number of cycles to check for. Only applicable if warn_cyclic_dependency == true.\nsubstitution_limit: The number times to substitute initial conditions into each other to attempt to arrive at a numeric value.\ncallback: An extra callback or CallbackSet to add to the problem, in addition to the ones defined symbolically in the system.\ncheck_compatibility: Whether to check if the given system sys contains all the information necessary to create a SciMLBase.BVProblem and no more. If disabled, assumes that sys at least contains the necessary information.\nexpression: Val{true} to return an Expr that constructs the corresponding problem instead of the problem itself. Val{false} otherwise.  Constructing the expression does not support callbacks\n\nAll other keyword arguments are forwarded to the SciMLBase.ODEFunction constructor.\n\nExtended docs\n\nThe following API is internal and may change or be removed without notice. Its usage is highly discouraged.\n\nbuild_initializeprob: If false, avoids building the initialization problem.\ncheck_length: Whether to check the number of equations along with number of unknowns and length of u0 vector for consistency. If false, do not check with equations. This is forwarded to check_eqs_u0.\ntime_dependent_init: Whether to build a time-dependent initialization for the problem. A time-dependent initialization solves for a consistent u0, whereas a time-independent one only runs parameter initialization.\nalgebraic_only: Whether to build the initialization problem using only algebraic equations.\nallow_incomplete: Whether to allow incomplete initialization problems.\n\n\n\n\n\n","category":"type"},{"location":"API/problems/#SciMLBase.DiscreteProblem","page":"Building and solving numerical problems","title":"SciMLBase.DiscreteProblem","text":"SciMLBase.SciMLBase.DiscreteProblem(sys::System, op, tspan::NTuple{2}; kwargs...)\nSciMLBase.SciMLBase.DiscreteProblem{iip}(sys::System, op, tspan::NTuple{2}; kwargs...)\nSciMLBase.SciMLBase.DiscreteProblem{iip, specialize}(sys::System, op, tspan::NTuple{2}; kwargs...)\n\nBuild a SciMLBase.DiscreteProblem given a system sys and operating point op  and timespan tspan. iip is a boolean indicating whether the problem should be in-place. specialization is a SciMLBase.AbstractSpecalize subtype indicating the level of specialization of the SciMLBase.DiscreteFunction. The operating point should be an iterable collection of key-value pairs mapping variables/parameters in the system to the (initial) values they should take in SciMLBase.DiscreteProblem. Any values not provided will fallback to the corresponding default (if present).\n\nModelingToolkit will build an initialization problem where all initial values for unknowns or observables of sys (either explicitly provided or in defaults) will be constraints. To remove an initial condition in the defaults (without providing a replacement) give the corresponding variable a value of nothing in the operating point. The initialization problem will also run parameter initialization. See the Initialization documentation for more information.\n\nKeyword arguments\n\neval_expression: Whether to compile any functions via eval or RuntimeGeneratedFunctions.\neval_module: If eval_expression == true, the module to eval into. Otherwise, the module in which to generate the RuntimeGeneratedFunction.\nguesses: The guesses for variables in the system, used as initial values for the initialization problem.\nwarn_initialize_determined: Warn if the initialization system is under/over-determined.\ninitialization_eqs: Extra equations to use in the initialization problem.\nfully_determined: Override whether the initialization system is fully determined.\nuse_scc: Whether to use SCCNonlinearProblem for initialization if the system is fully determined.\ncheck_initialization_units: Enable or disable unit checks when constructing the initialization problem.\ntofloat: Passed to varmap_to_vars when building the parameter vector of a non-split system.\nu0_eltype: The eltype of the u0 vector. If nothing, finds the promoted floating point type from op.\nu0_constructor: A function to apply to the u0 value returned from varmap_to_vars. to construct the final u0 value.\np_constructor: A function to apply to each array buffer created when constructing the parameter object.\nwarn_cyclic_dependency: Whether to emit a warning listing out cycles in initial conditions provided for unknowns and parameters.\ncircular_dependency_max_cycle_length: Maximum length of cycle to check for. Only applicable if warn_cyclic_dependency == true.\ncircular_dependency_max_cycles: Maximum number of cycles to check for. Only applicable if warn_cyclic_dependency == true.\nsubstitution_limit: The number times to substitute initial conditions into each other to attempt to arrive at a numeric value.\ncallback: An extra callback or CallbackSet to add to the problem, in addition to the ones defined symbolically in the system.\ncheck_compatibility: Whether to check if the given system sys contains all the information necessary to create a SciMLBase.DiscreteProblem and no more. If disabled, assumes that sys at least contains the necessary information.\nexpression: Val{true} to return an Expr that constructs the corresponding problem instead of the problem itself. Val{false} otherwise.  Constructing the expression does not support callbacks\n\nAll other keyword arguments are forwarded to the SciMLBase.DiscreteFunction constructor.\n\nExtended docs\n\nThe following API is internal and may change or be removed without notice. Its usage is highly discouraged.\n\nbuild_initializeprob: If false, avoids building the initialization problem.\ncheck_length: Whether to check the number of equations along with number of unknowns and length of u0 vector for consistency. If false, do not check with equations. This is forwarded to check_eqs_u0.\ntime_dependent_init: Whether to build a time-dependent initialization for the problem. A time-dependent initialization solves for a consistent u0, whereas a time-independent one only runs parameter initialization.\nalgebraic_only: Whether to build the initialization problem using only algebraic equations.\nallow_incomplete: Whether to allow incomplete initialization problems.\n\n\n\n\n\n","category":"type"},{"location":"API/problems/#SciMLBase.ImplicitDiscreteProblem","page":"Building and solving numerical problems","title":"SciMLBase.ImplicitDiscreteProblem","text":"SciMLBase.SciMLBase.ImplicitDiscreteProblem(sys::System, op, tspan::NTuple{2}; kwargs...)\nSciMLBase.SciMLBase.ImplicitDiscreteProblem{iip}(sys::System, op, tspan::NTuple{2}; kwargs...)\nSciMLBase.SciMLBase.ImplicitDiscreteProblem{iip, specialize}(sys::System, op, tspan::NTuple{2}; kwargs...)\n\nBuild a SciMLBase.ImplicitDiscreteProblem given a system sys and operating point op  and timespan tspan. iip is a boolean indicating whether the problem should be in-place. specialization is a SciMLBase.AbstractSpecalize subtype indicating the level of specialization of the SciMLBase.ImplicitDiscreteFunction. The operating point should be an iterable collection of key-value pairs mapping variables/parameters in the system to the (initial) values they should take in SciMLBase.ImplicitDiscreteProblem. Any values not provided will fallback to the corresponding default (if present).\n\nModelingToolkit will build an initialization problem where all initial values for unknowns or observables of sys (either explicitly provided or in defaults) will be constraints. To remove an initial condition in the defaults (without providing a replacement) give the corresponding variable a value of nothing in the operating point. The initialization problem will also run parameter initialization. See the Initialization documentation for more information.\n\nKeyword arguments\n\neval_expression: Whether to compile any functions via eval or RuntimeGeneratedFunctions.\neval_module: If eval_expression == true, the module to eval into. Otherwise, the module in which to generate the RuntimeGeneratedFunction.\nguesses: The guesses for variables in the system, used as initial values for the initialization problem.\nwarn_initialize_determined: Warn if the initialization system is under/over-determined.\ninitialization_eqs: Extra equations to use in the initialization problem.\nfully_determined: Override whether the initialization system is fully determined.\nuse_scc: Whether to use SCCNonlinearProblem for initialization if the system is fully determined.\ncheck_initialization_units: Enable or disable unit checks when constructing the initialization problem.\ntofloat: Passed to varmap_to_vars when building the parameter vector of a non-split system.\nu0_eltype: The eltype of the u0 vector. If nothing, finds the promoted floating point type from op.\nu0_constructor: A function to apply to the u0 value returned from varmap_to_vars. to construct the final u0 value.\np_constructor: A function to apply to each array buffer created when constructing the parameter object.\nwarn_cyclic_dependency: Whether to emit a warning listing out cycles in initial conditions provided for unknowns and parameters.\ncircular_dependency_max_cycle_length: Maximum length of cycle to check for. Only applicable if warn_cyclic_dependency == true.\ncircular_dependency_max_cycles: Maximum number of cycles to check for. Only applicable if warn_cyclic_dependency == true.\nsubstitution_limit: The number times to substitute initial conditions into each other to attempt to arrive at a numeric value.\ncallback: An extra callback or CallbackSet to add to the problem, in addition to the ones defined symbolically in the system.\ncheck_compatibility: Whether to check if the given system sys contains all the information necessary to create a SciMLBase.ImplicitDiscreteProblem and no more. If disabled, assumes that sys at least contains the necessary information.\nexpression: Val{true} to return an Expr that constructs the corresponding problem instead of the problem itself. Val{false} otherwise.  Constructing the expression does not support callbacks\n\nAll other keyword arguments are forwarded to the SciMLBase.ImplicitDiscreteFunction constructor.\n\nExtended docs\n\nThe following API is internal and may change or be removed without notice. Its usage is highly discouraged.\n\nbuild_initializeprob: If false, avoids building the initialization problem.\ncheck_length: Whether to check the number of equations along with number of unknowns and length of u0 vector for consistency. If false, do not check with equations. This is forwarded to check_eqs_u0.\ntime_dependent_init: Whether to build a time-dependent initialization for the problem. A time-dependent initialization solves for a consistent u0, whereas a time-independent one only runs parameter initialization.\nalgebraic_only: Whether to build the initialization problem using only algebraic equations.\nallow_incomplete: Whether to allow incomplete initialization problems.\n\n\n\n\n\n","category":"type"},{"location":"API/problems/#Linear-and-Nonlinear-systems","page":"Building and solving numerical problems","title":"Linear and Nonlinear systems","text":"","category":"section"},{"location":"API/problems/#SciMLBase.NonlinearFunction","page":"Building and solving numerical problems","title":"SciMLBase.NonlinearFunction","text":"SciMLBase.NonlinearFunction(sys::System; kwargs...)\nSciMLBase.NonlinearFunction{iip}(sys::System; kwargs...)\nSciMLBase.NonlinearFunction{iip, specialize}(sys::System; kwargs...)\n\nCreate a SciMLBase.NonlinearFunction from the given sys. iip is a boolean indicating whether the function should be in-place. specialization is a SciMLBase.AbstractSpecalize subtype indicating the level of specialization of the SciMLBase.NonlinearFunction.\n\nKeyword arguments\n\nu0: The u0 vector for the corresponding problem, if available. Can be obtained using ModelingToolkit.get_u0.\np: The parameter object for the corresponding problem, if available. Can be obtained using ModelingToolkit.get_p.\neval_expression: Whether to compile any functions via eval or RuntimeGeneratedFunctions.\neval_module: If eval_expression == true, the module to eval into. Otherwise, the module in which to generate the RuntimeGeneratedFunction.\ncheckbounds: Whether to enable bounds checking in the generated code.\nsimplify: Whether to simplify any symbolically computed jacobians/hessians/etc.\ncse: Whether to enable Common Subexpression Elimination (CSE) on the generated code. This typically improves performance of the generated code but reduces readability.\nsparse: Whether to generate jacobian/hessian/etc. functions that return/operate on sparse matrices. Also controls whether the mass matrix is sparse, wherever applicable.\ncheck_compatibility: Whether to check if the given system sys contains all the information necessary to create a SciMLBase.NonlinearFunction and no more. If disabled, assumes that sys at least contains the necessary information.\nexpression: Val{true} to return an Expr that constructs the corresponding problem instead of the problem itself. Val{false} otherwise.\nresid_prototype: The prototype of the residual function f for a problem involving a nonlinear solve where the residual and u0 have different sizes.\njac: Whether to symbolically compute and generate code for the jacobian function.\nsparsity: Whether to provide symbolically compute and provide sparsity patterns for the jacobian/hessian/etc.\n\nAll other keyword arguments are forwarded to the SciMLBase.NonlinearFunction struct constructor.\n\n\n\n\n\n","category":"type"},{"location":"API/problems/#SciMLBase.NonlinearProblem","page":"Building and solving numerical problems","title":"SciMLBase.NonlinearProblem","text":"SciMLBase.SciMLBase.NonlinearProblem(sys::System, op; kwargs...)\nSciMLBase.SciMLBase.NonlinearProblem{iip}(sys::System, op; kwargs...)\nSciMLBase.SciMLBase.NonlinearProblem{iip, specialize}(sys::System, op; kwargs...)\n\nBuild a SciMLBase.NonlinearProblem given a system sys and operating point op . iip is a boolean indicating whether the problem should be in-place. specialization is a SciMLBase.AbstractSpecalize subtype indicating the level of specialization of the SciMLBase.NonlinearFunction. The operating point should be an iterable collection of key-value pairs mapping variables/parameters in the system to the (initial) values they should take in SciMLBase.NonlinearProblem. Any values not provided will fallback to the corresponding default (if present).\n\nModelingToolkit will build an initialization problem that will run parameter initialization. Since it does not solve for initial values of unknowns, observed equations will not be initialization constraints. If an initialization equation of the system must involve the initial value of an unknown x, it must be used as Initial(x) in the equation. For example, an equation to be used to solve for parameter p in terms of unknowns x and y must be provided as Initial(x) + Initial(y) ~ p instead of x + y ~ p. See the Initialization documentation for more information.\n\nKeyword arguments\n\neval_expression: Whether to compile any functions via eval or RuntimeGeneratedFunctions.\neval_module: If eval_expression == true, the module to eval into. Otherwise, the module in which to generate the RuntimeGeneratedFunction.\nguesses: The guesses for variables in the system, used as initial values for the initialization problem.\nwarn_initialize_determined: Warn if the initialization system is under/over-determined.\ninitialization_eqs: Extra equations to use in the initialization problem.\nfully_determined: Override whether the initialization system is fully determined.\nuse_scc: Whether to use SCCNonlinearProblem for initialization if the system is fully determined.\ncheck_initialization_units: Enable or disable unit checks when constructing the initialization problem.\ntofloat: Passed to varmap_to_vars when building the parameter vector of a non-split system.\nu0_eltype: The eltype of the u0 vector. If nothing, finds the promoted floating point type from op.\nu0_constructor: A function to apply to the u0 value returned from varmap_to_vars. to construct the final u0 value.\np_constructor: A function to apply to each array buffer created when constructing the parameter object.\nwarn_cyclic_dependency: Whether to emit a warning listing out cycles in initial conditions provided for unknowns and parameters.\ncircular_dependency_max_cycle_length: Maximum length of cycle to check for. Only applicable if warn_cyclic_dependency == true.\ncircular_dependency_max_cycles: Maximum number of cycles to check for. Only applicable if warn_cyclic_dependency == true.\nsubstitution_limit: The number times to substitute initial conditions into each other to attempt to arrive at a numeric value.\n\ncheck_compatibility: Whether to check if the given system sys contains all the information necessary to create a SciMLBase.NonlinearProblem and no more. If disabled, assumes that sys at least contains the necessary information.\nexpression: Val{true} to return an Expr that constructs the corresponding problem instead of the problem itself. Val{false} otherwise.\n\nAll other keyword arguments are forwarded to the SciMLBase.NonlinearFunction constructor.\n\nExtended docs\n\nThe following API is internal and may change or be removed without notice. Its usage is highly discouraged.\n\nbuild_initializeprob: If false, avoids building the initialization problem.\ncheck_length: Whether to check the number of equations along with number of unknowns and length of u0 vector for consistency. If false, do not check with equations. This is forwarded to check_eqs_u0.\ntime_dependent_init: Whether to build a time-dependent initialization for the problem. A time-dependent initialization solves for a consistent u0, whereas a time-independent one only runs parameter initialization.\nalgebraic_only: Whether to build the initialization problem using only algebraic equations.\nallow_incomplete: Whether to allow incomplete initialization problems.\n\n\n\n\n\n","category":"type"},{"location":"API/problems/#SciMLBase.SCCNonlinearProblem","page":"Building and solving numerical problems","title":"SciMLBase.SCCNonlinearProblem","text":"SciMLBase.SciMLBase.SCCNonlinearProblem(sys::System, op; kwargs...)\nSciMLBase.SciMLBase.SCCNonlinearProblem{iip}(sys::System, op; kwargs...)\nSciMLBase.SciMLBase.SCCNonlinearProblem{iip, specialize}(sys::System, op; kwargs...)\n\nBuild a SciMLBase.SCCNonlinearProblem given a system sys and operating point op . iip is a boolean indicating whether the problem should be in-place. specialization is a SciMLBase.AbstractSpecalize subtype indicating the level of specialization of the SciMLBase.NonlinearFunction. The operating point should be an iterable collection of key-value pairs mapping variables/parameters in the system to the (initial) values they should take in SciMLBase.SCCNonlinearProblem. Any values not provided will fallback to the corresponding default (if present).\n\nModelingToolkit will build an initialization problem that will run parameter initialization. Since it does not solve for initial values of unknowns, observed equations will not be initialization constraints. If an initialization equation of the system must involve the initial value of an unknown x, it must be used as Initial(x) in the equation. For example, an equation to be used to solve for parameter p in terms of unknowns x and y must be provided as Initial(x) + Initial(y) ~ p instead of x + y ~ p. See the Initialization documentation for more information.\n\nKeyword arguments\n\neval_expression: Whether to compile any functions via eval or RuntimeGeneratedFunctions.\neval_module: If eval_expression == true, the module to eval into. Otherwise, the module in which to generate the RuntimeGeneratedFunction.\nguesses: The guesses for variables in the system, used as initial values for the initialization problem.\nwarn_initialize_determined: Warn if the initialization system is under/over-determined.\ninitialization_eqs: Extra equations to use in the initialization problem.\nfully_determined: Override whether the initialization system is fully determined.\nuse_scc: Whether to use SCCNonlinearProblem for initialization if the system is fully determined.\ncheck_initialization_units: Enable or disable unit checks when constructing the initialization problem.\ntofloat: Passed to varmap_to_vars when building the parameter vector of a non-split system.\nu0_eltype: The eltype of the u0 vector. If nothing, finds the promoted floating point type from op.\nu0_constructor: A function to apply to the u0 value returned from varmap_to_vars. to construct the final u0 value.\np_constructor: A function to apply to each array buffer created when constructing the parameter object.\nwarn_cyclic_dependency: Whether to emit a warning listing out cycles in initial conditions provided for unknowns and parameters.\ncircular_dependency_max_cycle_length: Maximum length of cycle to check for. Only applicable if warn_cyclic_dependency == true.\ncircular_dependency_max_cycles: Maximum number of cycles to check for. Only applicable if warn_cyclic_dependency == true.\nsubstitution_limit: The number times to substitute initial conditions into each other to attempt to arrive at a numeric value.\n\ncheck_compatibility: Whether to check if the given system sys contains all the information necessary to create a SciMLBase.SCCNonlinearProblem and no more. If disabled, assumes that sys at least contains the necessary information.\nexpression: Val{true} to return an Expr that constructs the corresponding problem instead of the problem itself. Val{false} otherwise.\n\nAll other keyword arguments are forwarded to the SciMLBase.NonlinearFunction constructor.\n\nExtended docs\n\nThe following API is internal and may change or be removed without notice. Its usage is highly discouraged.\n\nbuild_initializeprob: If false, avoids building the initialization problem.\ncheck_length: Whether to check the number of equations along with number of unknowns and length of u0 vector for consistency. If false, do not check with equations. This is forwarded to check_eqs_u0.\ntime_dependent_init: Whether to build a time-dependent initialization for the problem. A time-dependent initialization solves for a consistent u0, whereas a time-independent one only runs parameter initialization.\nalgebraic_only: Whether to build the initialization problem using only algebraic equations.\nallow_incomplete: Whether to allow incomplete initialization problems.\n\n\n\n\n\n","category":"type"},{"location":"API/problems/#SciMLBase.NonlinearLeastSquaresProblem","page":"Building and solving numerical problems","title":"SciMLBase.NonlinearLeastSquaresProblem","text":"SciMLBase.SciMLBase.NonlinearLeastSquaresProblem(sys::System, op; kwargs...)\nSciMLBase.SciMLBase.NonlinearLeastSquaresProblem{iip}(sys::System, op; kwargs...)\nSciMLBase.SciMLBase.NonlinearLeastSquaresProblem{iip, specialize}(sys::System, op; kwargs...)\n\nBuild a SciMLBase.NonlinearLeastSquaresProblem given a system sys and operating point op . iip is a boolean indicating whether the problem should be in-place. specialization is a SciMLBase.AbstractSpecalize subtype indicating the level of specialization of the SciMLBase.NonlinearFunction. The operating point should be an iterable collection of key-value pairs mapping variables/parameters in the system to the (initial) values they should take in SciMLBase.NonlinearLeastSquaresProblem. Any values not provided will fallback to the corresponding default (if present).\n\nModelingToolkit will build an initialization problem that will run parameter initialization. Since it does not solve for initial values of unknowns, observed equations will not be initialization constraints. If an initialization equation of the system must involve the initial value of an unknown x, it must be used as Initial(x) in the equation. For example, an equation to be used to solve for parameter p in terms of unknowns x and y must be provided as Initial(x) + Initial(y) ~ p instead of x + y ~ p. See the Initialization documentation for more information.\n\nKeyword arguments\n\neval_expression: Whether to compile any functions via eval or RuntimeGeneratedFunctions.\neval_module: If eval_expression == true, the module to eval into. Otherwise, the module in which to generate the RuntimeGeneratedFunction.\nguesses: The guesses for variables in the system, used as initial values for the initialization problem.\nwarn_initialize_determined: Warn if the initialization system is under/over-determined.\ninitialization_eqs: Extra equations to use in the initialization problem.\nfully_determined: Override whether the initialization system is fully determined.\nuse_scc: Whether to use SCCNonlinearProblem for initialization if the system is fully determined.\ncheck_initialization_units: Enable or disable unit checks when constructing the initialization problem.\ntofloat: Passed to varmap_to_vars when building the parameter vector of a non-split system.\nu0_eltype: The eltype of the u0 vector. If nothing, finds the promoted floating point type from op.\nu0_constructor: A function to apply to the u0 value returned from varmap_to_vars. to construct the final u0 value.\np_constructor: A function to apply to each array buffer created when constructing the parameter object.\nwarn_cyclic_dependency: Whether to emit a warning listing out cycles in initial conditions provided for unknowns and parameters.\ncircular_dependency_max_cycle_length: Maximum length of cycle to check for. Only applicable if warn_cyclic_dependency == true.\ncircular_dependency_max_cycles: Maximum number of cycles to check for. Only applicable if warn_cyclic_dependency == true.\nsubstitution_limit: The number times to substitute initial conditions into each other to attempt to arrive at a numeric value.\n\ncheck_compatibility: Whether to check if the given system sys contains all the information necessary to create a SciMLBase.NonlinearLeastSquaresProblem and no more. If disabled, assumes that sys at least contains the necessary information.\nexpression: Val{true} to return an Expr that constructs the corresponding problem instead of the problem itself. Val{false} otherwise.\n\nAll other keyword arguments are forwarded to the SciMLBase.NonlinearFunction constructor.\n\nExtended docs\n\nThe following API is internal and may change or be removed without notice. Its usage is highly discouraged.\n\nbuild_initializeprob: If false, avoids building the initialization problem.\ncheck_length: Whether to check the number of equations along with number of unknowns and length of u0 vector for consistency. If false, do not check with equations. This is forwarded to check_eqs_u0.\ntime_dependent_init: Whether to build a time-dependent initialization for the problem. A time-dependent initialization solves for a consistent u0, whereas a time-independent one only runs parameter initialization.\nalgebraic_only: Whether to build the initialization problem using only algebraic equations.\nallow_incomplete: Whether to allow incomplete initialization problems.\n\n\n\n\n\n","category":"type"},{"location":"API/problems/#SciMLBase.SteadyStateProblem","page":"Building and solving numerical problems","title":"SciMLBase.SteadyStateProblem","text":"SciMLBase.SciMLBase.SteadyStateProblem(sys::System, op; kwargs...)\nSciMLBase.SciMLBase.SteadyStateProblem{iip}(sys::System, op; kwargs...)\nSciMLBase.SciMLBase.SteadyStateProblem{iip, specialize}(sys::System, op; kwargs...)\n\nBuild a SciMLBase.SteadyStateProblem given a system sys and operating point op . iip is a boolean indicating whether the problem should be in-place. specialization is a SciMLBase.AbstractSpecalize subtype indicating the level of specialization of the SciMLBase.ODEFunction. The operating point should be an iterable collection of key-value pairs mapping variables/parameters in the system to the (initial) values they should take in SciMLBase.SteadyStateProblem. Any values not provided will fallback to the corresponding default (if present).\n\nModelingToolkit will build an initialization problem that will run parameter initialization. Since it does not solve for initial values of unknowns, observed equations will not be initialization constraints. If an initialization equation of the system must involve the initial value of an unknown x, it must be used as Initial(x) in the equation. For example, an equation to be used to solve for parameter p in terms of unknowns x and y must be provided as Initial(x) + Initial(y) ~ p instead of x + y ~ p. See the Initialization documentation for more information.\n\nKeyword arguments\n\neval_expression: Whether to compile any functions via eval or RuntimeGeneratedFunctions.\neval_module: If eval_expression == true, the module to eval into. Otherwise, the module in which to generate the RuntimeGeneratedFunction.\nguesses: The guesses for variables in the system, used as initial values for the initialization problem.\nwarn_initialize_determined: Warn if the initialization system is under/over-determined.\ninitialization_eqs: Extra equations to use in the initialization problem.\nfully_determined: Override whether the initialization system is fully determined.\nuse_scc: Whether to use SCCNonlinearProblem for initialization if the system is fully determined.\ncheck_initialization_units: Enable or disable unit checks when constructing the initialization problem.\ntofloat: Passed to varmap_to_vars when building the parameter vector of a non-split system.\nu0_eltype: The eltype of the u0 vector. If nothing, finds the promoted floating point type from op.\nu0_constructor: A function to apply to the u0 value returned from varmap_to_vars. to construct the final u0 value.\np_constructor: A function to apply to each array buffer created when constructing the parameter object.\nwarn_cyclic_dependency: Whether to emit a warning listing out cycles in initial conditions provided for unknowns and parameters.\ncircular_dependency_max_cycle_length: Maximum length of cycle to check for. Only applicable if warn_cyclic_dependency == true.\ncircular_dependency_max_cycles: Maximum number of cycles to check for. Only applicable if warn_cyclic_dependency == true.\nsubstitution_limit: The number times to substitute initial conditions into each other to attempt to arrive at a numeric value.\n\ncheck_compatibility: Whether to check if the given system sys contains all the information necessary to create a SciMLBase.SteadyStateProblem and no more. If disabled, assumes that sys at least contains the necessary information.\nexpression: Val{true} to return an Expr that constructs the corresponding problem instead of the problem itself. Val{false} otherwise.\n\nAll other keyword arguments are forwarded to the SciMLBase.ODEFunction constructor.\n\nExtended docs\n\nThe following API is internal and may change or be removed without notice. Its usage is highly discouraged.\n\nbuild_initializeprob: If false, avoids building the initialization problem.\ncheck_length: Whether to check the number of equations along with number of unknowns and length of u0 vector for consistency. If false, do not check with equations. This is forwarded to check_eqs_u0.\ntime_dependent_init: Whether to build a time-dependent initialization for the problem. A time-dependent initialization solves for a consistent u0, whereas a time-independent one only runs parameter initialization.\nalgebraic_only: Whether to build the initialization problem using only algebraic equations.\nallow_incomplete: Whether to allow incomplete initialization problems.\n\n\n\n\n\n","category":"type"},{"location":"API/problems/#SciMLBase.IntervalNonlinearFunction","page":"Building and solving numerical problems","title":"SciMLBase.IntervalNonlinearFunction","text":"SciMLBase.IntervalNonlinearFunction(sys::System; kwargs...)\nSciMLBase.IntervalNonlinearFunction{iip}(sys::System; kwargs...)\nSciMLBase.IntervalNonlinearFunction{iip, specialize}(sys::System; kwargs...)\n\nCreate a SciMLBase.IntervalNonlinearFunction from the given sys. iip is a boolean indicating whether the function should be in-place. specialization is a SciMLBase.AbstractSpecalize subtype indicating the level of specialization of the SciMLBase.IntervalNonlinearFunction.\n\nKeyword arguments\n\nu0: The u0 vector for the corresponding problem, if available. Can be obtained using ModelingToolkit.get_u0.\np: The parameter object for the corresponding problem, if available. Can be obtained using ModelingToolkit.get_p.\neval_expression: Whether to compile any functions via eval or RuntimeGeneratedFunctions.\neval_module: If eval_expression == true, the module to eval into. Otherwise, the module in which to generate the RuntimeGeneratedFunction.\ncheckbounds: Whether to enable bounds checking in the generated code.\nsimplify: Whether to simplify any symbolically computed jacobians/hessians/etc.\ncse: Whether to enable Common Subexpression Elimination (CSE) on the generated code. This typically improves performance of the generated code but reduces readability.\nsparse: Whether to generate jacobian/hessian/etc. functions that return/operate on sparse matrices. Also controls whether the mass matrix is sparse, wherever applicable.\ncheck_compatibility: Whether to check if the given system sys contains all the information necessary to create a SciMLBase.IntervalNonlinearFunction and no more. If disabled, assumes that sys at least contains the necessary information.\nexpression: Val{true} to return an Expr that constructs the corresponding problem instead of the problem itself. Val{false} otherwise.\n\nAll other keyword arguments are forwarded to the SciMLBase.IntervalNonlinearFunction struct constructor.\n\n\n\n\n\n","category":"type"},{"location":"API/problems/#SciMLBase.IntervalNonlinearProblem","page":"Building and solving numerical problems","title":"SciMLBase.IntervalNonlinearProblem","text":"SciMLBase.IntervalNonlinearProblem(sys::System, uspan::NTuple{2}, parammap = SciMLBase.NullParameters(); kwargs...)\n\nCreate an IntervalNonlinearProblem from the given sys. This is only valid for a system of nonlinear equations with a single equation and unknown. uspan is the interval in which the root is to be found, and parammap is an iterable collection of key-value pairs providing values for the parameters in the system.\n\nModelingToolkit will build an initialization problem that will run parameter initialization. Since it does not solve for initial values of unknowns, observed equations will not be initialization constraints. If an initialization equation of the system must involve the initial value of an unknown x, it must be used as Initial(x) in the equation. For example, an equation to be used to solve for parameter p in terms of unknowns x and y must be provided as Initial(x) + Initial(y) ~ p instead of x + y ~ p. See the Initialization documentation for more information.\n\nKeyword arguments\n\neval_expression: Whether to compile any functions via eval or RuntimeGeneratedFunctions.\neval_module: If eval_expression == true, the module to eval into. Otherwise, the module in which to generate the RuntimeGeneratedFunction.\nguesses: The guesses for variables in the system, used as initial values for the initialization problem.\nwarn_initialize_determined: Warn if the initialization system is under/over-determined.\ninitialization_eqs: Extra equations to use in the initialization problem.\nfully_determined: Override whether the initialization system is fully determined.\nuse_scc: Whether to use SCCNonlinearProblem for initialization if the system is fully determined.\ncheck_initialization_units: Enable or disable unit checks when constructing the initialization problem.\ntofloat: Passed to varmap_to_vars when building the parameter vector of a non-split system.\nu0_eltype: The eltype of the u0 vector. If nothing, finds the promoted floating point type from op.\nu0_constructor: A function to apply to the u0 value returned from varmap_to_vars. to construct the final u0 value.\np_constructor: A function to apply to each array buffer created when constructing the parameter object.\nwarn_cyclic_dependency: Whether to emit a warning listing out cycles in initial conditions provided for unknowns and parameters.\ncircular_dependency_max_cycle_length: Maximum length of cycle to check for. Only applicable if warn_cyclic_dependency == true.\ncircular_dependency_max_cycles: Maximum number of cycles to check for. Only applicable if warn_cyclic_dependency == true.\nsubstitution_limit: The number times to substitute initial conditions into each other to attempt to arrive at a numeric value.\ncheck_compatibility: Whether to check if the given system sys contains all the information necessary to create a SciMLBase.IntervalNonlinearProblem and no more. If disabled, assumes that sys at least contains the necessary information.\nexpression: Val{true} to return an Expr that constructs the corresponding problem instead of the problem itself. Val{false} otherwise.\n\nAll other keyword arguments are forwarded to the IntervalNonlinearFunction constructor.\n\nExtended docs\n\nThe following API is internal and may change or be removed without notice. Its usage is highly discouraged.\n\nbuild_initializeprob: If false, avoids building the initialization problem.\ncheck_length: Whether to check the number of equations along with number of unknowns and length of u0 vector for consistency. If false, do not check with equations. This is forwarded to check_eqs_u0.\ntime_dependent_init: Whether to build a time-dependent initialization for the problem. A time-dependent initialization solves for a consistent u0, whereas a time-independent one only runs parameter initialization.\nalgebraic_only: Whether to build the initialization problem using only algebraic equations.\nallow_incomplete: Whether to allow incomplete initialization problems.\n\n\n\n\n\n","category":"type"},{"location":"API/problems/#ModelingToolkit.HomotopyContinuationProblem","page":"Building and solving numerical problems","title":"ModelingToolkit.HomotopyContinuationProblem","text":"SciMLBase.ModelingToolkit.HomotopyContinuationProblem(sys::System, op; kwargs...)\nSciMLBase.ModelingToolkit.HomotopyContinuationProblem{iip}(sys::System, op; kwargs...)\nSciMLBase.ModelingToolkit.HomotopyContinuationProblem{iip, specialize}(sys::System, op; kwargs...)\n\nBuild a ModelingToolkit.HomotopyContinuationProblem given a system sys and operating point op . iip is a boolean indicating whether the problem should be in-place. specialization is a SciMLBase.AbstractSpecalize subtype indicating the level of specialization of the SciMLBase.HomotopyNonlinearFunction. The operating point should be an iterable collection of key-value pairs mapping variables/parameters in the system to the (initial) values they should take in ModelingToolkit.HomotopyContinuationProblem. Any values not provided will fallback to the corresponding default (if present).\n\nKeyword arguments\n\neval_expression: Whether to compile any functions via eval or RuntimeGeneratedFunctions.\neval_module: If eval_expression == true, the module to eval into. Otherwise, the module in which to generate the RuntimeGeneratedFunction.\nguesses: The guesses for variables in the system, used as initial values for the initialization problem.\nwarn_initialize_determined: Warn if the initialization system is under/over-determined.\ninitialization_eqs: Extra equations to use in the initialization problem.\nfully_determined: Override whether the initialization system is fully determined.\nuse_scc: Whether to use SCCNonlinearProblem for initialization if the system is fully determined.\ncheck_initialization_units: Enable or disable unit checks when constructing the initialization problem.\ntofloat: Passed to varmap_to_vars when building the parameter vector of a non-split system.\nu0_eltype: The eltype of the u0 vector. If nothing, finds the promoted floating point type from op.\nu0_constructor: A function to apply to the u0 value returned from varmap_to_vars. to construct the final u0 value.\np_constructor: A function to apply to each array buffer created when constructing the parameter object.\nwarn_cyclic_dependency: Whether to emit a warning listing out cycles in initial conditions provided for unknowns and parameters.\ncircular_dependency_max_cycle_length: Maximum length of cycle to check for. Only applicable if warn_cyclic_dependency == true.\ncircular_dependency_max_cycles: Maximum number of cycles to check for. Only applicable if warn_cyclic_dependency == true.\nsubstitution_limit: The number times to substitute initial conditions into each other to attempt to arrive at a numeric value.\n\ncheck_compatibility: Whether to check if the given system sys contains all the information necessary to create a ModelingToolkit.HomotopyContinuationProblem and no more. If disabled, assumes that sys at least contains the necessary information.\nexpression: Val{true} to return an Expr that constructs the corresponding problem instead of the problem itself. Val{false} otherwise.\n\nAll other keyword arguments are forwarded to the SciMLBase.HomotopyNonlinearFunction constructor.\n\nExtended docs\n\nThe following API is internal and may change or be removed without notice. Its usage is highly discouraged.\n\nbuild_initializeprob: If false, avoids building the initialization problem.\ncheck_length: Whether to check the number of equations along with number of unknowns and length of u0 vector for consistency. If false, do not check with equations. This is forwarded to check_eqs_u0.\ntime_dependent_init: Whether to build a time-dependent initialization for the problem. A time-dependent initialization solves for a consistent u0, whereas a time-independent one only runs parameter initialization.\nalgebraic_only: Whether to build the initialization problem using only algebraic equations.\nallow_incomplete: Whether to allow incomplete initialization problems.\n\n\n\n\n\n","category":"type"},{"location":"API/problems/#SciMLBase.HomotopyNonlinearFunction","page":"Building and solving numerical problems","title":"SciMLBase.HomotopyNonlinearFunction","text":"SciMLBase.HomotopyNonlinearFunction(sys::System; kwargs...)\nSciMLBase.HomotopyNonlinearFunction{iip}(sys::System; kwargs...)\nSciMLBase.HomotopyNonlinearFunction{iip, specialize}(sys::System; kwargs...)\n\nCreate a HomotopyNonlinearFunction from the given sys. iip is a boolean indicating whether the function should be in-place. specialization is a SciMLBase.AbstractSpecalize subtype indicating the level of specialization of the func.\n\nKeyword arguments\n\nu0: The u0 vector for the corresponding problem, if available. Can be obtained using ModelingToolkit.get_u0.\np: The parameter object for the corresponding problem, if available. Can be obtained using ModelingToolkit.get_p.\neval_expression: Whether to compile any functions via eval or RuntimeGeneratedFunctions.\neval_module: If eval_expression == true, the module to eval into. Otherwise, the module in which to generate the RuntimeGeneratedFunction.\ncheckbounds: Whether to enable bounds checking in the generated code.\nsimplify: Whether to simplify any symbolically computed jacobians/hessians/etc.\ncse: Whether to enable Common Subexpression Elimination (CSE) on the generated code. This typically improves performance of the generated code but reduces readability.\nfraction_cancel_fn: The function to use to simplify fractions in the polynomial expression. A more powerful function can increase processing time but be able to eliminate more rational functions, thus improving solve time. Should be a function that takes a symbolic expression containing zero or more fraction expressions and returns the simplified expression. While this defaults to SymbolicUtils.simplify_fractions, a viable alternative is SymbolicUtils.quick_cancel\n\nAll keyword arguments are forwarded to the wrapped NonlinearFunction constructor.\n\n\n\n\n\n","category":"type"},{"location":"API/problems/#SciMLBase.LinearProblem","page":"Building and solving numerical problems","title":"SciMLBase.LinearProblem","text":"SciMLBase.LinearProblem(sys::System, op; kwargs...)\nSciMLBase.LinearProblem{iip}(sys::System, op; kwargs...)\n\nBuild a LinearProblem given a system sys and operating point op. iip is a boolean indicating whether the problem should be in-place. The operating point should be an iterable collection of key-value pairs mapping variables/parameters in the system to the (initial) values they should take in LinearProblem. Any values not provided will fallback to the corresponding default (if present).\n\nNote that since u0 is optional for LinearProblem, values of unknowns do not need to be specified in op to create a LinearProblem. In such a case, prob.u0 will be nothing and attempting to symbolically index the problem with an unknown, observable, or expression depending on unknowns/observables will error.\n\nUpdating the parameters automatically updates the A and b arrays.\n\nKeyword arguments\n\neval_expression: Whether to compile any functions via eval or RuntimeGeneratedFunctions.\neval_module: If eval_expression == true, the module to eval into. Otherwise, the module in which to generate the RuntimeGeneratedFunction.\nguesses: The guesses for variables in the system, used as initial values for the initialization problem.\nwarn_initialize_determined: Warn if the initialization system is under/over-determined.\ninitialization_eqs: Extra equations to use in the initialization problem.\nfully_determined: Override whether the initialization system is fully determined.\nuse_scc: Whether to use SCCNonlinearProblem for initialization if the system is fully determined.\ncheck_initialization_units: Enable or disable unit checks when constructing the initialization problem.\ntofloat: Passed to varmap_to_vars when building the parameter vector of a non-split system.\nu0_eltype: The eltype of the u0 vector. If nothing, finds the promoted floating point type from op.\nu0_constructor: A function to apply to the u0 value returned from varmap_to_vars. to construct the final u0 value.\np_constructor: A function to apply to each array buffer created when constructing the parameter object.\nwarn_cyclic_dependency: Whether to emit a warning listing out cycles in initial conditions provided for unknowns and parameters.\ncircular_dependency_max_cycle_length: Maximum length of cycle to check for. Only applicable if warn_cyclic_dependency == true.\ncircular_dependency_max_cycles: Maximum number of cycles to check for. Only applicable if warn_cyclic_dependency == true.\nsubstitution_limit: The number times to substitute initial conditions into each other to attempt to arrive at a numeric value.\ncheck_compatibility: Whether to check if the given system sys contains all the information necessary to create a SciMLBase.LinearProblem and no more. If disabled, assumes that sys at least contains the necessary information.\nexpression: Val{true} to return an Expr that constructs the corresponding problem instead of the problem itself. Val{false} otherwise.\n\nAll other keyword arguments are forwarded to the func constructor.\n\nExtended docs\n\nThe following API is internal and may change or be removed without notice. Its usage is highly discouraged.\n\nbuild_initializeprob: If false, avoids building the initialization problem.\ncheck_length: Whether to check the number of equations along with number of unknowns and length of u0 vector for consistency. If false, do not check with equations. This is forwarded to check_eqs_u0.\ntime_dependent_init: Whether to build a time-dependent initialization for the problem. A time-dependent initialization solves for a consistent u0, whereas a time-independent one only runs parameter initialization.\nalgebraic_only: Whether to build the initialization problem using only algebraic equations.\nallow_incomplete: Whether to allow incomplete initialization problems.\n\n\n\n\n\n","category":"type"},{"location":"API/problems/#Optimization-and-optimal-control","page":"Building and solving numerical problems","title":"Optimization and optimal control","text":"","category":"section"},{"location":"API/problems/#SciMLBase.OptimizationFunction","page":"Building and solving numerical problems","title":"SciMLBase.OptimizationFunction","text":"SciMLBase.OptimizationFunction(sys::System; kwargs...)\nSciMLBase.OptimizationFunction{iip}(sys::System; kwargs...)\nSciMLBase.OptimizationFunction{iip, specialize}(sys::System; kwargs...)\n\nCreate a SciMLBase.OptimizationFunction from the given sys. iip is a boolean indicating whether the function should be in-place. specialization is a SciMLBase.AbstractSpecalize subtype indicating the level of specialization of the SciMLBase.OptimizationFunction.\n\nKeyword arguments\n\nu0: The u0 vector for the corresponding problem, if available. Can be obtained using ModelingToolkit.get_u0.\np: The parameter object for the corresponding problem, if available. Can be obtained using ModelingToolkit.get_p.\neval_expression: Whether to compile any functions via eval or RuntimeGeneratedFunctions.\neval_module: If eval_expression == true, the module to eval into. Otherwise, the module in which to generate the RuntimeGeneratedFunction.\ncheckbounds: Whether to enable bounds checking in the generated code.\nsimplify: Whether to simplify any symbolically computed jacobians/hessians/etc.\ncse: Whether to enable Common Subexpression Elimination (CSE) on the generated code. This typically improves performance of the generated code but reduces readability.\nsparse: Whether to generate jacobian/hessian/etc. functions that return/operate on sparse matrices. Also controls whether the mass matrix is sparse, wherever applicable.\ncheck_compatibility: Whether to check if the given system sys contains all the information necessary to create a SciMLBase.OptimizationFunction and no more. If disabled, assumes that sys at least contains the necessary information.\nexpression: Val{true} to return an Expr that constructs the corresponding problem instead of the problem itself. Val{false} otherwise.\njac: Whether to symbolically compute and generate code for the jacobian function.\ngrad: Whether the symbolically compute and generate code for the gradient of the cost function with respect to unknowns.\nhess: Whether to symbolically compute and generate code for the hessian function.\ncons_h: Whether to symbolically compute and generate code for the hessian function of constraints. Since the constraint function is vector-valued, the hessian is a vector of hessian matrices.\ncons_j: Whether to symbolically compute and generate code for the jacobian function of constraints.\nsparsity: Whether to provide symbolically compute and provide sparsity patterns for the jacobian/hessian/etc.\ncons_sparse: Identical to the sparse keyword, but specifically for jacobian/hessian functions of the constraints.\n\nAll other keyword arguments are forwarded to the SciMLBase.OptimizationFunction struct constructor.\n\n\n\n\n\n","category":"type"},{"location":"API/problems/#SciMLBase.OptimizationProblem","page":"Building and solving numerical problems","title":"SciMLBase.OptimizationProblem","text":"SciMLBase.SciMLBase.OptimizationProblem(sys::System, op; kwargs...)\nSciMLBase.SciMLBase.OptimizationProblem{iip}(sys::System, op; kwargs...)\nSciMLBase.SciMLBase.OptimizationProblem{iip, specialize}(sys::System, op; kwargs...)\n\nBuild a SciMLBase.OptimizationProblem given a system sys and operating point op . iip is a boolean indicating whether the problem should be in-place. specialization is a SciMLBase.AbstractSpecalize subtype indicating the level of specialization of the SciMLBase.OptimizationFunction. The operating point should be an iterable collection of key-value pairs mapping variables/parameters in the system to the (initial) values they should take in SciMLBase.OptimizationProblem. Any values not provided will fallback to the corresponding default (if present).\n\nModelingToolkit will build an initialization problem that will run parameter initialization. Since it does not solve for initial values of unknowns, observed equations will not be initialization constraints. If an initialization equation of the system must involve the initial value of an unknown x, it must be used as Initial(x) in the equation. For example, an equation to be used to solve for parameter p in terms of unknowns x and y must be provided as Initial(x) + Initial(y) ~ p instead of x + y ~ p. See the Initialization documentation for more information.\n\nKeyword arguments\n\neval_expression: Whether to compile any functions via eval or RuntimeGeneratedFunctions.\neval_module: If eval_expression == true, the module to eval into. Otherwise, the module in which to generate the RuntimeGeneratedFunction.\nguesses: The guesses for variables in the system, used as initial values for the initialization problem.\nwarn_initialize_determined: Warn if the initialization system is under/over-determined.\ninitialization_eqs: Extra equations to use in the initialization problem.\nfully_determined: Override whether the initialization system is fully determined.\nuse_scc: Whether to use SCCNonlinearProblem for initialization if the system is fully determined.\ncheck_initialization_units: Enable or disable unit checks when constructing the initialization problem.\ntofloat: Passed to varmap_to_vars when building the parameter vector of a non-split system.\nu0_eltype: The eltype of the u0 vector. If nothing, finds the promoted floating point type from op.\nu0_constructor: A function to apply to the u0 value returned from varmap_to_vars. to construct the final u0 value.\np_constructor: A function to apply to each array buffer created when constructing the parameter object.\nwarn_cyclic_dependency: Whether to emit a warning listing out cycles in initial conditions provided for unknowns and parameters.\ncircular_dependency_max_cycle_length: Maximum length of cycle to check for. Only applicable if warn_cyclic_dependency == true.\ncircular_dependency_max_cycles: Maximum number of cycles to check for. Only applicable if warn_cyclic_dependency == true.\nsubstitution_limit: The number times to substitute initial conditions into each other to attempt to arrive at a numeric value.\n\ncheck_compatibility: Whether to check if the given system sys contains all the information necessary to create a SciMLBase.OptimizationProblem and no more. If disabled, assumes that sys at least contains the necessary information.\nexpression: Val{true} to return an Expr that constructs the corresponding problem instead of the problem itself. Val{false} otherwise.\n\nAll other keyword arguments are forwarded to the SciMLBase.OptimizationFunction constructor.\n\nExtended docs\n\nThe following API is internal and may change or be removed without notice. Its usage is highly discouraged.\n\nbuild_initializeprob: If false, avoids building the initialization problem.\ncheck_length: Whether to check the number of equations along with number of unknowns and length of u0 vector for consistency. If false, do not check with equations. This is forwarded to check_eqs_u0.\ntime_dependent_init: Whether to build a time-dependent initialization for the problem. A time-dependent initialization solves for a consistent u0, whereas a time-independent one only runs parameter initialization.\nalgebraic_only: Whether to build the initialization problem using only algebraic equations.\nallow_incomplete: Whether to allow incomplete initialization problems.\n\n\n\n\n\n","category":"type"},{"location":"API/problems/#SciMLBase.ODEInputFunction","page":"Building and solving numerical problems","title":"SciMLBase.ODEInputFunction","text":"SciMLBase.ODEInputFunction(sys::System; kwargs...)\nSciMLBase.ODEInputFunction{iip}(sys::System; kwargs...)\nSciMLBase.ODEInputFunction{iip, specialize}(sys::System; kwargs...)\n\nCreate a SciMLBase.ODEInputFunction from the given sys. iip is a boolean indicating whether the function should be in-place. specialization is a SciMLBase.AbstractSpecalize subtype indicating the level of specialization of the SciMLBase.ODEInputFunction.\n\nKeyword arguments\n\nu0: The u0 vector for the corresponding problem, if available. Can be obtained using ModelingToolkit.get_u0.\np: The parameter object for the corresponding problem, if available. Can be obtained using ModelingToolkit.get_p.\nt: The initial time for the corresponding problem, if available.\neval_expression: Whether to compile any functions via eval or RuntimeGeneratedFunctions.\neval_module: If eval_expression == true, the module to eval into. Otherwise, the module in which to generate the RuntimeGeneratedFunction.\ncheckbounds: Whether to enable bounds checking in the generated code.\nsimplify: Whether to simplify any symbolically computed jacobians/hessians/etc.\ncse: Whether to enable Common Subexpression Elimination (CSE) on the generated code. This typically improves performance of the generated code but reduces readability.\nsparse: Whether to generate jacobian/hessian/etc. functions that return/operate on sparse matrices. Also controls whether the mass matrix is sparse, wherever applicable.\ncheck_compatibility: Whether to check if the given system sys contains all the information necessary to create a SciMLBase.ODEInputFunction and no more. If disabled, assumes that sys at least contains the necessary information.\nexpression: Val{true} to return an Expr that constructs the corresponding problem instead of the problem itself. Val{false} otherwise.  Constructing the expression does not support callbacks\ninputs: The variables in the input vector. The system must have been simplified using mtkcompile with these variables passed as inputs.\ndisturbance_inputs: The disturbance input variables. The system must have been simplified using mtkcompile with these variables passed as disturbance_inputs.\njac: Whether to symbolically compute and generate code for the jacobian function.\ntgrad: Whether to symbolically compute and generate code for the tgrad function.\ncontroljac: Whether to symbolically compute and generate code for the jacobian of the ODE with respect to the inputs.\nsparsity: Whether to provide symbolically compute and provide sparsity patterns for the jacobian/hessian/etc.\n\nAll other keyword arguments are forwarded to the SciMLBase.ODEInputFunction struct constructor.\n\n\n\n\n\n","category":"type"},{"location":"API/problems/#ModelingToolkit.JuMPDynamicOptProblem","page":"Building and solving numerical problems","title":"ModelingToolkit.JuMPDynamicOptProblem","text":"JuMPDynamicOptProblem(sys::System, op, tspan; dt, steps, guesses, kwargs...)\n\nConvert an System representing an optimal control system into a JuMP model for solving using optimization. Must provide either dt, the timestep between collocation  points (which, along with the timespan, determines the number of points), or directly  provide the number of points as steps.\n\nTo construct the problem, please load InfiniteOpt along with ModelingToolkit.\n\n\n\n\n\n","category":"function"},{"location":"API/problems/#ModelingToolkit.InfiniteOptDynamicOptProblem","page":"Building and solving numerical problems","title":"ModelingToolkit.InfiniteOptDynamicOptProblem","text":"InfiniteOptDynamicOptProblem(sys::System, op, tspan; dt)\n\nConvert an System representing an optimal control system into a InfiniteOpt model for solving using optimization. Must provide dt for determining the length  of the interpolation arrays.\n\nRelated to JuMPDynamicOptProblem, but directly adds the differential equations of the system as derivative constraints, rather than using a solver tableau.\n\nTo construct the problem, please load InfiniteOpt along with ModelingToolkit.\n\n\n\n\n\n","category":"function"},{"location":"API/problems/#ModelingToolkit.CasADiDynamicOptProblem","page":"Building and solving numerical problems","title":"ModelingToolkit.CasADiDynamicOptProblem","text":"CasADiDynamicOptProblem(sys::System, op, tspan; dt, steps, guesses, kwargs...)\n\nConvert an System representing an optimal control system into a CasADi model for solving using optimization. Must provide either dt, the timestep between collocation  points (which, along with the timespan, determines the number of points), or directly  provide the number of points as steps.\n\nTo construct the problem, please load CasADi along with ModelingToolkit.\n\n\n\n\n\n","category":"function"},{"location":"API/problems/#The-state-vector-and-parameter-object","page":"Building and solving numerical problems","title":"The state vector and parameter object","text":"","category":"section"},{"location":"API/problems/","page":"Building and solving numerical problems","title":"Building and solving numerical problems","text":"Typically the unknowns of the system are present as a Vector of the appropriate length in the numerical problem. The state vector can also be constructed manually without building a problem.","category":"page"},{"location":"API/problems/#ModelingToolkit.get_u0","page":"Building and solving numerical problems","title":"ModelingToolkit.get_u0","text":"get_u0(\n    sys::ModelingToolkit.AbstractSystem,\n    varmap;\n    kwargs...\n) -> Any\n\n\nReturn the u0 vector for the given system sys and variable-value mapping varmap. All keyword arguments are forwarded to varmap_to_vars.\n\n\n\n\n\n","category":"function"},{"location":"API/problems/#ModelingToolkit.varmap_to_vars","page":"Building and solving numerical problems","title":"ModelingToolkit.varmap_to_vars","text":"varmap_to_vars(\n    varmap::AbstractDict,\n    vars::Vector;\n    tofloat,\n    use_union,\n    container_type,\n    buffer_eltype,\n    toterm,\n    check,\n    allow_symbolic,\n    is_initializeprob,\n    substitution_limit\n) -> Any\n\n\nReturn an array of values where the ith element corresponds to the value of vars[i] in varmap. Will mutate varmap by symbolically substituting it into itself.\n\nKeyword arguments:\n\ncontainer_type: The type of the returned container.\nallow_symbolic: Whether the returned container of values can have symbolic expressions.\nbuffer_eltype: The eltype of the returned container if !allow_symbolic. If Nothing, automatically promotes the values in the container to a common eltype.\ntofloat: Whether to promote values to floating point numbers if buffer_eltype == Nothing.\nuse_union: Whether to allow using a Union as the eltype if buffer_eltype == Nothing.\ntoterm: The toterm function for canonicalizing keys of varmap. A value of nothing disables this process.\ncheck: Whether to check if all of vars are keys of varmap.\nis_initializeprob: Whether an initialization problem is being constructed. Used for better error messages.\nsubstitution_limit: The maximum number of times to recursively substitute varmap into itself to get a numeric value for each variable in vars.\n\n\n\n\n\n","category":"function"},{"location":"API/problems/","page":"Building and solving numerical problems","title":"Building and solving numerical problems","text":"By default, the parameters of the system are stored in a custom data structure called MTKParameters. The internals of this data structure are undocumented, and it should only be interacted with through defined public API. SymbolicIndexingInterface.jl contains functionality useful for this purpose.","category":"page"},{"location":"API/problems/#ModelingToolkit.MTKParameters","page":"Building and solving numerical problems","title":"ModelingToolkit.MTKParameters","text":"function MTKParameters(sys::AbstractSystem, p, u0 = Dict(); t0 = nothing)\n\nCreate an MTKParameters object for the system sys. p (u0) are symbolic maps from parameters (unknowns) to their values. The values can also be symbolic expressions, which are evaluated given the values of other parameters/unknowns. u0 is only required if the values of parameters depend on the unknowns. t0 is the initial time, for time- dependent systems. It is only required if the symbolic expressions also use the independent variable of the system.\n\nThis requires that complete has been called on the system (usually via mtkcompile or @mtkcompile) and the keyword split = true was passed (which is the default behavior).\n\n\n\n\n\n","category":"type"},{"location":"API/problems/#ModelingToolkit.get_p","page":"Building and solving numerical problems","title":"ModelingToolkit.get_p","text":"get_p(\n    sys::ModelingToolkit.AbstractSystem,\n    varmap;\n    split,\n    kwargs...\n) -> Any\n\n\nReturn the p object for the given system sys and variable-value mapping varmap. All keyword arguments are forwarded to MTKParameters for split systems and varmap_to_vars for non-split systems.\n\n\n\n\n\n","category":"function"},{"location":"API/problems/","page":"Building and solving numerical problems","title":"Building and solving numerical problems","text":"The following functions are useful when working with MTKParameters objects, and especially the Tunables portion. For more information about the \"portions\" of MTKParameters, refer to the SciMLStructures.jl documentation.","category":"page"},{"location":"API/problems/#ModelingToolkit.reorder_dimension_by_tunables!","page":"Building and solving numerical problems","title":"ModelingToolkit.reorder_dimension_by_tunables!","text":"reorder_dimension_by_tunables!(dest::AbstractArray, sys::AbstractSystem, arr::AbstractArray, syms; dim = 1)\n\nAssuming the order of values in dimension dim of arr correspond to the order of tunable parameters in the system, reorder them according to the order described in syms. syms must be a permutation of tunable_parameters(sys). The result is written to dest. The size of dest and arr must be equal. Return dest.\n\nSee also: MTKParameters, tunable_parameters, reorder_dimension_by_tunables.\n\n\n\n\n\n","category":"function"},{"location":"API/problems/#ModelingToolkit.reorder_dimension_by_tunables","page":"Building and solving numerical problems","title":"ModelingToolkit.reorder_dimension_by_tunables","text":"reorder_dimension_by_tunables(sys::AbstractSystem, arr::AbstractArray, syms; dim = 1)\n\nOut-of-place version of reorder_dimension_by_tunables!.\n\n\n\n\n\n","category":"function"},{"location":"API/problems/#Initialization","page":"Building and solving numerical problems","title":"Initialization","text":"","category":"section"},{"location":"API/problems/#ModelingToolkit.generate_initializesystem","page":"Building and solving numerical problems","title":"ModelingToolkit.generate_initializesystem","text":"generate_initializesystem(\n    sys::ModelingToolkit.AbstractSystem;\n    time_dependent_init,\n    kwargs...\n) -> System\n\n\nGenerate the initialization system for sys. The initialization system is a system of nonlinear equations that solve for the full set of initial conditions of sys given specified constraints.\n\nThe initialization system can be of two types: time-dependent and time-independent. Time-dependent initialization systems solve for the initial values of unknowns as well as the values of solvable parameters of the system. Time-independent initialization systems only solve for solvable parameters of the system.\n\nKeyword arguments\n\ntime_dependent_init: Whether to create an initialization system for a time-dependent system. A time-dependent initialization requires a time-dependent sys, but a time- independent initialization can be created regardless.\nop: The operating point of user-specified initial conditions of variables in sys.\ninitialization_eqs: Additional initialization equations to use apart from those in initialization_equations(sys).\nguesses: Additional guesses to use apart from those in guesses(sys).\ndefault_dd_guess: Default guess for dummy derivative variables in time-dependent initialization.\nalgebraic_only: If false, does not use initialization equations (provided via the keyword or part of the system) to construct initialization.\ncheck_defguess: Whether to error when a variable does not have a default or guess despite ModelingToolkit expecting it to.\nname: The name of the initialization system.\n\nAll other keyword arguments are forwarded to the System constructor.\n\n\n\n\n\n","category":"function"},{"location":"API/problems/#ModelingToolkit.InitializationProblem","page":"Building and solving numerical problems","title":"ModelingToolkit.InitializationProblem","text":"InitializationProblem(sys::AbstractSystem, t, op = Dict(); kwargs...)\nInitializationProblem{iip}(sys::AbstractSystem, t, op = Dict(); kwargs...)\nInitializationProblem{iip, specialize}(sys::AbstractSystem, t, op = Dict(); kwargs...)\n\nGenerate a NonlinearProblem, SCCNonlinearProblem or NonlinearLeastSquaresProblem to represent a consistent initialization of sys given the initial time t and operating point op. The initial time can be nothing for time-independent systems.\n\nKeyword arguments\n\nguesses: The guesses for variables in the system, used as initial values for the initialization problem.\nwarn_initialize_determined: Warn if the initialization system is under/over-determined.\ninitialization_eqs: Extra equations to use in the initialization problem.\nfully_determined: Override whether the initialization system is fully determined.\nuse_scc: Whether to use SCCNonlinearProblem for initialization if the system is fully determined.\ntime_dependent_init: Whether to build a time-dependent initialization for the problem. A time-dependent initialization solves for a consistent u0, whereas a time-independent one only runs parameter initialization.\nalgebraic_only: Whether to build the initialization problem using only algebraic equations.\nallow_incomplete: Whether to allow incomplete initialization problems.\n\nAll other keyword arguments are forwarded to the wrapped nonlinear problem constructor.\n\n\n\n\n\n","category":"type"},{"location":"API/problems/#Linear-analysis","page":"Building and solving numerical problems","title":"Linear analysis","text":"","category":"section"},{"location":"API/problems/#ModelingToolkit.linearization_function","page":"Building and solving numerical problems","title":"ModelingToolkit.linearization_function","text":"lin_fun, simplified_sys = linearization_function(sys::AbstractSystem, inputs, outputs; simplify = false, initialize = true, initialization_solver_alg = TrustRegion(), kwargs...)\n\nReturn a function that linearizes the system sys. The function linearize provides a higher-level and easier to use interface.\n\nlin_fun is a function (variables, p, t) -> (; f_x, f_z, g_x, g_z, f_u, g_u, h_x, h_z, h_u), i.e., it returns a NamedTuple with the Jacobians of f,g,h for the nonlinear sys (technically for simplified_sys) on the form\n\nbeginaligned\nx = f(x z u) \n0 = g(x z u) \ny = h(x z u)\nendaligned\n\nwhere x are differential unknown variables, z algebraic variables, u inputs and y outputs. To obtain a linear statespace representation, see linearize. The input argument variables is a vector defining the operating point, corresponding to unknowns(simplified_sys) and p is a vector corresponding to the parameters of simplified_sys. Note: all variables in inputs have been converted to parameters in simplified_sys.\n\nThe simplified_sys has undergone mtkcompile and had any occurring input or output variables replaced with the variables provided in arguments inputs and outputs. The unknowns of this system also indicate the order of the unknowns that holds for the linearized matrices.\n\nArguments:\n\nsys: A System of ODEs. This function will automatically apply simplification passes on sys and return the resulting simplified_sys.\ninputs: A vector of variables that indicate the inputs of the linearized input-output model.\noutputs: A vector of variables that indicate the outputs of the linearized input-output model.\nsimplify: Apply simplification in tearing.\ninitialize: If true, a check is performed to ensure that the operating point is consistent (satisfies algebraic equations). If the op is not consistent, initialization is performed.\ninitialization_solver_alg: A NonlinearSolve algorithm to use for solving for a feasible set of state and algebraic variables that satisfies the specified operating point.\nautodiff: An ADType supported by DifferentiationInterface.jl to use for calculating the necessary jacobians. Defaults to using AutoForwardDiff()\nkwargs: Are passed on to find_solvables!\n\nSee also linearize which provides a higher-level interface.\n\n\n\n\n\n","category":"function"},{"location":"API/problems/#ModelingToolkit.LinearizationProblem","page":"Building and solving numerical problems","title":"ModelingToolkit.LinearizationProblem","text":"mutable struct LinearizationProblem{F<:ModelingToolkit.LinearizationFunction, T}\n\nA struct representing a linearization operation to be performed. Can be symbolically indexed to efficiently update the operating point for multiple linearizations in a loop. The value of the independent variable can be set by mutating the .t field of this struct.\n\n\n\n\n\n","category":"type"},{"location":"API/problems/#ModelingToolkit.linearize","page":"Building and solving numerical problems","title":"ModelingToolkit.linearize","text":"(; A, B, C, D), simplified_sys, extras = linearize(sys, inputs, outputs;    t=0.0, op = Dict(), allow_input_derivatives = false, zero_dummy_der=false, kwargs...)\n(; A, B, C, D), extras                 = linearize(simplified_sys, lin_fun; t=0.0, op = Dict(), allow_input_derivatives = false, zero_dummy_der=false)\n\nLinearize sys between inputs and outputs, both vectors of variables. Return a NamedTuple with the matrices of a linear statespace representation on the form\n\nbeginaligned\nx = Ax + Bu\ny = Cx + Du\nendaligned\n\nThe first signature automatically calls linearization_function internally, while the second signature expects the outputs of linearization_function as input.\n\nop denotes the operating point around which to linearize. If none is provided, the default values of sys are used.\n\nIf allow_input_derivatives = false, an error will be thrown if input derivatives (u) appear as inputs in the linearized equations. If input derivatives are allowed, the returned B matrix will be of double width, corresponding to the input [u; u̇].\n\nzero_dummy_der can be set to automatically set the operating point to zero for all dummy derivatives.\n\nThe return value extras is a NamedTuple (; x, p, t) containing the result of the initialization problem that was solved to determine the operating point.\n\nSee also linearization_function which provides a lower-level interface, linearize_symbolic and ModelingToolkit.reorder_unknowns.\n\nSee extended help for an example.\n\nThe implementation and notation follows that of \"Linear Analysis Approach for Modelica Models\", Allain et al. 2009\n\nExtended help\n\nThis example builds the following feedback interconnection and linearizes it from the input of F to the output of P.\n\n\n  r ┌─────┐       ┌─────┐     ┌─────┐\n───►│     ├──────►│     │  u  │     │\n    │  F  │       │  C  ├────►│  P  │ y\n    └─────┘     ┌►│     │     │     ├─┬─►\n                │ └─────┘     └─────┘ │\n                │                     │\n                └─────────────────────┘\n\nusing ModelingToolkit\nusing ModelingToolkit: t_nounits as t, D_nounits as D\nfunction plant(; name)\n    @variables x(t) = 1\n    @variables u(t)=0 y(t)=0\n    eqs = [D(x) ~ -x + u\n           y ~ x]\n    System(eqs, t; name = name)\nend\n\nfunction ref_filt(; name)\n    @variables x(t)=0 y(t)=0\n    @variables u(t)=0 [input = true]\n    eqs = [D(x) ~ -2 * x + u\n           y ~ x]\n    System(eqs, t, name = name)\nend\n\nfunction controller(kp; name)\n    @variables y(t)=0 r(t)=0 u(t)=0\n    @parameters kp = kp\n    eqs = [\n        u ~ kp * (r - y),\n    ]\n    System(eqs, t; name = name)\nend\n\n@named f = ref_filt()\n@named c = controller(1)\n@named p = plant()\n\nconnections = [f.y ~ c.r # filtered reference to controller reference\n               c.u ~ p.u # controller output to plant input\n               p.y ~ c.y]\n\n@named cl = System(connections, t, systems = [f, c, p])\n\nlsys0, ssys = linearize(cl, [f.u], [p.x])\ndesired_order = [f.x, p.x]\nlsys = ModelingToolkit.reorder_unknowns(lsys0, unknowns(ssys), desired_order)\n\n@assert lsys.A == [-2 0; 1 -2]\n@assert lsys.B == [1; 0;;]\n@assert lsys.C == [0 1]\n@assert lsys.D[] == 0\n\n## Symbolic linearization\nlsys_sym, _ = ModelingToolkit.linearize_symbolic(cl, [f.u], [p.x])\n\n@assert substitute(lsys_sym.A, ModelingToolkit.defaults(cl)) == lsys.A\n\n\n\n\n\n","category":"function"},{"location":"API/problems/","page":"Building and solving numerical problems","title":"Building and solving numerical problems","text":"There are also utilities for manipulating the results of these analyses in a symbolic context.","category":"page"},{"location":"API/problems/#ModelingToolkit.similarity_transform","page":"Building and solving numerical problems","title":"ModelingToolkit.similarity_transform","text":"(; Ã, B̃, C̃, D̃) = similarity_transform(sys, T; unitary=false)\n\nPerform a similarity transform T : Tx̃ = x on linear system represented by matrices in NamedTuple sys such that\n\nÃ = T⁻¹AT\nB̃ = T⁻¹ B\nC̃ = CT\nD̃ = D\n\nIf unitary=true, T is assumed unitary and the matrix adjoint is used instead of the inverse.\n\n\n\n\n\n","category":"function"},{"location":"API/problems/#ModelingToolkit.reorder_unknowns","page":"Building and solving numerical problems","title":"ModelingToolkit.reorder_unknowns","text":"reorder_unknowns(sys::NamedTuple, old, new)\n\nPermute the state representation of sys obtained from linearize so that the state unknown is changed from old to new Example:\n\nlsys, ssys = linearize(pid, [reference.u, measurement.u], [ctr_output.u])\ndesired_order = [int.x, der.x] # Unknowns that are present in unknowns(ssys)\nlsys = ModelingToolkit.reorder_unknowns(lsys, unknowns(ssys), desired_order)\n\nSee also ModelingToolkit.similarity_transform\n\n\n\n\n\n","category":"function"},{"location":"API/problems/#Analysis-point-transformations","page":"Building and solving numerical problems","title":"Analysis point transformations","text":"","category":"section"},{"location":"API/problems/","page":"Building and solving numerical problems","title":"Building and solving numerical problems","text":"Linear analysis can also be done using analysis points to perform several common workflows.","category":"page"},{"location":"API/problems/#ModelingToolkit.get_sensitivity_function","page":"Building and solving numerical problems","title":"ModelingToolkit.get_sensitivity_function","text":"get_sensitivity_function(\n    sys::ModelingToolkit.AbstractSystem,\n    aps;\n    kwargs...\n) -> Tuple{ModelingToolkit.LinearizationFunction{DI, AI, _A, P, _B, _C, J1, J2, J3, J4, IA, @NamedTuple{abstol::Float64, reltol::Float64, nlsolve_alg::NonlinearSolveFirstOrder.GeneralizedFirstOrderAlgorithm{Missing, NonlinearSolveFirstOrder.GenericTrustRegionScheme{NonlinearSolveFirstOrder.RadiusUpdateSchemes.__Simple, Rational{Int64}, Rational{Int64}, Rational{Int64}, Rational{Int64}, Rational{Int64}, Rational{Int64}, Rational{Int64}}, NonlinearSolveBase.Dogleg{NonlinearSolveBase.NewtonDescent{Nothing}, NonlinearSolveBase.SteepestDescent{Nothing}}, Nothing, Nothing, Nothing, Val{false}}}} where {DI<:AbstractVector{Int64}, AI<:AbstractVector{Int64}, _A, P<:ODEProblem, _B, _C, J1<:Union{Nothing, ModelingToolkit.PreparedJacobian{true, DifferentiationInterfaceForwardDiffExt.ForwardDiffTwoArgJacobianPrep{Nothing, C, Tuple{Nothing, Nothing}}, ModelingToolkit.var\"#uff#953\"{var\"#1488#fun\"}, _A, ADTypes.AutoForwardDiff{nothing, Nothing}} where {C<:(ForwardDiff.JacobianConfig{T, _A, _B, <:Tuple{Any, Any}} where {T<:(ForwardDiff.Tag{F} where F<:ModelingToolkit.var\"#uff#953\"), _A, _B}), var\"#1488#fun\", _A}}, J2<:Union{Nothing, ModelingToolkit.PreparedJacobian{true, DifferentiationInterfaceForwardDiffExt.ForwardDiffTwoArgJacobianPrep{Nothing, C, Tuple{Nothing, Nothing}}, _A, _B, ADTypes.AutoForwardDiff{nothing, Nothing}} where {C<:ForwardDiff.JacobianConfig, _A, _B}}, J3<:Union{Nothing, ModelingToolkit.PreparedJacobian{true, DifferentiationInterfaceForwardDiffExt.ForwardDiffTwoArgJacobianPrep{Nothing, C, Tuple{Nothing, Nothing, Nothing}}, ModelingToolkit.var\"#pff#954\"{var\"#1489#fun\", var\"#1490#setter\"}, _A, ADTypes.AutoForwardDiff{nothing, Nothing}} where {C<:(ForwardDiff.JacobianConfig{T, _A, _B, <:Tuple{Any, Any}} where {T<:(ForwardDiff.Tag{F} where F<:ModelingToolkit.var\"#pff#954\"), _A, _B}), var\"#1489#fun\", var\"#1490#setter\", _A}}, J4<:(ModelingToolkit.PreparedJacobian{true, DifferentiationInterfaceForwardDiffExt.ForwardDiffTwoArgJacobianPrep{Nothing, C, Tuple{Nothing, Nothing, Nothing}}, ModelingToolkit.var\"#hpf#952\"{fun, setter}, _A, ADTypes.AutoForwardDiff{nothing, Nothing}} where {C<:(ForwardDiff.JacobianConfig{T, _A, _B, <:Tuple{Any, Any}} where {T<:(ForwardDiff.Tag{F} where F<:ModelingToolkit.var\"#hpf#952\"), _A, _B}), fun, setter, _A}), IA<:Union{SciMLBase.NoInit, SciMLBase.OverrideInit{Nothing, Nothing, Nothing}}}, Any}\n\n\nReturn the sensitivity function for the analysis point(s) aps, and the modified system simplified with the appropriate inputs and outputs.\n\nKeyword Arguments\n\n- `loop_openings`: A list of analysis points whose connections should be removed and\n  the outputs set to the input as a part of the linear analysis.\n\n- `system_modifier`: A function taking the transformed system and applying any\n  additional transformations, returning the modified system. The modified system\n  is passed to `linearization_function`.\n\nAll other keyword arguments are forwarded to linearization_function.\n\n\n\n\n\n","category":"function"},{"location":"API/problems/#ModelingToolkit.get_sensitivity","page":"Building and solving numerical problems","title":"ModelingToolkit.get_sensitivity","text":"    get_sensitivity(sys, ap::AnalysisPoint; kwargs)\n    get_sensitivity(sys, ap_name::Symbol; kwargs)\n\nCompute the sensitivity function in analysis point ap. The sensitivity function is obtained by introducing an infinitesimal perturbation d at the input of ap, linearizing the system and computing the transfer function between d and the output of ap.\n\nArguments:\n\nkwargs: Are sent to ModelingToolkit.linearize\n\nSee also get_comp_sensitivity, get_looptransfer.\n\n\n\n\n\n","category":"function"},{"location":"API/problems/#ModelingToolkit.get_comp_sensitivity_function","page":"Building and solving numerical problems","title":"ModelingToolkit.get_comp_sensitivity_function","text":"get_comp_sensitivity_function(\n    sys::ModelingToolkit.AbstractSystem,\n    aps;\n    kwargs...\n) -> Tuple{ModelingToolkit.LinearizationFunction{DI, AI, _A, P, _B, _C, J1, J2, J3, J4, IA, @NamedTuple{abstol::Float64, reltol::Float64, nlsolve_alg::NonlinearSolveFirstOrder.GeneralizedFirstOrderAlgorithm{Missing, NonlinearSolveFirstOrder.GenericTrustRegionScheme{NonlinearSolveFirstOrder.RadiusUpdateSchemes.__Simple, Rational{Int64}, Rational{Int64}, Rational{Int64}, Rational{Int64}, Rational{Int64}, Rational{Int64}, Rational{Int64}}, NonlinearSolveBase.Dogleg{NonlinearSolveBase.NewtonDescent{Nothing}, NonlinearSolveBase.SteepestDescent{Nothing}}, Nothing, Nothing, Nothing, Val{false}}}} where {DI<:AbstractVector{Int64}, AI<:AbstractVector{Int64}, _A, P<:ODEProblem, _B, _C, J1<:Union{Nothing, ModelingToolkit.PreparedJacobian{true, DifferentiationInterfaceForwardDiffExt.ForwardDiffTwoArgJacobianPrep{Nothing, C, Tuple{Nothing, Nothing}}, ModelingToolkit.var\"#uff#953\"{var\"#1488#fun\"}, _A, ADTypes.AutoForwardDiff{nothing, Nothing}} where {C<:(ForwardDiff.JacobianConfig{T, _A, _B, <:Tuple{Any, Any}} where {T<:(ForwardDiff.Tag{F} where F<:ModelingToolkit.var\"#uff#953\"), _A, _B}), var\"#1488#fun\", _A}}, J2<:Union{Nothing, ModelingToolkit.PreparedJacobian{true, DifferentiationInterfaceForwardDiffExt.ForwardDiffTwoArgJacobianPrep{Nothing, C, Tuple{Nothing, Nothing}}, _A, _B, ADTypes.AutoForwardDiff{nothing, Nothing}} where {C<:ForwardDiff.JacobianConfig, _A, _B}}, J3<:Union{Nothing, ModelingToolkit.PreparedJacobian{true, DifferentiationInterfaceForwardDiffExt.ForwardDiffTwoArgJacobianPrep{Nothing, C, Tuple{Nothing, Nothing, Nothing}}, ModelingToolkit.var\"#pff#954\"{var\"#1489#fun\", var\"#1490#setter\"}, _A, ADTypes.AutoForwardDiff{nothing, Nothing}} where {C<:(ForwardDiff.JacobianConfig{T, _A, _B, <:Tuple{Any, Any}} where {T<:(ForwardDiff.Tag{F} where F<:ModelingToolkit.var\"#pff#954\"), _A, _B}), var\"#1489#fun\", var\"#1490#setter\", _A}}, J4<:(ModelingToolkit.PreparedJacobian{true, DifferentiationInterfaceForwardDiffExt.ForwardDiffTwoArgJacobianPrep{Nothing, C, Tuple{Nothing, Nothing, Nothing}}, ModelingToolkit.var\"#hpf#952\"{fun, setter}, _A, ADTypes.AutoForwardDiff{nothing, Nothing}} where {C<:(ForwardDiff.JacobianConfig{T, _A, _B, <:Tuple{Any, Any}} where {T<:(ForwardDiff.Tag{F} where F<:ModelingToolkit.var\"#hpf#952\"), _A, _B}), fun, setter, _A}), IA<:Union{SciMLBase.NoInit, SciMLBase.OverrideInit{Nothing, Nothing, Nothing}}}, Any}\n\n\nReturn the complementary sensitivity function for the analysis point(s) aps, and the modified system simplified with the appropriate inputs and outputs.\n\nKeyword Arguments\n\n- `loop_openings`: A list of analysis points whose connections should be removed and\n  the outputs set to the input as a part of the linear analysis.\n\n- `system_modifier`: A function taking the transformed system and applying any\n  additional transformations, returning the modified system. The modified system\n  is passed to `linearization_function`.\n\nAll other keyword arguments are forwarded to linearization_function.\n\n\n\n\n\n","category":"function"},{"location":"API/problems/#ModelingToolkit.get_comp_sensitivity","page":"Building and solving numerical problems","title":"ModelingToolkit.get_comp_sensitivity","text":"get_comp_sensitivity(sys, ap::AnalysisPoint; kwargs)\nget_comp_sensitivity(sys, ap_name::Symbol; kwargs)\n\nCompute the complementary sensitivity function in analysis point ap. The complementary sensitivity function is obtained by introducing an infinitesimal perturbation d at the output of ap, linearizing the system and computing the transfer function between d and the input of ap.\n\nArguments:\n\nkwargs: Are sent to ModelingToolkit.linearize\n\nSee also get_sensitivity, get_looptransfer.\n\n\n\n\n\n","category":"function"},{"location":"API/problems/#ModelingToolkit.get_looptransfer_function","page":"Building and solving numerical problems","title":"ModelingToolkit.get_looptransfer_function","text":"get_looptransfer_function(\n    sys::ModelingToolkit.AbstractSystem,\n    aps;\n    kwargs...\n) -> Tuple{ModelingToolkit.LinearizationFunction{DI, AI, _A, P, _B, _C, J1, J2, J3, J4, IA, @NamedTuple{abstol::Float64, reltol::Float64, nlsolve_alg::NonlinearSolveFirstOrder.GeneralizedFirstOrderAlgorithm{Missing, NonlinearSolveFirstOrder.GenericTrustRegionScheme{NonlinearSolveFirstOrder.RadiusUpdateSchemes.__Simple, Rational{Int64}, Rational{Int64}, Rational{Int64}, Rational{Int64}, Rational{Int64}, Rational{Int64}, Rational{Int64}}, NonlinearSolveBase.Dogleg{NonlinearSolveBase.NewtonDescent{Nothing}, NonlinearSolveBase.SteepestDescent{Nothing}}, Nothing, Nothing, Nothing, Val{false}}}} where {DI<:AbstractVector{Int64}, AI<:AbstractVector{Int64}, _A, P<:ODEProblem, _B, _C, J1<:Union{Nothing, ModelingToolkit.PreparedJacobian{true, DifferentiationInterfaceForwardDiffExt.ForwardDiffTwoArgJacobianPrep{Nothing, C, Tuple{Nothing, Nothing}}, ModelingToolkit.var\"#uff#953\"{var\"#1488#fun\"}, _A, ADTypes.AutoForwardDiff{nothing, Nothing}} where {C<:(ForwardDiff.JacobianConfig{T, _A, _B, <:Tuple{Any, Any}} where {T<:(ForwardDiff.Tag{F} where F<:ModelingToolkit.var\"#uff#953\"), _A, _B}), var\"#1488#fun\", _A}}, J2<:Union{Nothing, ModelingToolkit.PreparedJacobian{true, DifferentiationInterfaceForwardDiffExt.ForwardDiffTwoArgJacobianPrep{Nothing, C, Tuple{Nothing, Nothing}}, _A, _B, ADTypes.AutoForwardDiff{nothing, Nothing}} where {C<:ForwardDiff.JacobianConfig, _A, _B}}, J3<:Union{Nothing, ModelingToolkit.PreparedJacobian{true, DifferentiationInterfaceForwardDiffExt.ForwardDiffTwoArgJacobianPrep{Nothing, C, Tuple{Nothing, Nothing, Nothing}}, ModelingToolkit.var\"#pff#954\"{var\"#1489#fun\", var\"#1490#setter\"}, _A, ADTypes.AutoForwardDiff{nothing, Nothing}} where {C<:(ForwardDiff.JacobianConfig{T, _A, _B, <:Tuple{Any, Any}} where {T<:(ForwardDiff.Tag{F} where F<:ModelingToolkit.var\"#pff#954\"), _A, _B}), var\"#1489#fun\", var\"#1490#setter\", _A}}, J4<:(ModelingToolkit.PreparedJacobian{true, DifferentiationInterfaceForwardDiffExt.ForwardDiffTwoArgJacobianPrep{Nothing, C, Tuple{Nothing, Nothing, Nothing}}, ModelingToolkit.var\"#hpf#952\"{fun, setter}, _A, ADTypes.AutoForwardDiff{nothing, Nothing}} where {C<:(ForwardDiff.JacobianConfig{T, _A, _B, <:Tuple{Any, Any}} where {T<:(ForwardDiff.Tag{F} where F<:ModelingToolkit.var\"#hpf#952\"), _A, _B}), fun, setter, _A}), IA<:Union{SciMLBase.NoInit, SciMLBase.OverrideInit{Nothing, Nothing, Nothing}}}, Any}\n\n\nReturn the loop-transfer function for the analysis point(s) aps, and the modified system simplified with the appropriate inputs and outputs.\n\nKeyword Arguments\n\n- `loop_openings`: A list of analysis points whose connections should be removed and\n  the outputs set to the input as a part of the linear analysis.\n\n- `system_modifier`: A function taking the transformed system and applying any\n  additional transformations, returning the modified system. The modified system\n  is passed to `linearization_function`.\n\nAll other keyword arguments are forwarded to linearization_function.\n\n\n\n\n\n","category":"function"},{"location":"API/problems/#ModelingToolkit.get_looptransfer","page":"Building and solving numerical problems","title":"ModelingToolkit.get_looptransfer","text":"get_looptransfer(sys, ap::AnalysisPoint; kwargs)\nget_looptransfer(sys, ap_name::Symbol; kwargs)\n\nCompute the (linearized) loop-transfer function in analysis point ap, from ap.out to ap.in.\n\ninfo: Negative feedback\nFeedback loops often use negative feedback, and the computed loop-transfer function will in this case have the negative feedback included. Standard analysis tools often assume a loop-transfer function without the negative gain built in, and the result of this function may thus need negation before use.\n\nArguments:\n\nkwargs: Are sent to ModelingToolkit.linearize\n\nSee also get_sensitivity, get_comp_sensitivity, open_loop.\n\n\n\n\n\n","category":"function"},{"location":"API/problems/#ModelingToolkit.open_loop","page":"Building and solving numerical problems","title":"ModelingToolkit.open_loop","text":"open_loop(\n    sys,\n    ap::Union{Symbol, AnalysisPoint};\n    system_modifier\n) -> Tuple{Any, Tuple{Any, Any}}\n\n\nApply LoopTransferTransform to the analysis point ap and return the result of apply_transformation.\n\nKeyword Arguments\n\nsystem_modifier: a function which takes the modified system and returns a new system with any required further modifications performed.\n\n\n\n\n\n","category":"function"},{"location":"examples/modelingtoolkitize_index_reduction/#Automated-Index-Reduction-of-DAEs","page":"Automated Index Reduction of DAEs","title":"Automated Index Reduction of DAEs","text":"","category":"section"},{"location":"examples/modelingtoolkitize_index_reduction/","page":"Automated Index Reduction of DAEs","title":"Automated Index Reduction of DAEs","text":"In many cases one may accidentally write down a DAE that is not easily solvable by numerical methods. In this tutorial, we will walk through an example of a pendulum which accidentally generates an index-3 DAE, and show how to use the modelingtoolkitize to correct the model definition before solving.","category":"page"},{"location":"examples/modelingtoolkitize_index_reduction/#Copy-Pastable-Example","page":"Automated Index Reduction of DAEs","title":"Copy-Pastable Example","text":"","category":"section"},{"location":"examples/modelingtoolkitize_index_reduction/","page":"Automated Index Reduction of DAEs","title":"Automated Index Reduction of DAEs","text":"using ModelingToolkit\nusing LinearAlgebra\nusing OrdinaryDiffEq\nusing Plots\n\nfunction pendulum!(du, u, p, t)\n    x, dx, y, dy, T = u\n    g, L = p\n    du[1] = dx\n    du[2] = T * x\n    du[3] = dy\n    du[4] = T * y - g\n    du[5] = x^2 + y^2 - L^2\n    return nothing\nend\npendulum_fun! = ODEFunction(pendulum!, mass_matrix = Diagonal([1, 1, 1, 1, 0]))\nu0 = [1.0, 0, 0, 0, 0]\np = [9.8, 1]\ntspan = (0, 10.0)\npendulum_prob = ODEProblem(pendulum_fun!, u0, tspan, p)\ntraced_sys = modelingtoolkitize(pendulum_prob)\npendulum_sys = mtkcompile(dae_index_lowering(traced_sys))\nprob = ODEProblem(pendulum_sys, [], tspan)\nsol = solve(prob, Rodas5P(), abstol = 1e-8, reltol = 1e-8)\nplot(sol, idxs = unknowns(traced_sys))","category":"page"},{"location":"examples/modelingtoolkitize_index_reduction/#Explanation","page":"Automated Index Reduction of DAEs","title":"Explanation","text":"","category":"section"},{"location":"examples/modelingtoolkitize_index_reduction/#Attempting-to-Solve-the-Equation","page":"Automated Index Reduction of DAEs","title":"Attempting to Solve the Equation","text":"","category":"section"},{"location":"examples/modelingtoolkitize_index_reduction/","page":"Automated Index Reduction of DAEs","title":"Automated Index Reduction of DAEs","text":"In this tutorial, we will look at the pendulum system:","category":"page"},{"location":"examples/modelingtoolkitize_index_reduction/","page":"Automated Index Reduction of DAEs","title":"Automated Index Reduction of DAEs","text":"beginaligned\n    x^prime = v_x\n    v_x^prime = Tx\n    y^prime = v_y\n    v_y^prime = Ty - g\n    0 = x^2 + y^2 - L^2\nendaligned","category":"page"},{"location":"examples/modelingtoolkitize_index_reduction/","page":"Automated Index Reduction of DAEs","title":"Automated Index Reduction of DAEs","text":"These equations can be derived using the Lagrangian equation of the first kind. Specifically, for a pendulum with unit mass and length L, which thus has kinetic energy frac12(v_x^2 + v_y^2), potential energy gy, and holonomic constraint x^2 + y^2 - L^2 = 0. The Lagrange multiplier related to this constraint is equal to half of T, and represents the tension in the rope of the pendulum.","category":"page"},{"location":"examples/modelingtoolkitize_index_reduction/","page":"Automated Index Reduction of DAEs","title":"Automated Index Reduction of DAEs","text":"As a good DifferentialEquations.jl user, one would follow the mass matrix DAE tutorial to arrive at code for simulating the model:","category":"page"},{"location":"examples/modelingtoolkitize_index_reduction/","page":"Automated Index Reduction of DAEs","title":"Automated Index Reduction of DAEs","text":"using OrdinaryDiffEq, LinearAlgebra\nfunction pendulum!(du, u, p, t)\n    x, dx, y, dy, T = u\n    g, L = p\n    du[1] = dx\n    du[2] = T * x\n    du[3] = dy\n    du[4] = T * y - g\n    du[5] = x^2 + y^2 - L^2\nend\npendulum_fun! = ODEFunction(pendulum!, mass_matrix = Diagonal([1, 1, 1, 1, 0]))\nu0 = [1.0, 0, 0, 0, 0];\np = [9.8, 1];\ntspan = (0, 10.0);\npendulum_prob = ODEProblem(pendulum_fun!, u0, tspan, p)\nsolve(pendulum_prob, Rodas5P())","category":"page"},{"location":"examples/modelingtoolkitize_index_reduction/","page":"Automated Index Reduction of DAEs","title":"Automated Index Reduction of DAEs","text":"However, one will quickly be greeted with the unfortunate message:","category":"page"},{"location":"examples/modelingtoolkitize_index_reduction/","page":"Automated Index Reduction of DAEs","title":"Automated Index Reduction of DAEs","text":"┌ Warning: First function call produced NaNs. Exiting.\n└ @ OrdinaryDiffEq C:\\Users\\accou\\.julia\\packages\\OrdinaryDiffEq\\yCczp\\src\\initdt.jl:76\n┌ Warning: Automatic dt set the starting dt as NaN, causing instability.\n└ @ OrdinaryDiffEq C:\\Users\\accou\\.julia\\packages\\OrdinaryDiffEq\\yCczp\\src\\solve.jl:485\n┌ Warning: NaN dt detected. Likely a NaN value in the unknowns, parameters, or derivative value caused this outcome.\n└ @ SciMLBase C:\\Users\\accou\\.julia\\packages\\SciMLBase\\DrPil\\src\\integrator_interface.jl:325","category":"page"},{"location":"examples/modelingtoolkitize_index_reduction/","page":"Automated Index Reduction of DAEs","title":"Automated Index Reduction of DAEs","text":"Did you implement the DAE incorrectly? No. Is the solver broken? No.","category":"page"},{"location":"examples/modelingtoolkitize_index_reduction/#Understanding-DAE-Index","page":"Automated Index Reduction of DAEs","title":"Understanding DAE Index","text":"","category":"section"},{"location":"examples/modelingtoolkitize_index_reduction/","page":"Automated Index Reduction of DAEs","title":"Automated Index Reduction of DAEs","text":"It turns out that this is a property of the DAE that we are attempting to solve. This kind of DAE is known as an index-3 DAE. For a complete discussion of DAE index, see this article. Essentially, the issue here is that we have 4 differential variables (x, v_x, y, v_y) and one algebraic variable T (which we can know because there is no D(T) term in the equations). An index-1 DAE always satisfies that the Jacobian of the algebraic equations is non-singular. Here, the first 4 equations are differential equations, with the last term the algebraic relationship. However, the partial derivative of x^2 + y^2 - L^2 w.r.t. T is zero, and thus the Jacobian of the algebraic equations is the zero matrix, and thus it's singular. This is a rapid way to see whether the DAE is index 1!","category":"page"},{"location":"examples/modelingtoolkitize_index_reduction/","page":"Automated Index Reduction of DAEs","title":"Automated Index Reduction of DAEs","text":"The problem with higher order DAEs is that the matrices used in Newton solves are singular or close to singular when applied to such problems. Because of this fact, the nonlinear solvers (or Rosenbrock methods) break down, making them difficult to solve. The classic paper DAEs are not ODEs goes into detail on this and shows that many methods are no longer convergent when index is higher than one. So, it's not necessarily the fault of the solver or the implementation: this is known.","category":"page"},{"location":"examples/modelingtoolkitize_index_reduction/","page":"Automated Index Reduction of DAEs","title":"Automated Index Reduction of DAEs","text":"But that's not a satisfying answer, so what do you do about it?","category":"page"},{"location":"examples/modelingtoolkitize_index_reduction/#Transforming-Higher-Order-DAEs-to-Index-1-DAEs","page":"Automated Index Reduction of DAEs","title":"Transforming Higher Order DAEs to Index-1 DAEs","text":"","category":"section"},{"location":"examples/modelingtoolkitize_index_reduction/","page":"Automated Index Reduction of DAEs","title":"Automated Index Reduction of DAEs","text":"It turns out that higher order DAEs can be transformed into lower order DAEs. If you differentiate the last equation two times and perform a substitution, you can arrive at the following set of equations:","category":"page"},{"location":"examples/modelingtoolkitize_index_reduction/","page":"Automated Index Reduction of DAEs","title":"Automated Index Reduction of DAEs","text":"beginaligned\nx^prime = v_x \nv_x^prime = x T \ny^prime = v_y \nv_y^prime = y T - g \n0 = 2 left(v_x^2 + v_y^2 + y ( y T - g ) + T x^2 right)\nendaligned","category":"page"},{"location":"examples/modelingtoolkitize_index_reduction/","page":"Automated Index Reduction of DAEs","title":"Automated Index Reduction of DAEs","text":"Note that this is mathematically-equivalent to the equation that we had before, but the Jacobian w.r.t. T of the algebraic equation is no longer zero because of the substitution. This means that if you wrote down this version of the model, it will be index-1 and solve correctly! In fact, this is how DAE index is commonly defined: the number of differentiations it takes to transform the DAE into an ODE, where an ODE is an index-0 DAE by substituting out all of the algebraic relationships.","category":"page"},{"location":"examples/modelingtoolkitize_index_reduction/#Automating-the-Index-Reduction","page":"Automated Index Reduction of DAEs","title":"Automating the Index Reduction","text":"","category":"section"},{"location":"examples/modelingtoolkitize_index_reduction/","page":"Automated Index Reduction of DAEs","title":"Automated Index Reduction of DAEs","text":"However, requiring the user to sit there and work through this process on potentially millions of equations is an unfathomable mental overhead. But, we can avoid this by using methods like the Pantelides algorithm for automatically performing this reduction to index 1. While this requires the ModelingToolkit symbolic form, we use modelingtoolkitize to transform the numerical code into symbolic code, run dae_index_lowering lowering, then transform back to numerical code with ODEProblem, and solve with a numerical solver. Let's try that out:","category":"page"},{"location":"examples/modelingtoolkitize_index_reduction/","page":"Automated Index Reduction of DAEs","title":"Automated Index Reduction of DAEs","text":"traced_sys = modelingtoolkitize(pendulum_prob)\npendulum_sys = mtkcompile(dae_index_lowering(traced_sys))\nprob = ODEProblem(pendulum_sys, Pair[], tspan)\nsol = solve(prob, Rodas5P())\n\nusing Plots\nplot(sol, idxs = unknowns(traced_sys))","category":"page"},{"location":"examples/modelingtoolkitize_index_reduction/","page":"Automated Index Reduction of DAEs","title":"Automated Index Reduction of DAEs","text":"Note that plotting using unknowns(traced_sys) is done so that any variables which are symbolically eliminated, or any variable reordering done for enhanced parallelism/performance, still show up in the resulting plot and the plot is shown in the same order as the original numerical code.","category":"page"},{"location":"basics/Precompilation/#Working-with-Precompilation-and-Binary-Building","page":"Working with Precompilation and Binary Building","title":"Working with Precompilation and Binary Building","text":"","category":"section"},{"location":"basics/Precompilation/#tl;dr,-I-just-want-precompilation-to-work","page":"Working with Precompilation and Binary Building","title":"tl;dr, I just want precompilation to work","text":"","category":"section"},{"location":"basics/Precompilation/","page":"Working with Precompilation and Binary Building","title":"Working with Precompilation and Binary Building","text":"The tl;dr is, if you want to make precompilation work then instead of","category":"page"},{"location":"basics/Precompilation/","page":"Working with Precompilation and Binary Building","title":"Working with Precompilation and Binary Building","text":"ODEProblem(sys, u0, tspan, p)","category":"page"},{"location":"basics/Precompilation/","page":"Working with Precompilation and Binary Building","title":"Working with Precompilation and Binary Building","text":"use:","category":"page"},{"location":"basics/Precompilation/","page":"Working with Precompilation and Binary Building","title":"Working with Precompilation and Binary Building","text":"ODEProblem(sys, u0, tspan, p, eval_module = @__MODULE__, eval_expression = true)","category":"page"},{"location":"basics/Precompilation/","page":"Working with Precompilation and Binary Building","title":"Working with Precompilation and Binary Building","text":"As a full example, here's an example of a module that would precompile effectively:","category":"page"},{"location":"basics/Precompilation/","page":"Working with Precompilation and Binary Building","title":"Working with Precompilation and Binary Building","text":"module PrecompilationMWE\nusing ModelingToolkit\n\n@variables x(ModelingToolkit.t_nounits)\n@named sys = System([ModelingToolkit.D_nounits(x) ~ -x + 1], ModelingToolkit.t_nounits)\nprob = ODEProblem(mtkcompile(sys), [x => 30.0], (0, 100), [],\n    eval_expression = true, eval_module = @__MODULE__)\n\nend","category":"page"},{"location":"basics/Precompilation/","page":"Working with Precompilation and Binary Building","title":"Working with Precompilation and Binary Building","text":"If you use that in your package's code then 99% of the time that's the right answer to get precompilation working.","category":"page"},{"location":"basics/Precompilation/#I'm-doing-something-fancier-and-need-a-bit-more-of-an-explanation","page":"Working with Precompilation and Binary Building","title":"I'm doing something fancier and need a bit more of an explanation","text":"","category":"section"},{"location":"basics/Precompilation/","page":"Working with Precompilation and Binary Building","title":"Working with Precompilation and Binary Building","text":"Oh you dapper soul, time for the bigger explanation. Julia's eval function evaluates a function into a module at a specified world-age. If you evaluate a function within a function and try to call it from within that same function, you will hit a world-age error. This looks like:","category":"page"},{"location":"basics/Precompilation/","page":"Working with Precompilation and Binary Building","title":"Working with Precompilation and Binary Building","text":"function worldageerror()\n    f = eval(:((x) -> 2x))\n    f(2)\nend","category":"page"},{"location":"basics/Precompilation/","page":"Working with Precompilation and Binary Building","title":"Working with Precompilation and Binary Building","text":"julia> worldageerror()\nERROR: MethodError: no method matching (::var\"#5#6\")(::Int64)\n\nClosest candidates are:\n  (::var\"#5#6\")(::Any) (method too new to be called from this world context.)\n   @ Main REPL[12]:2","category":"page"},{"location":"basics/Precompilation/","page":"Working with Precompilation and Binary Building","title":"Working with Precompilation and Binary Building","text":"This is done for many reasons, in particular if the code that is called within a function could change at any time, then Julia functions could not ever properly optimize because the meaning of any function or dispatch could always change and you would lose performance by guarding against that. For a full discussion of world-age, see this paper.","category":"page"},{"location":"basics/Precompilation/","page":"Working with Precompilation and Binary Building","title":"Working with Precompilation and Binary Building","text":"However, this would be greatly inhibiting to standard ModelingToolkit usage because then something as simple as building an ODEProblem in a function and then using it would get a world age error:","category":"page"},{"location":"basics/Precompilation/","page":"Working with Precompilation and Binary Building","title":"Working with Precompilation and Binary Building","text":"function wouldworldage()\n    prob = ODEProblem(sys, [], (0.0, 1.0))\n    sol = solve(prob)\nend","category":"page"},{"location":"basics/Precompilation/","page":"Working with Precompilation and Binary Building","title":"Working with Precompilation and Binary Building","text":"The reason is because prob.f would be constructed via eval, and thus prob.f could not be called in the function, which means that no solve could ever work in the same function that generated the problem. That does mean that:","category":"page"},{"location":"basics/Precompilation/","page":"Working with Precompilation and Binary Building","title":"Working with Precompilation and Binary Building","text":"function wouldworldage()\n    prob = ODEProblem(sys, [], (0.0, 1.0))\nend\nsol = solve(prob)","category":"page"},{"location":"basics/Precompilation/","page":"Working with Precompilation and Binary Building","title":"Working with Precompilation and Binary Building","text":"is fine, or putting","category":"page"},{"location":"basics/Precompilation/","page":"Working with Precompilation and Binary Building","title":"Working with Precompilation and Binary Building","text":"prob = ODEProblem(sys, [], (0.0, 1.0))\nsol = solve(prob)","category":"page"},{"location":"basics/Precompilation/","page":"Working with Precompilation and Binary Building","title":"Working with Precompilation and Binary Building","text":"at the top level of a module is perfectly fine too. They just cannot happen in the same function.","category":"page"},{"location":"basics/Precompilation/","page":"Working with Precompilation and Binary Building","title":"Working with Precompilation and Binary Building","text":"This would be a major limitation to ModelingToolkit, and thus we developed RuntimeGeneratedFunctions to get around this limitation. It will not be described beyond that, it is dark art and should not be investigated. But it does the job. But that does mean that it plays... oddly with Julia's compilation.","category":"page"},{"location":"basics/Precompilation/","page":"Working with Precompilation and Binary Building","title":"Working with Precompilation and Binary Building","text":"There are ways to force RuntimeGeneratedFunctions to perform their evaluation and caching within a given module, but that is not recommended because it does not play nicely with Julia v1.9's introduction of package images for binary caching.","category":"page"},{"location":"basics/Precompilation/","page":"Working with Precompilation and Binary Building","title":"Working with Precompilation and Binary Building","text":"Thus when trying to make things work with precompilation, we recommend using eval. This is done by simply adding eval_expression=true to the problem constructor. However, this is not a silver bullet because the moment you start using eval, all potential world-age restrictions apply, and thus it is recommended this is simply used for evaluating at the top level of modules for the purpose of precompilation and ensuring binaries of your MTK functions are built correctly.","category":"page"},{"location":"basics/Precompilation/","page":"Working with Precompilation and Binary Building","title":"Working with Precompilation and Binary Building","text":"However, there is one caveat that eval in Julia works depending on the module that it is given. If you have MyPackage that you are precompiling into, or say you are using juliac or PackageCompiler or some other static ahead-of-time (AOT) Julia compiler, then you don't want to accidentally eval that function to live in ModelingToolkit and instead want to make sure it is eval'd to live in MyPackage (since otherwise it will not cache into the binary). ModelingToolkit cannot know that in advance, and thus you have to pass in the module you wish for the functions to \"live\" in. This is done via the eval_module argument.","category":"page"},{"location":"basics/Precompilation/","page":"Working with Precompilation and Binary Building","title":"Working with Precompilation and Binary Building","text":"Hence ODEProblem(sys, u0, tspan, p, eval_module=@__MODULE__, eval_expression=true) will work if you are running this expression in the scope of the module you wish to be precompiling. However, if you are attempting to AOT compile a different module, this means that eval_module needs to be appropriately chosen. And, because eval_expression=true, all caveats of world-age apply.","category":"page"},{"location":"tutorials/optimization/#Modeling-Optimization-Problems","page":"Modeling Optimization Problems","title":"Modeling Optimization Problems","text":"","category":"section"},{"location":"tutorials/optimization/","page":"Modeling Optimization Problems","title":"Modeling Optimization Problems","text":"ModelingToolkit.jl is not only useful for generating initial value problems (ODEProblem). The package can also build optimization systems.","category":"page"},{"location":"tutorials/optimization/","page":"Modeling Optimization Problems","title":"Modeling Optimization Problems","text":"note: Note\nThe high level @mtkmodel macro used in the getting started tutorial is not yet compatible with OptimizationSystem. We thus have to use a lower level interface to define optimization systems. For an introduction to this interface, read the programmatically generating Systems tutorial.","category":"page"},{"location":"tutorials/optimization/#Unconstrained-Rosenbrock-Function","page":"Modeling Optimization Problems","title":"Unconstrained Rosenbrock Function","text":"","category":"section"},{"location":"tutorials/optimization/","page":"Modeling Optimization Problems","title":"Modeling Optimization Problems","text":"Let's optimize the classical Rosenbrock function in two dimensions.","category":"page"},{"location":"tutorials/optimization/","page":"Modeling Optimization Problems","title":"Modeling Optimization Problems","text":"using ModelingToolkit, Optimization, OptimizationOptimJL\n@variables begin\n    x = 1.0, [bounds = (-2.0, 2.0)]\n    y = 3.0, [bounds = (-1.0, 3.0)]\nend\n@parameters a=1.0 b=1.0\nrosenbrock = (a - x)^2 + b * (y - x^2)^2\n@mtkcompile sys = OptimizationSystem(rosenbrock, [x, y], [a, b])","category":"page"},{"location":"tutorials/optimization/","page":"Modeling Optimization Problems","title":"Modeling Optimization Problems","text":"Every optimization problem consists of a set of optimization variables. In this case, we create two variables: x and y, with initial guesses 1 and 3 for their optimal values. Additionally, we assign box constraints for each of them, using bounds, Bounds is an example of symbolic metadata. Fore more information, take a look at the symbolic metadata documentation page.","category":"page"},{"location":"tutorials/optimization/","page":"Modeling Optimization Problems","title":"Modeling Optimization Problems","text":"We also create two parameters with @parameters. Parameters are useful if you want to solve the same optimization problem multiple times, with different values for these parameters. Default values for these parameters can also be assigned, here 1 is used for both a and b. These optimization values and parameters are used in an objective function, here the Rosenbrock function.","category":"page"},{"location":"tutorials/optimization/","page":"Modeling Optimization Problems","title":"Modeling Optimization Problems","text":"Next, the actual OptimizationProblem can be created. The initial guesses for the optimization variables can be overwritten, via an array of Pairs, in the second argument of OptimizationProblem. Values for the parameters of the system can also be overwritten from their default values, in the third argument of OptimizationProblem. ModelingToolkit is also capable of constructing analytical gradients and Hessians of the objective function.","category":"page"},{"location":"tutorials/optimization/","page":"Modeling Optimization Problems","title":"Modeling Optimization Problems","text":"u0 = [y => 2.0]\np = [b => 100.0]\n\nprob = OptimizationProblem(sys, vcat(u0, p), grad = true, hess = true)\nu_opt = solve(prob, GradientDescent())","category":"page"},{"location":"tutorials/optimization/","page":"Modeling Optimization Problems","title":"Modeling Optimization Problems","text":"A visualization of the Rosenbrock function is depicted below.","category":"page"},{"location":"tutorials/optimization/","page":"Modeling Optimization Problems","title":"Modeling Optimization Problems","text":"using Plots\nx_plot = -2:0.01:2\ny_plot = -1:0.01:3\ncontour(\n    x_plot, y_plot, (x, y) -> (1 - x)^2 + 100 * (y - x^2)^2, fill = true, color = :viridis,\n    ratio = :equal, xlims = (-2, 2))\nscatter!([u_opt[1]], [u_opt[2]], ms = 10, label = \"minimum\")","category":"page"},{"location":"tutorials/optimization/#Rosenbrock-Function-with-Constraints","page":"Modeling Optimization Problems","title":"Rosenbrock Function with Constraints","text":"","category":"section"},{"location":"tutorials/optimization/","page":"Modeling Optimization Problems","title":"Modeling Optimization Problems","text":"ModelingToolkit is also capable of handing more complicated constraints than box constraints. Non-linear equality and inequality constraints can be added to the OptimizationSystem. Let's add an inequality constraint to the previous example:","category":"page"},{"location":"tutorials/optimization/","page":"Modeling Optimization Problems","title":"Modeling Optimization Problems","text":"using ModelingToolkit, Optimization, OptimizationOptimJL\n\n@variables begin\n    x = 0.14, [bounds = (-2.0, 2.0)]\n    y = 0.14, [bounds = (-1.0, 3.0)]\nend\n@parameters a=1.0 b=100.0\nrosenbrock = (a - x)^2 + b * (y - x^2)^2\ncons = [\n    x^2 + y^2 ≲ 1\n]\n@mtkcompile sys = OptimizationSystem(rosenbrock, [x, y], [a, b], constraints = cons)\nprob = OptimizationProblem(sys, [], grad = true, hess = true, cons_j = true, cons_h = true)\nu_opt = solve(prob, IPNewton())","category":"page"},{"location":"tutorials/optimization/","page":"Modeling Optimization Problems","title":"Modeling Optimization Problems","text":"Inequality constraints are constructed via a ≲ (or ≳). (To write these symbols in your own code write \\lesssim or \\gtrsim and then press tab.) An equality constraint can be specified via a ~, e.g., x^2 + y^2 ~ 1.","category":"page"},{"location":"tutorials/optimization/","page":"Modeling Optimization Problems","title":"Modeling Optimization Problems","text":"A visualization of the Rosenbrock function and the inequality constraint is depicted below.","category":"page"},{"location":"tutorials/optimization/","page":"Modeling Optimization Problems","title":"Modeling Optimization Problems","text":"using Plots\nx_plot = -2:0.01:2\ny_plot = -1:0.01:3\ncontour(\n    x_plot, y_plot, (x, y) -> (1 - x)^2 + 100 * (y - x^2)^2, fill = true, color = :viridis,\n    ratio = :equal, xlims = (-2, 2))\ncontour!(x_plot, y_plot, (x, y) -> x^2 + y^2, levels = [1], color = :lightblue, line = 4)\nscatter!([u_opt[1]], [u_opt[2]], ms = 10, label = \"minimum\")","category":"page"},{"location":"tutorials/optimization/#Nested-Systems","page":"Modeling Optimization Problems","title":"Nested Systems","text":"","category":"section"},{"location":"tutorials/optimization/","page":"Modeling Optimization Problems","title":"Modeling Optimization Problems","text":"Needs more text, but it's super cool and auto-parallelizes and sparsifies too. Plus, you can hierarchically nest systems to have it generate huge optimization problems.","category":"page"},{"location":"tutorials/linear_analysis/#Linear-Analysis","page":"Linear Analysis","title":"Linear Analysis","text":"","category":"section"},{"location":"tutorials/linear_analysis/","page":"Linear Analysis","title":"Linear Analysis","text":"Linear analysis refers to the process of linearizing a nonlinear model and analysing the resulting linear dynamical system. To facilitate linear analysis, ModelingToolkit provides the concept of an AnalysisPoint, which can be inserted in-between two causal blocks (such as those from ModelingToolkitStandardLibrary.Blocks sub module). Once a model containing analysis points is built, several operations are available:","category":"page"},{"location":"tutorials/linear_analysis/","page":"Linear Analysis","title":"Linear Analysis","text":"get_sensitivity get the sensitivity function (wiki), S(s), as defined in the field of control theory.\nget_comp_sensitivity get the complementary sensitivity function T(s)  S(s)+T(s)=1.\nget_looptransfer get the (open) loop-transfer function where the loop starts and ends in the analysis point. For a typical simple feedback connection with a plant P(s) and a controller C(s), the loop-transfer function at the plant output is P(s)C(s).\nlinearize can be called with two analysis points denoting the input and output of the linearized system.\nopen_loop return a new (nonlinear) system where the loop has been broken in the analysis point, i.e., the connection the analysis point usually implies has been removed.","category":"page"},{"location":"tutorials/linear_analysis/","page":"Linear Analysis","title":"Linear Analysis","text":"An analysis point can be created explicitly using the constructor AnalysisPoint, or automatically when connecting two causal components using connect:","category":"page"},{"location":"tutorials/linear_analysis/","page":"Linear Analysis","title":"Linear Analysis","text":"connect(comp1.output, :analysis_point_name, comp2.input)","category":"page"},{"location":"tutorials/linear_analysis/","page":"Linear Analysis","title":"Linear Analysis","text":"A single output can also be connected to multiple inputs:","category":"page"},{"location":"tutorials/linear_analysis/","page":"Linear Analysis","title":"Linear Analysis","text":"connect(comp1.output, :analysis_point_name, comp2.input, comp3.input, comp4.input)","category":"page"},{"location":"tutorials/linear_analysis/","page":"Linear Analysis","title":"Linear Analysis","text":"warning: Causality\nAnalysis points are causal, i.e., they imply a directionality for the flow of information. The order of the connections in the connect statement is thus important, i.e., connect(out, :name, in) is different from connect(in, :name, out).","category":"page"},{"location":"tutorials/linear_analysis/","page":"Linear Analysis","title":"Linear Analysis","text":"The directionality of an analysis point can be thought of as an arrow in a block diagram, where the name of the analysis point applies to the arrow itself.","category":"page"},{"location":"tutorials/linear_analysis/","page":"Linear Analysis","title":"Linear Analysis","text":"┌─────┐         ┌─────┐\n│     │  name   │     │\n│  out├────────►│in   │\n│     │         │     │\n└─────┘         └─────┘","category":"page"},{"location":"tutorials/linear_analysis/","page":"Linear Analysis","title":"Linear Analysis","text":"This is signified by the name being the middle argument to connect.","category":"page"},{"location":"tutorials/linear_analysis/","page":"Linear Analysis","title":"Linear Analysis","text":"Of the above mentioned functions, all except for open_loop return the output of ModelingToolkit.linearize, which is","category":"page"},{"location":"tutorials/linear_analysis/","page":"Linear Analysis","title":"Linear Analysis","text":"matrices, simplified_sys = linearize(_...)\n# matrices = (; A, B, C, D)","category":"page"},{"location":"tutorials/linear_analysis/","page":"Linear Analysis","title":"Linear Analysis","text":"i.e., matrices is a named tuple containing the matrices of a linear state-space system on the form","category":"page"},{"location":"tutorials/linear_analysis/","page":"Linear Analysis","title":"Linear Analysis","text":"beginaligned\ndot x = Ax + Bu\ny = Cx + Du\nendaligned","category":"page"},{"location":"tutorials/linear_analysis/#Example","page":"Linear Analysis","title":"Example","text":"","category":"section"},{"location":"tutorials/linear_analysis/","page":"Linear Analysis","title":"Linear Analysis","text":"The following example builds a simple closed-loop system with a plant P and a controller C. Two analysis points are inserted, one before and one after P. We then derive a number of sensitivity functions and show the corresponding code using the package ControlSystemBase.jl","category":"page"},{"location":"tutorials/linear_analysis/","page":"Linear Analysis","title":"Linear Analysis","text":"using ModelingToolkitStandardLibrary.Blocks, ModelingToolkit\nusing ModelingToolkit: t_nounits as t\n\n@named P = FirstOrder(k = 1, T = 1) # A first-order system with pole in -1\n@named C = Gain(-1)             # A P controller\n\neqs = [connect(P.output, :plant_output, C.input)  # Connect with an automatically created analysis point called :plant_output\n       connect(C.output, :plant_input, P.input)]\nsys = System(eqs, t, systems = [P, C], name = :feedback_system)\n\nmatrices_S = get_sensitivity(sys, :plant_input)[1] # Compute the matrices of a state-space representation of the (input)sensitivity function.\nmatrices_T = get_comp_sensitivity(sys, :plant_input)[1]","category":"page"},{"location":"tutorials/linear_analysis/","page":"Linear Analysis","title":"Linear Analysis","text":"Continued linear analysis and design can be performed using ControlSystemsBase.jl. We create ControlSystemsBase.StateSpace objects using","category":"page"},{"location":"tutorials/linear_analysis/","page":"Linear Analysis","title":"Linear Analysis","text":"using ControlSystemsBase, Plots\nS = ss(matrices_S...)\nT = ss(matrices_T...)\nbodeplot([S, T], lab = [\"S\" \"\" \"T\" \"\"], plot_title = \"Bode plot of sensitivity functions\",\n    margin = 5Plots.mm)","category":"page"},{"location":"tutorials/linear_analysis/","page":"Linear Analysis","title":"Linear Analysis","text":"The sensitivity functions obtained this way should be equivalent to the ones obtained with the code below","category":"page"},{"location":"tutorials/linear_analysis/","page":"Linear Analysis","title":"Linear Analysis","text":"using ControlSystemsBase\nP = tf(1.0, [1, 1]) |> ss\nC = 1                      # Negative feedback assumed in ControlSystems\nS = sensitivity(P, C)      # or feedback(1, P*C)\nT = comp_sensitivity(P, C) # or feedback(P*C)","category":"page"},{"location":"tutorials/linear_analysis/","page":"Linear Analysis","title":"Linear Analysis","text":"We may also derive the loop-transfer function L(s) = P(s)C(s) using","category":"page"},{"location":"tutorials/linear_analysis/","page":"Linear Analysis","title":"Linear Analysis","text":"matrices_L = get_looptransfer(sys, :plant_output)[1]\nL = ss(matrices_L...)","category":"page"},{"location":"tutorials/linear_analysis/","page":"Linear Analysis","title":"Linear Analysis","text":"which is equivalent to the following with ControlSystems","category":"page"},{"location":"tutorials/linear_analysis/","page":"Linear Analysis","title":"Linear Analysis","text":"L = P * (-C) # Add the minus sign to build the negative feedback into the controller","category":"page"},{"location":"tutorials/linear_analysis/","page":"Linear Analysis","title":"Linear Analysis","text":"To obtain the transfer function between two analysis points, we call linearize","category":"page"},{"location":"tutorials/linear_analysis/","page":"Linear Analysis","title":"Linear Analysis","text":"using ModelingToolkit # hide\nmatrices_PS = linearize(sys, :plant_input, :plant_output)[1]","category":"page"},{"location":"tutorials/linear_analysis/","page":"Linear Analysis","title":"Linear Analysis","text":"this particular transfer function should be equivalent to the linear system P(s)S(s), i.e., equivalent to","category":"page"},{"location":"tutorials/linear_analysis/","page":"Linear Analysis","title":"Linear Analysis","text":"feedback(P, C)","category":"page"},{"location":"tutorials/linear_analysis/#Obtaining-transfer-functions","page":"Linear Analysis","title":"Obtaining transfer functions","text":"","category":"section"},{"location":"tutorials/linear_analysis/","page":"Linear Analysis","title":"Linear Analysis","text":"A statespace system from ControlSystemsBase can be converted to a transfer function using the function tf:","category":"page"},{"location":"tutorials/linear_analysis/","page":"Linear Analysis","title":"Linear Analysis","text":"tf(S)","category":"page"},{"location":"tutorials/linear_analysis/#Gain-and-phase-margins","page":"Linear Analysis","title":"Gain and phase margins","text":"","category":"section"},{"location":"tutorials/linear_analysis/","page":"Linear Analysis","title":"Linear Analysis","text":"Further linear analysis can be performed using the analysis methods from ControlSystemsBase. For example, calculating the gain and phase margins of a system can be done using","category":"page"},{"location":"tutorials/linear_analysis/","page":"Linear Analysis","title":"Linear Analysis","text":"margin(P)","category":"page"},{"location":"tutorials/linear_analysis/","page":"Linear Analysis","title":"Linear Analysis","text":"(they are infinite for this system). A Nyquist plot can be produced using","category":"page"},{"location":"tutorials/linear_analysis/","page":"Linear Analysis","title":"Linear Analysis","text":"nyquistplot(P)","category":"page"},{"location":"tutorials/linear_analysis/#Index","page":"Linear Analysis","title":"Index","text":"","category":"section"},{"location":"tutorials/linear_analysis/","page":"Linear Analysis","title":"Linear Analysis","text":"Pages = [\"linear_analysis.md\"]","category":"page"},{"location":"tutorials/linear_analysis/#ModelingToolkit.connect-Tuple{ModelingToolkit.AbstractSystem, Symbol, Any, Vararg{Any}}-tutorials-linear_analysis","page":"Linear Analysis","title":"ModelingToolkit.connect","text":"connect(output_connector, ap_name::Symbol, input_connector; verbose = true)\nconnect(output_connector, ap::AnalysisPoint, input_connector; verbose = true)\n\nConnect output_connector and input_connector with an AnalysisPoint inbetween. The incoming connection output_connector is expected to be an output connector (for example, ModelingToolkitStandardLibrary.Blocks.RealOutput), and vice versa.\n\nPLEASE NOTE: The connection is assumed to be causal, meaning that\n\n@named P = FirstOrder(k = 1, T = 1)\n@named C = Gain(; k = -1)\nconnect(C.output, :plant_input, P.input)\n\nis correct, whereas\n\nconnect(P.input, :plant_input, C.output)\n\ntypically is not (unless the model is an inverse model).\n\nArguments\n\noutput_connector: An output connector\ninput_connector: An input connector\nap: An explicitly created AnalysisPoint\nap_name: If a name is given, an AnalysisPoint with the given name will be created automatically.\n\nKeyword arguments\n\nverbose: Warn if an input is connected to an output (reverse causality). Silence this warning if you are analyzing an inverse model.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/linear_analysis/#ModelingToolkit.get_comp_sensitivity-tutorials-linear_analysis","page":"Linear Analysis","title":"ModelingToolkit.get_comp_sensitivity","text":"get_comp_sensitivity(sys, ap::AnalysisPoint; kwargs)\nget_comp_sensitivity(sys, ap_name::Symbol; kwargs)\n\nCompute the complementary sensitivity function in analysis point ap. The complementary sensitivity function is obtained by introducing an infinitesimal perturbation d at the output of ap, linearizing the system and computing the transfer function between d and the input of ap.\n\nArguments:\n\nkwargs: Are sent to ModelingToolkit.linearize\n\nSee also get_sensitivity, get_looptransfer.\n\n\n\n\n\n","category":"function"},{"location":"tutorials/linear_analysis/#ModelingToolkit.get_comp_sensitivity_function-Tuple{ModelingToolkit.AbstractSystem, Any}-tutorials-linear_analysis","page":"Linear Analysis","title":"ModelingToolkit.get_comp_sensitivity_function","text":"get_comp_sensitivity_function(\n    sys::ModelingToolkit.AbstractSystem,\n    aps;\n    kwargs...\n) -> Tuple{ModelingToolkit.LinearizationFunction{DI, AI, _A, P, _B, _C, J1, J2, J3, J4, IA, @NamedTuple{abstol::Float64, reltol::Float64, nlsolve_alg::NonlinearSolveFirstOrder.GeneralizedFirstOrderAlgorithm{Missing, NonlinearSolveFirstOrder.GenericTrustRegionScheme{NonlinearSolveFirstOrder.RadiusUpdateSchemes.__Simple, Rational{Int64}, Rational{Int64}, Rational{Int64}, Rational{Int64}, Rational{Int64}, Rational{Int64}, Rational{Int64}}, NonlinearSolveBase.Dogleg{NonlinearSolveBase.NewtonDescent{Nothing}, NonlinearSolveBase.SteepestDescent{Nothing}}, Nothing, Nothing, Nothing, Val{false}}}} where {DI<:AbstractVector{Int64}, AI<:AbstractVector{Int64}, _A, P<:ODEProblem, _B, _C, J1<:Union{Nothing, ModelingToolkit.PreparedJacobian{true, DifferentiationInterfaceForwardDiffExt.ForwardDiffTwoArgJacobianPrep{Nothing, C, Tuple{Nothing, Nothing}}, ModelingToolkit.var\"#uff#953\"{var\"#1488#fun\"}, _A, ADTypes.AutoForwardDiff{nothing, Nothing}} where {C<:(ForwardDiff.JacobianConfig{T, _A, _B, <:Tuple{Any, Any}} where {T<:(ForwardDiff.Tag{F} where F<:ModelingToolkit.var\"#uff#953\"), _A, _B}), var\"#1488#fun\", _A}}, J2<:Union{Nothing, ModelingToolkit.PreparedJacobian{true, DifferentiationInterfaceForwardDiffExt.ForwardDiffTwoArgJacobianPrep{Nothing, C, Tuple{Nothing, Nothing}}, _A, _B, ADTypes.AutoForwardDiff{nothing, Nothing}} where {C<:ForwardDiff.JacobianConfig, _A, _B}}, J3<:Union{Nothing, ModelingToolkit.PreparedJacobian{true, DifferentiationInterfaceForwardDiffExt.ForwardDiffTwoArgJacobianPrep{Nothing, C, Tuple{Nothing, Nothing, Nothing}}, ModelingToolkit.var\"#pff#954\"{var\"#1489#fun\", var\"#1490#setter\"}, _A, ADTypes.AutoForwardDiff{nothing, Nothing}} where {C<:(ForwardDiff.JacobianConfig{T, _A, _B, <:Tuple{Any, Any}} where {T<:(ForwardDiff.Tag{F} where F<:ModelingToolkit.var\"#pff#954\"), _A, _B}), var\"#1489#fun\", var\"#1490#setter\", _A}}, J4<:(ModelingToolkit.PreparedJacobian{true, DifferentiationInterfaceForwardDiffExt.ForwardDiffTwoArgJacobianPrep{Nothing, C, Tuple{Nothing, Nothing, Nothing}}, ModelingToolkit.var\"#hpf#952\"{fun, setter}, _A, ADTypes.AutoForwardDiff{nothing, Nothing}} where {C<:(ForwardDiff.JacobianConfig{T, _A, _B, <:Tuple{Any, Any}} where {T<:(ForwardDiff.Tag{F} where F<:ModelingToolkit.var\"#hpf#952\"), _A, _B}), fun, setter, _A}), IA<:Union{SciMLBase.NoInit, SciMLBase.OverrideInit{Nothing, Nothing, Nothing}}}, Any}\n\n\nReturn the complementary sensitivity function for the analysis point(s) aps, and the modified system simplified with the appropriate inputs and outputs.\n\nKeyword Arguments\n\n- `loop_openings`: A list of analysis points whose connections should be removed and\n  the outputs set to the input as a part of the linear analysis.\n\n- `system_modifier`: A function taking the transformed system and applying any\n  additional transformations, returning the modified system. The modified system\n  is passed to `linearization_function`.\n\nAll other keyword arguments are forwarded to linearization_function.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/linear_analysis/#ModelingToolkit.get_looptransfer-tutorials-linear_analysis","page":"Linear Analysis","title":"ModelingToolkit.get_looptransfer","text":"get_looptransfer(sys, ap::AnalysisPoint; kwargs)\nget_looptransfer(sys, ap_name::Symbol; kwargs)\n\nCompute the (linearized) loop-transfer function in analysis point ap, from ap.out to ap.in.\n\ninfo: Negative feedback\nFeedback loops often use negative feedback, and the computed loop-transfer function will in this case have the negative feedback included. Standard analysis tools often assume a loop-transfer function without the negative gain built in, and the result of this function may thus need negation before use.\n\nArguments:\n\nkwargs: Are sent to ModelingToolkit.linearize\n\nSee also get_sensitivity, get_comp_sensitivity, open_loop.\n\n\n\n\n\n","category":"function"},{"location":"tutorials/linear_analysis/#ModelingToolkit.get_looptransfer_function-Tuple{ModelingToolkit.AbstractSystem, Any}-tutorials-linear_analysis","page":"Linear Analysis","title":"ModelingToolkit.get_looptransfer_function","text":"get_looptransfer_function(\n    sys::ModelingToolkit.AbstractSystem,\n    aps;\n    kwargs...\n) -> Tuple{ModelingToolkit.LinearizationFunction{DI, AI, _A, P, _B, _C, J1, J2, J3, J4, IA, @NamedTuple{abstol::Float64, reltol::Float64, nlsolve_alg::NonlinearSolveFirstOrder.GeneralizedFirstOrderAlgorithm{Missing, NonlinearSolveFirstOrder.GenericTrustRegionScheme{NonlinearSolveFirstOrder.RadiusUpdateSchemes.__Simple, Rational{Int64}, Rational{Int64}, Rational{Int64}, Rational{Int64}, Rational{Int64}, Rational{Int64}, Rational{Int64}}, NonlinearSolveBase.Dogleg{NonlinearSolveBase.NewtonDescent{Nothing}, NonlinearSolveBase.SteepestDescent{Nothing}}, Nothing, Nothing, Nothing, Val{false}}}} where {DI<:AbstractVector{Int64}, AI<:AbstractVector{Int64}, _A, P<:ODEProblem, _B, _C, J1<:Union{Nothing, ModelingToolkit.PreparedJacobian{true, DifferentiationInterfaceForwardDiffExt.ForwardDiffTwoArgJacobianPrep{Nothing, C, Tuple{Nothing, Nothing}}, ModelingToolkit.var\"#uff#953\"{var\"#1488#fun\"}, _A, ADTypes.AutoForwardDiff{nothing, Nothing}} where {C<:(ForwardDiff.JacobianConfig{T, _A, _B, <:Tuple{Any, Any}} where {T<:(ForwardDiff.Tag{F} where F<:ModelingToolkit.var\"#uff#953\"), _A, _B}), var\"#1488#fun\", _A}}, J2<:Union{Nothing, ModelingToolkit.PreparedJacobian{true, DifferentiationInterfaceForwardDiffExt.ForwardDiffTwoArgJacobianPrep{Nothing, C, Tuple{Nothing, Nothing}}, _A, _B, ADTypes.AutoForwardDiff{nothing, Nothing}} where {C<:ForwardDiff.JacobianConfig, _A, _B}}, J3<:Union{Nothing, ModelingToolkit.PreparedJacobian{true, DifferentiationInterfaceForwardDiffExt.ForwardDiffTwoArgJacobianPrep{Nothing, C, Tuple{Nothing, Nothing, Nothing}}, ModelingToolkit.var\"#pff#954\"{var\"#1489#fun\", var\"#1490#setter\"}, _A, ADTypes.AutoForwardDiff{nothing, Nothing}} where {C<:(ForwardDiff.JacobianConfig{T, _A, _B, <:Tuple{Any, Any}} where {T<:(ForwardDiff.Tag{F} where F<:ModelingToolkit.var\"#pff#954\"), _A, _B}), var\"#1489#fun\", var\"#1490#setter\", _A}}, J4<:(ModelingToolkit.PreparedJacobian{true, DifferentiationInterfaceForwardDiffExt.ForwardDiffTwoArgJacobianPrep{Nothing, C, Tuple{Nothing, Nothing, Nothing}}, ModelingToolkit.var\"#hpf#952\"{fun, setter}, _A, ADTypes.AutoForwardDiff{nothing, Nothing}} where {C<:(ForwardDiff.JacobianConfig{T, _A, _B, <:Tuple{Any, Any}} where {T<:(ForwardDiff.Tag{F} where F<:ModelingToolkit.var\"#hpf#952\"), _A, _B}), fun, setter, _A}), IA<:Union{SciMLBase.NoInit, SciMLBase.OverrideInit{Nothing, Nothing, Nothing}}}, Any}\n\n\nReturn the loop-transfer function for the analysis point(s) aps, and the modified system simplified with the appropriate inputs and outputs.\n\nKeyword Arguments\n\n- `loop_openings`: A list of analysis points whose connections should be removed and\n  the outputs set to the input as a part of the linear analysis.\n\n- `system_modifier`: A function taking the transformed system and applying any\n  additional transformations, returning the modified system. The modified system\n  is passed to `linearization_function`.\n\nAll other keyword arguments are forwarded to linearization_function.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/linear_analysis/#ModelingToolkit.get_sensitivity-tutorials-linear_analysis","page":"Linear Analysis","title":"ModelingToolkit.get_sensitivity","text":"    get_sensitivity(sys, ap::AnalysisPoint; kwargs)\n    get_sensitivity(sys, ap_name::Symbol; kwargs)\n\nCompute the sensitivity function in analysis point ap. The sensitivity function is obtained by introducing an infinitesimal perturbation d at the input of ap, linearizing the system and computing the transfer function between d and the output of ap.\n\nArguments:\n\nkwargs: Are sent to ModelingToolkit.linearize\n\nSee also get_comp_sensitivity, get_looptransfer.\n\n\n\n\n\n","category":"function"},{"location":"tutorials/linear_analysis/#ModelingToolkit.get_sensitivity_function-Tuple{ModelingToolkit.AbstractSystem, Any}-tutorials-linear_analysis","page":"Linear Analysis","title":"ModelingToolkit.get_sensitivity_function","text":"get_sensitivity_function(\n    sys::ModelingToolkit.AbstractSystem,\n    aps;\n    kwargs...\n) -> Tuple{ModelingToolkit.LinearizationFunction{DI, AI, _A, P, _B, _C, J1, J2, J3, J4, IA, @NamedTuple{abstol::Float64, reltol::Float64, nlsolve_alg::NonlinearSolveFirstOrder.GeneralizedFirstOrderAlgorithm{Missing, NonlinearSolveFirstOrder.GenericTrustRegionScheme{NonlinearSolveFirstOrder.RadiusUpdateSchemes.__Simple, Rational{Int64}, Rational{Int64}, Rational{Int64}, Rational{Int64}, Rational{Int64}, Rational{Int64}, Rational{Int64}}, NonlinearSolveBase.Dogleg{NonlinearSolveBase.NewtonDescent{Nothing}, NonlinearSolveBase.SteepestDescent{Nothing}}, Nothing, Nothing, Nothing, Val{false}}}} where {DI<:AbstractVector{Int64}, AI<:AbstractVector{Int64}, _A, P<:ODEProblem, _B, _C, J1<:Union{Nothing, ModelingToolkit.PreparedJacobian{true, DifferentiationInterfaceForwardDiffExt.ForwardDiffTwoArgJacobianPrep{Nothing, C, Tuple{Nothing, Nothing}}, ModelingToolkit.var\"#uff#953\"{var\"#1488#fun\"}, _A, ADTypes.AutoForwardDiff{nothing, Nothing}} where {C<:(ForwardDiff.JacobianConfig{T, _A, _B, <:Tuple{Any, Any}} where {T<:(ForwardDiff.Tag{F} where F<:ModelingToolkit.var\"#uff#953\"), _A, _B}), var\"#1488#fun\", _A}}, J2<:Union{Nothing, ModelingToolkit.PreparedJacobian{true, DifferentiationInterfaceForwardDiffExt.ForwardDiffTwoArgJacobianPrep{Nothing, C, Tuple{Nothing, Nothing}}, _A, _B, ADTypes.AutoForwardDiff{nothing, Nothing}} where {C<:ForwardDiff.JacobianConfig, _A, _B}}, J3<:Union{Nothing, ModelingToolkit.PreparedJacobian{true, DifferentiationInterfaceForwardDiffExt.ForwardDiffTwoArgJacobianPrep{Nothing, C, Tuple{Nothing, Nothing, Nothing}}, ModelingToolkit.var\"#pff#954\"{var\"#1489#fun\", var\"#1490#setter\"}, _A, ADTypes.AutoForwardDiff{nothing, Nothing}} where {C<:(ForwardDiff.JacobianConfig{T, _A, _B, <:Tuple{Any, Any}} where {T<:(ForwardDiff.Tag{F} where F<:ModelingToolkit.var\"#pff#954\"), _A, _B}), var\"#1489#fun\", var\"#1490#setter\", _A}}, J4<:(ModelingToolkit.PreparedJacobian{true, DifferentiationInterfaceForwardDiffExt.ForwardDiffTwoArgJacobianPrep{Nothing, C, Tuple{Nothing, Nothing, Nothing}}, ModelingToolkit.var\"#hpf#952\"{fun, setter}, _A, ADTypes.AutoForwardDiff{nothing, Nothing}} where {C<:(ForwardDiff.JacobianConfig{T, _A, _B, <:Tuple{Any, Any}} where {T<:(ForwardDiff.Tag{F} where F<:ModelingToolkit.var\"#hpf#952\"), _A, _B}), fun, setter, _A}), IA<:Union{SciMLBase.NoInit, SciMLBase.OverrideInit{Nothing, Nothing, Nothing}}}, Any}\n\n\nReturn the sensitivity function for the analysis point(s) aps, and the modified system simplified with the appropriate inputs and outputs.\n\nKeyword Arguments\n\n- `loop_openings`: A list of analysis points whose connections should be removed and\n  the outputs set to the input as a part of the linear analysis.\n\n- `system_modifier`: A function taking the transformed system and applying any\n  additional transformations, returning the modified system. The modified system\n  is passed to `linearization_function`.\n\nAll other keyword arguments are forwarded to linearization_function.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/linear_analysis/#ModelingToolkit.linearization_ap_transform-Tuple{Any, Union{Vector{Symbol}, Vector{AnalysisPoint}, Symbol, AnalysisPoint}, Any, Any}-tutorials-linear_analysis","page":"Linear Analysis","title":"ModelingToolkit.linearization_ap_transform","text":"sys, input_vars, output_vars =\n\nlinearization_ap_transform(\n    sys,\n    inputs::Union{Vector{Symbol}, Vector{AnalysisPoint}, Symbol, AnalysisPoint},\n    outputs,\n    loop_openings\n) -> Tuple{Any, Vector{Any}, Vector{Any}}\n\n\nApply analysis-point transformations to prepare a system for linearization.\n\nReturns\n\nsys: The transformed system.\ninput_vars: A vector of input variables corresponding to the input analysis points.\noutput_vars: A vector of output variables corresponding to the output analysis points.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/linear_analysis/#ModelingToolkit.open_loop-Tuple{Any, Union{Symbol, AnalysisPoint}}-tutorials-linear_analysis","page":"Linear Analysis","title":"ModelingToolkit.open_loop","text":"open_loop(\n    sys,\n    ap::Union{Symbol, AnalysisPoint};\n    system_modifier\n) -> Tuple{Any, Tuple{Any, Any}}\n\n\nApply LoopTransferTransform to the analysis point ap and return the result of apply_transformation.\n\nKeyword Arguments\n\nsystem_modifier: a function which takes the modified system and returns a new system with any required further modifications performed.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/linear_analysis/#ModelingToolkit.AnalysisPoint-Tuple{Symbol}-tutorials-linear_analysis","page":"Linear Analysis","title":"ModelingToolkit.AnalysisPoint","text":"AnalysisPoint(name::Symbol) -> AnalysisPoint\n\n\nCreate an AnalysisPoint with the given name, with no input or outputs specified.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/linear_analysis/#ModelingToolkit.AnalysisPoint-tutorials-linear_analysis","page":"Linear Analysis","title":"ModelingToolkit.AnalysisPoint","text":"struct AnalysisPoint\n\nAnalysisPoint(input, name::Symbol, outputs::Vector)\n\nCreate an AnalysisPoint for linear analysis. Analysis points can be created by calling\n\nconnect(out, :ap_name, in...)\n\nWhere out is the output being connected to the inputs in.... All involved connectors (input and outputs) are required to either have an unknown named u or a single unknown, all of which should have the same size.\n\nSee also get_sensitivity, get_comp_sensitivity, get_looptransfer, open_loop\n\nFields\n\ninput::Any: The input to the connection. In the context of ModelingToolkitStandardLibrary.jl, this is a RealOutput connector.\n\nname::Symbol: The name of the analysis point.\n\noutputs::Union{Nothing, Vector{Any}}: The outputs of the connection. In the context of ModelingToolkitStandardLibrary.jl, these are all RealInput connectors.\n\nExample\n\nusing ModelingToolkit\nusing ModelingToolkitStandardLibrary.Blocks\nusing ModelingToolkit: t_nounits as t\n\n@named P = FirstOrder(k = 1, T = 1)\n@named C = Gain(; k = -1)\nt = ModelingToolkit.get_iv(P)\n\neqs = [connect(P.output, C.input)\n       connect(C.output, :plant_input, P.input)]\nsys = System(eqs, t, systems = [P, C], name = :feedback_system)\n\nmatrices_S, _ = get_sensitivity(sys, :plant_input) # Compute the matrices of a state-space representation of the (input) sensitivity function.\nmatrices_T, _ = get_comp_sensitivity(sys, :plant_input)\n\nContinued linear analysis and design can be performed using ControlSystemsBase.jl. Create ControlSystemsBase.StateSpace objects using\n\nusing ControlSystemsBase, Plots\nS = ss(matrices_S...)\nT = ss(matrices_T...)\nbodeplot([S, T], lab = [\"S\" \"T\"])\n\nThe sensitivity functions obtained this way should be equivalent to the ones obtained with the code below\n\nusing ControlSystemsBase\nP = tf(1.0, [1, 1])\nC = 1                      # Negative feedback assumed in ControlSystems\nS = sensitivity(P, C)      # or feedback(1, P*C)\nT = comp_sensitivity(P, C) # or feedback(P*C)\n\n\n\n\n\n","category":"type"},{"location":"tutorials/stochastic_diffeq/#Modeling-with-Stochasticity","page":"Modeling with Stochasticity","title":"Modeling with Stochasticity","text":"","category":"section"},{"location":"tutorials/stochastic_diffeq/","page":"Modeling with Stochasticity","title":"Modeling with Stochasticity","text":"All previous differential equations tutorials deal with deterministic Systems. In this tutorial, we add randomness. In particular, we show how to represent a stochastic differential equation as a SDESystem.","category":"page"},{"location":"tutorials/stochastic_diffeq/","page":"Modeling with Stochasticity","title":"Modeling with Stochasticity","text":"note: Note\nThe high level @mtkmodel macro used in the getting started tutorial is not yet compatible with SDESystem. We thus have to use a lower level interface to define stochastic differential equations. For an introduction to this interface, read the programmatically generating Systems tutorial.","category":"page"},{"location":"tutorials/stochastic_diffeq/","page":"Modeling with Stochasticity","title":"Modeling with Stochasticity","text":"Let's take the Lorenz equation and add noise to each of the states. To show the flexibility of ModelingToolkit, we do not use homogeneous noise, with constant variance, but instead use heterogeneous noise, where the magnitude of the noise scales with (0.3 times) the magnitude of each of the states:","category":"page"},{"location":"tutorials/stochastic_diffeq/","page":"Modeling with Stochasticity","title":"Modeling with Stochasticity","text":"beginaligned\nfracdxdt = (sigma (y-x))  + 03xfracdBdt \nfracdydt = (x(rho-z) - y) + 03yfracdBdt  \nfracdzdt = (xy - beta z)  + 03zfracdBdt  \nendaligned","category":"page"},{"location":"tutorials/stochastic_diffeq/","page":"Modeling with Stochasticity","title":"Modeling with Stochasticity","text":"Where B, is standard Brownian motion, also called the Wiener process. We use notation similar to the Langevin equation, often used in physics. By \"multiplying\" the equations by dt, the notation used in probability theory can be recovered.","category":"page"},{"location":"tutorials/stochastic_diffeq/","page":"Modeling with Stochasticity","title":"Modeling with Stochasticity","text":"We use this Langevin-like notation because it allows us to extend MTK modeling capacity from ODEs to SDEs, using only a single new concept, @brownians variables, which represent fracdBdt in the above equation.","category":"page"},{"location":"tutorials/stochastic_diffeq/","page":"Modeling with Stochasticity","title":"Modeling with Stochasticity","text":"using ModelingToolkit, StochasticDiffEq\nusing ModelingToolkit: t_nounits as t, D_nounits as D\nusing Plots\n\n@parameters σ=10.0 ρ=2.33 β=26.0\n@variables x(t)=5.0 y(t)=5.0 z(t)=1.0\n@brownians B\neqs = [D(x) ~ σ * (y - x) + 0.3x * B,\n    D(y) ~ x * (ρ - z) - y + 0.3y * B,\n    D(z) ~ x * y - β * z + 0.3z * B]\n\n@mtkcompile de = System(eqs, t)","category":"page"},{"location":"tutorials/stochastic_diffeq/","page":"Modeling with Stochasticity","title":"Modeling with Stochasticity","text":"Even though we did not explicitly use SDESystem, ModelingToolkit can still infer this from the equations.","category":"page"},{"location":"tutorials/stochastic_diffeq/","page":"Modeling with Stochasticity","title":"Modeling with Stochasticity","text":"typeof(de)","category":"page"},{"location":"tutorials/stochastic_diffeq/","page":"Modeling with Stochasticity","title":"Modeling with Stochasticity","text":"We continue by solving and plotting the SDE.","category":"page"},{"location":"tutorials/stochastic_diffeq/","page":"Modeling with Stochasticity","title":"Modeling with Stochasticity","text":"prob = SDEProblem(de, [], (0.0, 100.0))\nsol = solve(prob, SRIW1())\nplot(sol, idxs = [(1, 2, 3)])","category":"page"},{"location":"tutorials/stochastic_diffeq/","page":"Modeling with Stochasticity","title":"Modeling with Stochasticity","text":"The noise present in all 3 equations is correlated, as can be seen on the below figure. The figure also shows the multiplicative nature of the noise. Because states x and y generally take on larger values, the noise also takes on a more pronounced effect on these states compared to the state z.","category":"page"},{"location":"tutorials/stochastic_diffeq/","page":"Modeling with Stochasticity","title":"Modeling with Stochasticity","text":"plot(sol)","category":"page"},{"location":"tutorials/stochastic_diffeq/","page":"Modeling with Stochasticity","title":"Modeling with Stochasticity","text":"If you want uncorrelated noise for each equation, multiple @brownians variables have to be declared.","category":"page"},{"location":"tutorials/stochastic_diffeq/","page":"Modeling with Stochasticity","title":"Modeling with Stochasticity","text":"@brownians Bx By Bz\neqs = [D(x) ~ σ * (y - x) + 0.3x * Bx,\n    D(y) ~ x * (ρ - z) - y + 0.3y * By,\n    D(z) ~ x * y - β * z + 0.3z * Bz]\n@mtkcompile de = System(eqs, t)\nprob = SDEProblem(de, [], (0.0, 100.0))\nsol = solve(prob, SRIW1())\nplot(sol)","category":"page"},{"location":"API/model_building/#model_building_api","page":"Model building reference","title":"Model building reference","text":"","category":"section"},{"location":"API/model_building/","page":"Model building reference","title":"Model building reference","text":"This page lists functionality and utilities related to building hierarchical models. It is recommended to read the page on the System before this.","category":"page"},{"location":"API/model_building/#Hierarchical-model-composition","page":"Model building reference","title":"Hierarchical model composition","text":"","category":"section"},{"location":"API/model_building/","page":"Model building reference","title":"Model building reference","text":"The System data structure can represent a tree-like hierarchy of systems for building models from composable blocks. The ModelingToolkit.get_systems function can be used for querying the subsystems of a system. The @component macro should be used when writing building blocks for model composition.","category":"page"},{"location":"API/model_building/#ModelingToolkit.@component","page":"Model building reference","title":"ModelingToolkit.@component","text":"Mark a system constructor function as building a component. For example,\n\n@component function AddOne(; name)\n    @variables in(t) out(t)\n    eqs = [out ~ in + 1]\n    return System(eqs, t, [in, out], []; name)\nend\n\nModelingToolkit systems are either components or connectors. Components define dynamics of the model. Connectors are used to connect components together. See the Model building reference section of the documentation for more information.\n\nSee also: @connector.\n\n\n\n\n\n","category":"macro"},{"location":"API/model_building/","page":"Model building reference","title":"Model building reference","text":"Every constructor function should build either a component or a connector. Components define the dynamics of the system. Connectors are used to connect components together and propagate information between them. See also @connector.","category":"page"},{"location":"API/model_building/#Scoping-of-variables","page":"Model building reference","title":"Scoping of variables","text":"","category":"section"},{"location":"API/model_building/","page":"Model building reference","title":"Model building reference","text":"When building hierarchical systems, is is often necessary to pass variables from a parent system to the subsystems. If done naively, this will result in the child system assuming it \"owns\" the variables passed to it and any occurrences of those variables in the child system will be namespaced. To prevent this, ModelingToolkit has the concept of variable scope. The scope allows specifying which system a variable belongs to relative to the system in which it is used.","category":"page"},{"location":"API/model_building/#ModelingToolkit.LocalScope","page":"Model building reference","title":"ModelingToolkit.LocalScope","text":"struct LocalScope <: SymScope\n\nThe default scope of a variable. It belongs to the system whose equations it is involved in and is namespaced by every level of the hierarchy.\n\n\n\n\n\n","category":"type"},{"location":"API/model_building/#ModelingToolkit.ParentScope","page":"Model building reference","title":"ModelingToolkit.ParentScope","text":"struct ParentScope <: SymScope\n\nDenotes that the variable does not belong to the system whose equations it is involved in. It is not namespaced by this system. In the immediate parent of this system, the scope of this variable is given by parent.\n\nFields\n\nparent::SymScope\n\n\n\n\n\n","category":"type"},{"location":"API/model_building/#ModelingToolkit.GlobalScope","page":"Model building reference","title":"ModelingToolkit.GlobalScope","text":"struct GlobalScope <: SymScope\n\nDenotes that a variable belongs to the root system in the hierarchy, regardless of which equations of subsystems in the hierarchy it is involved in. Variables with this scope are never namespaced and only added to the unknowns/parameters of a system when calling complete or mtkcompile.\n\n\n\n\n\n","category":"type"},{"location":"API/model_building/","page":"Model building reference","title":"Model building reference","text":"Note that the scopes must be applied to individual variables and not expressions. For example, ParentScope(x + y) is incorrect. Instead, ParentScope(x) + ParentScope(y) is the correct usage. Applying the same scope (more generally, the same function) to all variables in an expression is a common task, and ModelingToolkit exposes a utility for the same:","category":"page"},{"location":"API/model_building/#ModelingToolkit.apply_to_variables","page":"Model building reference","title":"ModelingToolkit.apply_to_variables","text":"apply_to_variables(f, ex) -> Any\n\n\nApply function f to each variable in expression ex. f should be a function that takes a variable and returns the replacement to use. A \"variable\" in this context refers to a symbolic quantity created directly from a variable creation macro such as Symbolics.@variables, @independent_variables, @parameters, @constants or @brownians.\n\n\n\n\n\n","category":"function"},{"location":"API/model_building/","page":"Model building reference","title":"Model building reference","text":"It is still tedious to manually use apply_to_variables on any symbolic expression passed to a subsystem. The @named macro automatically wraps all symbolic arguments in ParentScope and uses the identifier being assigned as the name of the system.","category":"page"},{"location":"API/model_building/#ModelingToolkit.@named","page":"Model building reference","title":"ModelingToolkit.@named","text":"@named y = foo(x)\n@named y[1:10] = foo(x)\n@named begin\n    y[1:10] = foo(x)\n    z = foo(x)\nend # returns `[y; z]`\n@named y 1:10 i -> foo(x*i)  # This is not recommended\n\nPass the LHS name to the model. When it's calling anything that's not an AbstractSystem, it wraps all keyword arguments in default_to_parentscope so that namespacing works intuitively when passing a symbolic default into a component.\n\nExamples:\n\njulia> using ModelingToolkit\n\njulia> foo(i; name) = (; i, name)\nfoo (generic function with 1 method)\n\njulia> x = 41\n41\n\njulia> @named y = foo(x)\n(i = 41, name = :y)\n\njulia> @named y[1:3] = foo(x)\n3-element Vector{NamedTuple{(:i, :name), Tuple{Int64, Symbol}}}:\n (i = 41, name = :y_1)\n (i = 41, name = :y_2)\n (i = 41, name = :y_3)\n\n\n\n\n\n","category":"macro"},{"location":"API/model_building/#Exploring-the-tree-structure","page":"Model building reference","title":"Exploring the tree structure","text":"","category":"section"},{"location":"API/model_building/","page":"Model building reference","title":"Model building reference","text":"The System type implements the AbstractTrees interface. This can be used to explore the hierarchical structure.","category":"page"},{"location":"API/model_building/#ModelingToolkit.hierarchy","page":"Model building reference","title":"ModelingToolkit.hierarchy","text":"hierarchy(sys::AbstractSystem; describe = false, bold = describe, kwargs...)\n\nPrint a tree of a system's hierarchy of subsystems.\n\nKeyword arguments\n\ndescribe: Whether to also print the description of each subsystem, if present.\nbold: Whether to print the name of the system in bold font.\n\n\n\n\n\n","category":"function"},{"location":"API/model_building/#connect_semantics","page":"Model building reference","title":"Connection semantics","text":"","category":"section"},{"location":"API/model_building/","page":"Model building reference","title":"Model building reference","text":"ModelingToolkit implements connection semantics similar to those in the Modelica specification. We do not support the concept of inner and outer elements or expandable connectors. Connectors in ModelingToolkit are systems with the appropriate metadata added via the @connector macro.","category":"page"},{"location":"API/model_building/#ModelingToolkit.connect","page":"Model building reference","title":"ModelingToolkit.connect","text":"connect(\n    sys1::ModelingToolkit.AbstractSystem,\n    sys2::ModelingToolkit.AbstractSystem,\n    syss::ModelingToolkit.AbstractSystem...\n) -> Equation\n\n\nConnect multiple connectors created via @connector. All connected connectors must be unique.\n\n\n\n\n\nconnect(\n    var1::Union{Num, SymbolicUtils.BasicSymbolic, Symbolics.Arr},\n    var2::Union{Num, SymbolicUtils.BasicSymbolic, Symbolics.Arr},\n    vars::Union{Num, SymbolicUtils.BasicSymbolic, Symbolics.Arr}...\n) -> Equation\n\n\nConnect multiple causal variables. The first variable must be an output, and all subsequent variables must be inputs. The statement connect(var1, var2, var3, ...) expands to:\n\nvar1 ~ var2\nvar1 ~ var3\n# ...\n\n\n\n\n\nconnect(output_connector, ap_name::Symbol, input_connector; verbose = true)\nconnect(output_connector, ap::AnalysisPoint, input_connector; verbose = true)\n\nConnect output_connector and input_connector with an AnalysisPoint inbetween. The incoming connection output_connector is expected to be an output connector (for example, ModelingToolkitStandardLibrary.Blocks.RealOutput), and vice versa.\n\nPLEASE NOTE: The connection is assumed to be causal, meaning that\n\n@named P = FirstOrder(k = 1, T = 1)\n@named C = Gain(; k = -1)\nconnect(C.output, :plant_input, P.input)\n\nis correct, whereas\n\nconnect(P.input, :plant_input, C.output)\n\ntypically is not (unless the model is an inverse model).\n\nArguments\n\noutput_connector: An output connector\ninput_connector: An input connector\nap: An explicitly created AnalysisPoint\nap_name: If a name is given, an AnalysisPoint with the given name will be created automatically.\n\nKeyword arguments\n\nverbose: Warn if an input is connected to an output (reverse causality). Silence this warning if you are analyzing an inverse model.\n\n\n\n\n\n","category":"function"},{"location":"API/model_building/#ModelingToolkit.domain_connect","page":"Model building reference","title":"ModelingToolkit.domain_connect","text":"domain_connect(\n    sys1::ModelingToolkit.AbstractSystem,\n    sys2::ModelingToolkit.AbstractSystem,\n    syss::ModelingToolkit.AbstractSystem...\n) -> Equation\n\n\nAdds a domain only connection equation, through and across state equations are not generated.\n\n\n\n\n\n","category":"function"},{"location":"API/model_building/#ModelingToolkit.@connector","page":"Model building reference","title":"ModelingToolkit.@connector","text":"Mark a system constructor function as building a connector. For example,\n\n@connector function ElectricalPin(; name, v = nothing, i = nothing)\n    @variables begin\n        v(t) = v, [description = \"Potential at the pin [V]\"]\n        i(t) = i, [connect = Flow, description = \"Current flowing into the pin [A]\"]\n    end\n    return System(Equation[], t, [v, i], []; name)\nend\n\nSince connectors only declare variables, the equivalent shorthand syntax can also be used:\n\n@connector Pin begin\n    v(t), [description = \"Potential at the pin [V]\"]\n    i(t), [connect = Flow, description = \"Current flowing into the pin [A]\"]\nend\n\nModelingToolkit systems are either components or connectors. Components define dynamics of the model. Connectors are used to connect components together. See the Model building reference section of the documentation for more information.\n\nSee also: @component.\n\n\n\n\n\n","category":"macro"},{"location":"API/model_building/","page":"Model building reference","title":"Model building reference","text":"Connections can be expanded using expand_connections.","category":"page"},{"location":"API/model_building/#ModelingToolkit.expand_connections","page":"Model building reference","title":"ModelingToolkit.expand_connections","text":"expand_connections(\n    sys::ModelingToolkit.AbstractSystem;\n    tol\n) -> Any\n\n\nGiven a hierarchical system with connect equations, expand the connection equations and return the new system. tol is the tolerance for handling the singularities in stream connection equations that happen when a flow variable approaches zero.\n\n\n\n\n\n","category":"function"},{"location":"API/model_building/","page":"Model building reference","title":"Model building reference","text":"Similar to the stream and flow keyword arguments in the specification, ModelingToolkit allows specifying how variables in a connector behave in a connection.","category":"page"},{"location":"API/model_building/#ModelingToolkit.Equality","page":"Model building reference","title":"ModelingToolkit.Equality","text":"struct Equality <: ModelingToolkit.AbstractConnectType\n\nFlag which is meant to be passed to the connect metadata of a variable to affect how it behaves when the connector it is in is part of a connect equation. Equality is the default value and such variables when connected are made equal. For example, electric potential is equated at a junction.\n\nFor more information, refer to the Connection semantics section of the docs.\n\nSee also: connect, @connector, Flow, Stream.\n\n\n\n\n\n","category":"type"},{"location":"API/model_building/#ModelingToolkit.Flow","page":"Model building reference","title":"ModelingToolkit.Flow","text":"struct Flow <: ModelingToolkit.AbstractConnectType\n\nFlag which is meant to be passed to the connect metadata of a variable to affect how it behaves when the connector it is in is part of a connect equation. Flow denotes that the sum of marked variable in all connectors in the connection set must sum to zero. For example, electric current sums to zero at a junction (assuming appropriate signs are used for current flowing in and out of the function).\n\nFor more information, refer to the Connection semantics section of the docs.\n\nSee also: connect, @connector, Equality, Stream.\n\n\n\n\n\n","category":"type"},{"location":"API/model_building/#ModelingToolkit.Stream","page":"Model building reference","title":"ModelingToolkit.Stream","text":"struct Stream <: ModelingToolkit.AbstractConnectType\n\nFlag which is meant to be passed to the connect metadata of a variable to affect how it behaves when the connector it is in is part of a connect equation. Stream denotes that the variable is part of a special stream connector.\n\nFor more information, refer to the Connection semantics section of the docs.\n\nSee also: connect, @connector, Equality, Flow.\n\n\n\n\n\n","category":"type"},{"location":"API/model_building/","page":"Model building reference","title":"Model building reference","text":"These are specified using the connect metadata. ModelingToolkit also supports instream. Refer to the Modelica specification on Stream connectors for more information.","category":"page"},{"location":"API/model_building/#ModelingToolkit.instream","page":"Model building reference","title":"ModelingToolkit.instream","text":"instream(a) -> SymbolicUtils.BasicSymbolic\n\n\ninstream is used when modeling stream connections. It is only allowed to be used on Stream variables.\n\nRefer to the Connection semantics section of the docs for more information.\n\n\n\n\n\n","category":"function"},{"location":"API/model_building/#System-composition-utilities","page":"Model building reference","title":"System composition utilities","text":"","category":"section"},{"location":"API/model_building/#ModelingToolkit.extend","page":"Model building reference","title":"ModelingToolkit.extend","text":"extend(\n    sys::ModelingToolkit.AbstractSystem,\n    basesys::ModelingToolkit.AbstractSystem;\n    name,\n    description,\n    gui_metadata\n) -> Any\n\n\nExtend basesys with sys. This can be thought of as the merge operation on systems. Values in sys take priority over duplicates in basesys (for example, defaults).\n\nBy default, the resulting system inherits sys's name and description.\n\nThe & operator can also be used for this purpose. sys & basesys is equivalent to extend(sys, basesys).\n\nSee also compose.\n\n\n\n\n\nextend(\n    sys,\n    basesys::Array{T<:ModelingToolkit.AbstractSystem, 1}\n) -> Any\n\n\nExtend sys with all systems in basesys in order.\n\n\n\n\n\n","category":"function"},{"location":"API/model_building/#ModelingToolkit.compose","page":"Model building reference","title":"ModelingToolkit.compose","text":"compose(sys, systems; name)\n\n\nCompose multiple systems together. This adds all of systems as subsystems of sys. The resulting system inherits the name of sys by default.\n\nThe ∘ operator can also be used for this purpose. sys ∘ basesys is equivalent to compose(sys, basesys).\n\nSee also extend.\n\n\n\n\n\ncompose(syss...; name) -> Any\n\n\nSyntactic sugar for adding all systems in syss as the subsystems of first(syss).\n\n\n\n\n\n","category":"function"},{"location":"API/model_building/#ModelingToolkit.substitute_component","page":"Model building reference","title":"ModelingToolkit.substitute_component","text":"substitute_component(\n    sys::ModelingToolkit.AbstractSystem,\n    rule::Pair{T<:ModelingToolkit.AbstractSystem, T<:ModelingToolkit.AbstractSystem}\n) -> Any\n\n\nGiven a hierarchical system sys and a rule lhs => rhs, replace the subsystem lhs in sys by rhs. The lhs must be the namespaced version of a subsystem of sys (e.g. obtained via sys.inner.component). The rhs must be valid as per the following conditions:\n\nrhs must not be namespaced.\nThe name of rhs must be the same as the unnamespaced name of lhs.\nNeither one of lhs or rhs can be marked as complete.\nBoth lhs and rhs must share the same independent variable.\nrhs must contain at least all of the unknowns and parameters present in lhs.\nCorresponding unknowns in rhs must share the same connection and causality (input/output) metadata as their counterparts in lhs.\nFor each subsystem of lhs, there must be an identically named subsystem of rhs. These two corresponding subsystems must satisfy conditions 3, 4, 5, 6, 7. If the subsystem of lhs is a connector, the corresponding subsystem of rhs must also be a connector of the same type.\n\nsys also cannot be marked as complete.\n\n\n\n\n\n","category":"function"},{"location":"API/model_building/#Flattening-systems","page":"Model building reference","title":"Flattening systems","text":"","category":"section"},{"location":"API/model_building/","page":"Model building reference","title":"Model building reference","text":"The hierarchical structure can be flattened. This operation is performed during simplification.","category":"page"},{"location":"API/model_building/#ModelingToolkit.flatten","page":"Model building reference","title":"ModelingToolkit.flatten","text":"flatten(sys::System) -> System\nflatten(sys::System, noeqs) -> System\n\n\nFlatten the hierarchical structure of a system, collecting all equations, unknowns, etc. into one top-level system after namespacing appropriately.\n\n\n\n\n\n","category":"function"},{"location":"API/model_building/#System-simplification","page":"Model building reference","title":"System simplification","text":"","category":"section"},{"location":"API/model_building/","page":"Model building reference","title":"Model building reference","text":"Systems can be simplified to reformulate them in a way that enables it to be solved numerically, and also perform other optimizations. This is done via the mtkcompile function. Connection expansion and flattening are preprocessing steps of simplification.","category":"page"},{"location":"API/model_building/#ModelingToolkit.mtkcompile","page":"Model building reference","title":"ModelingToolkit.mtkcompile","text":"mtkcompile(\n    sys;\n    additional_passes,\n    simplify,\n    split,\n    allow_symbolic,\n    allow_parameter,\n    conservative,\n    fully_determined,\n    inputs,\n    outputs,\n    disturbance_inputs,\n    kwargs...\n)\n\n\nCompile the given system into a form that ModelingToolkit can generate code for. Also performs a variety of symbolic-numeric enhancements. For ODEs, this includes processes such as order reduction, index reduction, alias elimination and tearing. A subset of the unknowns of the system may be eliminated as observables, eliminating the need for the numerical solver to solve for these variables.\n\nDoes not rely on metadata to identify variables/parameters/brownians. Instead, queries the system for which symbolic quantites belong to which category. Any variables not present in the equations of the system will be removed in this process.\n\nKeyword Arguments\n\nWhen simplify=true, the simplify function will be applied during the tearing process.\nallow_symbolic=false, allow_parameter=true, and conservative=false limit the coefficient types during tearing. In particular, conservative=true limits tearing to only solve for trivial linear systems where the coefficient has the absolute value of 1.\nfully_determined=true controls whether or not an error will be thrown if the number of equations don't match the number of inputs, outputs, and equations.\ninputs, outputs and disturbance_inputs are passed as keyword arguments.All inputs get converted to parameters and are allowed to be unconnected, allowing models where n_unknowns = n_equations - n_inputs.\nsort_eqs=true controls whether equations are sorted lexicographically before simplification or not.\n\n\n\n\n\n","category":"function"},{"location":"API/model_building/#ModelingToolkit.@mtkcompile","page":"Model building reference","title":"ModelingToolkit.@mtkcompile","text":"Macro shorthand for building and compiling a system in one step.\n\n@mtkcompile sys = Constructor(args...; kwargs....)\n\nIs shorthand for\n\n@named sys = Constructor(args...; kwargs...)\nsys = mtkcompile(sys)\n\n\n\n\n\n","category":"macro"},{"location":"API/model_building/","page":"Model building reference","title":"Model building reference","text":"It is also possible (though not always advisable) to build numerical problems from systems without passing them through mtkcompile. To do this, the system must first be marked as \"complete\" via the complete function. This process is used to indicate that a system will not be modified further and allows ModelingToolkit to perform any necessary preprocessing to it. mtkcompile calls complete internally.","category":"page"},{"location":"API/model_building/#ModelingToolkit.complete","page":"Model building reference","title":"ModelingToolkit.complete","text":"complete(\n    sys::ModelingToolkit.AbstractSystem;\n    split,\n    flatten,\n    add_initial_parameters\n) -> Any\n\n\nMark a system as completed. A completed system is a system which is done being defined/modified and is ready for structural analysis or other transformations. This allows for analyses and optimizations to be performed which require knowing the global structure of the system.\n\nOne property to note is that if a system is complete, the system will no longer namespace its subsystems or variables, i.e. isequal(complete(sys).v.i, v.i).\n\nThis namespacing functionality can also be toggled independently of complete using toggle_namespacing.\n\n\n\n\n\n","category":"function"},{"location":"API/model_building/#Exploring-the-results-of-simplification","page":"Model building reference","title":"Exploring the results of simplification","text":"","category":"section"},{"location":"API/model_building/","page":"Model building reference","title":"Model building reference","text":"Similar to how full_equations returns the equations of a system with all variables eliminated during mtkcompile substituted, we can perform this substitution on an arbitrary expression.","category":"page"},{"location":"API/model_building/#ModelingToolkit.substitute_observed","page":"Model building reference","title":"ModelingToolkit.substitute_observed","text":"substitute_observed(\n    sys::ModelingToolkit.AbstractSystem,\n    expr;\n    simplify\n) -> Any\n\n\nRecursively substitute the observed equations of sys into expr. If simplify, call Symbolics.simplify on the resultant expression.\n\n\n\n\n\n","category":"function"},{"location":"API/model_building/#ModelingToolkit.empty_substitutions","page":"Model building reference","title":"ModelingToolkit.empty_substitutions","text":"empty_substitutions(sys) -> Any\n\n\nCheck if any variables were eliminated from the system as part of mtkcompile.\n\n\n\n\n\n","category":"function"},{"location":"API/model_building/#ModelingToolkit.get_substitutions","page":"Model building reference","title":"ModelingToolkit.get_substitutions","text":"get_substitutions(sys) -> Dict\n\n\nGet a dictionary mapping variables eliminated from the system during mtkcompile to the expressions used to calculate them.\n\n\n\n\n\n","category":"function"},{"location":"API/model_building/#Experimental-simplification","page":"Model building reference","title":"Experimental simplification","text":"","category":"section"},{"location":"API/model_building/","page":"Model building reference","title":"Model building reference","text":"ModelingToolkit may have a variety of experimental simplification passes. These are not enabled by default, but can be used by passing to the additional_passes keyword argument of mtkcompile.","category":"page"},{"location":"API/model_building/#ModelingToolkit.IfLifting","page":"Model building reference","title":"ModelingToolkit.IfLifting","text":"If lifting converts (nested) if statements into a series of continuous events + a logically equivalent if statement + parameters.\n\nLifting proceeds through the following process:\n\nrewrite comparisons to be of the form eqn [op] 0; subtract the RHS from the LHS \nreplace comparisons with generated parameters; for each comparison eqn [op] 0, generate an event (dependent on op) that sets the parameter\n\nwarn: Warn\nThis is an experimental simplification pass. It may have bugs. Please open issues with MWEs for any bugs encountered while using this.\n\n\n\n\n\n","category":"function"},{"location":"API/model_building/#Event-handling","page":"Model building reference","title":"Event handling","text":"","category":"section"},{"location":"API/model_building/","page":"Model building reference","title":"Model building reference","text":"Time-dependent systems may have several events. These are used to trigger discontinuities in the model. They compile to standard callbacks from DiffEqCallbacks.jl.","category":"page"},{"location":"API/model_building/#ModelingToolkit.SymbolicContinuousCallback","page":"Model building reference","title":"ModelingToolkit.SymbolicContinuousCallback","text":"SymbolicContinuousCallback(eqs::Vector{Equation}, affect = nothing, iv = nothing; \n                           affect_neg = affect, initialize = nothing, finalize = nothing, rootfind = SciMLBase.LeftRootFind, alg_eqs = Equation[])\n\nA ContinuousCallback specified symbolically. Takes a vector of equations eq as well as the positive-edge affect and negative-edge affect_neg that apply when any of eq are satisfied. By default affect_neg = affect; to only get rising edges specify affect_neg = nothing.\n\nAssume without loss of generality that the equation is of the form c(u,p,t) ~ 0; we denote the integrator state as i.u. For compactness, we define prev_sign = sign(c(u[t-1], p[t-1], t-1)) and cur_sign = sign(c(u[t], p[t], t)). A condition edge will be detected and the callback will be invoked iff prev_sign * cur_sign <= 0. The positive edge affect will be triggered iff an edge is detected and if prev_sign < 0; similarly, affect_neg will be triggered iff an edge is detected and prev_sign > 0.\n\nInter-sample condition activation is not guaranteed; for example if we use the dirac delta function as c to insert a sharp discontinuity between integrator steps (which in this example would not normally be identified by adaptivity) then the condition is not guaranteed to be triggered.\n\nOnce detected the integrator will \"wind back\" through a root-finding process to identify the point when the condition became active; the method used is specified by rootfind from SciMLBase.RootfindOpt. If we denote the time when the condition becomes active as tc, the value in the integrator after windback will be:\n\nu[tc-epsilon], p[tc-epsilon], tc if LeftRootFind is used,\nu[tc+epsilon], p[tc+epsilon], tc if RightRootFind is used,\nor u[t], p[t], t if NoRootFind is used.\n\nFor example, if we want to detect when an unknown variable x satisfies x > 0 using the condition x ~ 0 on a positive edge (that is, D(x) > 0), then left root finding will get us x=-epsilon, right root finding x=epsilon and no root finding will produce whatever the next step of the integrator was after it passed through 0.\n\nMultiple callbacks in the same system with different rootfind operations will be grouped by their rootfind value into separate VectorContinuousCallbacks in the enumeration order of SciMLBase.RootfindOpt. This may cause some callbacks to not fire if several become active at the same instant. See the SciMLBase documentation for more information on the semantic rules.\n\nAffects (i.e. affect and affect_neg) can be specified as either:\n\nA list of equations that should be applied when the callback is triggered (e.g. x ~ 3, y ~ 7) which must be of the form unknown ~ observed value where each unknown appears only once. Equations will be applied in the order that they appear in the vector; parameters and state updates will become immediately visible to following equations.\nA tuple (f!, unknowns, read_parameters, modified_parameters, ctx), where:\nf! is a function with signature (integ, u, p, ctx) that is called with the integrator, a state index vector u derived from unknowns, a parameter index vector p derived from read_parameters, and the ctx that was given at construction time. Note that ctx is aliased between instances.\nunknowns is a vector of symbolic unknown variables and optionally their aliases (e.g. if the model was defined with @variables x(t) then a valid value for unknowns would be [x]). A variable can be aliased with a pair x => :y. The indices of these unknowns will be passed to f! in u in a named tuple; in the earlier example, if we pass [x] as unknowns then f! can access x as integ.u[u.x]. If no alias is specified the name of the index will be the symbol version of the variable name.\nread_parameters is a vector of the parameters that are used by f!. Their indices are passed to f in p similarly to the indices of unknowns passed in u.\nmodified_parameters is a vector of the parameters that are modified by f!. Note that a parameter will not appear in p if it only appears in modified_parameters; it must appear in both parameters and modified_parameters if it is used in the affect definition.\nctx is a user-defined context object passed to f! when invoked. This value is aliased for each problem.\nA ImperativeAffect; refer to its documentation for details.\n\nreinitializealg is used to set how the system will be reinitialized after the callback. \n\nSymbolic affects have reinitialization built in. In this case the algorithm will default to SciMLBase.NoInit(), and should not be provided.\nFunctional and imperative affects will default to SciMLBase.CheckInit(), which will error if the system is not properly reinitialized after the callback. If your system is a DAE, pass in an algorithm like SciMLBase.BrownBasicFullInit() to properly re-initialize.\n\nInitial and final affects can also be specified identically to positive and negative edge affects. Initialization affects will run as soon as the solver starts, while finalization affects will be executed after termination.\n\n\n\n\n\n","category":"type"},{"location":"API/model_building/#ModelingToolkit.SymbolicDiscreteCallback","page":"Model building reference","title":"ModelingToolkit.SymbolicDiscreteCallback","text":"SymbolicDiscreteCallback(conditions::Vector{Equation}, affect = nothing, iv = nothing;\n                         initialize = nothing, finalize = nothing, alg_eqs = Equation[])\n\nA callback that triggers at the first timestep that the conditions are satisfied.\n\nThe condition can be one of: \n\nΔt::Real              - periodic events with period Δt\nts::Vector{Real}      - events trigger at these preset times given by ts\neqs::Vector{Symbolic} - events trigger when the condition evaluates to true\n\nArguments: \n\niv: The independent variable of the system. This must be specified if the independent variable appears in one of the equations explicitly, as in x ~ t + 1.\nalg_eqs: Algebraic equations of the system that must be satisfied after the callback occurs.\n\n\n\n\n\n","category":"type"},{"location":"API/model_building/","page":"Model building reference","title":"Model building reference","text":"The affect functions for the above callbacks can be symbolic or user-defined functions. Symbolic affects are handled using equations as described in the Events section of the documentation. User-defined functions can be used via ImperativeAffect.","category":"page"},{"location":"API/model_building/#ModelingToolkit.ImperativeAffect","page":"Model building reference","title":"ModelingToolkit.ImperativeAffect","text":"ImperativeAffect(f::Function; modified::NamedTuple, observed::NamedTuple, ctx)\n\nImperativeAffect is a helper for writing affect functions that will compute observed values and ensure that modified values are correctly written back into the system. The affect function f needs to have the signature \n\n    f(modified::NamedTuple, observed::NamedTuple, ctx, integrator)::NamedTuple\n\nThe function f will be called with observed and modified NamedTuples that are derived from their respective NamedTuple definitions. Each  declarationNamedTuple should map an expression to a symbol; for example if we pass observed=(; x = a + b) this will alias the result of executing a+b in the system as x so the value of a + b will be accessible as observed.x in f. modified currently restricts symbolic expressions to only bare variables, so only tuples of the form (; x = y) or (; x) (which aliases x as itself) are allowed.\n\nThe argument NamedTuples (for instance (;x=y)) will be populated with the declared values on function entry; if we require (;x=y) in observed and y=2, for example, then the NamedTuple (;x=2) will be passed as observed to the affect function f. \n\nThe NamedTuple returned from f includes the values to be written back to the system after f returns. For example, if we want to update the value of x to be the result of x + y we could write\n\nImperativeAffect(observed=(; x_plus_y = x + y), modified=(; x)) do m, o\n    @set! m.x = o.x_plus_y\nend\n\nWhere we use Setfield to copy the tuple m with a new value for x, then return the modified value of m. All values updated by the tuple must have names originally declared in modified; a runtime error will be produced if a value is written that does not appear in modified. The user can dynamically decide not to write a value back by not including it in the returned tuple, in which case the associated field will not be updated.\n\n\n\n\n\n","category":"type"},{"location":"API/model_building/#Modelingtoolkitize","page":"Model building reference","title":"Modelingtoolkitize","text":"","category":"section"},{"location":"API/model_building/","page":"Model building reference","title":"Model building reference","text":"ModelingToolkit can take some numerical problems created non-symbolically and build a symbolic representation from them.","category":"page"},{"location":"API/model_building/#ModelingToolkit.modelingtoolkitize","page":"Model building reference","title":"ModelingToolkit.modelingtoolkitize","text":"modelingtoolkitize(\n    prob::ODEProblem;\n    u_names,\n    p_names,\n    return_symbolic_u0_p,\n    kwargs...\n) -> Any\n\n\nConvert an ODEProblem to a ModelingToolkit.System.\n\nKeyword arguments\n\nu_names: An array of names of the same size as prob.u0 to use as the names of the unknowns of the system. The names should be given as Symbols.\np_names: A collection of names to use for parameters of the system. The collection should have keys corresponding to indexes of prob.p. For example, if prob.p is an associative container like NamedTuple, then p_names should map keys of prob.p to the name that the corresponding parameter should have in the returned system. The names should be given as Symbols.\nINTERNAL return_symbolic_u0_p: Also return the symbolic state and parameter objects.\n\nAll other keyword arguments are forwarded to the created System.\n\n\n\n\n\nmodelingtoolkitize(\n    prob::SDEProblem;\n    u_names,\n    p_names,\n    kwargs...\n) -> Any\n\n\nConvert an SDEProblem to a ModelingToolkit.System.\n\nKeyword arguments\n\nu_names: an array of names of the same size as prob.u0 to use as the names of the unknowns of the system. The names should be given as Symbols.\np_names: a collection of names to use for parameters of the system. The collection should have keys corresponding to indexes of prob.p. For example, if prob.p is an associative container like NamedTuple, then p_names should map keys of prob.p to the name that the corresponding parameter should have in the returned system. The names should be given as Symbols.\n\nAll other keyword arguments are forwarded to the created System.\n\n\n\n\n\nmodelingtoolkitize(\n    prob::OptimizationProblem;\n    u_names,\n    p_names,\n    kwargs...\n) -> System\n\n\nConvert an OptimizationProblem to a ModelingToolkit.System.\n\nKeyword arguments\n\nu_names: An array of names of the same size as prob.u0 to use as the names of the unknowns of the system. The names should be given as Symbols.\np_names: A collection of names to use for parameters of the system. The collection should have keys corresponding to indexes of prob.p. For example, if prob.p is an associative container like NamedTuple, then p_names should map keys of prob.p to the name that the corresponding parameter should have in the returned system. The names should be given as Symbols.\n\nAll other keyword arguments are forwarded to the created System.\n\n\n\n\n\nmodelingtoolkitize(\n    prob::Union{SciMLBase.NonlinearLeastSquaresProblem, NonlinearProblem};\n    u_names,\n    p_names,\n    kwargs...\n) -> System\n\n\nConvert a NonlinearProblem or NonlinearLeastSquaresProblem to a ModelingToolkit.System.\n\nKeyword arguments\n\nu_names: An array of names of the same size as prob.u0 to use as the names of the unknowns of the system. The names should be given as Symbols.\np_names: A collection of names to use for parameters of the system. The collection should have keys corresponding to indexes of prob.p. For example, if prob.p is an associative container like NamedTuple, then p_names should map keys of prob.p to the name that the corresponding parameter should have in the returned system. The names should be given as Symbols.\n\nAll other keyword arguments are forwarded to the created System.\n\n\n\n\n\n","category":"function"},{"location":"API/model_building/#Using-FMUs","page":"Model building reference","title":"Using FMUs","text":"","category":"section"},{"location":"API/model_building/","page":"Model building reference","title":"Model building reference","text":"ModelingToolkit is capable of importing FMUs as black-box symbolic models. Currently only a subset of FMU features are supported. This functionality requires importing FMI.jl.","category":"page"},{"location":"API/model_building/#ModelingToolkit.FMIComponent","page":"Model building reference","title":"ModelingToolkit.FMIComponent","text":"FMIComponent(\n    ::Val{Ver};\n    fmu,\n    tolerance,\n    communication_step_size,\n    reinitializealg,\n    type,\n    name\n)\n\n\nA component that wraps an FMU loaded via FMI.jl. The FMI version (2 or 3) should be provided as a Val to the function. Supports Model Exchange and CoSimulation FMUs. All inputs, continuous variables and outputs must be FMI.fmi2Real or FMI.fmi3Float64. Does not support events or discrete variables in the FMU. Does not support automatic differentiation. Parameters of the FMU will have defaults corresponding to their initial values in the FMU specification. All other variables will not have a default. Hierarchical names in the FMU of the form namespace.variable are transformed into symbolic variables with the name namespace__variable.\n\nKeyword Arguments\n\nfmu: The FMU loaded via FMI.loadFMU.\ntolerance: The tolerance to provide to the FMU. Not used for v3 FMUs since it is not supported by FMI.jl.\ncommunication_step_size: The periodic interval at which communication with CoSimulation FMUs will occur. Must be provided for CoSimulation FMU components.\nreinitializealg: The DAE initialization algorithm to use for the callback managing the FMU. For CoSimulation FMUs whose states/outputs are used in algebraic equations of the system, this needs to be an algorithm that will solve for the new algebraic variables. For example, OrdinaryDiffEqCore.BrownFullBasicInit().\ntype: Either :ME or :CS depending on whether fmu is a Model Exchange or CoSimulation FMU respectively.\nname: The name of the system.\n\n\n\n\n\n","category":"function"},{"location":"API/model_building/#Model-transformations","page":"Model building reference","title":"Model transformations","text":"","category":"section"},{"location":"API/model_building/","page":"Model building reference","title":"Model building reference","text":"ModelingToolkit exposes a variety of transformations that can be applied to models to aid in symbolic analysis.","category":"page"},{"location":"API/model_building/#ModelingToolkit.liouville_transform","page":"Model building reference","title":"ModelingToolkit.liouville_transform","text":"liouville_transform(sys::System; kwargs...) -> System\n\n\nGenerates the Liouville transformed set of ODEs, which is the original ODE system with a new variable trJ appended, corresponding to the -tr(Jacobian). This variable is used for properties like uncertainty propagation from a given initial distribution density.\n\nFor example, if u=p*u and p follows a probability distribution f(p), then the probability density of a future value with a given choice of p is computed by setting the initial trJ = f(p), and the final value of trJ is the probability of u(t).\n\nExample:\n\nusing ModelingToolkit, OrdinaryDiffEq\n\n@independent_variables t\n@parameters α β γ δ\n@variables x(t) y(t)\nD = Differential(t)\neqs = [D(x) ~ α*x - β*x*y, D(y) ~ -δ*y + γ*x*y]\n@named sys = System(eqs, t)\n\nsys2 = liouville_transform(sys)\nsys2 = complete(sys2)\nu0 = [x => 1.0, y => 1.0, sys2.trJ => 1.0]\nprob = ODEProblem(sys2, u0, tspan, p)\nsol = solve(prob, Tsit5())\n\nWhere sol[3,:] is the evolution of trJ over time.\n\nSources:\n\nProbabilistic Robustness Analysis of F-16 Controller Performance: An Optimal Transport Approach\n\nAbhishek Halder, Kooktae Lee, and Raktim Bhattacharya https://abhishekhalder.bitbucket.io/F16ACC2013Final.pdf\n\n\n\n\n\n","category":"function"},{"location":"API/model_building/#ModelingToolkit.change_of_variables","page":"Model building reference","title":"ModelingToolkit.change_of_variables","text":"change_of_variables(\n    sys::System,\n    iv,\n    forward_subs,\n    backward_subs;\n    simplify,\n    t0,\n    isSDE\n) -> Any\n\n\nGenerates the set of ODEs after change of variables.\n\nExample:\n\nusing ModelingToolkit, OrdinaryDiffEq, Test\n\n# Change of variables: z = log(x)\n# (this implies that x = exp(z) is automatically non-negative)\n\n@independent_variables t\n@parameters α\n@variables x(t)\nD = Differential(t)\neqs = [D(x) ~ α*x]\n\ntspan = (0., 1.)\ndef = [x => 1.0, α => -0.5]\n\n@mtkcompile sys = System(eqs, t;defaults=def)\nprob = ODEProblem(sys, [], tspan)\nsol = solve(prob, Tsit5())\n\n@variables z(t)\nforward_subs  = [log(x) => z]\nbackward_subs = [x => exp(z)]\nnew_sys = change_of_variables(sys, t, forward_subs, backward_subs)\n@test equations(new_sys)[1] == (D(z) ~ α)\n\nnew_prob = ODEProblem(new_sys, [], tspan)\nnew_sol = solve(new_prob, Tsit5())\n\n@test isapprox(new_sol[x][end], sol[x][end], atol=1e-4)\n\n\n\n\n\n","category":"function"},{"location":"API/model_building/#ModelingToolkit.stochastic_integral_transform","page":"Model building reference","title":"ModelingToolkit.stochastic_integral_transform","text":"stochastic_integral_transform(\n    sys::System,\n    correction_factor\n) -> Any\n\n\nChoose correction_factor=-1//2 (1//2) to convert Ito -> Stratonovich (Stratonovich->Ito).\n\n\n\n\n\n","category":"function"},{"location":"API/model_building/#ModelingToolkit.Girsanov_transform","page":"Model building reference","title":"ModelingToolkit.Girsanov_transform","text":"Girsanov_transform(sys::System, u; θ0) -> Any\n\n\nMeasure transformation method that allows for a reduction in the variance of an estimator Exp(g(X_t)). Input:  Original SDE system and symbolic function u(t,x) with scalar output that         defines the adjustable parameters d in the Girsanov transformation. Optional: initial         condition for θ0. Output: Modified SDE System with additional component θ_t and initial value θ0, as well as         the weight θ_t/θ0 as observed equation, such that the estimator Exp(g(X_t)θ_t/θ0)         has a smaller variance.\n\nReference: Kloeden, P. E., Platen, E., & Schurz, H. (2012). Numerical solution of SDE through computer experiments. Springer Science & Business Media.\n\nExample\n\nusing ModelingToolkit\nusing ModelingToolkit: t_nounits as t, D_nounits as D\n\n@parameters α β\n@variables x(t) y(t) z(t)\n\neqs = [D(x) ~ α*x]\nnoiseeqs = [β*x]\n\n@named de = System(eqs,t,[x],[α,β]; noise_eqs = noiseeqs)\n\n# define u (user choice)\nu = x\nθ0 = 0.1\ng(x) = x[1]^2\ndemod = ModelingToolkit.Girsanov_transform(de, u; θ0=0.1)\n\nu0modmap = [\n    x => x0\n]\n\nparammap = [\n    α => 1.5,\n    β => 1.0\n]\n\nprobmod = SDEProblem(complete(demod),u0modmap,(0.0,1.0),parammap)\nensemble_probmod = EnsembleProblem(probmod;\n          output_func = (sol,i) -> (g(sol[x,end])*sol[demod.weight,end],false),\n          )\n\nsimmod = solve(ensemble_probmod,EM(),dt=dt,trajectories=numtraj)\n\n\n\n\n\n","category":"function"},{"location":"API/model_building/#ModelingToolkit.change_independent_variable","page":"Model building reference","title":"ModelingToolkit.change_independent_variable","text":"change_independent_variable(\n    sys::System, iv, eqs = [];\n    add_old_diff = false, simplify = true, fold = false\n)\n\nTransform the independent variable (e.g. t) of the ODE system sys to a dependent variable iv (e.g. u(t)). The transformation is well-defined when the mapping between the new and old independent variables are one-to-one. This is satisfied if one is a strictly increasing function of the other (e.g. du(t)dt  0 or du(t)dt  0).\n\nAny extra equations eqs involving the new and old independent variables will be taken into account in the transformation.\n\nKeyword arguments\n\nadd_old_diff: Whether to add a differential equation for the old independent variable in terms of the new one using the inverse function rule dtdu = 1(dudt).\nsimplify: Whether expanded derivative expressions are simplified. This can give a tidier transformation.\nfold: Whether internal substitutions will evaluate numerical expressions.\n\nUsage before structural simplification\n\nThe variable change must take place before structural simplification. In following calls to mtkcompile, consider passing allow_symbolic = true to avoid undesired constraint equations between between dummy variables.\n\nUsage with non-autonomous systems\n\nIf sys is non-autonomous (i.e. t appears explicitly in its equations), consider passing an algebraic equation relating the new and old independent variables (e.g. t = f(u(t))). Otherwise the transformed system can be underdetermined. If an algebraic relation is not known, consider using add_old_diff instead.\n\nUsage with hierarchical systems\n\nIt is recommended that iv is a non-namespaced variable in sys. This means it can belong to the top-level system or be a variable in a subsystem declared with GlobalScope.\n\nExample\n\nConsider a free fall with constant horizontal velocity. Physics naturally describes position as a function of time. By changing the independent variable, it can be reformulated for vertical position as a function of horizontal position:\n\njulia> @variables x(t) y(t);\n\njulia> @named M = System([D(D(y)) ~ -9.81, D(D(x)) ~ 0.0], t);\n\njulia> M = change_independent_variable(M, x);\n\njulia> M = mtkcompile(M; allow_symbolic = true);\n\njulia> unknowns(M)\n3-element Vector{SymbolicUtils.BasicSymbolic{Real}}:\n xˍt(x)\n y(x)\n yˍx(x)\n\n\n\n\n\n","category":"function"},{"location":"API/model_building/#ModelingToolkit.add_accumulations","page":"Model building reference","title":"ModelingToolkit.add_accumulations","text":"add_accumulations(sys::System) -> Any\nadd_accumulations(sys::System, vars) -> Any\n\n\nAdd accumulation variables for vars. For every unknown x in vars, add D(accumulation_x) ~ x as an equation.\n\n\n\n\n\nadd_accumulations(sys::System, vars::Vector{<:Pair}) -> Any\n\n\nAdd accumulation variables for vars. vars is a vector of pairs in the form of\n\n[cumulative_var1 => x + y, cumulative_var2 => x^2]\n\nThen, cumulative variables cumulative_var1 and cumulative_var2 that computes the cumulative x + y and x^2 would be added to sys.\n\nAll accumulation variables have a default of zero.\n\n\n\n\n\n","category":"function"},{"location":"API/model_building/#ModelingToolkit.noise_to_brownians","page":"Model building reference","title":"ModelingToolkit.noise_to_brownians","text":"noise_to_brownians(sys::System; names) -> Any\n\n\nGiven a system with noise in the form of noise equation (get_noise_eqs(sys) !== nothing) return an equivalent system which represents the noise using brownian variables.\n\nKeyword Arguments\n\nnames: The name(s) to use for the brownian variables. If this is a Symbol, variables with the given name and successive numeric _i suffixes will be used. If a Vector, this must have appropriate length for the noise equations of the system. The corresponding number of brownian variables are created with the given names.\n\n\n\n\n\n","category":"function"},{"location":"API/model_building/#ModelingToolkit.convert_system_indepvar","page":"Model building reference","title":"ModelingToolkit.convert_system_indepvar","text":"convert_system_indepvar(sys::System, t; name) -> Any\n\n\nFunction which takes a system sys and an independent variable t and changes the independent variable of sys to t. This is different from change_independent_variable since this function only does a symbolic substitution of the independent variable. sys must not be a reduced system (observed(sys) must be empty). If sys is time-independent, this can be used to turn it into a time-dependent system.\n\nKeyword arguments\n\nname: The name of the returned system.\n\n\n\n\n\n","category":"function"},{"location":"API/model_building/#Hybrid-systems","page":"Model building reference","title":"Hybrid systems","text":"","category":"section"},{"location":"API/model_building/","page":"Model building reference","title":"Model building reference","text":"Hybrid systems are dynamical systems involving one or more discrete-time subsystems. These discrete time systems follow clock semantics - they are synchronous systems and the relevant variables are only defined at points where the clock ticks.","category":"page"},{"location":"API/model_building/","page":"Model building reference","title":"Model building reference","text":"While ModelingToolkit is unable to simplify, compile and solve such systems on its own, it has the ability to represent them. Compilation strategies can be implemented independently on top of mtkcompile using the additional_passes functionality.","category":"page"},{"location":"API/model_building/","page":"Model building reference","title":"Model building reference","text":"warn: Warn\nThese operators are considered experimental API.","category":"page"},{"location":"API/model_building/#ModelingToolkit.Sample-API-model_building","page":"Model building reference","title":"ModelingToolkit.Sample","text":"struct Sample <: Symbolics.Operator\n\nRepresents a sample operator. A discrete-time signal is created by sampling a continuous-time signal.\n\nConstructors\n\nSample(clock::Union{TimeDomain, InferredTimeDomain} = InferredDiscrete()) Sample(dt::Real)\n\nSample(x::Num), with a single argument, is shorthand for Sample()(x).\n\nFields\n\nclock\n\nExamples\n\njulia> using Symbolics\n\njulia> t = ModelingToolkit.t_nounits\n\njulia> Δ = Sample(0.01)\n(::Sample) (generic function with 2 methods)\n\n\n\n\n\n","category":"type"},{"location":"API/model_building/#ModelingToolkit.Hold-API-model_building","page":"Model building reference","title":"ModelingToolkit.Hold","text":"struct Hold <: Symbolics.Operator\n\nRepresents a hold operator. A continuous-time signal is produced by holding a discrete-time signal x with zero-order hold.\n\ncont_x = Hold()(disc_x)\n\n\n\n\n\n","category":"type"},{"location":"API/model_building/#ModelingToolkit.SampleTime-API-model_building","page":"Model building reference","title":"ModelingToolkit.SampleTime","text":"function SampleTime()\n\nSampleTime() can be used in the equations of a hybrid system to represent time sampled at the inferred clock for that equation.\n\n\n\n\n\n","category":"type"},{"location":"API/model_building/","page":"Model building reference","title":"Model building reference","text":"ModelingToolkit uses the clock definition in SciMLBase","category":"page"},{"location":"API/model_building/#State-machines","page":"Model building reference","title":"State machines","text":"","category":"section"},{"location":"API/model_building/","page":"Model building reference","title":"Model building reference","text":"While ModelingToolkit has the capability to represent state machines, it lacks the ability to compile and simulate them.","category":"page"},{"location":"API/model_building/","page":"Model building reference","title":"Model building reference","text":"warn: Warn\nThis functionality is considered experimental API","category":"page"},{"location":"API/model_building/#ModelingToolkit.transition","page":"Model building reference","title":"ModelingToolkit.transition","text":"transition(from, to, cond; immediate::Bool = true, reset::Bool = true, synchronize::Bool = false, priority::Int = 1)\n\nCreate a transition from state from to state to that is enabled when transitioncondition cond evaluates to true.\n\nArguments:\n\nfrom: The source state of the transition.\nto: The target state of the transition.\ncond: A transition condition that evaluates to a Bool, such as ticksInState() >= 2.\nimmediate: If true, the transition will fire at the same tick as it becomes true, if false, the actions of the state are evaluated first, and the transition fires during the next tick.\nreset: If true, the destination state to is reset to its initial condition when the transition fires.\nsynchronize: If true, the transition will only fire if all sub-state machines in the source state are in their final (terminal) state. A final state is one that has no outgoing transitions.\npriority: If a state has more than one outgoing transition, all outgoing transitions must have a unique priority. The transitions are evaluated in priority order, i.e., the transition with priority 1 is evaluated first.\n\n\n\n\n\n","category":"function"},{"location":"API/model_building/#ModelingToolkit.activeState","page":"Model building reference","title":"ModelingToolkit.activeState","text":"activeState(state)\n\nWhen used in a finite state machine, this operator returns true if the queried state is active and false otherwise. \n\n\n\n\n\n","category":"function"},{"location":"API/model_building/#ModelingToolkit.entry","page":"Model building reference","title":"ModelingToolkit.entry","text":"entry()\nentry(state)\n\nWhen used in a finite-state machine, this operator returns true at the first tick when the state is active, and false otherwise.\n\nWhen used to query the entry of the enclosing state, the method without arguments is used, when used to query the entry of another state, the state is passed as an argument.\n\nThis can be used to perform a unique action when entering a state.\n\n\n\n\n\n","category":"function"},{"location":"API/model_building/#ModelingToolkit.ticksInState","page":"Model building reference","title":"ModelingToolkit.ticksInState","text":"ticksInState()\nticksInState(state)\n\nGet the number of ticks spent in a state in a finite state machine.\n\nWhen used to query the number of ticks spent in the enclosing state, the method without arguments is used, i.e.,\n\n@mtkmodel FSM begin\n    ...\n    @equations begin\n        var(k+1) ~ ticksInState() >= 2 ? 0.0 : var(k)\n    end\nend\n\nIf used to query the number of ticks in another state, the state is passed as an argument.\n\nThis operator can be used in both equations and transition conditions.\n\nSee also timeInState and entry\n\n\n\n\n\n","category":"function"},{"location":"API/model_building/#ModelingToolkit.timeInState","page":"Model building reference","title":"ModelingToolkit.timeInState","text":"timeInState()\ntimeInState(state)\n\nGet the time (in seconds) spent in a state in a finite state machine.\n\nWhen used to query the time spent in the enclosing state, the method without arguments is used, i.e.,\n\n@mtkmodel FSM begin\n    ...\n    @equations begin\n        var(k+1) ~ timeInState() >= 2 ? 0.0 : var(k)\n    end\nend\n\nIf used to query the residence time of another state, the state is passed as an argument.\n\nThis operator can be used in both equations and transition conditions.\n\nSee also ticksInState and entry\n\n\n\n\n\n","category":"function"},{"location":"internals/#Internal-Details","page":"Internal Details","title":"Internal Details","text":"","category":"section"},{"location":"internals/","page":"Internal Details","title":"Internal Details","text":"This is a page for detailing some of the inner workings to help future contributors to the library.","category":"page"},{"location":"tutorials/modelingtoolkitize/#Modelingtoolkitize:-Automatically-Translating-Numerical-to-Symbolic-Code","page":"Modelingtoolkitize: Automatically Translating Numerical to Symbolic Code","title":"Modelingtoolkitize: Automatically Translating Numerical to Symbolic Code","text":"","category":"section"},{"location":"tutorials/modelingtoolkitize/#What-is-modelingtoolkitize?","page":"Modelingtoolkitize: Automatically Translating Numerical to Symbolic Code","title":"What is modelingtoolkitize?","text":"","category":"section"},{"location":"tutorials/modelingtoolkitize/","page":"Modelingtoolkitize: Automatically Translating Numerical to Symbolic Code","title":"Modelingtoolkitize: Automatically Translating Numerical to Symbolic Code","text":"From the other tutorials you will have learned that ModelingToolkit is a symbolic library with all kinds of goodies, such as the ability to derive analytical expressions for things like Jacobians, determine the sparsity of a set of equations, perform index reduction, tearing, and other transformations to improve both stability and performance. All of these are good things, but all of these require that one has defined the problem symbolically.","category":"page"},{"location":"tutorials/modelingtoolkitize/","page":"Modelingtoolkitize: Automatically Translating Numerical to Symbolic Code","title":"Modelingtoolkitize: Automatically Translating Numerical to Symbolic Code","text":"But what happens if one wants to use ModelingToolkit functionality on code that is already written for DifferentialEquations.jl, NonlinearSolve.jl, Optimization.jl, or beyond?","category":"page"},{"location":"tutorials/modelingtoolkitize/","page":"Modelingtoolkitize: Automatically Translating Numerical to Symbolic Code","title":"Modelingtoolkitize: Automatically Translating Numerical to Symbolic Code","text":"modelingtoolktize is a function in ModelingToolkit which takes a numerically-defined SciMLProblem and transforms it into its symbolic ModelingToolkit equivalent. By doing so, ModelingToolkit analysis passes and transformations can be run as intermediate steps to improve a simulation code before it's passed to the solver.","category":"page"},{"location":"tutorials/modelingtoolkitize/","page":"Modelingtoolkitize: Automatically Translating Numerical to Symbolic Code","title":"Modelingtoolkitize: Automatically Translating Numerical to Symbolic Code","text":"note: Note\nmodelingtoolkitize does have some limitations, i.e. not all codes that work with the numerical solvers will work with modelingtoolkitize. Namely, it requires the ability to trace the equations with Symbolics.jl Num types. Generally, a code which is compatible with forward-mode automatic differentiation is compatible with modelingtoolkitize.","category":"page"},{"location":"tutorials/modelingtoolkitize/","page":"Modelingtoolkitize: Automatically Translating Numerical to Symbolic Code","title":"Modelingtoolkitize: Automatically Translating Numerical to Symbolic Code","text":"warn: Warn\nmodelingtoolkitize expressions cannot keep control flow structures (loops), and thus equations with long loops will be translated into large expressions, which can increase the compile time of the equations and reduce the SIMD vectorization achieved by LLVM.","category":"page"},{"location":"tutorials/modelingtoolkitize/#Example-Usage:-Generating-an-Analytical-Jacobian-Expression-for-an-ODE-Code","page":"Modelingtoolkitize: Automatically Translating Numerical to Symbolic Code","title":"Example Usage: Generating an Analytical Jacobian Expression for an ODE Code","text":"","category":"section"},{"location":"tutorials/modelingtoolkitize/","page":"Modelingtoolkitize: Automatically Translating Numerical to Symbolic Code","title":"Modelingtoolkitize: Automatically Translating Numerical to Symbolic Code","text":"Take, for example, the Robertson ODE defined as an ODEProblem for OrdinaryDiffEq.jl:","category":"page"},{"location":"tutorials/modelingtoolkitize/","page":"Modelingtoolkitize: Automatically Translating Numerical to Symbolic Code","title":"Modelingtoolkitize: Automatically Translating Numerical to Symbolic Code","text":"using OrdinaryDiffEq, ModelingToolkit\nfunction rober(du, u, p, t)\n    y₁, y₂, y₃ = u\n    k₁, k₂, k₃ = p\n    du[1] = -k₁ * y₁ + k₃ * y₂ * y₃\n    du[2] = k₁ * y₁ - k₂ * y₂^2 - k₃ * y₂ * y₃\n    du[3] = k₂ * y₂^2\n    nothing\nend\nprob = ODEProblem(rober, [1.0, 0.0, 0.0], (0.0, 1e5), (0.04, 3e7, 1e4))","category":"page"},{"location":"tutorials/modelingtoolkitize/","page":"Modelingtoolkitize: Automatically Translating Numerical to Symbolic Code","title":"Modelingtoolkitize: Automatically Translating Numerical to Symbolic Code","text":"If we want to get a symbolic representation, we can simply call modelingtoolkitize on the prob, which will return an System:","category":"page"},{"location":"tutorials/modelingtoolkitize/","page":"Modelingtoolkitize: Automatically Translating Numerical to Symbolic Code","title":"Modelingtoolkitize: Automatically Translating Numerical to Symbolic Code","text":"@mtkcompile sys = modelingtoolkitize(prob)","category":"page"},{"location":"tutorials/modelingtoolkitize/","page":"Modelingtoolkitize: Automatically Translating Numerical to Symbolic Code","title":"Modelingtoolkitize: Automatically Translating Numerical to Symbolic Code","text":"Using this, we can symbolically build the Jacobian and then rebuild the ODEProblem:","category":"page"},{"location":"tutorials/modelingtoolkitize/","page":"Modelingtoolkitize: Automatically Translating Numerical to Symbolic Code","title":"Modelingtoolkitize: Automatically Translating Numerical to Symbolic Code","text":"prob_jac = ODEProblem(sys, [], (0.0, 1e5), jac = true)","category":"page"},{"location":"tutorials/attractors/#attractors","page":"Multi- and Nonlocal- Continuation","title":"Multi- and Nonlocal- Continuation","text":"","category":"section"},{"location":"tutorials/attractors/","page":"Multi- and Nonlocal- Continuation","title":"Multi- and Nonlocal- Continuation","text":"In the tutorial on Bifurcation Diagrams we saw how one can create them by integrating ModelingToolkit.jl with BifurcationKit.jl. This approach is also often called continuation in the broader literature, because in essence we are \"continuing\" the location of individual un/stable fixed points or limit cycles in a dynamical system across a parameter axis.","category":"page"},{"location":"tutorials/attractors/","page":"Multi- and Nonlocal- Continuation","title":"Multi- and Nonlocal- Continuation","text":"Recently, an alternative continuation framework was proposed that takes a fundamentally different approach to continuation that is particularly suitable for complex systems. This framework is implemented in Attractors.jl as part of the DynamicalSystems.jl software library. This new continuation is called global continuation, while the one of BifurcationKit.jl is called local continuation.","category":"page"},{"location":"tutorials/attractors/","page":"Multi- and Nonlocal- Continuation","title":"Multi- and Nonlocal- Continuation","text":"Instead of continuing an individual fixed point or limit cycle, the global continuation finds all attractors of the dynamical system and continues all of them, in parallel, in a single continuation. It distinguishes and labels automatically the different attractors. Hence \"multi-\" for multiple attractors. Another key difference is that instead of estimating the local (or linear, or Jacobian) stability of the attractors, it estimates various measures of nonlocal stability (e.g, related with the size of the basins of attraction, or the size of a perturbation that would make the dynamical system state converge to an alternative attractor). Hence the \"nonlocal-\" component. More differences and pros & cons are discussed in the documentation of Attractors.jl.","category":"page"},{"location":"tutorials/attractors/","page":"Multi- and Nonlocal- Continuation","title":"Multi- and Nonlocal- Continuation","text":"note: Attractors and basins\nThis tutorial assumes that you have some familiarity with dynamical systems, specifically what are attractors and basins of attraction. If you don't have this yet, we recommend Chapter 1 of the textbook Nonlinear Dynamics.","category":"page"},{"location":"tutorials/attractors/#Creating-the-DynamicalSystem-via-MTK","page":"Multi- and Nonlocal- Continuation","title":"Creating the DynamicalSystem via MTK","text":"","category":"section"},{"location":"tutorials/attractors/","page":"Multi- and Nonlocal- Continuation","title":"Multi- and Nonlocal- Continuation","text":"Let's showcase this framework by modelling a chaotic bistable dynamical system that we define via ModelingToolkit.jl, which will the be casted into a DynamicalSystem type for the DynamicalSystems.jl library. The equations of our system are","category":"page"},{"location":"tutorials/attractors/","page":"Multi- and Nonlocal- Continuation","title":"Multi- and Nonlocal- Continuation","text":"using ModelingToolkit\nusing ModelingToolkit: t_nounits as t, D_nounits as D\n\n@variables x(t)=-4.0 y(t)=5.0 z(t)=0.0\n@parameters a=5.0 b=0.1\n\neqs = [\n    D(x) ~ y - x,\n    D(y) ~ -x * z + b * abs(z),\n    D(z) ~ x * y - a\n]","category":"page"},{"location":"tutorials/attractors/","page":"Multi- and Nonlocal- Continuation","title":"Multi- and Nonlocal- Continuation","text":"Because our dynamical system is super simple, we will directly make an System and cast it in an ODEProblem as in the Systems tutorial. Since all state variables and parameters have a default value we can immediately write","category":"page"},{"location":"tutorials/attractors/","page":"Multi- and Nonlocal- Continuation","title":"Multi- and Nonlocal- Continuation","text":"@named modlorenz = System(eqs, t)\nssys = mtkcompile(modlorenz)\n# The timespan given to the problem is irrelevant for DynamicalSystems.jl\nprob = ODEProblem(ssys, [], (0.0, 1.0))","category":"page"},{"location":"tutorials/attractors/","page":"Multi- and Nonlocal- Continuation","title":"Multi- and Nonlocal- Continuation","text":"This prob can be turned to a dynamical system as simply as","category":"page"},{"location":"tutorials/attractors/","page":"Multi- and Nonlocal- Continuation","title":"Multi- and Nonlocal- Continuation","text":"using Attractors # or `DynamicalSystems`\nds = CoupledODEs(prob)","category":"page"},{"location":"tutorials/attractors/","page":"Multi- and Nonlocal- Continuation","title":"Multi- and Nonlocal- Continuation","text":"DynamicalSystems.jl integrates fully with ModelingToolkit.jl out of the box and understands whether a given problem has been created via ModelingToolkit.jl. For example you can use the symbolic variables, or their Symbol representations, to access a system state or parameter","category":"page"},{"location":"tutorials/attractors/","page":"Multi- and Nonlocal- Continuation","title":"Multi- and Nonlocal- Continuation","text":"observe_state(ds, x)","category":"page"},{"location":"tutorials/attractors/","page":"Multi- and Nonlocal- Continuation","title":"Multi- and Nonlocal- Continuation","text":"current_parameter(ds, :a) # or `a` directly","category":"page"},{"location":"tutorials/attractors/#Finding-all-attractors-in-the-state-space","page":"Multi- and Nonlocal- Continuation","title":"Finding all attractors in the state space","text":"","category":"section"},{"location":"tutorials/attractors/","page":"Multi- and Nonlocal- Continuation","title":"Multi- and Nonlocal- Continuation","text":"Attractors.jl provides an extensive interface for finding all (within a state space region and numerical accuracy) attractors of a dynamical system. This interface is structured around the type AttractorMapper and is discussed in the Attractors.jl documentation in detail. Here we will briefly mention one of the possible approaches, the recurrences-based algorithm. It finds attractors by finding locations in the state space where the trajectory returns again and again.","category":"page"},{"location":"tutorials/attractors/","page":"Multi- and Nonlocal- Continuation","title":"Multi- and Nonlocal- Continuation","text":"To use this technique, we first need to create a tessellation of the state space","category":"page"},{"location":"tutorials/attractors/","page":"Multi- and Nonlocal- Continuation","title":"Multi- and Nonlocal- Continuation","text":"grid = (\n    range(-15.0, 15.0; length = 150), # x\n    range(-20.0, 20.0; length = 150), # y\n    range(-20.0, 20.0; length = 150) # z\n)","category":"page"},{"location":"tutorials/attractors/","page":"Multi- and Nonlocal- Continuation","title":"Multi- and Nonlocal- Continuation","text":"which we then give as input to the AttractorsViaRecurrences mapper along with the dynamical system","category":"page"},{"location":"tutorials/attractors/","page":"Multi- and Nonlocal- Continuation","title":"Multi- and Nonlocal- Continuation","text":"mapper = AttractorsViaRecurrences(ds, grid;\n    consecutive_recurrences = 1000,\n    consecutive_lost_steps = 100\n)","category":"page"},{"location":"tutorials/attractors/","page":"Multi- and Nonlocal- Continuation","title":"Multi- and Nonlocal- Continuation","text":"to learn about the metaparameters of the algorithm visit the documentation of Attractors.jl.","category":"page"},{"location":"tutorials/attractors/","page":"Multi- and Nonlocal- Continuation","title":"Multi- and Nonlocal- Continuation","text":"This mapper object is incredibly powerful! It can be used to map initial conditions to attractor they converge to, while ensuring that initial conditions that converge to the same attractor are given the same label. For example, if we use the mapper as a function and give it an initial condition we get","category":"page"},{"location":"tutorials/attractors/","page":"Multi- and Nonlocal- Continuation","title":"Multi- and Nonlocal- Continuation","text":"mapper([-4.0, 5, 0])","category":"page"},{"location":"tutorials/attractors/","page":"Multi- and Nonlocal- Continuation","title":"Multi- and Nonlocal- Continuation","text":"mapper([4.0, 2, 0])","category":"page"},{"location":"tutorials/attractors/","page":"Multi- and Nonlocal- Continuation","title":"Multi- and Nonlocal- Continuation","text":"mapper([1.0, 3, 2])","category":"page"},{"location":"tutorials/attractors/","page":"Multi- and Nonlocal- Continuation","title":"Multi- and Nonlocal- Continuation","text":"The numbers returned are simply the unique identifiers of the attractors the initial conditions converged to.","category":"page"},{"location":"tutorials/attractors/","page":"Multi- and Nonlocal- Continuation","title":"Multi- and Nonlocal- Continuation","text":"DynamicalSystems.jl library is the only dynamical systems software (in any language) that provides such an infrastructure for mapping initial conditions of any arbitrary dynamical system to its unique attractors. And this is only the tip of this iceberg! The rest of the functionality of Attractors.jl is all full of brand new cutting edge progress in dynamical systems research.","category":"page"},{"location":"tutorials/attractors/","page":"Multi- and Nonlocal- Continuation","title":"Multi- and Nonlocal- Continuation","text":"The found attractors are stored in the mapper internally, to obtain them we use the function","category":"page"},{"location":"tutorials/attractors/","page":"Multi- and Nonlocal- Continuation","title":"Multi- and Nonlocal- Continuation","text":"attractors = extract_attractors(mapper)","category":"page"},{"location":"tutorials/attractors/","page":"Multi- and Nonlocal- Continuation","title":"Multi- and Nonlocal- Continuation","text":"This is a dictionary that maps attractor IDs to the attractor sets themselves. StateSpaceSet is a wrapper of a vector of points and behaves exactly like a vector of points. We can plot them easily like","category":"page"},{"location":"tutorials/attractors/","page":"Multi- and Nonlocal- Continuation","title":"Multi- and Nonlocal- Continuation","text":"using CairoMakie\nfig = Figure()\nax = Axis(fig[1, 1])\ncolors = [\"#7143E0\", \"#191E44\"]\nfor (id, A) in attractors\n    scatter!(ax, A[:, [1, 3]]; color = colors[id])\nend\nfig","category":"page"},{"location":"tutorials/attractors/#Basins-of-attraction","page":"Multi- and Nonlocal- Continuation","title":"Basins of attraction","text":"","category":"section"},{"location":"tutorials/attractors/","page":"Multi- and Nonlocal- Continuation","title":"Multi- and Nonlocal- Continuation","text":"Estimating the basins of attraction of these attractors is a matter of a couple lines of code. First we define the state space are to estimate the basins for. Here we can re-use the grid we defined above. Then we only have to call","category":"page"},{"location":"tutorials/attractors/","page":"Multi- and Nonlocal- Continuation","title":"Multi- and Nonlocal- Continuation","text":"basins = basins_of_attraction(mapper, grid)","category":"page"},{"location":"tutorials/attractors/","page":"Multi- and Nonlocal- Continuation","title":"Multi- and Nonlocal- Continuation","text":"We won't run this in this tutorial because it is a length computation (150×150×150). We will however estimate a slice of the 3D basins of attraction. DynamicalSystems.jl allows for a rather straightforward setting of initial conditions:","category":"page"},{"location":"tutorials/attractors/","page":"Multi- and Nonlocal- Continuation","title":"Multi- and Nonlocal- Continuation","text":"ics = [Dict(:x => x, :y => 0, :z => z) for x in grid[1] for z in grid[3]]","category":"page"},{"location":"tutorials/attractors/","page":"Multi- and Nonlocal- Continuation","title":"Multi- and Nonlocal- Continuation","text":"now we can estimate the basins of attraction on a slice on the x-z grid","category":"page"},{"location":"tutorials/attractors/","page":"Multi- and Nonlocal- Continuation","title":"Multi- and Nonlocal- Continuation","text":"fs, labels = basins_fractions(mapper, ics)\nlabels = reshape(labels, (length(grid[1]), length(grid[3])))","category":"page"},{"location":"tutorials/attractors/","page":"Multi- and Nonlocal- Continuation","title":"Multi- and Nonlocal- Continuation","text":"and visualize them","category":"page"},{"location":"tutorials/attractors/","page":"Multi- and Nonlocal- Continuation","title":"Multi- and Nonlocal- Continuation","text":"heatmap(grid[1], grid[3], labels; colormap = colors)","category":"page"},{"location":"tutorials/attractors/#Global-continuation","page":"Multi- and Nonlocal- Continuation","title":"Global continuation","text":"","category":"section"},{"location":"tutorials/attractors/","page":"Multi- and Nonlocal- Continuation","title":"Multi- and Nonlocal- Continuation","text":"We've already outlined the principles of the global continuation, so let's just do it here! We first have to define a global continuation algorithm, which for this tutorial, it is just a wrapper of the existing mapper","category":"page"},{"location":"tutorials/attractors/","page":"Multi- and Nonlocal- Continuation","title":"Multi- and Nonlocal- Continuation","text":"ascm = AttractorSeedContinueMatch(mapper);","category":"page"},{"location":"tutorials/attractors/","page":"Multi- and Nonlocal- Continuation","title":"Multi- and Nonlocal- Continuation","text":"we need two more ingredients to perform the global continuation. One is a sampler of initial conditions in the state space. Here we'll uniformly sample initial conditions within this grid we have already defined","category":"page"},{"location":"tutorials/attractors/","page":"Multi- and Nonlocal- Continuation","title":"Multi- and Nonlocal- Continuation","text":"sampler, = statespace_sampler(grid);","category":"page"},{"location":"tutorials/attractors/","page":"Multi- and Nonlocal- Continuation","title":"Multi- and Nonlocal- Continuation","text":"the last ingredient is what parameter(s) to perform the continuation over. In contrast to local continuation, where we can only specify a parameter range, in global continuation one can specify an exact parameter curve to continue over. This curve can span any-dimensional parameter space, in contrast to the 1D or 2D parameter spaces supported in local continuation. Here we will use the curve","category":"page"},{"location":"tutorials/attractors/","page":"Multi- and Nonlocal- Continuation","title":"Multi- and Nonlocal- Continuation","text":"params(θ) = [:a => 5 + 0.5cos(θ), :b => 0.1 + 0.01sin(θ)]\nθs = range(0, 2π; length = 101)\npcurve = params.(θs)","category":"page"},{"location":"tutorials/attractors/","page":"Multi- and Nonlocal- Continuation","title":"Multi- and Nonlocal- Continuation","text":"which makes an ellipsis over the parameter space.","category":"page"},{"location":"tutorials/attractors/","page":"Multi- and Nonlocal- Continuation","title":"Multi- and Nonlocal- Continuation","text":"We put these three ingredients together to call the global continuation","category":"page"},{"location":"tutorials/attractors/","page":"Multi- and Nonlocal- Continuation","title":"Multi- and Nonlocal- Continuation","text":"fractions_cont, attractors_cont = global_continuation(ascm, pcurve, sampler);","category":"page"},{"location":"tutorials/attractors/","page":"Multi- and Nonlocal- Continuation","title":"Multi- and Nonlocal- Continuation","text":"The output of the continuation is how the attractors and their basins fractions change over this parameter curve. We can visualize this directly using a convenience function","category":"page"},{"location":"tutorials/attractors/","page":"Multi- and Nonlocal- Continuation","title":"Multi- and Nonlocal- Continuation","text":"fig = plot_basins_attractors_curves(\n    fractions_cont, attractors_cont, A -> minimum(A[:, 1]), θs\n)","category":"page"},{"location":"tutorials/attractors/","page":"Multi- and Nonlocal- Continuation","title":"Multi- and Nonlocal- Continuation","text":"The top panel shows the relative basins of attractions of the attractors and the bottom panel shows their minimum x-position. The colors correspond to unique attractors. Perhaps making a video is easier to understand:","category":"page"},{"location":"tutorials/attractors/","page":"Multi- and Nonlocal- Continuation","title":"Multi- and Nonlocal- Continuation","text":"animate_attractors_continuation(\n    ds, attractors_cont, fractions_cont, pcurve;\n    savename = \"curvecont.mp4\"\n);","category":"page"},{"location":"tutorials/attractors/","page":"Multi- and Nonlocal- Continuation","title":"Multi- and Nonlocal- Continuation","text":"<video width=\"auto\" controls loop>\n<source src=\"../curvecont.mp4\" type=\"video/mp4\">\n</video>","category":"page"},{"location":"tutorials/attractors/","page":"Multi- and Nonlocal- Continuation","title":"Multi- and Nonlocal- Continuation","text":"To learn more about this global continuation and its various options, and more details about how it compares with local continuation, visit the documentation of Attractors.jl.","category":"page"},{"location":"API/variables/#symbolic_metadata","page":"Symbolic variables and variable metadata","title":"Symbolic variables and variable metadata","text":"","category":"section"},{"location":"API/variables/","page":"Symbolic variables and variable metadata","title":"Symbolic variables and variable metadata","text":"ModelingToolkit uses Symbolics.jl for the symbolic manipulation infrastructure. In fact, the @variables macro is defined in Symbolics.jl. In addition to @variables, ModelingToolkit defines @parameters, @independent_variables, @constants and @brownians. These macros function identically to @variables but allow ModelingToolkit to attach additional metadata.","category":"page"},{"location":"API/variables/#ModelingToolkit.@independent_variables","page":"Symbolic variables and variable metadata","title":"ModelingToolkit.@independent_variables","text":"@independent_variables t₁ t₂ ...\n\nDefine one or more independent variables. For example:\n\n@independent_variables t\n@variables x(t)\n\n\n\n\n\n","category":"macro"},{"location":"API/variables/#ModelingToolkit.@parameters","page":"Symbolic variables and variable metadata","title":"ModelingToolkit.@parameters","text":"Define one or more known parameters.\n\nSee also @independent_variables, @variables and @constants.\n\n\n\n\n\n","category":"macro"},{"location":"API/variables/#ModelingToolkit.@constants","page":"Symbolic variables and variable metadata","title":"ModelingToolkit.@constants","text":"Define one or more constants.\n\nSee also @independent_variables, @parameters and @variables.\n\n\n\n\n\n","category":"macro"},{"location":"API/variables/#ModelingToolkit.@brownians","page":"Symbolic variables and variable metadata","title":"ModelingToolkit.@brownians","text":"Define one or more Brownian variables.\n\n\n\n\n\n","category":"macro"},{"location":"API/variables/","page":"Symbolic variables and variable metadata","title":"Symbolic variables and variable metadata","text":"Symbolic variables can have metadata attached to them. The defaults and guesses assigned at variable construction time are examples of this metadata. ModelingToolkit also defines additional types of metadata.","category":"page"},{"location":"API/variables/#Variable-descriptions","page":"Symbolic variables and variable metadata","title":"Variable descriptions","text":"","category":"section"},{"location":"API/variables/","page":"Symbolic variables and variable metadata","title":"Symbolic variables and variable metadata","text":"Descriptive strings can be attached to variables using the [description = \"descriptive string\"] syntax:","category":"page"},{"location":"API/variables/","page":"Symbolic variables and variable metadata","title":"Symbolic variables and variable metadata","text":"using ModelingToolkit\nusing ModelingToolkit: t_nounits as t, D_nounits as D\n@variables u [description = \"This is my input\"]\ngetdescription(u)","category":"page"},{"location":"API/variables/","page":"Symbolic variables and variable metadata","title":"Symbolic variables and variable metadata","text":"When variables with descriptions are present in systems, they will be printed when the system is shown in the terminal:","category":"page"},{"location":"API/variables/","page":"Symbolic variables and variable metadata","title":"Symbolic variables and variable metadata","text":"@variables u(t) [description = \"A short description of u\"]\n@parameters p [description = \"A description of p\"]\n@named sys = System([u ~ p], t)\nshow(stdout, \"text/plain\", sys) # hide","category":"page"},{"location":"API/variables/","page":"Symbolic variables and variable metadata","title":"Symbolic variables and variable metadata","text":"Calling help on the variable u displays the description, alongside other metadata:","category":"page"},{"location":"API/variables/","page":"Symbolic variables and variable metadata","title":"Symbolic variables and variable metadata","text":"help?> u\n\n  A variable of type Symbolics.Num (Num wraps anything in a type that is a subtype of Real)\n\n  Metadata\n  ≡≡≡≡≡≡≡≡≡≡\n\n  ModelingToolkit.VariableDescription: This is my input\n\n  Symbolics.VariableSource: (:variables, :u)","category":"page"},{"location":"API/variables/#ModelingToolkit.hasdescription","page":"Symbolic variables and variable metadata","title":"ModelingToolkit.hasdescription","text":"hasdescription(x) -> Any\n\n\nCheck if variable x has a non-empty attached description.\n\n\n\n\n\n","category":"function"},{"location":"API/variables/#ModelingToolkit.getdescription","page":"Symbolic variables and variable metadata","title":"ModelingToolkit.getdescription","text":"getdescription(x)\n\nReturn any description attached to variables x. If no description is attached, an empty string is returned.\n\n\n\n\n\n","category":"function"},{"location":"API/variables/#Connect","page":"Symbolic variables and variable metadata","title":"Connect","text":"","category":"section"},{"location":"API/variables/","page":"Symbolic variables and variable metadata","title":"Symbolic variables and variable metadata","text":"Variables in connectors can have connect metadata which describes the type of connections.","category":"page"},{"location":"API/variables/","page":"Symbolic variables and variable metadata","title":"Symbolic variables and variable metadata","text":"Flow is used for variables that represent physical quantities that \"flow\" ex: current in a resistor. These variables sum up to zero in connections.","category":"page"},{"location":"API/variables/","page":"Symbolic variables and variable metadata","title":"Symbolic variables and variable metadata","text":"Stream can be specified for variables that flow bi-directionally.","category":"page"},{"location":"API/variables/","page":"Symbolic variables and variable metadata","title":"Symbolic variables and variable metadata","text":"using ModelingToolkit\nusing ModelingToolkit: t_nounits as t, D_nounits as D\n\n@variables i(t) [connect = Flow]\n@variables k(t) [connect = Stream]\nhasconnect(i)","category":"page"},{"location":"API/variables/","page":"Symbolic variables and variable metadata","title":"Symbolic variables and variable metadata","text":"getconnect(k)","category":"page"},{"location":"API/variables/#ModelingToolkit.hasconnect","page":"Symbolic variables and variable metadata","title":"ModelingToolkit.hasconnect","text":"hasconnect(x)\n\nDetermine whether variable x has a connect type. See also getconnect.\n\n\n\n\n\n","category":"function"},{"location":"API/variables/#ModelingToolkit.getconnect","page":"Symbolic variables and variable metadata","title":"ModelingToolkit.getconnect","text":"getconnect(x)\n\nGet the connect type of x. See also hasconnect.\n\n\n\n\n\n","category":"function"},{"location":"API/variables/#ModelingToolkit.Flow-API-variables","page":"Symbolic variables and variable metadata","title":"ModelingToolkit.Flow","text":"struct Flow <: ModelingToolkit.AbstractConnectType\n\nFlag which is meant to be passed to the connect metadata of a variable to affect how it behaves when the connector it is in is part of a connect equation. Flow denotes that the sum of marked variable in all connectors in the connection set must sum to zero. For example, electric current sums to zero at a junction (assuming appropriate signs are used for current flowing in and out of the function).\n\nFor more information, refer to the Connection semantics section of the docs.\n\nSee also: connect, @connector, Equality, Stream.\n\n\n\n\n\n","category":"type"},{"location":"API/variables/#ModelingToolkit.Stream-API-variables","page":"Symbolic variables and variable metadata","title":"ModelingToolkit.Stream","text":"struct Stream <: ModelingToolkit.AbstractConnectType\n\nFlag which is meant to be passed to the connect metadata of a variable to affect how it behaves when the connector it is in is part of a connect equation. Stream denotes that the variable is part of a special stream connector.\n\nFor more information, refer to the Connection semantics section of the docs.\n\nSee also: connect, @connector, Equality, Flow.\n\n\n\n\n\n","category":"type"},{"location":"API/variables/#Input-or-output","page":"Symbolic variables and variable metadata","title":"Input or output","text":"","category":"section"},{"location":"API/variables/","page":"Symbolic variables and variable metadata","title":"Symbolic variables and variable metadata","text":"Designate a variable as either an input or an output using the following","category":"page"},{"location":"API/variables/","page":"Symbolic variables and variable metadata","title":"Symbolic variables and variable metadata","text":"using ModelingToolkit\nusing ModelingToolkit: t_nounits as t, D_nounits as D\n\n@variables u [input = true]\nisinput(u)","category":"page"},{"location":"API/variables/","page":"Symbolic variables and variable metadata","title":"Symbolic variables and variable metadata","text":"@variables y [output = true]\nisoutput(y)","category":"page"},{"location":"API/variables/#ModelingToolkit.isinput","page":"Symbolic variables and variable metadata","title":"ModelingToolkit.isinput","text":"isinput(x) -> Any\n\n\nCheck if variable x is marked as an input.\n\n\n\n\n\n","category":"function"},{"location":"API/variables/#ModelingToolkit.isoutput","page":"Symbolic variables and variable metadata","title":"ModelingToolkit.isoutput","text":"isoutput(x) -> Any\n\n\nCheck if variable x is marked as an output.\n\n\n\n\n\n","category":"function"},{"location":"API/variables/#ModelingToolkit.setinput","page":"Symbolic variables and variable metadata","title":"ModelingToolkit.setinput","text":"setinput(x, v::Bool) -> Any\n\n\nSet the input metadata of variable x to v.\n\n\n\n\n\n","category":"function"},{"location":"API/variables/#ModelingToolkit.setoutput","page":"Symbolic variables and variable metadata","title":"ModelingToolkit.setoutput","text":"setoutput(x, v::Bool) -> Any\n\n\nSet the output metadata of variable x to v.\n\n\n\n\n\n","category":"function"},{"location":"API/variables/#Bounds","page":"Symbolic variables and variable metadata","title":"Bounds","text":"","category":"section"},{"location":"API/variables/","page":"Symbolic variables and variable metadata","title":"Symbolic variables and variable metadata","text":"Bounds are useful when parameters are to be optimized, or to express intervals of uncertainty.","category":"page"},{"location":"API/variables/","page":"Symbolic variables and variable metadata","title":"Symbolic variables and variable metadata","text":"@variables u [bounds = (-1, 1)];\nhasbounds(u)\ngetbounds(u)","category":"page"},{"location":"API/variables/","page":"Symbolic variables and variable metadata","title":"Symbolic variables and variable metadata","text":"Bounds can also be specified for array variables. A scalar array bound is applied to each element of the array. A bound may also be specified as an array, in which case the size of the array must match the size of the symbolic variable.","category":"page"},{"location":"API/variables/","page":"Symbolic variables and variable metadata","title":"Symbolic variables and variable metadata","text":"@variables x[1:2, 1:2] [bounds = (-1, 1)];\nhasbounds(x)\ngetbounds(x)\ngetbounds(x[1, 1])\ngetbounds(x[1:2, 1])\n@variables x[1:2] [bounds = (-Inf, [1.0, Inf])];\nhasbounds(x)\ngetbounds(x)\ngetbounds(x[2])\nhasbounds(x[2])","category":"page"},{"location":"API/variables/#ModelingToolkit.hasbounds","page":"Symbolic variables and variable metadata","title":"ModelingToolkit.hasbounds","text":"hasbounds(x)\n\nDetermine whether symbolic variable x has bounds associated with it. See also getbounds.\n\n\n\n\n\n","category":"function"},{"location":"API/variables/#ModelingToolkit.getbounds","page":"Symbolic variables and variable metadata","title":"ModelingToolkit.getbounds","text":"getbounds(x)\n\nGet the bounds associated with symbolic variable x. Create parameters with bounds like this\n\n@parameters p [bounds=(-1, 1)]\n\n\n\n\n\ngetbounds(sys::ModelingToolkit.AbstractSystem, p = parameters(sys))\n\nReturns a dict with pairs p => (lb, ub) mapping parameters of sys to lower and upper bounds. Create parameters with bounds like this\n\n@parameters p [bounds=(-1, 1)]\n\nTo obtain unknown variable bounds, call getbounds(sys, unknowns(sys))\n\n\n\n\n\nlb, ub = getbounds(p::AbstractVector)\n\nReturn vectors of lower and upper bounds of parameter vector p. Create parameters with bounds like this\n\n@parameters p [bounds=(-1, 1)]\n\nSee also tunable_parameters, hasbounds\n\n\n\n\n\n","category":"function"},{"location":"API/variables/#Guess","page":"Symbolic variables and variable metadata","title":"Guess","text":"","category":"section"},{"location":"API/variables/","page":"Symbolic variables and variable metadata","title":"Symbolic variables and variable metadata","text":"Specify an initial guess for variables of a System. This is used when building the InitializationProblem.","category":"page"},{"location":"API/variables/","page":"Symbolic variables and variable metadata","title":"Symbolic variables and variable metadata","text":"@variables u [guess = 1];\nhasguess(u)\ngetguess(u)","category":"page"},{"location":"API/variables/#ModelingToolkit.hasguess","page":"Symbolic variables and variable metadata","title":"ModelingToolkit.hasguess","text":"hasguess(x)\n\nDetermine whether symbolic variable x has a guess associated with it. See also getguess.\n\n\n\n\n\n","category":"function"},{"location":"API/variables/#ModelingToolkit.getguess","page":"Symbolic variables and variable metadata","title":"ModelingToolkit.getguess","text":"getguess(x)\n\nGet the guess for the initial value associated with symbolic variable x. Create variables with a guess like this\n\n@variables x [guess=1]\n\n\n\n\n\n","category":"function"},{"location":"API/variables/","page":"Symbolic variables and variable metadata","title":"Symbolic variables and variable metadata","text":"When a system is constructed, the guesses of the involved variables are stored in a Dict in the system. After this point, the guess metadata of the variable is irrelevant.","category":"page"},{"location":"API/variables/#ModelingToolkit.guesses-API-variables","page":"Symbolic variables and variable metadata","title":"ModelingToolkit.guesses","text":"guesses(sys::ModelingToolkit.AbstractSystem) -> Any\n\n\nGet the guesses for variables in the initialization system of the system sys and its subsystems.\n\nSee also initialization_equations and ModelingToolkit.get_guesses.\n\n\n\n\n\n","category":"function"},{"location":"API/variables/#Mark-input-as-a-disturbance","page":"Symbolic variables and variable metadata","title":"Mark input as a disturbance","text":"","category":"section"},{"location":"API/variables/","page":"Symbolic variables and variable metadata","title":"Symbolic variables and variable metadata","text":"Indicate that an input is not available for control, i.e., it's a disturbance input.","category":"page"},{"location":"API/variables/","page":"Symbolic variables and variable metadata","title":"Symbolic variables and variable metadata","text":"@variables u [input = true, disturbance = true]\nisdisturbance(u)","category":"page"},{"location":"API/variables/#ModelingToolkit.isdisturbance","page":"Symbolic variables and variable metadata","title":"ModelingToolkit.isdisturbance","text":"isdisturbance(x)\n\nDetermine whether symbolic variable x is marked as a disturbance input.\n\n\n\n\n\n","category":"function"},{"location":"API/variables/#Mark-parameter-as-tunable","page":"Symbolic variables and variable metadata","title":"Mark parameter as tunable","text":"","category":"section"},{"location":"API/variables/","page":"Symbolic variables and variable metadata","title":"Symbolic variables and variable metadata","text":"Indicate that a parameter can be automatically tuned by parameter optimization or automatic control tuning apps.","category":"page"},{"location":"API/variables/","page":"Symbolic variables and variable metadata","title":"Symbolic variables and variable metadata","text":"@parameters Kp [tunable = true]\nistunable(Kp)","category":"page"},{"location":"API/variables/#ModelingToolkit.istunable","page":"Symbolic variables and variable metadata","title":"ModelingToolkit.istunable","text":"istunable(x, default = true)\n\nDetermine whether symbolic variable x is marked as a tunable for an automatic tuning algorithm.\n\ndefault indicates whether variables without tunable metadata are to be considered tunable or not.\n\nCreate a tunable parameter by\n\n@parameters u [tunable=true]\n\nSee also tunable_parameters, getbounds\n\n\n\n\n\n","category":"function"},{"location":"API/variables/#ModelingToolkit.isconstant","page":"Symbolic variables and variable metadata","title":"ModelingToolkit.isconstant","text":"Test whether x is a constant-type Sym.\n\n\n\n\n\n","category":"function"},{"location":"API/variables/","page":"Symbolic variables and variable metadata","title":"Symbolic variables and variable metadata","text":"note: Note\n@constants is a convenient way to create @parameters with tunable = false metadata","category":"page"},{"location":"API/variables/#Probability-distributions","page":"Symbolic variables and variable metadata","title":"Probability distributions","text":"","category":"section"},{"location":"API/variables/","page":"Symbolic variables and variable metadata","title":"Symbolic variables and variable metadata","text":"A probability distribution may be associated with a parameter to indicate either uncertainty about its value, or as a prior distribution for Bayesian optimization.","category":"page"},{"location":"API/variables/","page":"Symbolic variables and variable metadata","title":"Symbolic variables and variable metadata","text":"using Distributions;\nd = Normal(10, 1);\n@parameters m [dist = d];\nhasdist(m)\ngetdist(m)","category":"page"},{"location":"API/variables/#ModelingToolkit.hasdist","page":"Symbolic variables and variable metadata","title":"ModelingToolkit.hasdist","text":"hasdist(x)\n\nDetermine whether symbolic variable x has a probability distribution associated with it.\n\n\n\n\n\n","category":"function"},{"location":"API/variables/#ModelingToolkit.getdist","page":"Symbolic variables and variable metadata","title":"ModelingToolkit.getdist","text":"getdist(x)\n\nGet the probability distribution associated with symbolic variable x. If no distribution is associated with x, nothing is returned. Create parameters with associated distributions like this\n\nusing Distributions\nd = Normal(0, 1)\n@parameters u [dist = d]\nhasdist(u) # true\ngetdist(u) # retrieve distribution\n\n\n\n\n\n","category":"function"},{"location":"API/variables/#Irreducible","page":"Symbolic variables and variable metadata","title":"Irreducible","text":"","category":"section"},{"location":"API/variables/","page":"Symbolic variables and variable metadata","title":"Symbolic variables and variable metadata","text":"A variable can be marked irreducible to prevent it from being moved to an observed state. This forces the variable to be computed during solving so that it can be accessed in callbacks","category":"page"},{"location":"API/variables/","page":"Symbolic variables and variable metadata","title":"Symbolic variables and variable metadata","text":"@variables important_value [irreducible = true]\nisirreducible(important_value)","category":"page"},{"location":"API/variables/#ModelingToolkit.isirreducible","page":"Symbolic variables and variable metadata","title":"ModelingToolkit.isirreducible","text":"isirreducible(x) -> Any\n\n\nCheck if x is marked as irreducible. This prevents it from being eliminated as an observed variable in mtkcompile.\n\n\n\n\n\n","category":"function"},{"location":"API/variables/#State-Priority","page":"Symbolic variables and variable metadata","title":"State Priority","text":"","category":"section"},{"location":"API/variables/","page":"Symbolic variables and variable metadata","title":"Symbolic variables and variable metadata","text":"When a model is structurally simplified, the algorithm will try to ensure that the variables with higher state priority become states of the system. A variable's state priority is a number set using the state_priority metadata.","category":"page"},{"location":"API/variables/","page":"Symbolic variables and variable metadata","title":"Symbolic variables and variable metadata","text":"@variables important_dof [state_priority = 10] unimportant_dof [state_priority = -2]\nstate_priority(important_dof)","category":"page"},{"location":"API/variables/#ModelingToolkit.state_priority","page":"Symbolic variables and variable metadata","title":"ModelingToolkit.state_priority","text":"state_priority(x) -> Float64\n\n\nReturn the state_priority metadata of variable x. This influences its priority to be chosen as a state in mtkcompile.\n\n\n\n\n\n","category":"function"},{"location":"API/variables/#Units","page":"Symbolic variables and variable metadata","title":"Units","text":"","category":"section"},{"location":"API/variables/","page":"Symbolic variables and variable metadata","title":"Symbolic variables and variable metadata","text":"Units for variables can be designated using symbolic metadata. For more information, please see the model validation and units section of the docs. Note that getunit is not equivalent to get_unit - the former is a metadata getter for individual variables (and is provided so the same interface function for unit exists like other metadata), while the latter is used to handle more general symbolic expressions.","category":"page"},{"location":"API/variables/","page":"Symbolic variables and variable metadata","title":"Symbolic variables and variable metadata","text":"using DynamicQuantities;\n@variables speed [unit = u\"m/s\"];\nhasunit(speed)\ngetunit(speed)","category":"page"},{"location":"API/variables/#ModelingToolkit.hasunit","page":"Symbolic variables and variable metadata","title":"ModelingToolkit.hasunit","text":"hasunit(x)\n\nCheck if the variable x has a unit.\n\n\n\n\n\n","category":"function"},{"location":"API/variables/#ModelingToolkit.getunit","page":"Symbolic variables and variable metadata","title":"ModelingToolkit.getunit","text":"getunit(x)\n\nFetch the unit associated with variable x. This function is a metadata getter for an individual variable, while get_unit is used for unit inference on more complicated sdymbolic expressions.\n\n\n\n\n\n","category":"function"},{"location":"API/variables/#Miscellaneous-metadata","page":"Symbolic variables and variable metadata","title":"Miscellaneous metadata","text":"","category":"section"},{"location":"API/variables/","page":"Symbolic variables and variable metadata","title":"Symbolic variables and variable metadata","text":"User-defined metadata can be added using the misc metadata. This can be queried using the hasmisc and getmisc functions.","category":"page"},{"location":"API/variables/","page":"Symbolic variables and variable metadata","title":"Symbolic variables and variable metadata","text":"@variables u [misc = :conserved_parameter] y [misc = [2, 4, 6]];\nhasmisc(u)\ngetmisc(y)","category":"page"},{"location":"API/variables/#ModelingToolkit.hasmisc","page":"Symbolic variables and variable metadata","title":"ModelingToolkit.hasmisc","text":"hasmisc(x)\n\nDetermine whether a symbolic variable x has misc metadata associated with it. \n\nSee also getmisc(x).\n\n\n\n\n\n","category":"function"},{"location":"API/variables/#ModelingToolkit.getmisc","page":"Symbolic variables and variable metadata","title":"ModelingToolkit.getmisc","text":"getmisc(x)\n\nFetch any miscellaneous data associated with symbolic variable x. See also hasmisc(x).\n\n\n\n\n\n","category":"function"},{"location":"API/variables/#Dumping-metadata","page":"Symbolic variables and variable metadata","title":"Dumping metadata","text":"","category":"section"},{"location":"API/variables/","page":"Symbolic variables and variable metadata","title":"Symbolic variables and variable metadata","text":"ModelingToolkit allows dumping the metadata of a variable as a NamedTuple.","category":"page"},{"location":"API/variables/#ModelingToolkit.dump_variable_metadata","page":"Symbolic variables and variable metadata","title":"ModelingToolkit.dump_variable_metadata","text":"dump_variable_metadata(var)\n\nReturn all the metadata associated with symbolic variable var as a NamedTuple.\n\nusing ModelingToolkit\n\n@parameters p::Int [description = \"My description\", bounds = (0.5, 1.5)]\nModelingToolkit.dump_variable_metadata(p)\n\n\n\n\n\n","category":"function"},{"location":"API/variables/#Additional-functions","page":"Symbolic variables and variable metadata","title":"Additional functions","text":"","category":"section"},{"location":"API/variables/","page":"Symbolic variables and variable metadata","title":"Symbolic variables and variable metadata","text":"For systems that contain parameters with metadata like described above, have some additional functions defined for convenience. In the example below, we define a system with tunable parameters and extract bounds vectors","category":"page"},{"location":"API/variables/","page":"Symbolic variables and variable metadata","title":"Symbolic variables and variable metadata","text":"@variables x(t)=0 u(t)=0 [input=true] y(t)=0 [output=true]\n@parameters T [tunable = true, bounds = (0, Inf)]\n@parameters k [tunable = true, bounds = (0, Inf)]\neqs = [D(x) ~ (-x + k * u) / T # A first-order system with time constant T and gain k\n       y ~ x]\nsys = System(eqs, t, name = :tunable_first_order)","category":"page"},{"location":"API/variables/","page":"Symbolic variables and variable metadata","title":"Symbolic variables and variable metadata","text":"p = tunable_parameters(sys) # extract all parameters marked as tunable","category":"page"},{"location":"API/variables/","page":"Symbolic variables and variable metadata","title":"Symbolic variables and variable metadata","text":"lb, ub = getbounds(p) # operating on a vector, we get lower and upper bound vectors","category":"page"},{"location":"API/variables/","page":"Symbolic variables and variable metadata","title":"Symbolic variables and variable metadata","text":"b = getbounds(sys) # Operating on the system, we get a dict","category":"page"},{"location":"API/variables/","page":"Symbolic variables and variable metadata","title":"Symbolic variables and variable metadata","text":"See also:","category":"page"},{"location":"API/variables/#ModelingToolkit.tunable_parameters-API-variables","page":"Symbolic variables and variable metadata","title":"ModelingToolkit.tunable_parameters","text":"tunable_parameters(sys, p = parameters(sys; initial_parameters = true); default=true)\n\nGet all parameters of sys that are marked as tunable.\n\nKeyword argument default indicates whether variables without tunable metadata are to be considered tunable or not.\n\nCreate a tunable parameter by\n\n@parameters u [tunable=true]\n\nFor systems created with split = true (the default) and default = true passed to this function, the order of parameters returned is the order in which they are stored in the tunables portion of MTKParameters. Note that array variables will not be scalarized. To obtain the flattened representation of the tunables portion, call Symbolics.scalarize(tunable_parameters(sys)) and concatenate the resulting arrays.\n\nSee also getbounds, istunable, MTKParameters, complete\n\n\n\n\n\n","category":"function"},{"location":"API/variables/#ModelingToolkit.dump_unknowns-API-variables","page":"Symbolic variables and variable metadata","title":"ModelingToolkit.dump_unknowns","text":"dump_unknowns(sys::AbstractSystem)\n\nReturn an array of NamedTuples containing the metadata associated with each unknown in sys. Also includes the default value of the unknown, if provided.\n\nusing ModelingToolkit\nusing DynamicQuantities\nusing ModelingToolkit: t, D\n\n@parameters p = 1.0, [description = \"My parameter\", tunable = false] q = 2.0, [description = \"Other parameter\"]\n@variables x(t) = 3.0 [unit = u\"m\"]\n@named sys = System(Equation[], t, [x], [p, q])\nModelingToolkit.dump_unknowns(sys)\n\nSee also: ModelingToolkit.dump_variable_metadata, ModelingToolkit.dump_parameters\n\n\n\n\n\n","category":"function"},{"location":"API/variables/#ModelingToolkit.dump_parameters-API-variables","page":"Symbolic variables and variable metadata","title":"ModelingToolkit.dump_parameters","text":"dump_parameters(sys::AbstractSystem)\n\nReturn an array of NamedTuples containing the metadata associated with each parameter in sys. Also includes the default value of the parameter, if provided.\n\nusing ModelingToolkit\nusing DynamicQuantities\nusing ModelingToolkit: t, D\n\n@parameters p = 1.0, [description = \"My parameter\", tunable = false] q = 2.0, [description = \"Other parameter\"]\n@variables x(t) = 3.0 [unit = u\"m\"]\n@named sys = System(Equation[], t, [x], [p, q])\nModelingToolkit.dump_parameters(sys)\n\nSee also: ModelingToolkit.dump_variable_metadata, ModelingToolkit.dump_unknowns\n\n\n\n\n\n","category":"function"},{"location":"API/variables/#Symbolic-operators","page":"Symbolic variables and variable metadata","title":"Symbolic operators","text":"","category":"section"},{"location":"API/variables/","page":"Symbolic variables and variable metadata","title":"Symbolic variables and variable metadata","text":"ModelingToolkit makes heavy use of \"operators\". These are custom functions that are applied to symbolic variables. The most common operator is the Differential operator, defined in Symbolics.jl.","category":"page"},{"location":"API/variables/","page":"Symbolic variables and variable metadata","title":"Symbolic variables and variable metadata","text":"ModelingToolkit also defines a plethora of custom operators.","category":"page"},{"location":"API/variables/#ModelingToolkit.Pre","page":"Symbolic variables and variable metadata","title":"ModelingToolkit.Pre","text":"Pre(x)\n\nThe Pre operator. Used by the callback system to indicate the value of a parameter or variable before the callback is triggered.\n\n\n\n\n\n","category":"type"},{"location":"API/variables/#ModelingToolkit.Initial","page":"Symbolic variables and variable metadata","title":"ModelingToolkit.Initial","text":"Initial(x)\n\nThe Initial operator. Used by initialization to store constant constraints on variables of a system. See the documentation section on initialization for more information.\n\n\n\n\n\n","category":"type"},{"location":"API/variables/#ModelingToolkit.Shift","page":"Symbolic variables and variable metadata","title":"ModelingToolkit.Shift","text":"struct Shift <: Symbolics.Operator\n\nRepresents a shift operator.\n\nFields\n\nt: Fixed Shift\nsteps\n\nExamples\n\njulia> using Symbolics\n\njulia> Δ = Shift(t)\n(::Shift) (generic function with 2 methods)\n\n\n\n\n\n","category":"type"},{"location":"API/variables/","page":"Symbolic variables and variable metadata","title":"Symbolic variables and variable metadata","text":"While not an operator, ShiftIndex is commonly used to use Shift operators in a more convenient way when writing discrete systems.","category":"page"},{"location":"API/variables/#ModelingToolkit.ShiftIndex","page":"Symbolic variables and variable metadata","title":"ModelingToolkit.ShiftIndex","text":"ShiftIndex\n\nThe ShiftIndex operator allows you to index a signal and obtain a shifted discrete-time signal. If the signal is continuous-time, the signal is sampled before shifting.\n\nExamples\n\njulia> t = ModelingToolkit.t_nounits;\n\njulia> @variables x(t);\n\njulia> k = ShiftIndex(t, 0.1);\n\njulia> x(k)      # no shift\nx(t)\n\njulia> x(k+1)    # shift\nShift(1)(x(t))\n\n\n\n\n\n","category":"type"},{"location":"API/variables/#Sampled-time-operators","page":"Symbolic variables and variable metadata","title":"Sampled time operators","text":"","category":"section"},{"location":"API/variables/","page":"Symbolic variables and variable metadata","title":"Symbolic variables and variable metadata","text":"The following operators are used in hybrid ODE systems, where part of the dynamics of the system happen at discrete intervals on a clock. While ModelingToolkit cannot yet simulate such systems, it has the capability to represent them.","category":"page"},{"location":"API/variables/","page":"Symbolic variables and variable metadata","title":"Symbolic variables and variable metadata","text":"warn: Warn\nThese operators are considered experimental API.","category":"page"},{"location":"API/variables/#ModelingToolkit.Sample","page":"Symbolic variables and variable metadata","title":"ModelingToolkit.Sample","text":"struct Sample <: Symbolics.Operator\n\nRepresents a sample operator. A discrete-time signal is created by sampling a continuous-time signal.\n\nConstructors\n\nSample(clock::Union{TimeDomain, InferredTimeDomain} = InferredDiscrete()) Sample(dt::Real)\n\nSample(x::Num), with a single argument, is shorthand for Sample()(x).\n\nFields\n\nclock\n\nExamples\n\njulia> using Symbolics\n\njulia> t = ModelingToolkit.t_nounits\n\njulia> Δ = Sample(0.01)\n(::Sample) (generic function with 2 methods)\n\n\n\n\n\n","category":"type"},{"location":"API/variables/#ModelingToolkit.Hold","page":"Symbolic variables and variable metadata","title":"ModelingToolkit.Hold","text":"struct Hold <: Symbolics.Operator\n\nRepresents a hold operator. A continuous-time signal is produced by holding a discrete-time signal x with zero-order hold.\n\ncont_x = Hold()(disc_x)\n\n\n\n\n\n","category":"type"},{"location":"API/variables/#ModelingToolkit.SampleTime","page":"Symbolic variables and variable metadata","title":"ModelingToolkit.SampleTime","text":"function SampleTime()\n\nSampleTime() can be used in the equations of a hybrid system to represent time sampled at the inferred clock for that equation.\n\n\n\n\n\n","category":"type"},{"location":"examples/spring_mass/#Component-Based-Modeling-of-a-Spring-Mass-System","page":"Component-Based Modeling of a Spring-Mass System","title":"Component-Based Modeling of a Spring-Mass System","text":"","category":"section"},{"location":"examples/spring_mass/","page":"Component-Based Modeling of a Spring-Mass System","title":"Component-Based Modeling of a Spring-Mass System","text":"In this tutorial, we will build a simple component-based model of a spring-mass system. A spring-mass system consists of one or more masses connected by springs. Hooke's law gives the force exerted by a spring when it is extended or compressed by a given distance. This specifies a differential-equation system where the acceleration of the masses is specified using the forces acting on them.","category":"page"},{"location":"examples/spring_mass/#Copy-Paste-Example","page":"Component-Based Modeling of a Spring-Mass System","title":"Copy-Paste Example","text":"","category":"section"},{"location":"examples/spring_mass/","page":"Component-Based Modeling of a Spring-Mass System","title":"Component-Based Modeling of a Spring-Mass System","text":"using ModelingToolkit, Plots, OrdinaryDiffEq, LinearAlgebra\nusing ModelingToolkit: t_nounits as t, D_nounits as D\nusing Symbolics: scalarize\n\nfunction Mass(; name, m = 1.0, xy = [0.0, 0.0], u = [0.0, 0.0])\n    ps = @parameters m = m\n    sts = @variables pos(t)[1:2]=xy v(t)[1:2]=u\n    eqs = scalarize(D.(pos) .~ v)\n    System(eqs, t, [pos..., v...], ps; name)\nend\n\nfunction Spring(; name, k = 1e4, l = 1.0)\n    ps = @parameters k=k l=l\n    @variables x(t), dir(t)[1:2]\n    System(Equation[], t, [x, dir...], ps; name)\nend\n\nfunction connect_spring(spring, a, b)\n    [spring.x ~ norm(scalarize(a .- b))\n     scalarize(spring.dir .~ scalarize(a .- b))]\nend\n\nfunction spring_force(spring)\n    -spring.k .* scalarize(spring.dir) .* (spring.x - spring.l) ./ spring.x\nend\n\nm = 1.0\nxy = [1.0, -1.0]\nk = 1e4\nl = 1.0\ncenter = [0.0, 0.0]\ng = [0.0, -9.81]\n@named mass = Mass(m = m, xy = xy)\n@named spring = Spring(k = k, l = l)\n\neqs = [connect_spring(spring, mass.pos, center)\n       scalarize(D.(mass.v) .~ spring_force(spring) / mass.m .+ g)]\n\n@named _model = System(eqs, t, [spring.x; spring.dir; mass.pos], [])\n@named model = compose(_model, mass, spring)\nsys = mtkcompile(model)\n\nprob = ODEProblem(sys, [], (0.0, 3.0))\nsol = solve(prob, Rosenbrock23())\nplot(sol)","category":"page"},{"location":"examples/spring_mass/#Explanation","page":"Component-Based Modeling of a Spring-Mass System","title":"Explanation","text":"","category":"section"},{"location":"examples/spring_mass/#Building-the-components","page":"Component-Based Modeling of a Spring-Mass System","title":"Building the components","text":"","category":"section"},{"location":"examples/spring_mass/","page":"Component-Based Modeling of a Spring-Mass System","title":"Component-Based Modeling of a Spring-Mass System","text":"For each component, we use a Julia function that returns an System. At the top, we define the fundamental properties of a Mass: it has a mass m, a position pos and a velocity v. We also define that the velocity is the rate of change of position with respect to time.","category":"page"},{"location":"examples/spring_mass/","page":"Component-Based Modeling of a Spring-Mass System","title":"Component-Based Modeling of a Spring-Mass System","text":"function Mass(; name, m = 1.0, xy = [0.0, 0.0], u = [0.0, 0.0])\n    ps = @parameters m = m\n    sts = @variables pos(t)[1:2]=xy v(t)[1:2]=u\n    eqs = scalarize(D.(pos) .~ v)\n    System(eqs, t, [pos..., v...], ps; name)\nend","category":"page"},{"location":"examples/spring_mass/","page":"Component-Based Modeling of a Spring-Mass System","title":"Component-Based Modeling of a Spring-Mass System","text":"Note that this is an incompletely specified System. It cannot be simulated on its own, since the equations for the velocity v[1:2](t) are unknown. Notice the addition of a name keyword. This allows us to generate different masses with different names. A Mass can now be constructed as:","category":"page"},{"location":"examples/spring_mass/","page":"Component-Based Modeling of a Spring-Mass System","title":"Component-Based Modeling of a Spring-Mass System","text":"Mass(name = :mass1)","category":"page"},{"location":"examples/spring_mass/","page":"Component-Based Modeling of a Spring-Mass System","title":"Component-Based Modeling of a Spring-Mass System","text":"Or using the @named helper macro","category":"page"},{"location":"examples/spring_mass/","page":"Component-Based Modeling of a Spring-Mass System","title":"Component-Based Modeling of a Spring-Mass System","text":"@named mass1 = Mass()","category":"page"},{"location":"examples/spring_mass/","page":"Component-Based Modeling of a Spring-Mass System","title":"Component-Based Modeling of a Spring-Mass System","text":"Next, we build the spring component. It is characterized by the spring constant k and the length l of the spring when no force is applied to it. The state of a spring is defined by its current length and direction.","category":"page"},{"location":"examples/spring_mass/","page":"Component-Based Modeling of a Spring-Mass System","title":"Component-Based Modeling of a Spring-Mass System","text":"function Spring(; name, k = 1e4, l = 1.0)\n    ps = @parameters k=k l=l\n    @variables x(t), dir(t)[1:2]\n    System(Equation[], t, [x, dir...], ps; name)\nend","category":"page"},{"location":"examples/spring_mass/","page":"Component-Based Modeling of a Spring-Mass System","title":"Component-Based Modeling of a Spring-Mass System","text":"We now define functions that help construct the equations for a mass-spring system. First, the connect_spring function connects a spring between two positions a and b. Note that a and b can be the pos of a Mass, or just a fixed position such as [0., 0.]. In that sense, the length of the spring x is given by the length of the vector dir joining a and b.","category":"page"},{"location":"examples/spring_mass/","page":"Component-Based Modeling of a Spring-Mass System","title":"Component-Based Modeling of a Spring-Mass System","text":"function connect_spring(spring, a, b)\n    [spring.x ~ norm(scalarize(a .- b))\n     scalarize(spring.dir .~ scalarize(a .- b))]\nend","category":"page"},{"location":"examples/spring_mass/","page":"Component-Based Modeling of a Spring-Mass System","title":"Component-Based Modeling of a Spring-Mass System","text":"Lastly, we define the spring_force function that takes a spring and returns the force exerted by this spring.","category":"page"},{"location":"examples/spring_mass/","page":"Component-Based Modeling of a Spring-Mass System","title":"Component-Based Modeling of a Spring-Mass System","text":"function spring_force(spring)\n    -spring.k .* scalarize(spring.dir) .* (spring.x - spring.l) ./ spring.x\nend","category":"page"},{"location":"examples/spring_mass/","page":"Component-Based Modeling of a Spring-Mass System","title":"Component-Based Modeling of a Spring-Mass System","text":"To create our system, we will first create the components: a mass and a spring. This is done as follows:","category":"page"},{"location":"examples/spring_mass/","page":"Component-Based Modeling of a Spring-Mass System","title":"Component-Based Modeling of a Spring-Mass System","text":"m = 1.0\nxy = [1.0, -1.0]\nk = 1e4\nl = 1.0\ncenter = [0.0, 0.0]\ng = [0.0, -9.81]\n@named mass = Mass(m = m, xy = xy)\n@named spring = Spring(k = k, l = l)","category":"page"},{"location":"examples/spring_mass/","page":"Component-Based Modeling of a Spring-Mass System","title":"Component-Based Modeling of a Spring-Mass System","text":"We can now create the equations describing this system, by connecting spring to mass and a fixed point.","category":"page"},{"location":"examples/spring_mass/","page":"Component-Based Modeling of a Spring-Mass System","title":"Component-Based Modeling of a Spring-Mass System","text":"eqs = [connect_spring(spring, mass.pos, center)\n       scalarize(D.(mass.v) .~ spring_force(spring) / mass.m .+ g)]","category":"page"},{"location":"examples/spring_mass/","page":"Component-Based Modeling of a Spring-Mass System","title":"Component-Based Modeling of a Spring-Mass System","text":"Finally, we can build the model using these equations and components.","category":"page"},{"location":"examples/spring_mass/","page":"Component-Based Modeling of a Spring-Mass System","title":"Component-Based Modeling of a Spring-Mass System","text":"@named _model = System(eqs, t, [spring.x; spring.dir; mass.pos], [])\n@named model = compose(_model, mass, spring)","category":"page"},{"location":"examples/spring_mass/","page":"Component-Based Modeling of a Spring-Mass System","title":"Component-Based Modeling of a Spring-Mass System","text":"We can take a look at the equations in the model using the equations function.","category":"page"},{"location":"examples/spring_mass/","page":"Component-Based Modeling of a Spring-Mass System","title":"Component-Based Modeling of a Spring-Mass System","text":"equations(model)","category":"page"},{"location":"examples/spring_mass/","page":"Component-Based Modeling of a Spring-Mass System","title":"Component-Based Modeling of a Spring-Mass System","text":"The unknowns of this model are:","category":"page"},{"location":"examples/spring_mass/","page":"Component-Based Modeling of a Spring-Mass System","title":"Component-Based Modeling of a Spring-Mass System","text":"unknowns(model)","category":"page"},{"location":"examples/spring_mass/","page":"Component-Based Modeling of a Spring-Mass System","title":"Component-Based Modeling of a Spring-Mass System","text":"And the parameters of this model are:","category":"page"},{"location":"examples/spring_mass/","page":"Component-Based Modeling of a Spring-Mass System","title":"Component-Based Modeling of a Spring-Mass System","text":"parameters(model)","category":"page"},{"location":"examples/spring_mass/#Simplifying-and-solving-this-system","page":"Component-Based Modeling of a Spring-Mass System","title":"Simplifying and solving this system","text":"","category":"section"},{"location":"examples/spring_mass/","page":"Component-Based Modeling of a Spring-Mass System","title":"Component-Based Modeling of a Spring-Mass System","text":"This system can be solved directly as a DAE using one of the DAE solvers from DifferentialEquations.jl. However, we can symbolically simplify the system first beforehand. Running mtkcompile eliminates unnecessary variables from the model to give the leanest numerical representation of the system.","category":"page"},{"location":"examples/spring_mass/","page":"Component-Based Modeling of a Spring-Mass System","title":"Component-Based Modeling of a Spring-Mass System","text":"sys = mtkcompile(model)\nequations(sys)","category":"page"},{"location":"examples/spring_mass/","page":"Component-Based Modeling of a Spring-Mass System","title":"Component-Based Modeling of a Spring-Mass System","text":"We are left with only 4 equations involving 4 unknown variables (mass.pos[1], mass.pos[2], mass.v[1], mass.v[2]). We can solve the system by converting it to an ODEProblem. Some observed variables are not expanded by default. To view the complete equations, one can do","category":"page"},{"location":"examples/spring_mass/","page":"Component-Based Modeling of a Spring-Mass System","title":"Component-Based Modeling of a Spring-Mass System","text":"full_equations(sys)","category":"page"},{"location":"examples/spring_mass/","page":"Component-Based Modeling of a Spring-Mass System","title":"Component-Based Modeling of a Spring-Mass System","text":"This is done as follows:","category":"page"},{"location":"examples/spring_mass/","page":"Component-Based Modeling of a Spring-Mass System","title":"Component-Based Modeling of a Spring-Mass System","text":"prob = ODEProblem(sys, [], (0.0, 3.0))\nsol = solve(prob, Rosenbrock23())\nplot(sol)","category":"page"},{"location":"examples/spring_mass/","page":"Component-Based Modeling of a Spring-Mass System","title":"Component-Based Modeling of a Spring-Mass System","text":"What if we want the timeseries of a different variable? That information is not lost! Instead, mtkcompile simply changes unknown variables into observed variables.","category":"page"},{"location":"examples/spring_mass/","page":"Component-Based Modeling of a Spring-Mass System","title":"Component-Based Modeling of a Spring-Mass System","text":"observed(sys)","category":"page"},{"location":"examples/spring_mass/","page":"Component-Based Modeling of a Spring-Mass System","title":"Component-Based Modeling of a Spring-Mass System","text":"These are explicit algebraic equations which can be used to reconstruct the required variables on the fly. This leads to dramatic computational savings since implicitly solving an ODE scales as O(n^3), so fewer unknowns are significantly better!","category":"page"},{"location":"examples/spring_mass/","page":"Component-Based Modeling of a Spring-Mass System","title":"Component-Based Modeling of a Spring-Mass System","text":"We can access these variables using the solution object. For example, let's retrieve the x-position of the mass over time:","category":"page"},{"location":"examples/spring_mass/","page":"Component-Based Modeling of a Spring-Mass System","title":"Component-Based Modeling of a Spring-Mass System","text":"sol[mass.pos[1]]","category":"page"},{"location":"examples/spring_mass/","page":"Component-Based Modeling of a Spring-Mass System","title":"Component-Based Modeling of a Spring-Mass System","text":"We can also plot the path of the mass:","category":"page"},{"location":"examples/spring_mass/","page":"Component-Based Modeling of a Spring-Mass System","title":"Component-Based Modeling of a Spring-Mass System","text":"plot(sol, idxs = (mass.pos[1], mass.pos[2]))","category":"page"},{"location":"basics/ContextualVariables/#Contextual-Variable-Types","page":"Contextual Variable Types","title":"Contextual Variable Types","text":"","category":"section"},{"location":"basics/ContextualVariables/","page":"Contextual Variable Types","title":"Contextual Variable Types","text":"ModelingToolkit.jl has a system of contextual variable types which allows for helping the system transformation machinery do complex manipulations and automatic detection. The standard variable definition in ModelingToolkit.jl is the @variable which is defined by Symbolics.jl. For example:","category":"page"},{"location":"basics/ContextualVariables/","page":"Contextual Variable Types","title":"Contextual Variable Types","text":"@variables x y(x)","category":"page"},{"location":"basics/ContextualVariables/","page":"Contextual Variable Types","title":"Contextual Variable Types","text":"This is used for the “normal” variable of a given system, like the unknowns of a differential equation or objective function. All the macros below support the same syntax as @variables.","category":"page"},{"location":"basics/ContextualVariables/#Parameters","page":"Contextual Variable Types","title":"Parameters","text":"","category":"section"},{"location":"basics/ContextualVariables/","page":"Contextual Variable Types","title":"Contextual Variable Types","text":"All modeling projects have some form of parameters. @parameters marks a variable as being the parameter of some system, which allows automatic detection algorithms to ignore such variables when attempting to find the unknowns of a system.","category":"page"},{"location":"basics/ContextualVariables/#constants","page":"Contextual Variable Types","title":"Constants","text":"","category":"section"},{"location":"basics/ContextualVariables/","page":"Contextual Variable Types","title":"Contextual Variable Types","text":"Constants, defined by e.g. @constants myconst1 are like parameters that:","category":"page"},{"location":"basics/ContextualVariables/","page":"Contextual Variable Types","title":"Contextual Variable Types","text":"always have a default value, which must be assigned when the constants are declared\ndo not show up in the list of parameters of a system.","category":"page"},{"location":"basics/ContextualVariables/","page":"Contextual Variable Types","title":"Contextual Variable Types","text":"The intended use-cases for constants are:","category":"page"},{"location":"basics/ContextualVariables/","page":"Contextual Variable Types","title":"Contextual Variable Types","text":"representing literals (e.g., π) symbolically, which results in cleaner Latexification of equations (avoids turning d ~ 2π*r into d = 6.283185307179586 r)\nallowing auto-generated unit conversion factors to live outside the list of parameters\nrepresenting fundamental constants (e.g., speed of light c) that should never be adjusted inadvertently.","category":"page"},{"location":"basics/ContextualVariables/#Wildcard-Variable-Arguments","page":"Contextual Variable Types","title":"Wildcard Variable Arguments","text":"","category":"section"},{"location":"basics/ContextualVariables/","page":"Contextual Variable Types","title":"Contextual Variable Types","text":"@variables u(..)","category":"page"},{"location":"basics/ContextualVariables/","page":"Contextual Variable Types","title":"Contextual Variable Types","text":"It is possible to define a dependent variable which is an open function as above, for which its arguments must be specified each time it is used. This is useful with PDEs for example, where one may need to use u(t, x) in the equations, but will need to be able to write u(t, 0.0) to define a boundary condition at x = 0.","category":"page"},{"location":"basics/ContextualVariables/#Variable-metadata","page":"Contextual Variable Types","title":"Variable metadata","text":"","category":"section"},{"location":"basics/ContextualVariables/","page":"Contextual Variable Types","title":"Contextual Variable Types","text":"In many engineering systems, some variables act like “flows” while others do not. For example, in circuit models you have current which flows, and the related voltage which does not. Or in thermal models you have heat flows. In these cases, the connect statement enforces conservation of flow between all of the connected components.","category":"page"},{"location":"basics/ContextualVariables/","page":"Contextual Variable Types","title":"Contextual Variable Types","text":"For example, the following specifies that x is a 2x2 matrix of flow variables with the unit m^3/s:","category":"page"},{"location":"basics/ContextualVariables/","page":"Contextual Variable Types","title":"Contextual Variable Types","text":"@variables x[1:2, 1:2] [connect = Flow; unit = u\"m^3/s\"]","category":"page"},{"location":"basics/ContextualVariables/","page":"Contextual Variable Types","title":"Contextual Variable Types","text":"ModelingToolkit defines connect, unit, noise, and description keys for the metadata. One can get and set metadata by","category":"page"},{"location":"basics/ContextualVariables/","page":"Contextual Variable Types","title":"Contextual Variable Types","text":"julia> @variables x [unit = u\"m^3/s\"];\n\njulia> hasmetadata(x, VariableUnit)\ntrue\n\njulia> ModelingToolkit.get_unit(x)\nm³ s⁻¹\n\njulia> x = setmetadata(x, VariableUnit, u\"m/s\")\nx\n\njulia> ModelingToolkit.get_unit(x)\nm s⁻¹","category":"page"},{"location":"basics/ContextualVariables/","page":"Contextual Variable Types","title":"Contextual Variable Types","text":"See Symbolic Metadata for more details on variable metadata.","category":"page"},{"location":"tutorials/change_independent_variable/#Changing-the-independent-variable-of-ODEs","page":"Changing the independent variable of ODEs","title":"Changing the independent variable of ODEs","text":"","category":"section"},{"location":"tutorials/change_independent_variable/","page":"Changing the independent variable of ODEs","title":"Changing the independent variable of ODEs","text":"Ordinary differential equations describe the rate of change of some dependent variables with respect to one independent variable. For the modeler it is often most natural to write down the equations with a particular independent variable, say time t. However, in many cases there are good reasons for changing the independent variable:","category":"page"},{"location":"tutorials/change_independent_variable/","page":"Changing the independent variable of ODEs","title":"Changing the independent variable of ODEs","text":"One may want y(x) as a function of x instead of (x(t) y(t)) as a function of t\nSome differential equations vary more nicely (e.g. less stiff) with respect to one independent variable than another.\nIt can reduce the number of equations that must be solved (e.g. y(x) is one equation, while (x(t) y(t)) are two).","category":"page"},{"location":"tutorials/change_independent_variable/","page":"Changing the independent variable of ODEs","title":"Changing the independent variable of ODEs","text":"To manually change the independent variable of an ODE, one must rewrite all equations in terms of a new variable and transform differentials with the chain rule. This is mechanical and error-prone. ModelingToolkit provides the utility function change_independent_variable that automates this process.","category":"page"},{"location":"tutorials/change_independent_variable/#1.-Get-one-dependent-variable-as-a-function-of-another","page":"Changing the independent variable of ODEs","title":"1. Get one dependent variable as a function of another","text":"","category":"section"},{"location":"tutorials/change_independent_variable/","page":"Changing the independent variable of ODEs","title":"Changing the independent variable of ODEs","text":"Consider a projectile shot with some initial velocity in a vertical gravitational field with constant horizontal velocity.","category":"page"},{"location":"tutorials/change_independent_variable/","page":"Changing the independent variable of ODEs","title":"Changing the independent variable of ODEs","text":"using ModelingToolkit\nusing ModelingToolkit: t_nounits as t, D_nounits as D\n@variables x(t) y(t)\n@parameters g=9.81 v # gravitational acceleration and horizontal velocity\neqs = [D(D(y)) ~ -g, D(x) ~ v]\ninitialization_eqs = [D(x) ~ D(y)] # 45° initial angle\nM1 = System(eqs, t; initialization_eqs, name = :M)\nM1s = mtkcompile(M1)\n@assert length(equations(M1s)) == 3 # hide\nM1s # hide","category":"page"},{"location":"tutorials/change_independent_variable/","page":"Changing the independent variable of ODEs","title":"Changing the independent variable of ODEs","text":"This is the standard parametrization that arises naturally from kinematics and Newton's laws. It expresses the position (x(t) y(t)) as a function of time t. But suppose we want to determine whether the projectile hits a target 10 meters away. There are at least three ways of answering this:","category":"page"},{"location":"tutorials/change_independent_variable/","page":"Changing the independent variable of ODEs","title":"Changing the independent variable of ODEs","text":"Solve the ODE for (x(t) y(t)) and use a callback to terminate when x reaches 10 meters, and evaluate y at the final time.\nSolve the ODE for (x(t) y(t)) and use root finding to find the time when x reaches 10 meters, and evaluate y at that time.\nSolve the ODE for y(x) and evaluate it at 10 meters.","category":"page"},{"location":"tutorials/change_independent_variable/","page":"Changing the independent variable of ODEs","title":"Changing the independent variable of ODEs","text":"We will demonstrate the last method by changing the independent variable from t to x. This transformation is well-defined for any non-zero horizontal velocity v, so x and t are one-to-one.","category":"page"},{"location":"tutorials/change_independent_variable/","page":"Changing the independent variable of ODEs","title":"Changing the independent variable of ODEs","text":"M2 = change_independent_variable(M1, x)\nM2s = mtkcompile(M2; allow_symbolic = true)\n# a sanity test on the 10 x/y variables that are accessible to the user # hide\n@assert allequal([x, M1s.x]) # hide\n@assert allequal([M2.x, M2s.x]) # hide\n@assert allequal([y, M1s.y]) # hide\n@assert allunique([M1.x, M1.y, M2.y, M2s.y]) # hide\n@assert length(equations(M2s)) == 2 # hide\nM2s # display this # hide","category":"page"},{"location":"tutorials/change_independent_variable/","page":"Changing the independent variable of ODEs","title":"Changing the independent variable of ODEs","text":"The derivatives are now with respect to the new independent variable x, which can be accessed with M2.x.","category":"page"},{"location":"tutorials/change_independent_variable/","page":"Changing the independent variable of ODEs","title":"Changing the independent variable of ODEs","text":"info: Info\nAt this point x, M1.x, M1s.x, M2.x, M2s.x are three different variables. Meanwhile y, M1.y, M1s.y, M2.y and M2s.y are four different variables. It can be instructive to inspect these yourself to see their subtle differences.","category":"page"},{"location":"tutorials/change_independent_variable/","page":"Changing the independent variable of ODEs","title":"Changing the independent variable of ODEs","text":"Notice how the number of equations has also decreased from three to two, as mathrmdxmathrmdt has been turned into an observed equation. It is straightforward to evolve the ODE for 10 meters and plot the resulting trajectory y(x):","category":"page"},{"location":"tutorials/change_independent_variable/","page":"Changing the independent variable of ODEs","title":"Changing the independent variable of ODEs","text":"using OrdinaryDiffEq, Plots\nprob = ODEProblem(M2s, [M2s.y => 0.0, v => 8.0], [0.0, 10.0]) # throw 10 meters\nsol = solve(prob, Tsit5())\nplot(sol; idxs = M2.y) # must index by M2.y = y(x); not M1.y = y(t)!","category":"page"},{"location":"tutorials/change_independent_variable/","page":"Changing the independent variable of ODEs","title":"Changing the independent variable of ODEs","text":"tip: Usage tips\nLook up the documentation of change_independent_variable for tips on how to use it.For example, if you also need t(x), you can tell it to add a differential equation for the old independent variable in terms of the new one using the inverse function rule (here mathrmdtmathrmdx = 1  (mathrmdxmathrmdt)). If you know an analytical expression between the independent variables (here t = xv), you can also pass it directly to the function to avoid the extra differential equation.","category":"page"},{"location":"tutorials/change_independent_variable/#2.-Alleviating-stiffness-by-changing-to-logarithmic-time","page":"Changing the independent variable of ODEs","title":"2. Alleviating stiffness by changing to logarithmic time","text":"","category":"section"},{"location":"tutorials/change_independent_variable/","page":"Changing the independent variable of ODEs","title":"Changing the independent variable of ODEs","text":"In cosmology, the Friedmann equations describe the expansion of the universe. In terms of conformal time t, they can be written","category":"page"},{"location":"tutorials/change_independent_variable/","page":"Changing the independent variable of ODEs","title":"Changing the independent variable of ODEs","text":"@variables a(t) Ω(t)\na = GlobalScope(a) # global var needed by all species\nfunction species(w; kw...)\n    eqs = [D(Ω) ~ -3(1 + w) * D(a) / a * Ω]\n    return System(eqs, t, [Ω], []; kw...)\nend\n@named r = species(1 // 3) # radiation\n@named m = species(0) # matter\n@named Λ = species(-1) # dark energy / cosmological constant\neqs = [Ω ~ r.Ω + m.Ω + Λ.Ω, D(a) ~ √(Ω) * a^2]\ninitialization_eqs = [Λ.Ω + r.Ω + m.Ω ~ 1]\nM1 = System(eqs, t, [Ω, a], []; initialization_eqs, name = :M)\nM1 = compose(M1, r, m, Λ)\nM1s = mtkcompile(M1)","category":"page"},{"location":"tutorials/change_independent_variable/","page":"Changing the independent variable of ODEs","title":"Changing the independent variable of ODEs","text":"Of course, we can solve this ODE as it is:","category":"page"},{"location":"tutorials/change_independent_variable/","page":"Changing the independent variable of ODEs","title":"Changing the independent variable of ODEs","text":"prob = ODEProblem(M1s, [M1s.a => 1.0, M1s.r.Ω => 5e-5, M1s.m.Ω => 0.3], (0.0, -3.3), [])\nsol = solve(prob, Tsit5(); reltol = 1e-5)\n@assert Symbol(sol.retcode) == :Unstable # surrounding text assumes this was unstable # hide\nplot(sol, idxs = [M1.a, M1.r.Ω / M1.Ω, M1.m.Ω / M1.Ω, M1.Λ.Ω / M1.Ω])","category":"page"},{"location":"tutorials/change_independent_variable/","page":"Changing the independent variable of ODEs","title":"Changing the independent variable of ODEs","text":"But the solver becomes unstable due to stiffness. Also notice the interesting dynamics taking place towards the end of the integration (in the early universe), which gets compressed into a very small time interval. These ODEs would benefit from being defined with respect to a logarithmic \"time\" that better captures the evolution of the universe through orders of magnitude of time, rather than linear time.","category":"page"},{"location":"tutorials/change_independent_variable/","page":"Changing the independent variable of ODEs","title":"Changing the independent variable of ODEs","text":"It is therefore common to write these ODEs in terms of b = ln a. To do this, we will change the independent variable in two stages; first from t to a, and then from a to b. Notice that mathrmdamathrmdt  0 provided that Omega  0, and mathrmdbmathrmda  0, so the transformation is well-defined since t leftrightarrow a leftrightarrow b are one-to-one. First, we transform from t to a:","category":"page"},{"location":"tutorials/change_independent_variable/","page":"Changing the independent variable of ODEs","title":"Changing the independent variable of ODEs","text":"M2 = change_independent_variable(M1, M1.a)\n@assert !ModelingToolkit.isautonomous(M2) # hide\nM2 # hide","category":"page"},{"location":"tutorials/change_independent_variable/","page":"Changing the independent variable of ODEs","title":"Changing the independent variable of ODEs","text":"Unlike the original, notice that this system is non-autonomous because the independent variable a appears explicitly in the equations! This means that to change the independent variable from a to b, we must provide not only the rate of change relation db(a)da = exp(-b), but also the equation a(b) = exp(b) so a can be eliminated in favor of b:","category":"page"},{"location":"tutorials/change_independent_variable/","page":"Changing the independent variable of ODEs","title":"Changing the independent variable of ODEs","text":"a = M2.a # get independent variable of M2\nDa = Differential(a)\n@variables b(a)\nM3 = change_independent_variable(M2, b, [Da(b) ~ exp(-b), a ~ exp(b)])","category":"page"},{"location":"tutorials/change_independent_variable/","page":"Changing the independent variable of ODEs","title":"Changing the independent variable of ODEs","text":"We can now solve and plot the ODE in terms of b:","category":"page"},{"location":"tutorials/change_independent_variable/","page":"Changing the independent variable of ODEs","title":"Changing the independent variable of ODEs","text":"M3s = mtkcompile(M3; allow_symbolic = true)\nprob = ODEProblem(M3s, [M3s.r.Ω => 5e-5, M3s.m.Ω => 0.3], (0, -15), [])\nsol = solve(prob, Tsit5())\n@assert Symbol(sol.retcode) == :Success # surrounding text assumes the solution was successful # hide\nplot(sol, idxs = [M3.r.Ω / M3.Ω, M3.m.Ω / M3.Ω, M3.Λ.Ω / M3.Ω])","category":"page"},{"location":"tutorials/change_independent_variable/","page":"Changing the independent variable of ODEs","title":"Changing the independent variable of ODEs","text":"Notice that the variables vary \"more nicely\" with respect to b than t, making the solver happier and avoiding numerical problems.","category":"page"},{"location":"examples/perturbation/#perturb_diff","page":"Symbolic-Numeric Perturbation Theory for ODEs","title":"Symbolic-Numeric Perturbation Theory for ODEs","text":"","category":"section"},{"location":"examples/perturbation/","page":"Symbolic-Numeric Perturbation Theory for ODEs","title":"Symbolic-Numeric Perturbation Theory for ODEs","text":"In the Mixed Symbolic-Numeric Perturbation Theory tutorial, we discussed how to solve algebraic equations using Symbolics.jl. Here we extend the method to differential equations. The procedure is similar, but the Taylor series coefficients now become functions of an independent variable (usually time).","category":"page"},{"location":"examples/perturbation/#Free-fall-in-a-varying-gravitational-field","page":"Symbolic-Numeric Perturbation Theory for ODEs","title":"Free fall in a varying gravitational field","text":"","category":"section"},{"location":"examples/perturbation/","page":"Symbolic-Numeric Perturbation Theory for ODEs","title":"Symbolic-Numeric Perturbation Theory for ODEs","text":"Our first ODE example is a well-known physics problem: what is the altitude x(t) of an object (say, a ball or a rocket) thrown vertically with initial velocity x(0) from the surface of a planet with mass M and radius R? According to Newton's second law and law of gravity, it is the solution of the ODE","category":"page"},{"location":"examples/perturbation/","page":"Symbolic-Numeric Perturbation Theory for ODEs","title":"Symbolic-Numeric Perturbation Theory for ODEs","text":"x = -fracGM(R+x)^2 = -fracGMR^2 frac1left(1+ϵfracxRright)^2","category":"page"},{"location":"examples/perturbation/","page":"Symbolic-Numeric Perturbation Theory for ODEs","title":"Symbolic-Numeric Perturbation Theory for ODEs","text":"In the last equality, we introduced a perturbative expansion parameter ϵ. When ϵ=1, we recover the original problem. When ϵ=0, the problem reduces to the trivial problem x = -g with constant gravitational acceleration g = GMR^2 and solution x(t) = x(0) + x(0) t - frac12 g t^2. This is a good setup for perturbation theory.","category":"page"},{"location":"examples/perturbation/","page":"Symbolic-Numeric Perturbation Theory for ODEs","title":"Symbolic-Numeric Perturbation Theory for ODEs","text":"To make the problem dimensionless, we redefine x leftarrow x  R and t leftarrow t  sqrtR^3GM. Then the ODE becomes","category":"page"},{"location":"examples/perturbation/","page":"Symbolic-Numeric Perturbation Theory for ODEs","title":"Symbolic-Numeric Perturbation Theory for ODEs","text":"using ModelingToolkit\nusing ModelingToolkit: t_nounits as t, D_nounits as D\n@variables ϵ x(t)\neq = D(D(x)) ~ -(1 + ϵ * x)^(-2)","category":"page"},{"location":"examples/perturbation/","page":"Symbolic-Numeric Perturbation Theory for ODEs","title":"Symbolic-Numeric Perturbation Theory for ODEs","text":"Next, expand x(t) in a series up to second order in ϵ:","category":"page"},{"location":"examples/perturbation/","page":"Symbolic-Numeric Perturbation Theory for ODEs","title":"Symbolic-Numeric Perturbation Theory for ODEs","text":"using Symbolics\n@variables y(t)[0:2] # coefficients\nx_series = series(y, ϵ)","category":"page"},{"location":"examples/perturbation/","page":"Symbolic-Numeric Perturbation Theory for ODEs","title":"Symbolic-Numeric Perturbation Theory for ODEs","text":"Insert this into the equation and collect perturbed equations to each order:","category":"page"},{"location":"examples/perturbation/","page":"Symbolic-Numeric Perturbation Theory for ODEs","title":"Symbolic-Numeric Perturbation Theory for ODEs","text":"eq_pert = substitute(eq, x => x_series)\neqs_pert = taylor_coeff(eq_pert, ϵ, 0:2)","category":"page"},{"location":"examples/perturbation/","page":"Symbolic-Numeric Perturbation Theory for ODEs","title":"Symbolic-Numeric Perturbation Theory for ODEs","text":"note: Note\nThe 0-th order equation can be solved analytically, but ModelingToolkit does currently not feature automatic analytical solution of ODEs, so we proceed with solving it numerically.","category":"page"},{"location":"examples/perturbation/","page":"Symbolic-Numeric Perturbation Theory for ODEs","title":"Symbolic-Numeric Perturbation Theory for ODEs","text":"These are the ODEs we want to solve. Now construct an System, which automatically inserts dummy derivatives for the velocities:","category":"page"},{"location":"examples/perturbation/","page":"Symbolic-Numeric Perturbation Theory for ODEs","title":"Symbolic-Numeric Perturbation Theory for ODEs","text":"@mtkcompile sys = System(eqs_pert, t)","category":"page"},{"location":"examples/perturbation/","page":"Symbolic-Numeric Perturbation Theory for ODEs","title":"Symbolic-Numeric Perturbation Theory for ODEs","text":"To solve the System, we generate an ODEProblem with initial conditions x(0) = 0, and x(0) = 1, and solve it:","category":"page"},{"location":"examples/perturbation/","page":"Symbolic-Numeric Perturbation Theory for ODEs","title":"Symbolic-Numeric Perturbation Theory for ODEs","text":"using OrdinaryDiffEq\nu0 = Dict([unknowns(sys) .=> 0.0; D(y[0]) => 1.0]) # nonzero initial velocity\nprob = ODEProblem(sys, u0, (0.0, 3.0))\nsol = solve(prob)","category":"page"},{"location":"examples/perturbation/","page":"Symbolic-Numeric Perturbation Theory for ODEs","title":"Symbolic-Numeric Perturbation Theory for ODEs","text":"This is the solution for the coefficients in the series for x(t) and their derivatives. Finally, we calculate the solution to the original problem by summing the series for different ϵ:","category":"page"},{"location":"examples/perturbation/","page":"Symbolic-Numeric Perturbation Theory for ODEs","title":"Symbolic-Numeric Perturbation Theory for ODEs","text":"using Plots\np = plot()\nfor ϵᵢ in 0.0:0.1:1.0\n    plot!(p, sol, idxs = substitute(x_series, ϵ => ϵᵢ), label = \"ϵ = $ϵᵢ\")\nend\np","category":"page"},{"location":"examples/perturbation/","page":"Symbolic-Numeric Perturbation Theory for ODEs","title":"Symbolic-Numeric Perturbation Theory for ODEs","text":"This makes sense: for larger ϵ, gravity weakens with altitude, and the trajectory goes higher for a fixed initial velocity.","category":"page"},{"location":"examples/perturbation/","page":"Symbolic-Numeric Perturbation Theory for ODEs","title":"Symbolic-Numeric Perturbation Theory for ODEs","text":"An advantage of the perturbative method is that we run the ODE solver only once and calculate trajectories for several ϵ for free. Had we solved the full unperturbed ODE directly, we would need to do repeat it for every ϵ.","category":"page"},{"location":"examples/perturbation/#Weakly-nonlinear-oscillator","page":"Symbolic-Numeric Perturbation Theory for ODEs","title":"Weakly nonlinear oscillator","text":"","category":"section"},{"location":"examples/perturbation/","page":"Symbolic-Numeric Perturbation Theory for ODEs","title":"Symbolic-Numeric Perturbation Theory for ODEs","text":"Our second example applies perturbation theory to nonlinear oscillators – a very important class of problems. As we will see, perturbation theory has difficulty providing a good solution to this problem, but the process is nevertheless instructive. This example closely follows chapter 7.6 of Nonlinear Dynamics and Chaos by Steven Strogatz.","category":"page"},{"location":"examples/perturbation/","page":"Symbolic-Numeric Perturbation Theory for ODEs","title":"Symbolic-Numeric Perturbation Theory for ODEs","text":"The goal is to solve the ODE","category":"page"},{"location":"examples/perturbation/","page":"Symbolic-Numeric Perturbation Theory for ODEs","title":"Symbolic-Numeric Perturbation Theory for ODEs","text":"eq = D(D(x)) + 2 * ϵ * D(x) + x ~ 0","category":"page"},{"location":"examples/perturbation/","page":"Symbolic-Numeric Perturbation Theory for ODEs","title":"Symbolic-Numeric Perturbation Theory for ODEs","text":"with initial conditions x(0) = 0 and x(0) = 1. With ϵ = 0, the problem reduces to the simple linear harmonic oscillator with the exact solution x(t) = sin(t).","category":"page"},{"location":"examples/perturbation/","page":"Symbolic-Numeric Perturbation Theory for ODEs","title":"Symbolic-Numeric Perturbation Theory for ODEs","text":"We follow the same steps as in the previous example to construct the System:","category":"page"},{"location":"examples/perturbation/","page":"Symbolic-Numeric Perturbation Theory for ODEs","title":"Symbolic-Numeric Perturbation Theory for ODEs","text":"eq_pert = substitute(eq, x => x_series)\neqs_pert = taylor_coeff(eq_pert, ϵ, 0:2)\n@mtkcompile sys = System(eqs_pert, t)","category":"page"},{"location":"examples/perturbation/","page":"Symbolic-Numeric Perturbation Theory for ODEs","title":"Symbolic-Numeric Perturbation Theory for ODEs","text":"We solve and plot it as in the previous example, and compare the solution with ϵ=01 to the exact solution x(t ϵ) = e^-ϵ t sin(sqrt(1-ϵ^2)t)  sqrt1-ϵ^2 of the unperturbed equation:","category":"page"},{"location":"examples/perturbation/","page":"Symbolic-Numeric Perturbation Theory for ODEs","title":"Symbolic-Numeric Perturbation Theory for ODEs","text":"u0 = [y[0] => 0.0, y[1] => 0.0, y[2] => 0.0, D(y[0]) => 1.0, D(y[1]) => 0.0, D(y[2]) => 0.0] # nonzero initial velocity\nprob = ODEProblem(sys, u0, (0.0, 50.0))\nsol = solve(prob)\nplot(sol, idxs = substitute(x_series, ϵ => 0.1); label = \"Perturbative (ϵ=0.1)\")\n\nx_exact(t, ϵ) = exp(-ϵ * t) * sin(√(1 - ϵ^2) * t) / √(1 - ϵ^2)\n@assert isapprox(\n    sol(π/2; idxs = substitute(x_series, ϵ => 0.1)), x_exact(π/2, 0.1); atol = 1e-2) # compare around 1st peak # hide\nplot!(sol.t, x_exact.(sol.t, 0.1); label = \"Exact (ϵ=0.1)\")","category":"page"},{"location":"examples/perturbation/","page":"Symbolic-Numeric Perturbation Theory for ODEs","title":"Symbolic-Numeric Perturbation Theory for ODEs","text":"This is similar to Figure 7.6.2 in Nonlinear Dynamics and Chaos. The two curves fit well for the first couple of cycles, but then the perturbative solution diverges from the exact solution. The main reason is that the problem has two or more time-scales that introduce secular terms in the solution. One solution is to explicitly account for the two time scales and use an analytic method called two-timing, but this is outside the scope of this example.","category":"page"},{"location":"#ModelingToolkit.jl:-High-Performance-Symbolic-Numeric-Equation-Based-Modeling","page":"Home","title":"ModelingToolkit.jl: High-Performance Symbolic-Numeric Equation-Based Modeling","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ModelingToolkit.jl is a modeling language for high-performance symbolic-numeric computation in scientific computing and scientific machine learning. It then mixes ideas from symbolic computational algebra systems with causal and acausal equation-based modeling frameworks to give an extendable and parallel modeling system. It allows for users to give a high-level description of a model for symbolic preprocessing to analyze and enhance the model. Automatic symbolic transformations, such as index reduction of differential-algebraic equations, make it possible to solve equations that are impossible to solve with a purely numeric-based technique.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install ModelingToolkit.jl, use the Julia package manager:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"ModelingToolkit\")","category":"page"},{"location":"#Citation","page":"Home","title":"Citation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you use ModelingToolkit in your work, please cite the following:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@misc{ma2021modelingtoolkit,\n      title={ModelingToolkit: A Composable Graph Transformation System For Equation-Based Modeling},\n      author={Yingbo Ma and Shashi Gowda and Ranjan Anantharaman and Chris Laughman and Viral Shah and Chris Rackauckas},\n      year={2021},\n      eprint={2103.05244},\n      archivePrefix={arXiv},\n      primaryClass={cs.MS}\n}","category":"page"},{"location":"#Feature-Summary","page":"Home","title":"Feature Summary","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"danger: ModelingToolkit version 10\nModelingToolkit version 10 just released. Please refer to the changelog for a summary of the changes. Some documentation pages may be broken while downstram packages update to the new version.","category":"page"},{"location":"","page":"Home","title":"Home","text":"ModelingToolkit.jl is a symbolic-numeric modeling package. Thus it combines some of the features from symbolic computing packages like SymPy or Mathematica with the ideas of equation-based modeling systems like the causal Simulink and the acausal Modelica. It bridges the gap between many different kinds of equations, allowing one to quickly and easily transform systems of DAEs into optimization problems, or vice-versa, and then simplify and parallelize the resulting expressions before generating code.","category":"page"},{"location":"#Feature-List","page":"Home","title":"Feature List","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Causal and acausal modeling (Simulink/Modelica)\nAutomated model transformation, simplification, and composition\nAutomatic conversion of numerical models into symbolic models\nComposition of models through the components, a lazy connection system, and tools for expanding/flattening\nPervasive parallelism in symbolic computations and generated functions\nTransformations like alias elimination and tearing of nonlinear systems for efficiently numerically handling large-scale systems of equations\nThe ability to use the entire Symbolics.jl Computer Algebra System (CAS) as part of the modeling process.\nImport models from common formats like SBML, CellML, BioNetGen, and more.\nExtensibility: the whole system is written in pure Julia, so adding new functions, simplification rules, and model transformations has no barrier.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For information on how to use the Symbolics.jl CAS system that ModelingToolkit.jl is built on, consult the Symbolics.jl documentation","category":"page"},{"location":"#Equation-Types","page":"Home","title":"Equation Types","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Ordinary differential equations\nStochastic differential equations\nPartial differential equations\nNonlinear systems\nOptimization problems\nContinuous-Time Markov Chains\nChemical Reactions (via Catalyst.jl)\nNonlinear Optimal Control","category":"page"},{"location":"#Standard-Library","page":"Home","title":"Standard Library","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For quick development, ModelingToolkit.jl includes ModelingToolkitStandardLibrary.jl, a standard library of prebuilt components for the ModelingToolkit ecosystem.","category":"page"},{"location":"#Model-Import-Formats","page":"Home","title":"Model Import Formats","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CellMLToolkit.jl: Import CellML models into ModelingToolkit\nRepository of more than a thousand pre-made models\nFocus on biomedical models in areas such as: Calcium Dynamics, Cardiovascular Circulation, Cell Cycle, Cell Migration, Circadian Rhythms, Electrophysiology, Endocrine, Excitation-Contraction Coupling, Gene Regulation, Hepatology, Immunology, Ion Transport, Mechanical Constitutive Laws, Metabolism, Myofilament Mechanics, Neurobiology, pH Regulation, PKPD, Protein Modules, Signal Transduction, and Synthetic Biology.\nSBMLToolkit.jl: Import SBML models into ModelingToolkit\nUses the robust libsbml library for parsing and transforming the SBML\nReactionNetworkImporters.jl: Import various models into ModelingToolkit\nSupports the BioNetGen .net file\nSupports importing networks specified by stoichiometric matrices","category":"page"},{"location":"#Extension-Libraries","page":"Home","title":"Extension Libraries","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Because ModelingToolkit.jl is the core foundation of an equation-based modeling ecosystem, there is a large set of libraries adding features to this system. Below is an incomplete list of extension libraries one may want to be aware of:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Catalyst.jl: Symbolic representations of chemical reactions\nSymbolically build and represent large systems of chemical reactions\nGenerate code for ODEs, SDEs, continuous-time Markov Chains, and more\nSimulate the models using the SciML ecosystem with O(1) Gillespie methods\nDataDrivenDiffEq.jl: Automatic identification of equations from data\nAutomated construction of ODEs and DAEs from data\nRepresentations of Koopman operators and Dynamic Mode Decomposition (DMD)\nMomentClosure.jl: Automatic transformation of ReactionSystems into deterministic systems\nGenerates Systems for the moment closures\nAllows for geometrically-distributed random reaction rates\nReactionMechanismSimulator.jl: Simulating and analyzing large chemical reaction mechanisms\nIdeal gas and dilute liquid phases.\nConstant T and P and constant V adiabatic ideal gas reactors.\nConstant T and V dilute liquid reactors.\nDiffusion limited rates. Sensitivity analysis for all reactors.\nFlux diagrams with molecular images (if molecular information is provided).\nNumCME.jl: High-performance simulation of chemical master equations (CME)\nTransient solution of the CME\nDynamic state spaces\nAccepts reaction systems defined using Catalyst.jl DSL.\nFiniteStateProjection.jl: High-performance simulation of chemical master equations (CME) via finite state projections\nAccepts reaction systems defined using Catalyst.jl DSL.","category":"page"},{"location":"#Compatible-Numerical-Solvers","page":"Home","title":"Compatible Numerical Solvers","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"All of the symbolic systems have a direct conversion to a numerical system, which can then be handled through the SciML interfaces. For example, after building a model and performing symbolic manipulations, an System can be converted into an ODEProblem to then be solved by a numerical ODE solver. Below is a list of the solver libraries which are the numerical targets of the ModelingToolkit system:","category":"page"},{"location":"","page":"Home","title":"Home","text":"DifferentialEquations.jl\nMulti-package interface of high performance numerical solvers for System, SDESystem, and JumpSystem\nNonlinearSolve.jl\nHigh performance numerical solving of NonlinearSystem\nOptimization.jl\nMulti-package interface for numerical solving OptimizationSystem\nNeuralPDE.jl\nPhysics-Informed Neural Network (PINN) training on PDESystem\nMethodOfLines.jl\nAutomated finite difference method (FDM) discretization of PDESystem","category":"page"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Please refer to the SciML ColPrac: Contributor's Guide on Collaborative Practices for Community Packages for guidance on PRs, issues, and other matters relating to contributing to SciML.\nSee the SciML Style Guide for common coding practices and other style decisions.\nThere are a few community forums:\nThe #diffeq-bridged and #sciml-bridged channels in the Julia Slack\nThe #diffeq-bridged and #sciml-bridged channels in the Julia Zulip\nOn the Julia Discourse forums\nSee also SciML Community page","category":"page"},{"location":"#Reproducibility","page":"Home","title":"Reproducibility","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"<details><summary>The documentation of this SciML package was built using these direct dependencies,</summary>","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg # hide\nPkg.status() # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"</details>","category":"page"},{"location":"","page":"Home","title":"Home","text":"<details><summary>and using this machine and Julia version.</summary>","category":"page"},{"location":"","page":"Home","title":"Home","text":"using InteractiveUtils # hide\nversioninfo() # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"</details>","category":"page"},{"location":"","page":"Home","title":"Home","text":"<details><summary>A more complete overview of all dependencies and their versions is also provided.</summary>","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg # hide\nPkg.status(; mode = PKGMODE_MANIFEST) # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"</details>","category":"page"},{"location":"","page":"Home","title":"Home","text":"using TOML\nusing Markdown\nversion = TOML.parse(read(\"../../Project.toml\", String))[\"version\"]\nname = TOML.parse(read(\"../../Project.toml\", String))[\"name\"]\nlink_manifest = \"https://github.com/SciML/\" * name * \".jl/tree/gh-pages/v\" * version *\n                \"/assets/Manifest.toml\"\nlink_project = \"https://github.com/SciML/\" * name * \".jl/tree/gh-pages/v\" * version *\n               \"/assets/Project.toml\"\nMarkdown.parse(\"\"\"You can also download the\n[manifest]($link_manifest)\nfile and the\n[project]($link_project)\nfile.\n\"\"\")","category":"page"},{"location":"API/System/#System_type","page":"The System type","title":"The System type","text":"","category":"section"},{"location":"API/System/","page":"The System type","title":"The System type","text":"ModelingToolkit.jl uses System to symbolically represent all types of numerical problems. Users create Systems representing the problem they want to solve and mtkcompile transforms them into a format ModelingToolkit.jl can generate code for (alongside performing other optimizations).","category":"page"},{"location":"API/System/#ModelingToolkit.System","page":"The System type","title":"ModelingToolkit.System","text":"struct System <: ModelingToolkit.IntermediateDeprecationSystem\n\nA symbolic representation of a numerical system to be solved. This is a recursive tree-like data structure - each system can contain additional subsystems. As such, it implements the AbstractTrees.jl interface to enable exploring the hierarchical structure.\n\nFields\n\ntag::UInt64: This field is internal API. It may be removed or changed without notice in a non-breaking release. Usage of this field is not advised.\nA unique integer tag for the system.\n\neqs::Vector{Equation}: The equations of the system.\n\nnoise_eqs::Union{Nothing, AbstractMatrix, AbstractVector}: The noise terms for each equation of the system. This field is only used for flattened systems. To represent noise in a hierarchical system, use brownians. In a system with N equations and K independent brownian variables, this should be an N x K matrix. In the special case where N == K and each equation has independent noise, this noise matrix is diagonal. Diagonal noise can be specified by providing an N length vector. If this field is nothing, the system does not have noise.\n\njumps::Vector{Union{JumpProcesses.ConstantRateJump, JumpProcesses.MassActionJump, JumpProcesses.VariableRateJump}}: Jumps associated with the system. Each jump can be a VariableRateJump, ConstantRateJump or MassActionJump. See JumpProcesses.jl for more information.\n\nconstraints::Vector{Union{Equation, Inequality}}: The constraints of the system. This can be used to represent the constraints in an optimal-control problem or boundary-value differential equation, or the constraints in a constrained optimization.\n\ncosts::Vector{<:Union{Real, SymbolicUtils.BasicSymbolic}}: The costs of the system. This can be the cost in an optimal-control problem, or the loss of an optimization problem. Scalar loss values must also be provided as a single- element vector.\n\nconsolidate::Any: A function which combines costs into a scalar value. This should take two arguments, the costs of this system and the consolidated costs of all subsystems in the order they are present in the systems field. It should return a scalar cost that combines all of the individual values. This defaults to a function that simply sums all cost values.\n\nunknowns::Vector: The variables being solved for by this system. For example, in a differential equation system, this contains the dependent variables.\n\nps::Vector: The parameters of the system. Parameters can either be variables that parameterize the problem being solved for (e.g. the spring constant of a mass-spring system) or additional unknowns not part of the main dynamics of the system (e.g. discrete/clocked variables in a hybrid ODE).\n\nbrownians::Vector: The brownian variables of the system, created via @brownians. Each brownian variable represents an independent noise. A system with brownians cannot be simulated directly. It needs to be compiled using mtkcompile into noise_eqs.\n\niv::Union{Nothing, SymbolicUtils.BasicSymbolic{Real}}: The independent variable for a time-dependent system, or nothing for a time-independent system.\n\nobserved::Vector{Equation}: Equations that compute variables of a system that have been eliminated from the set of unknowns by mtkcompile. More generally, this contains all variables that can be computed from the unknowns and parameters and do not need to be solved for. Such variables are termed as \"observables\". Each equation must be of the form observable ~ expression and observables cannot appear on the LHS of multiple equations. Equations must be sorted such that every observable appears on the left hand side of an equation before it appears on the right hand side of any other equation.\n\nparameter_dependencies::Vector{Equation}: This field is internal API. It may be removed or changed without notice in a non-breaking release. Usage of this field is not advised.\nAll the explicit equations relating parameters. Equations here only contain parameters and are in the same format as observed.\n\nvar_to_name::Dict{Symbol, Any}: This field is internal API. It may be removed or changed without notice in a non-breaking release. Usage of this field is not advised.\nA mapping from the name of a variable to the actual symbolic variable in the system. This is used to enable getproperty syntax to access variables of a system.\n\nname::Symbol: The name of the system.\n\ndescription::String: An optional description for the system.\n\ndefaults::Dict: Default values that variables (unknowns/observables/parameters) should take when constructing a numerical problem from the system. These values can be overridden by initial values provided to the problem constructor. Defaults of parent systems take priority over those in child systems.\n\nguesses::Dict: Guess values for variables of a system that are solved for during initialization.\n\nsystems::Vector{System}: A list of subsystems of this system. Used for hierarchically building models.\n\ninitialization_eqs::Vector{Equation}: Equations that must be satisfied during initialization of the numerical problem created from this system. For time-dependent systems, these equations are not valid after the initial time.\n\ncontinuous_events::Vector{ModelingToolkit.SymbolicContinuousCallback}: Symbolic representation of continuous events in a dynamical system. See SymbolicContinuousCallback.\n\ndiscrete_events::Vector{ModelingToolkit.SymbolicDiscreteCallback}: Symbolic representation of discrete events in a dynamica system. See SymbolicDiscreteCallback.\n\nconnector_type::Any: This field is internal API. It may be removed or changed without notice in a non-breaking release. Usage of this field is not advised.\nIf this system is a connector, the type of connector it is.\n\nassertions::Dict{SymbolicUtils.BasicSymbolic, String}: A map from expressions that must be through throughout the solution process to an associated error message. By default these assertions cause the generated code to output NaNs if violated, but can be made to error using debug_system.\n\nmetadata::Base.ImmutableDict{DataType, Any}: The metadata associated with this system, as a Base.ImmutableDict. This follows the same interface as SymbolicUtils.jl. Metadata can be queried and updated using SymbolicUtils.getmetadata and SymbolicUtils.setmetadata respectively.\n\ngui_metadata::Any: This field is internal API. It may be removed or changed without notice in a non-breaking release. Usage of this field is not advised.\nMetadata added by the @mtkmodel macro.\n\nis_dde::Bool: Whether the system contains delay terms. This is inferred from the equations, but can also be provided explicitly.\n\ntstops::Vector{Any}: Extra time points for the integrator to stop at. These can be numeric values, or expressions of parameters and time.\n\ntearing_state::Any: The TearingState of the system post-simplification with mtkcompile.\n\nnamespacing::Bool: Whether the system namespaces variables accessed via getproperty. completed systems do not namespace, but this flag can be toggled independently of complete using toggle_namespacing.\n\ncomplete::Bool: Whether the system is marked as \"complete\". Completed systems cannot be used as subsystems.\n\nindex_cache::Union{Nothing, ModelingToolkit.IndexCache}: This field is internal API. It may be removed or changed without notice in a non-breaking release. Usage of this field is not advised.\nFor systems simplified or completed with split = true (the default) this contains an IndexCache which aids in symbolic indexing. If this field is nothing, the system is either not completed, or completed with split = false.\n\nignored_connections::Union{Nothing, Vector{Connection}}: This field is internal API. It may be removed or changed without notice in a non-breaking release. Usage of this field is not advised.\nConnections that should be ignored because they were removed by an analysis point transformation. The first element of the tuple contains all such \"standard\" connections (ones between connector systems) and the second contains all such causal variable connections.\n\npreface::Any: SymbolicUtils.Code.Assignments to prepend to all code generated from this system.\n\nparent::Union{Nothing, System}: After simplification with mtkcompile, this field contains the unsimplified system with the hierarchical structure. There may be multiple levels of parents. The root parent is used for accessing variables via getproperty syntax.\n\ninitializesystem::Union{Nothing, System}: A custom initialization system to use if no initial conditions are provided for the unknowns or observables of this system.\n\nis_initializesystem::Bool: Whether the current system is an initialization system.\n\nis_discrete::Bool\nisscheduled::Bool: This field is internal API. It may be removed or changed without notice in a non-breaking release. Usage of this field is not advised.\nWhether the system has been simplified by mtkcompile.\n\nschedule::Union{Nothing, ModelingToolkit.Schedule}: This field is internal API. It may be removed or changed without notice in a non-breaking release. Usage of this field is not advised.\nThe Schedule containing additional information about the simplified system.\n\n\n\n\n\n","category":"type"},{"location":"API/System/#Utility-constructors","page":"The System type","title":"Utility constructors","text":"","category":"section"},{"location":"API/System/","page":"The System type","title":"The System type","text":"Several utility constructors also exist to easily construct alternative system formulations.","category":"page"},{"location":"API/System/#ModelingToolkit.NonlinearSystem","page":"The System type","title":"ModelingToolkit.NonlinearSystem","text":"NonlinearSystem(sys::System) -> Any\n\n\nGiven a time-dependent system sys of ODEs, convert it to a time-independent system of nonlinear equations that solve for the steady-state of the unknowns. This is done by replacing every derivative D(x) of an unknown x with zero. Note that this process does not retain noise equations, brownian terms, jumps or costs associated with sys. All other information such as defaults, guesses, observed and initialization equations are retained. The independent variable of sys becomes a parameter of the returned system.\n\nIf sys is hierarchical (it contains subsystems) this transformation will be applied recursively to all subsystems. The output system will be marked as complete if and only if the input system is also complete. This also retains the split flag passed to complete.\n\nSee also: complete.\n\n\n\n\n\n","category":"function"},{"location":"API/System/#ModelingToolkit.SDESystem","page":"The System type","title":"ModelingToolkit.SDESystem","text":"SDESystem(eqs::Vector{Equation}, noise, iv; is_scalar_noise = false, kwargs...)\n\nConstruct a system of equations with associated noise terms. Instead of specifying noise using @brownians variables, it is specified using a noise matrix noise. iv is the independent variable of the system.\n\nIn the general case, noise should be a N x M matrix where N is the number of equations (length(eqs)) and M is the number of independent random variables. noise[i, j] is the diffusion term for equation i and random variable j. If the noise is diagonal (N == M and noise[i, j] == 0 for all i != j) it can be specified as a Vector of length N corresponding to the diagonal of the noise matrix. As a special case, if all equations have the same noise then all rows of noise are identical. This is known as \"scalar noise\". In this case, noise can be a Vector corresponding to the repeated row and is_scalar_noise must be true.\n\nNote that systems created in this manner cannot be used hierarchically. This should only be used to construct flattened systems. To use such a system hierarchically, it must be converted to use brownian variables using noise_to_brownians. mtkcompile will automatically perform this conversion.\n\nAll keyword arguments are the same as those of the System constructor.\n\n\n\n\n\nSDESystem(eqs::Vector{Equation}, noise, iv, dvs, ps; is_scalar_noise = false, kwargs...)\n\nIdentical to the 3-argument SDESystem constructor, but uses the explicitly provided dvs and ps for unknowns and parameters of the system.\n\n\n\n\n\nSDESystem(sys::System, noise; kwargs...)\n\n\nAttach the given noise matrix noise to the system sys.\n\n\n\n\n\n","category":"function"},{"location":"API/System/#ModelingToolkit.JumpSystem","page":"The System type","title":"ModelingToolkit.JumpSystem","text":"JumpSystem(jumps, iv; kwargs...)\n\n\nConstruct a System to solve a system of jump equations. jumps is an array of jumps, expressed using JumpProcesses.MassActionJump, JumpProcesses.ConstantRateJump and JumpProcesses.VariableRateJump. It can also include standard equations to simulate jump-diffusion processes. iv should be the independent variable of the system.\n\nAll keyword arguments are the same as those of the System constructor.\n\n\n\n\n\nJumpSystem(jumps, iv, dvs, ps; kwargs...)\n\n\nIdentical to the 2-argument JumpSystem constructor, but uses the explicitly provided dvs and ps for unknowns and parameters of the system.\n\n\n\n\n\n","category":"function"},{"location":"API/System/#ModelingToolkit.OptimizationSystem","page":"The System type","title":"ModelingToolkit.OptimizationSystem","text":"OptimizationSystem(cost; kwargs...)\n\n\nConstruct a time-independent System for optimizing the specified scalar cost. The system will have no equations.\n\nUnknowns and parameters of the system are inferred from the cost and other values (such as defaults) passed to it.\n\nAll keyword arguments are the same as those of the System constructor.\n\n\n\n\n\nOptimizationSystem(cost, dvs, ps; kwargs...)\n\n\nIdentical to the corresponding single-argument OptimizationSystem constructor, except the unknowns and parameters are specified by passing arrays of symbolic variables to dvs and ps respectively.\n\n\n\n\n\nOptimizationSystem(cost::Array; kwargs...)\n\n\nConstruct a time-independent System for optimizing the specified multi-objective cost. The cost will be reduced to a scalar using the consolidate function. This defaults to summing the specified cost and that of all subsystems. The system will have no equations.\n\nUnknowns and parameters of the system are inferred from the cost and other values (such as defaults) passed to it.\n\nAll keyword arguments are the same as those of the System constructor.\n\n\n\n\n\nOptimizationSystem(cost::Array, dvs, ps; kwargs...)\n\n\nIdentical to the corresponding single-argument OptimizationSystem constructor, except the unknowns and parameters are specified by passing arrays of symbolic variables to dvs and ps respectively.\n\n\n\n\n\n","category":"function"},{"location":"API/System/#Accessor-functions","page":"The System type","title":"Accessor functions","text":"","category":"section"},{"location":"API/System/","page":"The System type","title":"The System type","text":"Several accessor functions exist to query systems for the information they contain. In general, for every field x there exists a has_x function which checks if the system contains the field and a get_x function for obtaining the value in the field. Note that fields of a system cannot be accessed via getproperty - that is reserved for accessing variables, subsystems or analysis points of the hierarchical system.","category":"page"},{"location":"API/System/#ModelingToolkit.has_eqs","page":"The System type","title":"ModelingToolkit.has_eqs","text":"has_eqs(sys::ModelingToolkit.AbstractSystem) -> Bool\n\n\nReturns whether the system sys has the internal field eqs.\n\nSee also get_eqs.\n\n\n\n\n\n","category":"function"},{"location":"API/System/#ModelingToolkit.get_eqs","page":"The System type","title":"ModelingToolkit.get_eqs","text":"get_eqs(sys::ModelingToolkit.AbstractSystem) -> Any\n\n\nGet the internal field eqs of a system sys. It only includes eqs local to sys; not those of its subsystems, like unknowns(sys), parameters(sys) and equations(sys) does.\n\nSee also has_eqs.\n\n\n\n\n\n","category":"function"},{"location":"API/System/#ModelingToolkit.equations","page":"The System type","title":"ModelingToolkit.equations","text":"equations(sys::ModelingToolkit.AbstractSystem) -> Any\n\n\nGet the flattened equations of the system sys and its subsystems. It may include some abbreviations and aliases of observables. It is often the most useful way to inspect the equations of a system.\n\nSee also full_equations and ModelingToolkit.get_eqs.\n\n\n\n\n\n","category":"function"},{"location":"API/System/#ModelingToolkit.equations_toplevel","page":"The System type","title":"ModelingToolkit.equations_toplevel","text":"equations_toplevel(sys::AbstractSystem)\n\nReplicates the behaviour of equations, but ignores equations of subsystems.\n\nNotes:\n\nCannot be applied to non-complete systems.\n\n\n\n\n\n","category":"function"},{"location":"API/System/#ModelingToolkit.full_equations","page":"The System type","title":"ModelingToolkit.full_equations","text":"full_equations(\n    sys::ModelingToolkit.AbstractSystem;\n    simplify\n) -> Any\n\n\nLike equations(sys), but also substitutes the observed equations eliminated from the equations during mtkcompile. These equations matches generated numerical code.\n\nSee also equations and ModelingToolkit.get_eqs.\n\n\n\n\n\n","category":"function"},{"location":"API/System/#ModelingToolkit.has_noise_eqs","page":"The System type","title":"ModelingToolkit.has_noise_eqs","text":"has_noise_eqs(sys::ModelingToolkit.AbstractSystem) -> Bool\n\n\nReturns whether the system sys has the internal field noise_eqs.\n\nSee also get_noise_eqs.\n\n\n\n\n\n","category":"function"},{"location":"API/System/#ModelingToolkit.get_noise_eqs","page":"The System type","title":"ModelingToolkit.get_noise_eqs","text":"get_noise_eqs(sys::ModelingToolkit.AbstractSystem) -> Any\n\n\nGet the internal field noise_eqs of a system sys. It only includes noise_eqs local to sys; not those of its subsystems, like unknowns(sys), parameters(sys) and equations(sys) does.\n\nSee also has_noise_eqs.\n\n\n\n\n\n","category":"function"},{"location":"API/System/#ModelingToolkit.has_jumps","page":"The System type","title":"ModelingToolkit.has_jumps","text":"has_jumps(sys::ModelingToolkit.AbstractSystem) -> Bool\n\n\nReturns whether the system sys has the internal field jumps.\n\nSee also get_jumps.\n\n\n\n\n\n","category":"function"},{"location":"API/System/#ModelingToolkit.get_jumps","page":"The System type","title":"ModelingToolkit.get_jumps","text":"get_jumps(sys::ModelingToolkit.AbstractSystem) -> Any\n\n\nGet the internal field jumps of a system sys. It only includes jumps local to sys; not those of its subsystems, like unknowns(sys), parameters(sys) and equations(sys) does.\n\nSee also has_jumps.\n\n\n\n\n\n","category":"function"},{"location":"API/System/#ModelingToolkit.jumps","page":"The System type","title":"ModelingToolkit.jumps","text":"jumps(sys::ModelingToolkit.AbstractSystem) -> Any\n\n\nGet the flattened jumps of the system. In other words, obtain all of the jumps in sys and all the subsystems of sys (appropriately namespaced).\n\n\n\n\n\n","category":"function"},{"location":"API/System/#ModelingToolkit.has_constraints","page":"The System type","title":"ModelingToolkit.has_constraints","text":"has_constraints(sys::ModelingToolkit.AbstractSystem) -> Bool\n\n\nReturns whether the system sys has the internal field constraints.\n\nSee also get_constraints.\n\n\n\n\n\n","category":"function"},{"location":"API/System/#ModelingToolkit.get_constraints","page":"The System type","title":"ModelingToolkit.get_constraints","text":"get_constraints(sys::ModelingToolkit.AbstractSystem) -> Any\n\n\nGet the internal field constraints of a system sys. It only includes constraints local to sys; not those of its subsystems, like unknowns(sys), parameters(sys) and equations(sys) does.\n\nSee also has_constraints.\n\n\n\n\n\n","category":"function"},{"location":"API/System/#ModelingToolkit.constraints","page":"The System type","title":"ModelingToolkit.constraints","text":"constraints(sys::ModelingToolkit.AbstractSystem) -> Any\n\n\nGet all constraints in the system sys and all of its subsystems, appropriately namespaced.\n\n\n\n\n\n","category":"function"},{"location":"API/System/#ModelingToolkit.has_costs","page":"The System type","title":"ModelingToolkit.has_costs","text":"has_costs(sys::ModelingToolkit.AbstractSystem) -> Bool\n\n\nReturns whether the system sys has the internal field costs.\n\nSee also get_costs.\n\n\n\n\n\n","category":"function"},{"location":"API/System/#ModelingToolkit.get_costs","page":"The System type","title":"ModelingToolkit.get_costs","text":"get_costs(sys::ModelingToolkit.AbstractSystem) -> Any\n\n\nGet the internal field costs of a system sys. It only includes costs local to sys; not those of its subsystems, like unknowns(sys), parameters(sys) and equations(sys) does.\n\nSee also has_costs.\n\n\n\n\n\n","category":"function"},{"location":"API/System/#ModelingToolkit.cost","page":"The System type","title":"ModelingToolkit.cost","text":"cost(sys::ModelingToolkit.AbstractSystem) -> Any\n\n\nRecursively consolidate the cost vector of sys and all subsystems of sys, returning the final scalar cost function.\n\n\n\n\n\n","category":"function"},{"location":"API/System/#ModelingToolkit.has_consolidate","page":"The System type","title":"ModelingToolkit.has_consolidate","text":"has_consolidate(sys::ModelingToolkit.AbstractSystem) -> Bool\n\n\nReturns whether the system sys has the internal field consolidate.\n\nSee also get_consolidate.\n\n\n\n\n\n","category":"function"},{"location":"API/System/#ModelingToolkit.get_consolidate","page":"The System type","title":"ModelingToolkit.get_consolidate","text":"get_consolidate(sys::ModelingToolkit.AbstractSystem) -> Any\n\n\nGet the internal field consolidate of a system sys. It only includes consolidate local to sys; not those of its subsystems, like unknowns(sys), parameters(sys) and equations(sys) does.\n\nSee also has_consolidate.\n\n\n\n\n\n","category":"function"},{"location":"API/System/#ModelingToolkit.has_unknowns","page":"The System type","title":"ModelingToolkit.has_unknowns","text":"has_unknowns(sys::ModelingToolkit.AbstractSystem) -> Bool\n\n\nReturns whether the system sys has the internal field unknowns.\n\nSee also get_unknowns.\n\n\n\n\n\n","category":"function"},{"location":"API/System/#ModelingToolkit.get_unknowns","page":"The System type","title":"ModelingToolkit.get_unknowns","text":"get_unknowns(sys::ModelingToolkit.AbstractSystem) -> Any\n\n\nGet the internal field unknowns of a system sys. It only includes unknowns local to sys; not those of its subsystems, like unknowns(sys), parameters(sys) and equations(sys) does.\n\nSee also has_unknowns.\n\n\n\n\n\n","category":"function"},{"location":"API/System/#ModelingToolkit.unknowns","page":"The System type","title":"ModelingToolkit.unknowns","text":"unknowns(sys::ModelingToolkit.AbstractSystem) -> Any\n\n\nGet the unknown variables of the system sys and its subsystems. These must be explicitly solved for, unlike observables(sys).\n\nSee also ModelingToolkit.get_unknowns.\n\n\n\n\n\n","category":"function"},{"location":"API/System/#ModelingToolkit.unknowns_toplevel","page":"The System type","title":"ModelingToolkit.unknowns_toplevel","text":"unknowns_toplevel(sys::AbstractSystem)\n\nReplicates the behaviour of unknowns, but ignores unknowns of subsystems.\n\n\n\n\n\n","category":"function"},{"location":"API/System/#ModelingToolkit.has_ps","page":"The System type","title":"ModelingToolkit.has_ps","text":"has_ps(sys::ModelingToolkit.AbstractSystem) -> Bool\n\n\nReturns whether the system sys has the internal field ps.\n\nSee also get_ps.\n\n\n\n\n\n","category":"function"},{"location":"API/System/#ModelingToolkit.get_ps","page":"The System type","title":"ModelingToolkit.get_ps","text":"get_ps(sys::ModelingToolkit.AbstractSystem) -> Any\n\n\nGet the internal field ps of a system sys. It only includes ps local to sys; not those of its subsystems, like unknowns(sys), parameters(sys) and equations(sys) does.\n\nSee also has_ps.\n\n\n\n\n\n","category":"function"},{"location":"API/System/#ModelingToolkit.parameters","page":"The System type","title":"ModelingToolkit.parameters","text":"parameters(\n    sys::ModelingToolkit.AbstractSystem;\n    initial_parameters\n) -> Any\n\n\nGet the parameters of the system sys and its subsystems.\n\nSee also @parameters and ModelingToolkit.get_ps.\n\n\n\n\n\n","category":"function"},{"location":"API/System/#ModelingToolkit.parameters_toplevel","page":"The System type","title":"ModelingToolkit.parameters_toplevel","text":"parameters_toplevel(sys::AbstractSystem)\n\nReplicates the behaviour of parameters, but ignores parameters of subsystems.\n\n\n\n\n\n","category":"function"},{"location":"API/System/#ModelingToolkit.tunable_parameters","page":"The System type","title":"ModelingToolkit.tunable_parameters","text":"tunable_parameters(sys, p = parameters(sys; initial_parameters = true); default=true)\n\nGet all parameters of sys that are marked as tunable.\n\nKeyword argument default indicates whether variables without tunable metadata are to be considered tunable or not.\n\nCreate a tunable parameter by\n\n@parameters u [tunable=true]\n\nFor systems created with split = true (the default) and default = true passed to this function, the order of parameters returned is the order in which they are stored in the tunables portion of MTKParameters. Note that array variables will not be scalarized. To obtain the flattened representation of the tunables portion, call Symbolics.scalarize(tunable_parameters(sys)) and concatenate the resulting arrays.\n\nSee also getbounds, istunable, MTKParameters, complete\n\n\n\n\n\n","category":"function"},{"location":"API/System/#ModelingToolkit.has_brownians","page":"The System type","title":"ModelingToolkit.has_brownians","text":"has_brownians(sys::ModelingToolkit.AbstractSystem) -> Bool\n\n\nReturns whether the system sys has the internal field brownians.\n\nSee also get_brownians.\n\n\n\n\n\n","category":"function"},{"location":"API/System/#ModelingToolkit.get_brownians","page":"The System type","title":"ModelingToolkit.get_brownians","text":"get_brownians(sys::ModelingToolkit.AbstractSystem) -> Any\n\n\nGet the internal field brownians of a system sys. It only includes brownians local to sys; not those of its subsystems, like unknowns(sys), parameters(sys) and equations(sys) does.\n\nSee also has_brownians.\n\n\n\n\n\n","category":"function"},{"location":"API/System/#ModelingToolkit.brownians","page":"The System type","title":"ModelingToolkit.brownians","text":"brownians(sys::ModelingToolkit.AbstractSystem) -> Any\n\n\nGet all of the brownian variables involved in the system sys and all subsystems, appropriately namespaced.\n\n\n\n\n\n","category":"function"},{"location":"API/System/#ModelingToolkit.has_iv","page":"The System type","title":"ModelingToolkit.has_iv","text":"has_iv(sys::ModelingToolkit.AbstractSystem) -> Bool\n\n\nReturns whether the system sys has the internal field iv.\n\nSee also get_iv.\n\n\n\n\n\n","category":"function"},{"location":"API/System/#ModelingToolkit.get_iv","page":"The System type","title":"ModelingToolkit.get_iv","text":"get_iv(sys::ModelingToolkit.AbstractSystem) -> Any\n\n\nGet the internal field iv of a system sys. It only includes iv local to sys; not those of its subsystems, like unknowns(sys), parameters(sys) and equations(sys) does.\n\nSee also has_iv.\n\n\n\n\n\n","category":"function"},{"location":"API/System/#ModelingToolkit.has_observed","page":"The System type","title":"ModelingToolkit.has_observed","text":"has_observed(sys::ModelingToolkit.AbstractSystem) -> Bool\n\n\nReturns whether the system sys has the internal field observed.\n\nSee also get_observed.\n\n\n\n\n\n","category":"function"},{"location":"API/System/#ModelingToolkit.get_observed","page":"The System type","title":"ModelingToolkit.get_observed","text":"get_observed(sys::ModelingToolkit.AbstractSystem) -> Any\n\n\nGet the internal field observed of a system sys. It only includes observed local to sys; not those of its subsystems, like unknowns(sys), parameters(sys) and equations(sys) does.\n\nSee also has_observed.\n\n\n\n\n\n","category":"function"},{"location":"API/System/#ModelingToolkit.observed","page":"The System type","title":"ModelingToolkit.observed","text":"observed(sys::ModelingToolkit.AbstractSystem) -> Any\n\n\nGet the observed equations of the system sys and its subsystems. These can be expressed in terms of unknowns(sys), and do not have to be explicitly solved for.\n\nSee also observables and ModelingToolkit.get_observed().\n\n\n\n\n\n","category":"function"},{"location":"API/System/#ModelingToolkit.observables","page":"The System type","title":"ModelingToolkit.observables","text":"observables(sys::ModelingToolkit.AbstractSystem) -> Any\n\n\nGet the observed variables of the system sys and its subsystems. These can be expressed in terms of unknowns(sys), and do not have to be explicitly solved for. It is equivalent to all left hand sides of observed(sys).\n\nSee also observed.\n\n\n\n\n\n","category":"function"},{"location":"API/System/#ModelingToolkit.has_name","page":"The System type","title":"ModelingToolkit.has_name","text":"has_name(sys::ModelingToolkit.AbstractSystem) -> Bool\n\n\nReturns whether the system sys has the internal field name.\n\nSee also get_name.\n\n\n\n\n\n","category":"function"},{"location":"API/System/#ModelingToolkit.get_name","page":"The System type","title":"ModelingToolkit.get_name","text":"get_name(sys::ModelingToolkit.AbstractSystem) -> Any\n\n\nGet the internal field name of a system sys. It only includes name local to sys; not those of its subsystems, like unknowns(sys), parameters(sys) and equations(sys) does.\n\nSee also has_name.\n\n\n\n\n\n","category":"function"},{"location":"API/System/#Base.nameof","page":"The System type","title":"Base.nameof","text":"nameof(sys::ModelingToolkit.AbstractSystem) -> Any\n\n\nObtain the name of sys.\n\n\n\n\n\n","category":"function"},{"location":"API/System/#ModelingToolkit.has_description","page":"The System type","title":"ModelingToolkit.has_description","text":"has_description(sys::ModelingToolkit.AbstractSystem) -> Bool\n\n\nReturns whether the system sys has the internal field description.\n\nSee also get_description.\n\n\n\n\n\n","category":"function"},{"location":"API/System/#ModelingToolkit.get_description","page":"The System type","title":"ModelingToolkit.get_description","text":"get_description(sys::ModelingToolkit.AbstractSystem) -> Any\n\n\nGet the internal field description of a system sys. It only includes description local to sys; not those of its subsystems, like unknowns(sys), parameters(sys) and equations(sys) does.\n\nSee also has_description.\n\n\n\n\n\n","category":"function"},{"location":"API/System/#ModelingToolkit.description","page":"The System type","title":"ModelingToolkit.description","text":"description(sys::ModelingToolkit.AbstractSystem) -> Any\n\n\nObtain the description associated with sys if present, and an empty string otherwise.\n\n\n\n\n\n","category":"function"},{"location":"API/System/#ModelingToolkit.has_defaults","page":"The System type","title":"ModelingToolkit.has_defaults","text":"has_defaults(sys::ModelingToolkit.AbstractSystem) -> Bool\n\n\nReturns whether the system sys has the internal field defaults.\n\nSee also get_defaults.\n\n\n\n\n\n","category":"function"},{"location":"API/System/#ModelingToolkit.get_defaults","page":"The System type","title":"ModelingToolkit.get_defaults","text":"get_defaults(sys::ModelingToolkit.AbstractSystem) -> Any\n\n\nGet the internal field defaults of a system sys. It only includes defaults local to sys; not those of its subsystems, like unknowns(sys), parameters(sys) and equations(sys) does.\n\nSee also has_defaults.\n\n\n\n\n\n","category":"function"},{"location":"API/System/#ModelingToolkit.defaults","page":"The System type","title":"ModelingToolkit.defaults","text":"defaults(sys::ModelingToolkit.AbstractSystem) -> Any\n\n\nGet the default values of the system sys and its subsystems. If they are not explicitly provided, variables and parameters are initialized to these values.\n\nSee also initialization_equations and ModelingToolkit.get_defaults.\n\n\n\n\n\n","category":"function"},{"location":"API/System/#ModelingToolkit.has_guesses","page":"The System type","title":"ModelingToolkit.has_guesses","text":"has_guesses(sys::ModelingToolkit.AbstractSystem) -> Bool\n\n\nReturns whether the system sys has the internal field guesses.\n\nSee also get_guesses.\n\n\n\n\n\n","category":"function"},{"location":"API/System/#ModelingToolkit.get_guesses","page":"The System type","title":"ModelingToolkit.get_guesses","text":"get_guesses(sys::ModelingToolkit.AbstractSystem) -> Any\n\n\nGet the internal field guesses of a system sys. It only includes guesses local to sys; not those of its subsystems, like unknowns(sys), parameters(sys) and equations(sys) does.\n\nSee also has_guesses.\n\n\n\n\n\n","category":"function"},{"location":"API/System/#ModelingToolkit.guesses","page":"The System type","title":"ModelingToolkit.guesses","text":"guesses(sys::ModelingToolkit.AbstractSystem) -> Any\n\n\nGet the guesses for variables in the initialization system of the system sys and its subsystems.\n\nSee also initialization_equations and ModelingToolkit.get_guesses.\n\n\n\n\n\n","category":"function"},{"location":"API/System/#ModelingToolkit.get_systems","page":"The System type","title":"ModelingToolkit.get_systems","text":"get_systems(sys::ModelingToolkit.AbstractSystem) -> Any\n\n\nGet the internal field systems of a system sys. It only includes systems local to sys; not those of its subsystems, like unknowns(sys), parameters(sys) and equations(sys) does.\n\nSee also has_systems.\n\n\n\n\n\n","category":"function"},{"location":"API/System/#ModelingToolkit.has_initialization_eqs","page":"The System type","title":"ModelingToolkit.has_initialization_eqs","text":"has_initialization_eqs(\n    sys::ModelingToolkit.AbstractSystem\n) -> Bool\n\n\nReturns whether the system sys has the internal field initialization_eqs.\n\nSee also get_initialization_eqs.\n\n\n\n\n\n","category":"function"},{"location":"API/System/#ModelingToolkit.get_initialization_eqs","page":"The System type","title":"ModelingToolkit.get_initialization_eqs","text":"get_initialization_eqs(\n    sys::ModelingToolkit.AbstractSystem\n) -> Any\n\n\nGet the internal field initialization_eqs of a system sys. It only includes initialization_eqs local to sys; not those of its subsystems, like unknowns(sys), parameters(sys) and equations(sys) does.\n\nSee also has_initialization_eqs.\n\n\n\n\n\n","category":"function"},{"location":"API/System/#ModelingToolkit.initialization_equations","page":"The System type","title":"ModelingToolkit.initialization_equations","text":"initialization_equations(\n    sys::ModelingToolkit.AbstractSystem\n) -> Any\n\n\nGet the initialization equations of the system sys and its subsystems.\n\nSee also guesses, defaults and ModelingToolkit.get_initialization_eqs.\n\n\n\n\n\n","category":"function"},{"location":"API/System/#ModelingToolkit.has_continuous_events","page":"The System type","title":"ModelingToolkit.has_continuous_events","text":"has_continuous_events(\n    sys::ModelingToolkit.AbstractSystem\n) -> Bool\n\n\nReturns whether the system sys has the internal field continuous_events.\n\nSee also get_continuous_events.\n\n\n\n\n\n","category":"function"},{"location":"API/System/#ModelingToolkit.get_continuous_events","page":"The System type","title":"ModelingToolkit.get_continuous_events","text":"get_continuous_events(\n    sys::ModelingToolkit.AbstractSystem\n) -> Any\n\n\nGet the internal field continuous_events of a system sys. It only includes continuous_events local to sys; not those of its subsystems, like unknowns(sys), parameters(sys) and equations(sys) does.\n\nSee also has_continuous_events.\n\n\n\n\n\n","category":"function"},{"location":"API/System/#ModelingToolkit.continuous_events","page":"The System type","title":"ModelingToolkit.continuous_events","text":"continuous_events(sys::AbstractSystem)::Vector{SymbolicContinuousCallback}\n\nReturns a vector of all the continuous_events in an abstract system and its component subsystems. The SymbolicContinuousCallbacks in the returned vector are structs with two fields: eqs and affect which correspond to the first and second elements of a Pair used to define an event, i.e. eqs => affect.\n\nSee also get_continuous_events, which only returns the events of the top-level system.\n\n\n\n\n\n","category":"function"},{"location":"API/System/#ModelingToolkit.continuous_events_toplevel","page":"The System type","title":"ModelingToolkit.continuous_events_toplevel","text":"continuous_events_toplevel(sys::AbstractSystem)\n\nReplicates the behaviour of continuous_events, but ignores events of subsystems.\n\nNotes:\n\nCannot be applied to non-complete systems.\n\n\n\n\n\n","category":"function"},{"location":"API/System/#ModelingToolkit.has_discrete_events","page":"The System type","title":"ModelingToolkit.has_discrete_events","text":"has_discrete_events(\n    sys::ModelingToolkit.AbstractSystem\n) -> Bool\n\n\nReturns whether the system sys has the internal field discrete_events.\n\nSee also get_discrete_events.\n\n\n\n\n\n","category":"function"},{"location":"API/System/#ModelingToolkit.get_discrete_events","page":"The System type","title":"ModelingToolkit.get_discrete_events","text":"get_discrete_events(\n    sys::ModelingToolkit.AbstractSystem\n) -> Any\n\n\nGet the internal field discrete_events of a system sys. It only includes discrete_events local to sys; not those of its subsystems, like unknowns(sys), parameters(sys) and equations(sys) does.\n\nSee also has_discrete_events.\n\n\n\n\n\n","category":"function"},{"location":"API/System/#ModelingToolkit.discrete_events_toplevel","page":"The System type","title":"ModelingToolkit.discrete_events_toplevel","text":"discrete_events_toplevel(sys::AbstractSystem)\n\nReplicates the behaviour of discrete_events, but ignores events of subsystems.\n\nNotes:\n\nCannot be applied to non-complete systems.\n\n\n\n\n\n","category":"function"},{"location":"API/System/#ModelingToolkit.has_assertions","page":"The System type","title":"ModelingToolkit.has_assertions","text":"has_assertions(sys::ModelingToolkit.AbstractSystem) -> Bool\n\n\nReturns whether the system sys has the internal field assertions.\n\nSee also get_assertions.\n\n\n\n\n\n","category":"function"},{"location":"API/System/#ModelingToolkit.get_assertions","page":"The System type","title":"ModelingToolkit.get_assertions","text":"get_assertions(sys::ModelingToolkit.AbstractSystem) -> Any\n\n\nGet the internal field assertions of a system sys. It only includes assertions local to sys; not those of its subsystems, like unknowns(sys), parameters(sys) and equations(sys) does.\n\nSee also has_assertions.\n\n\n\n\n\n","category":"function"},{"location":"API/System/#ModelingToolkit.assertions","page":"The System type","title":"ModelingToolkit.assertions","text":"assertions(sys::ModelingToolkit.AbstractSystem) -> Any\n\n\nGet the assertions for a system sys and its subsystems.\n\n\n\n\n\n","category":"function"},{"location":"API/System/#ModelingToolkit.has_metadata","page":"The System type","title":"ModelingToolkit.has_metadata","text":"has_metadata(sys::ModelingToolkit.AbstractSystem) -> Bool\n\n\nReturns whether the system sys has the internal field metadata.\n\nSee also get_metadata.\n\n\n\n\n\n","category":"function"},{"location":"API/System/#ModelingToolkit.get_metadata","page":"The System type","title":"ModelingToolkit.get_metadata","text":"get_metadata(sys::ModelingToolkit.AbstractSystem) -> Any\n\n\nGet the internal field metadata of a system sys. It only includes metadata local to sys; not those of its subsystems, like unknowns(sys), parameters(sys) and equations(sys) does.\n\nSee also has_metadata.\n\n\n\n\n\n","category":"function"},{"location":"API/System/#SymbolicUtils.getmetadata-Tuple{ModelingToolkit.AbstractSystem, DataType, Any}","page":"The System type","title":"SymbolicUtils.getmetadata","text":"getmetadata(\n    sys::ModelingToolkit.AbstractSystem,\n    k::DataType,\n    default\n) -> Any\n\n\nGet the metadata associated with key k in system sys or default if it does not exist.\n\n\n\n\n\n","category":"method"},{"location":"API/System/#SymbolicUtils.setmetadata-Tuple{ModelingToolkit.AbstractSystem, DataType, Any}","page":"The System type","title":"SymbolicUtils.setmetadata","text":"setmetadata(\n    sys::ModelingToolkit.AbstractSystem,\n    k::DataType,\n    v\n) -> Any\n\n\nSet the metadata associated with key k in system sys to value v. This is an out-of-place operation, and will return a shallow copy of sys with the appropriate metadata values.\n\n\n\n\n\n","category":"method"},{"location":"API/System/#ModelingToolkit.has_is_dde","page":"The System type","title":"ModelingToolkit.has_is_dde","text":"has_is_dde(sys::ModelingToolkit.AbstractSystem) -> Bool\n\n\nReturns whether the system sys has the internal field is_dde.\n\nSee also get_is_dde.\n\n\n\n\n\n","category":"function"},{"location":"API/System/#ModelingToolkit.get_is_dde","page":"The System type","title":"ModelingToolkit.get_is_dde","text":"get_is_dde(sys::ModelingToolkit.AbstractSystem) -> Any\n\n\nGet the internal field is_dde of a system sys. It only includes is_dde local to sys; not those of its subsystems, like unknowns(sys), parameters(sys) and equations(sys) does.\n\nSee also has_is_dde.\n\n\n\n\n\n","category":"function"},{"location":"API/System/#ModelingToolkit.is_dde","page":"The System type","title":"ModelingToolkit.is_dde","text":"is_dde(sys::AbstractSystem)\n\nReturn a boolean indicating whether a system represents a set of delay differential equations.\n\n\n\n\n\n","category":"function"},{"location":"API/System/#ModelingToolkit.has_tstops","page":"The System type","title":"ModelingToolkit.has_tstops","text":"has_tstops(sys::ModelingToolkit.AbstractSystem) -> Bool\n\n\nReturns whether the system sys has the internal field tstops.\n\nSee also get_tstops.\n\n\n\n\n\n","category":"function"},{"location":"API/System/#ModelingToolkit.get_tstops","page":"The System type","title":"ModelingToolkit.get_tstops","text":"get_tstops(sys::ModelingToolkit.AbstractSystem) -> Any\n\n\nGet the internal field tstops of a system sys. It only includes tstops local to sys; not those of its subsystems, like unknowns(sys), parameters(sys) and equations(sys) does.\n\nSee also has_tstops.\n\n\n\n\n\n","category":"function"},{"location":"API/System/#ModelingToolkit.symbolic_tstops","page":"The System type","title":"ModelingToolkit.symbolic_tstops","text":"symbolic_tstops(sys::ModelingToolkit.AbstractSystem) -> Any\n\n\nGet the tstops present in sys and its subsystems, appropriately namespaced.\n\n\n\n\n\n","category":"function"},{"location":"API/System/#ModelingToolkit.has_tearing_state","page":"The System type","title":"ModelingToolkit.has_tearing_state","text":"has_tearing_state(\n    sys::ModelingToolkit.AbstractSystem\n) -> Bool\n\n\nReturns whether the system sys has the internal field tearing_state.\n\nSee also get_tearing_state.\n\n\n\n\n\n","category":"function"},{"location":"API/System/#ModelingToolkit.get_tearing_state","page":"The System type","title":"ModelingToolkit.get_tearing_state","text":"get_tearing_state(\n    sys::ModelingToolkit.AbstractSystem\n) -> Any\n\n\nGet the internal field tearing_state of a system sys. It only includes tearing_state local to sys; not those of its subsystems, like unknowns(sys), parameters(sys) and equations(sys) does.\n\nSee also has_tearing_state.\n\n\n\n\n\n","category":"function"},{"location":"API/System/#ModelingToolkit.does_namespacing","page":"The System type","title":"ModelingToolkit.does_namespacing","text":"does_namespacing(sys::ModelingToolkit.AbstractSystem) -> Any\n\n\nCheck whether a system performs namespacing.\n\n\n\n\n\n","category":"function"},{"location":"API/System/#ModelingToolkit.toggle_namespacing","page":"The System type","title":"ModelingToolkit.toggle_namespacing","text":"toggle_namespacing(\n    sys::ModelingToolkit.AbstractSystem,\n    value::Bool;\n    safe\n) -> Any\n\n\nReturn a new sys with namespacing enabled or disabled, depending on value. The keyword argument safe denotes whether systems that do not support such a toggle should error or be ignored.\n\n\n\n\n\n","category":"function"},{"location":"API/System/#ModelingToolkit.iscomplete","page":"The System type","title":"ModelingToolkit.iscomplete","text":"iscomplete(sys::ModelingToolkit.AbstractSystem) -> Any\n\n\nCheck whether a system is marked as complete.\n\n\n\n\n\n","category":"function"},{"location":"API/System/#ModelingToolkit.has_preface","page":"The System type","title":"ModelingToolkit.has_preface","text":"has_preface(sys::ModelingToolkit.AbstractSystem) -> Bool\n\n\nReturns whether the system sys has the internal field preface.\n\nSee also get_preface.\n\n\n\n\n\n","category":"function"},{"location":"API/System/#ModelingToolkit.get_preface","page":"The System type","title":"ModelingToolkit.get_preface","text":"get_preface(sys::ModelingToolkit.AbstractSystem) -> Any\n\n\nGet the internal field preface of a system sys. It only includes preface local to sys; not those of its subsystems, like unknowns(sys), parameters(sys) and equations(sys) does.\n\nSee also has_preface.\n\n\n\n\n\n","category":"function"},{"location":"API/System/#ModelingToolkit.preface","page":"The System type","title":"ModelingToolkit.preface","text":"preface(sys::ModelingToolkit.AbstractSystem) -> Any\n\n\nObtain the preface associated with sys and all of its subsystems, appropriately namespaced.\n\n\n\n\n\n","category":"function"},{"location":"API/System/#ModelingToolkit.has_parent","page":"The System type","title":"ModelingToolkit.has_parent","text":"has_parent(sys::ModelingToolkit.AbstractSystem) -> Bool\n\n\nReturns whether the system sys has the internal field parent.\n\nSee also get_parent.\n\n\n\n\n\n","category":"function"},{"location":"API/System/#ModelingToolkit.get_parent","page":"The System type","title":"ModelingToolkit.get_parent","text":"get_parent(sys::ModelingToolkit.AbstractSystem) -> Any\n\n\nGet the internal field parent of a system sys. It only includes parent local to sys; not those of its subsystems, like unknowns(sys), parameters(sys) and equations(sys) does.\n\nSee also has_parent.\n\n\n\n\n\n","category":"function"},{"location":"API/System/#ModelingToolkit.has_initializesystem","page":"The System type","title":"ModelingToolkit.has_initializesystem","text":"has_initializesystem(\n    sys::ModelingToolkit.AbstractSystem\n) -> Bool\n\n\nReturns whether the system sys has the internal field initializesystem.\n\nSee also get_initializesystem.\n\n\n\n\n\n","category":"function"},{"location":"API/System/#ModelingToolkit.get_initializesystem","page":"The System type","title":"ModelingToolkit.get_initializesystem","text":"get_initializesystem(\n    sys::ModelingToolkit.AbstractSystem\n) -> Any\n\n\nGet the internal field initializesystem of a system sys. It only includes initializesystem local to sys; not those of its subsystems, like unknowns(sys), parameters(sys) and equations(sys) does.\n\nSee also has_initializesystem.\n\n\n\n\n\n","category":"function"},{"location":"API/System/#ModelingToolkit.is_initializesystem","page":"The System type","title":"ModelingToolkit.is_initializesystem","text":"is_initializesystem(\n    sys::ModelingToolkit.AbstractSystem\n) -> Any\n\n\nCheck if the given system is an initialization system.\n\n\n\n\n\n","category":"function"},{"location":"API/System/#getproperty-syntax","page":"The System type","title":"getproperty syntax","text":"","category":"section"},{"location":"API/System/","page":"The System type","title":"The System type","text":"ModelingToolkit allows obtaining in a system using getproperty. For a system sys with a subcomponent inner containing variable var, sys.inner.var will obtain the appropriately namespaced version of var. Note that this can also be used to access subsystems (sys.inner) or analysis points.","category":"page"},{"location":"API/System/","page":"The System type","title":"The System type","text":"note: Note\nBy default, top-level systems not marked as complete will apply their namespace. Systems marked as complete will not do this namespacing. This namespacing behavior can be toggled independently of whether the system is completed using toggle_namespacing and the current namespacing behavior can be queried via ModelingToolkit.does_namespacing.","category":"page"},{"location":"API/System/#Base.getproperty-Tuple{ModelingToolkit.AbstractSystem, Symbol}","page":"The System type","title":"Base.getproperty","text":"Base.getproperty(sys::AbstractSystem, name::Symbol)\n\nAccess the subsystem, variable or analysis point of sys named name. To check if sys will namespace the returned value, use ModelingToolkit.does_namespacing(sys).\n\nSee also: ModelingToolkit.does_namespacing.\n\n\n\n\n\n","category":"method"},{"location":"API/System/#Functions-for-querying-system-equations","page":"The System type","title":"Functions for querying system equations","text":"","category":"section"},{"location":"API/System/#ModelingToolkit.has_diff_eqs","page":"The System type","title":"ModelingToolkit.has_diff_eqs","text":"has_diff_eqs(sys::AbstractSystem)\n\nReturn true if a system contains at least one differential equation (i.e. an equation with a differential term). Note that this does not consider subsystems, and only takes into account equations in the top-level system.\n\nExample:\n\nusing ModelingToolkit\nusing ModelingToolkit: t_nounits as t, D_nounits as D\n@parameters p d\n@variables X(t)\neq1 = D(X) ~ p - d*X\neq2 = 0 ~ p - d*X\n@named osys1 = tem([eq1], t)\n@named osys2 = tem([eq2], t)\nosys12 = compose(osys1, [osys2])\nosys21 = compose(osys2, [osys1])\n\nhas_diff_eqs(osys12) # returns `true`.\nhas_diff_eqs(osys21) # returns `false`.\n\n\n\n\n\n","category":"function"},{"location":"API/System/#ModelingToolkit.has_alg_eqs","page":"The System type","title":"ModelingToolkit.has_alg_eqs","text":"has_alg_eqs(sys::AbstractSystem)\n\nFor a system, returns true if it contain at least one algebraic equation (i.e. that does not contain any differentials) in its top-level system.\n\nExample:\n\nusing ModelingToolkit\nusing ModelingToolkit: t_nounits as t, D_nounits as D\n@parameters p d\n@variables X(t)\neq1 = D(X) ~ p - d*X\neq2 = 0 ~ p - d*X\n@named osys1 = System([eq1], t)\n@named osys2 = System([eq2], t)\nosys12 = compose(osys1, [osys2])\nosys21 = compose(osys2, [osys1])\n\nhas_alg_eqs(osys12) # returns `false`.\nhas_alg_eqs(osys21) # returns `true`.\n\n\n\n\n\n","category":"function"},{"location":"API/System/#ModelingToolkit.get_diff_eqs","page":"The System type","title":"ModelingToolkit.get_diff_eqs","text":"get_diff_eqs(sys::AbstractSystem)\n\nFor a system, returns a vector of all differential equations (i.e. that does contain a differential) in its top-level system.\n\nExample:\n\nusing ModelingToolkit\nusing ModelingToolkit: t_nounits as t, D_nounits as D\n@parameters p d\n@variables X(t)\neq1 = D(X) ~ p - d*X\neq2 = 0 ~ p - d*X\n@named osys1 = tem([eq1], t)\n@named osys2 = tem([eq2], t)\nosys12 = compose(osys1, [osys2])\nosys21 = compose(osys2, [osys1])\n\nget_diff_eqs(osys12) # returns `[Differential(t)(X(t)) ~ p - d*X(t)]`.\nget_diff_eqs(osys21) # returns `Equation[]``.\n\n\n\n\n\n","category":"function"},{"location":"API/System/#ModelingToolkit.get_alg_eqs","page":"The System type","title":"ModelingToolkit.get_alg_eqs","text":"get_alg_eqs(sys::AbstractSystem)\n\nFor a system, returns a vector of all algebraic equations (i.e. that does not contain any differentials) in its top-level system.\n\nExample:\n\nusing ModelingToolkit\nusing ModelingToolkit: t_nounits as t, D_nounits as D\n@parameters p d\n@variables X(t)\neq1 = D(X) ~ p - d*X\neq2 = 0 ~ p - d*X\n@named osys1 = ([eq1], t)\n@named osys2 = ([eq2], t)\nosys12 = compose(sys1, [osys2])\nosys21 = compose(osys2, [osys1])\n\nget_alg_eqs(osys12) # returns `Equation[]`.\nget_alg_eqs(osys21) # returns `[0 ~ p - d*X(t)]`.\n\n\n\n\n\n","category":"function"},{"location":"API/System/#ModelingToolkit.has_diff_equations","page":"The System type","title":"ModelingToolkit.has_diff_equations","text":"has_diff_equations(sys::AbstractSystem)\n\nFor a system, returns true if it contain at least one differential equation (i.e. that contain a differential).\n\nExample:\n\nusing ModelingToolkit\nusing ModelingToolkit: t_nounits as t, D_nounits as D\n@parameters p d\n@variables X(t)\neq1 = D(X) ~ p - d*X\neq2 = 0 ~ p - d*X\n@named osys1 = System([eq1], t)\n@named osys2 = System([eq2], t)\n\nhas_diff_equations(osys1) # returns `true`.\nhas_diff_equations(osys2) # returns `false`.\n\n\n\n\n\n","category":"function"},{"location":"API/System/#ModelingToolkit.has_alg_equations","page":"The System type","title":"ModelingToolkit.has_alg_equations","text":"has_alg_equations(sys::AbstractSystem)\n\nFor a system, returns true if it contain at least one algebraic equation (i.e. that does not contain any differentials).\n\nExample:\n\nusing ModelingToolkit\nusing ModelingToolkit: t_nounits as t, D_nounits as D\n@parameters p d\n@variables X(t)\neq1 = D(X) ~ p - d*X\neq2 = 0 ~ p - d*X\n@named osys1 = System([eq1], t)\n@named osys2 = System([eq2], t)\n\nhas_alg_equations(osys1) # returns `false`.\nhas_alg_equations(osys2) # returns `true`.\n\n\n\n\n\n","category":"function"},{"location":"API/System/#ModelingToolkit.diff_equations","page":"The System type","title":"ModelingToolkit.diff_equations","text":"diff_equations(sys::AbstractSystem)\n\nFor a system, returns a vector of all its differential equations (i.e. that does contain a differential).\n\nExample: ```julia using ModelingToolkit using ModelingToolkit: tnounits as t, Dnounits as D @parameters p d @variables X(t) eq1 = D(X) ~ p - dX eq2 = 0 ~ p - dX @named osys = System([eq1, eq2], t)\n\ndiff_equations(osys) # returns [Differential(t)(X(t)) ~ p - d*X(t)].\n\n\n\n\n\n","category":"function"},{"location":"API/System/#ModelingToolkit.alg_equations","page":"The System type","title":"ModelingToolkit.alg_equations","text":"alg_equations(sys::AbstractSystem)\n\nFor a system, returns a vector of all its algebraic equations (i.e. that does not contain any differentials).\n\nExample: ```julia using ModelingToolkit using ModelingToolkit: tnounits as t, Dnounits as D @parameters p d @variables X(t) eq1 = D(X) ~ p - dX eq2 = 0 ~ p - dX @named osys = System([eq1, eq2], t)\n\nalg_equations(osys) # returns [0 ~ p - d*X(t)].\n\n\n\n\n\n","category":"function"},{"location":"API/System/#ModelingToolkit.is_alg_equation","page":"The System type","title":"ModelingToolkit.is_alg_equation","text":"is_alg_equation(eq)\n\nReturn true if the input is an algebraic equation, i.e. an equation that does not contain any differentials.\n\nExample:\n\nusing ModelingToolkit\nusing ModelingToolkit: t_nounits as t, D_nounits as D\n@parameters p d\n@variables X(t)\neq1 = D(X) ~ p - d*X\neq2 = 0 ~ p - d*X\n\nis_alg_equation(eq1) # false\nis_alg_equation(eq2) # true\n\n\n\n\n\n","category":"function"},{"location":"API/System/#ModelingToolkit.is_diff_equation","page":"The System type","title":"ModelingToolkit.is_diff_equation","text":"is_diff_equation(eq)\n\nReturn true if the input is a differential equation, i.e. an equation that contains a differential term.\n\nExample:\n\nusing ModelingToolkit\nusing ModelingToolkit: t_nounits as t, D_nounits as D\n@parameters p d\n@variables X(t)\neq1 = D(X) ~ p - d*X\neq2 = 0 ~ p - d*X\n\nis_diff_equation(eq1) # true\nis_diff_equation(eq2) # false\n\n\n\n\n\n","category":"function"},{"location":"API/System/#String-parsing","page":"The System type","title":"String parsing","text":"","category":"section"},{"location":"API/System/","page":"The System type","title":"The System type","text":"ModelingToolkit can parse system variables from strings.","category":"page"},{"location":"API/System/#ModelingToolkit.parse_variable","page":"The System type","title":"ModelingToolkit.parse_variable","text":"parse_variable(\n    sys::ModelingToolkit.AbstractSystem,\n    str::AbstractString\n) -> Any\n\n\nReturn the variable in sys referred to by its string representation str. Roughly supports the following CFG:\n\nvarname                  = \"D(\" varname \")\" | \"Differential(\" iv \")(\" varname \")\" | arrvar | maybe_dummy_var\narrvar                   = maybe_dummy_var \"[idxs...]\"\nidxs                     = int | int \",\" idxs\nmaybe_dummy_var          = namespacedvar | namespacedvar \"(\" iv \")\" |\n                           namespacedvar \"(\" iv \")\" \"ˍ\" ts | namespacedvar \"ˍ\" ts |\n                           namespacedvar \"ˍ\" ts \"(\" iv \")\"\nts                       = iv | iv ts\nnamespacedvar            = ident \"₊\" namespacedvar | ident \".\" namespacedvar | ident\n\nWhere iv is the independent variable, int is an integer and ident is an identifier.\n\n\n\n\n\n","category":"function"},{"location":"API/System/#Dumping-system-data","page":"The System type","title":"Dumping system data","text":"","category":"section"},{"location":"API/System/#ModelingToolkit.dump_unknowns","page":"The System type","title":"ModelingToolkit.dump_unknowns","text":"dump_unknowns(sys::AbstractSystem)\n\nReturn an array of NamedTuples containing the metadata associated with each unknown in sys. Also includes the default value of the unknown, if provided.\n\nusing ModelingToolkit\nusing DynamicQuantities\nusing ModelingToolkit: t, D\n\n@parameters p = 1.0, [description = \"My parameter\", tunable = false] q = 2.0, [description = \"Other parameter\"]\n@variables x(t) = 3.0 [unit = u\"m\"]\n@named sys = System(Equation[], t, [x], [p, q])\nModelingToolkit.dump_unknowns(sys)\n\nSee also: ModelingToolkit.dump_variable_metadata, ModelingToolkit.dump_parameters\n\n\n\n\n\n","category":"function"},{"location":"API/System/#ModelingToolkit.dump_parameters","page":"The System type","title":"ModelingToolkit.dump_parameters","text":"dump_parameters(sys::AbstractSystem)\n\nReturn an array of NamedTuples containing the metadata associated with each parameter in sys. Also includes the default value of the parameter, if provided.\n\nusing ModelingToolkit\nusing DynamicQuantities\nusing ModelingToolkit: t, D\n\n@parameters p = 1.0, [description = \"My parameter\", tunable = false] q = 2.0, [description = \"Other parameter\"]\n@variables x(t) = 3.0 [unit = u\"m\"]\n@named sys = System(Equation[], t, [x], [p, q])\nModelingToolkit.dump_parameters(sys)\n\nSee also: ModelingToolkit.dump_variable_metadata, ModelingToolkit.dump_unknowns\n\n\n\n\n\n","category":"function"},{"location":"API/System/#ModelingToolkit.dump_variable_metadata-API-System","page":"The System type","title":"ModelingToolkit.dump_variable_metadata","text":"dump_variable_metadata(var)\n\nReturn all the metadata associated with symbolic variable var as a NamedTuple.\n\nusing ModelingToolkit\n\n@parameters p::Int [description = \"My description\", bounds = (0.5, 1.5)]\nModelingToolkit.dump_variable_metadata(p)\n\n\n\n\n\n","category":"function"},{"location":"API/System/#Inputs-and-outputs","page":"The System type","title":"Inputs and outputs","text":"","category":"section"},{"location":"API/System/#ModelingToolkit.inputs","page":"The System type","title":"ModelingToolkit.inputs","text":"inputs(sys)\n\nReturn all variables that mare marked as inputs. See also unbound_inputs See also bound_inputs, unbound_inputs\n\n\n\n\n\n","category":"function"},{"location":"API/System/#ModelingToolkit.outputs","page":"The System type","title":"ModelingToolkit.outputs","text":"outputs(sys)\n\nReturn all variables that mare marked as outputs. See also unbound_outputs See also bound_outputs, unbound_outputs\n\n\n\n\n\n","category":"function"},{"location":"API/System/#ModelingToolkit.bound_inputs","page":"The System type","title":"ModelingToolkit.bound_inputs","text":"bound_inputs(sys)\n\nReturn inputs that are bound within the system, i.e., internal inputs See also bound_inputs, unbound_inputs, bound_outputs, unbound_outputs\n\n\n\n\n\n","category":"function"},{"location":"API/System/#ModelingToolkit.unbound_inputs","page":"The System type","title":"ModelingToolkit.unbound_inputs","text":"unbound_inputs(sys)\n\nReturn inputs that are not bound within the system, i.e., external inputs See also bound_inputs, unbound_inputs, bound_outputs, unbound_outputs\n\n\n\n\n\n","category":"function"},{"location":"API/System/#ModelingToolkit.bound_outputs","page":"The System type","title":"ModelingToolkit.bound_outputs","text":"bound_outputs(sys)\n\nReturn outputs that are bound within the system, i.e., internal outputs See also bound_inputs, unbound_inputs, bound_outputs, unbound_outputs\n\n\n\n\n\n","category":"function"},{"location":"API/System/#ModelingToolkit.unbound_outputs","page":"The System type","title":"ModelingToolkit.unbound_outputs","text":"unbound_outputs(sys)\n\nReturn outputs that are not bound within the system, i.e., external outputs See also bound_inputs, unbound_inputs, bound_outputs, unbound_outputs\n\n\n\n\n\n","category":"function"},{"location":"API/System/#ModelingToolkit.is_bound","page":"The System type","title":"ModelingToolkit.is_bound","text":"is_bound(sys, u)\n\nDetermine whether input/output variable u is \"bound\" within the system, i.e., if it's to be considered internal to sys. A variable/signal is considered bound if it appears in an equation together with variables from other subsystems. The typical usecase for this function is to determine whether the input to an IO component is connected to another component, or if it remains an external input that the user has to supply before simulating the system.\n\nSee also bound_inputs, unbound_inputs, bound_outputs, unbound_outputs\n\n\n\n\n\n","category":"function"},{"location":"API/System/#Debugging-utilities","page":"The System type","title":"Debugging utilities","text":"","category":"section"},{"location":"API/System/#ModelingToolkit.debug_system","page":"The System type","title":"ModelingToolkit.debug_system","text":"debug_system(sys::AbstractSystem; functions = [log, sqrt, (^), /, inv, asin, acos], error_nonfinite = true)\n\nWrap functions in sys so any error thrown in them shows helpful symbolic-numeric information about its input. If error_nonfinite, functions that output nonfinite values (like Inf or NaN) also display errors, even though the raw function itself does not throw an exception (like 1/0). For example:\n\njulia> sys = debug_system(complete(sys))\n\njulia> prob = ODEProblem(sys, [0.0, 2.0], (0.0, 1.0))\n\njulia> prob.f(prob.u0, prob.p, 0.0)\nERROR: Function /(1, sin(P(t))) output non-finite value Inf with input\n  1 => 1\n  sin(P(t)) => 0.0\n\nAdditionally, all assertions in the system are optionally logged when they fail. A new parameter is also added to the system which controls whether the message associated with each assertion will be logged when the assertion fails. This parameter defaults to true and can be toggled by symbolic indexing with ModelingToolkit.ASSERTION_LOG_VARIABLE. For example, prob.ps[ModelingToolkit.ASSERTION_LOG_VARIABLE] = false will disable logging.\n\n\n\n\n\n","category":"function"},{"location":"tutorials/programmatically_generating/#programmatically","page":"Programmatically Generating and Scripting Systems","title":"Programmatically Generating and Scripting Systems","text":"","category":"section"},{"location":"tutorials/programmatically_generating/","page":"Programmatically Generating and Scripting Systems","title":"Programmatically Generating and Scripting Systems","text":"In the following tutorial, we will discuss how to programmatically generate Systems. This is useful for functions that generate Systems, for example when you implement a reader that parses some file format, such as SBML, to generate an System. It is also useful for functions that transform an System, for example when you write a function that log-transforms a variable in an System.","category":"page"},{"location":"tutorials/programmatically_generating/#The-Representation-of-a-ModelingToolkit-System","page":"Programmatically Generating and Scripting Systems","title":"The Representation of a ModelingToolkit System","text":"","category":"section"},{"location":"tutorials/programmatically_generating/","page":"Programmatically Generating and Scripting Systems","title":"Programmatically Generating and Scripting Systems","text":"ModelingToolkit is built on Symbolics.jl, a symbolic Computer Algebra System (CAS) developed in Julia. As such, all CAS functionality is also available to be used on ModelingToolkit systems, such as symbolic differentiation, Groebner basis calculations, and whatever else you can think of. Under the hood, all ModelingToolkit variables and expressions are Symbolics.jl variables and expressions. Thus when scripting a ModelingToolkit system, one simply needs to generate Symbolics.jl variables and equations as demonstrated in the Symbolics.jl documentation. This looks like:","category":"page"},{"location":"tutorials/programmatically_generating/","page":"Programmatically Generating and Scripting Systems","title":"Programmatically Generating and Scripting Systems","text":"using ModelingToolkit # reexports Symbolics\n@independent_variables t\n@variables x(t) y(t) # Define variables\nD = Differential(t)\neqs = [D(x) ~ y\n       D(y) ~ x] # Define an array of equations","category":"page"},{"location":"tutorials/programmatically_generating/","page":"Programmatically Generating and Scripting Systems","title":"Programmatically Generating and Scripting Systems","text":"However, ModelingToolkit has many higher-level features which will make scripting ModelingToolkit systems more convenient. For example, as shown in the next section, defining your own independent variables and differentials is rarely needed.","category":"page"},{"location":"tutorials/programmatically_generating/#The-Non-DSL-(non-@mtkmodel)-Way-of-Defining-an-System","page":"Programmatically Generating and Scripting Systems","title":"The Non-DSL (non-@mtkmodel) Way of Defining an System","text":"","category":"section"},{"location":"tutorials/programmatically_generating/","page":"Programmatically Generating and Scripting Systems","title":"Programmatically Generating and Scripting Systems","text":"Using @mtkmodel, like in the getting started tutorial, is the preferred way of defining ODEs with MTK. However generating the contents of a @mtkmodel programmatically can be tedious. Let us look at how we can define the same system without @mtkmodel.","category":"page"},{"location":"tutorials/programmatically_generating/","page":"Programmatically Generating and Scripting Systems","title":"Programmatically Generating and Scripting Systems","text":"using ModelingToolkit\nusing ModelingToolkit: t_nounits as t, D_nounits as D\n@variables x(t) = 0.0  # independent and dependent variables\n@parameters τ = 3.0       # parameters\n@constants h = 1    # constants\neqs = [D(x) ~ (h - x) / τ] # create an array of equations\n\n# your first ODE, consisting of a single equation, indicated by ~\n@named model = System(eqs, t)\n\n# Perform the standard transformations and mark the model complete\n# Note: Complete models cannot be subsystems of other models!\nfol = mtkcompile(model)\nprob = ODEProblem(fol, [], (0.0, 10.0), [])\nusing OrdinaryDiffEq\nsol = solve(prob)\n\nusing Plots\nplot(sol)","category":"page"},{"location":"tutorials/programmatically_generating/","page":"Programmatically Generating and Scripting Systems","title":"Programmatically Generating and Scripting Systems","text":"As you can see, generating an System is as simple as creating an array of equations and passing it to the System constructor.","category":"page"},{"location":"tutorials/programmatically_generating/","page":"Programmatically Generating and Scripting Systems","title":"Programmatically Generating and Scripting Systems","text":"@named automatically gives a name to the System, and is shorthand for","category":"page"},{"location":"tutorials/programmatically_generating/","page":"Programmatically Generating and Scripting Systems","title":"Programmatically Generating and Scripting Systems","text":"fol_model = System(eqs, t; name = :fol_model) # @named fol_model = System(eqs, t)","category":"page"},{"location":"tutorials/programmatically_generating/","page":"Programmatically Generating and Scripting Systems","title":"Programmatically Generating and Scripting Systems","text":"Thus, if we had read a name from a file and wish to populate an System with said name, we could do:","category":"page"},{"location":"tutorials/programmatically_generating/","page":"Programmatically Generating and Scripting Systems","title":"Programmatically Generating and Scripting Systems","text":"namesym = :name_from_file\nfol_model = System(eqs, t; name = namesym)","category":"page"},{"location":"tutorials/programmatically_generating/#Warning-About-Mutation","page":"Programmatically Generating and Scripting Systems","title":"Warning About Mutation","text":"","category":"section"},{"location":"tutorials/programmatically_generating/","page":"Programmatically Generating and Scripting Systems","title":"Programmatically Generating and Scripting Systems","text":"Be advsied that it's never a good idea to mutate an System, or any AbstractSystem.","category":"page"},{"location":"API/codegen/#Code-generation-utilities","page":"Code generation utilities","title":"Code generation utilities","text":"","category":"section"},{"location":"API/codegen/","page":"Code generation utilities","title":"Code generation utilities","text":"These are lower-level functions that ModelingToolkit leverages to generate code for building numerical problems.","category":"page"},{"location":"API/codegen/#ModelingToolkit.generate_rhs","page":"Code generation utilities","title":"ModelingToolkit.generate_rhs","text":"generate_rhs(\n    sys::System;\n    implicit_dae,\n    scalar,\n    expression,\n    wrap_gfw,\n    eval_expression,\n    eval_module,\n    override_discrete,\n    kwargs...\n) -> Union{Expr, Tuple{Expr, Expr}}\n\n\nGenerate the RHS function for the equations of a System.\n\nKeyword Arguments\n\nexpression: Val{true} if this should return an Expr (or tuple of Exprs) of the generated code. Val{false} otherwise.\nwrap_gfw: Val{true} if the returned functions should be wrapped in a callable struct to make them callable using the expected syntax. The callable struct itself is internal API. If expression == Val{true}, the returned expression will construct the callable struct. If this function returns a tuple of functions/expressions, both will be identical if wrap_gfw == Val{true}.\neval_expression: Whether to compile any functions via eval or RuntimeGeneratedFunctions.\neval_module: If eval_expression == true, the module to eval into. Otherwise, the module in which to generate the RuntimeGeneratedFunction.\n\nimplicit_dae: Whether the generated function should be in the implicit form. Applicable only for ODEs/DAEs or discrete systems. Instead of f(u, p, t) (f(du, u, p, t) for the in-place form) the function is f(du, u, p, t) (respectively f(resid, du, u, p, t)).\noverride_discrete: Whether to assume the system is discrete regardless of is_discrete_system(sys).\nscalar: Whether to generate a single-out-of-place function that returns a scalar for the only equation in the system.\n\nAll other keyword arguments are forwarded to build_function_wrapper.\n\n\n\n\n\n","category":"function"},{"location":"API/codegen/#ModelingToolkit.generate_diffusion_function","page":"Code generation utilities","title":"ModelingToolkit.generate_diffusion_function","text":"generate_diffusion_function(\n    sys::System;\n    expression,\n    wrap_gfw,\n    eval_expression,\n    eval_module,\n    kwargs...\n) -> Any\n\n\nGenerate the diffusion function for the noise equations of a System.\n\nKeyword Arguments\n\nexpression: Val{true} if this should return an Expr (or tuple of Exprs) of the generated code. Val{false} otherwise.\nwrap_gfw: Val{true} if the returned functions should be wrapped in a callable struct to make them callable using the expected syntax. The callable struct itself is internal API. If expression == Val{true}, the returned expression will construct the callable struct. If this function returns a tuple of functions/expressions, both will be identical if wrap_gfw == Val{true}.\neval_expression: Whether to compile any functions via eval or RuntimeGeneratedFunctions.\neval_module: If eval_expression == true, the module to eval into. Otherwise, the module in which to generate the RuntimeGeneratedFunction.\n\nAll other keyword arguments are forwarded to build_function_wrapper.\n\n\n\n\n\n","category":"function"},{"location":"API/codegen/#ModelingToolkit.generate_jacobian","page":"Code generation utilities","title":"ModelingToolkit.generate_jacobian","text":"generate_jacobian(\n    sys::System;\n    simplify,\n    sparse,\n    eval_expression,\n    eval_module,\n    expression,\n    wrap_gfw,\n    kwargs...\n) -> Union{Expr, Tuple{Expr, Expr}}\n\n\nGenerate the jacobian function for the equations of a System.\n\nKeyword Arguments\n\nexpression: Val{true} if this should return an Expr (or tuple of Exprs) of the generated code. Val{false} otherwise.\nwrap_gfw: Val{true} if the returned functions should be wrapped in a callable struct to make them callable using the expected syntax. The callable struct itself is internal API. If expression == Val{true}, the returned expression will construct the callable struct. If this function returns a tuple of functions/expressions, both will be identical if wrap_gfw == Val{true}.\neval_expression: Whether to compile any functions via eval or RuntimeGeneratedFunctions.\neval_module: If eval_expression == true, the module to eval into. Otherwise, the module in which to generate the RuntimeGeneratedFunction.\n\nsimplify, sparse: Forwarded to calculate_jacobian.\n\nAll other keyword arguments are forwarded to build_function_wrapper.\n\n\n\n\n\n","category":"function"},{"location":"API/codegen/#ModelingToolkit.generate_tgrad","page":"Code generation utilities","title":"ModelingToolkit.generate_tgrad","text":"generate_tgrad(\n    sys::System;\n    simplify,\n    eval_expression,\n    eval_module,\n    expression,\n    wrap_gfw,\n    kwargs...\n) -> Union{Expr, Tuple{Expr, Expr}}\n\n\nGenerate the tgrad function for the equations of a System.\n\nKeyword Arguments\n\nexpression: Val{true} if this should return an Expr (or tuple of Exprs) of the generated code. Val{false} otherwise.\nwrap_gfw: Val{true} if the returned functions should be wrapped in a callable struct to make them callable using the expected syntax. The callable struct itself is internal API. If expression == Val{true}, the returned expression will construct the callable struct. If this function returns a tuple of functions/expressions, both will be identical if wrap_gfw == Val{true}.\neval_expression: Whether to compile any functions via eval or RuntimeGeneratedFunctions.\neval_module: If eval_expression == true, the module to eval into. Otherwise, the module in which to generate the RuntimeGeneratedFunction.\n\nsimplify: Forwarded to calculate_tgrad.\n\nAll other keyword arguments are forwarded to build_function_wrapper.\n\n\n\n\n\n","category":"function"},{"location":"API/codegen/#ModelingToolkit.generate_W","page":"Code generation utilities","title":"ModelingToolkit.generate_W","text":"generate_W(\n    sys::System;\n    simplify,\n    sparse,\n    expression,\n    wrap_gfw,\n    eval_expression,\n    eval_module,\n    kwargs...\n) -> Union{Expr, Tuple{Expr, Expr}}\n\n\nGenerate the W = γ * M + J function for the equations of a System.\n\nKeyword Arguments\n\nexpression: Val{true} if this should return an Expr (or tuple of Exprs) of the generated code. Val{false} otherwise.\nwrap_gfw: Val{true} if the returned functions should be wrapped in a callable struct to make them callable using the expected syntax. The callable struct itself is internal API. If expression == Val{true}, the returned expression will construct the callable struct. If this function returns a tuple of functions/expressions, both will be identical if wrap_gfw == Val{true}.\neval_expression: Whether to compile any functions via eval or RuntimeGeneratedFunctions.\neval_module: If eval_expression == true, the module to eval into. Otherwise, the module in which to generate the RuntimeGeneratedFunction.\n\nsimplify, sparse: Forwarded to calculate_jacobian.\n\nAll other keyword arguments are forwarded to build_function_wrapper.\n\n\n\n\n\n","category":"function"},{"location":"API/codegen/#ModelingToolkit.generate_dae_jacobian","page":"Code generation utilities","title":"ModelingToolkit.generate_dae_jacobian","text":"generate_dae_jacobian(\n    sys::System;\n    simplify,\n    sparse,\n    expression,\n    wrap_gfw,\n    eval_expression,\n    eval_module,\n    kwargs...\n) -> Union{Expr, Tuple{Expr, Expr}}\n\n\nGenerate the DAE jacobian γ * J′ + J function for the equations of a System. J′ is the jacobian of the equations with respect to the du vector, and J is the standard jacobian.\n\nKeyword Arguments\n\nexpression: Val{true} if this should return an Expr (or tuple of Exprs) of the generated code. Val{false} otherwise.\nwrap_gfw: Val{true} if the returned functions should be wrapped in a callable struct to make them callable using the expected syntax. The callable struct itself is internal API. If expression == Val{true}, the returned expression will construct the callable struct. If this function returns a tuple of functions/expressions, both will be identical if wrap_gfw == Val{true}.\neval_expression: Whether to compile any functions via eval or RuntimeGeneratedFunctions.\neval_module: If eval_expression == true, the module to eval into. Otherwise, the module in which to generate the RuntimeGeneratedFunction.\n\nsimplify, sparse: Forwarded to calculate_jacobian.\n\nAll other keyword arguments are forwarded to build_function_wrapper.\n\n\n\n\n\n","category":"function"},{"location":"API/codegen/#ModelingToolkit.generate_history","page":"Code generation utilities","title":"ModelingToolkit.generate_history","text":"generate_history(\n    sys::System,\n    u0;\n    expression,\n    wrap_gfw,\n    eval_expression,\n    eval_module,\n    kwargs...\n) -> Union{Expr, Tuple{Expr, Expr}}\n\n\nGenerate the history function for a System, given a symbolic representation of the u0 vector prior to the initial time.\n\nKeyword Arguments\n\nexpression: Val{true} if this should return an Expr (or tuple of Exprs) of the generated code. Val{false} otherwise.\nwrap_gfw: Val{true} if the returned functions should be wrapped in a callable struct to make them callable using the expected syntax. The callable struct itself is internal API. If expression == Val{true}, the returned expression will construct the callable struct. If this function returns a tuple of functions/expressions, both will be identical if wrap_gfw == Val{true}.\neval_expression: Whether to compile any functions via eval or RuntimeGeneratedFunctions.\neval_module: If eval_expression == true, the module to eval into. Otherwise, the module in which to generate the RuntimeGeneratedFunction.\n\nAll other keyword arguments are forwarded to build_function_wrapper.\n\n\n\n\n\n","category":"function"},{"location":"API/codegen/#ModelingToolkit.generate_boundary_conditions","page":"Code generation utilities","title":"ModelingToolkit.generate_boundary_conditions","text":"generate_boundary_conditions(\n    sys::System,\n    u0,\n    u0_idxs,\n    t0;\n    expression,\n    wrap_gfw,\n    eval_expression,\n    eval_module,\n    kwargs...\n) -> Union{Expr, Tuple{Expr, Expr}}\n\n\nGenerate the boundary condition function for a System given the state vector u0, the indexes of u0 to consider as hard constraints u0_idxs and the initial time t0.\n\nKeyword Arguments\n\nexpression: Val{true} if this should return an Expr (or tuple of Exprs) of the generated code. Val{false} otherwise.\nwrap_gfw: Val{true} if the returned functions should be wrapped in a callable struct to make them callable using the expected syntax. The callable struct itself is internal API. If expression == Val{true}, the returned expression will construct the callable struct. If this function returns a tuple of functions/expressions, both will be identical if wrap_gfw == Val{true}.\neval_expression: Whether to compile any functions via eval or RuntimeGeneratedFunctions.\neval_module: If eval_expression == true, the module to eval into. Otherwise, the module in which to generate the RuntimeGeneratedFunction.\n\nAll other keyword arguments are forwarded to build_function_wrapper.\n\n\n\n\n\n","category":"function"},{"location":"API/codegen/#ModelingToolkit.generate_cost","page":"Code generation utilities","title":"ModelingToolkit.generate_cost","text":"generate_cost(\n    sys::System;\n    expression,\n    wrap_gfw,\n    eval_expression,\n    eval_module,\n    kwargs...\n) -> Any\n\n\nGenerate the cost function for a System.\n\nKeyword Arguments\n\nexpression: Val{true} if this should return an Expr (or tuple of Exprs) of the generated code. Val{false} otherwise.\nwrap_gfw: Val{true} if the returned functions should be wrapped in a callable struct to make them callable using the expected syntax. The callable struct itself is internal API. If expression == Val{true}, the returned expression will construct the callable struct. If this function returns a tuple of functions/expressions, both will be identical if wrap_gfw == Val{true}.\neval_expression: Whether to compile any functions via eval or RuntimeGeneratedFunctions.\neval_module: If eval_expression == true, the module to eval into. Otherwise, the module in which to generate the RuntimeGeneratedFunction.\n\nAll other keyword arguments are forwarded to build_function_wrapper.\n\n\n\n\n\n","category":"function"},{"location":"API/codegen/#ModelingToolkit.generate_cost_gradient","page":"Code generation utilities","title":"ModelingToolkit.generate_cost_gradient","text":"generate_cost_gradient(\n    sys::System;\n    expression,\n    wrap_gfw,\n    eval_expression,\n    eval_module,\n    simplify,\n    kwargs...\n) -> Union{Expr, Tuple{Expr, Expr}}\n\n\nGenerate the gradient of the cost function with respect to unknowns for a System.\n\nKeyword Arguments\n\nexpression: Val{true} if this should return an Expr (or tuple of Exprs) of the generated code. Val{false} otherwise.\nwrap_gfw: Val{true} if the returned functions should be wrapped in a callable struct to make them callable using the expected syntax. The callable struct itself is internal API. If expression == Val{true}, the returned expression will construct the callable struct. If this function returns a tuple of functions/expressions, both will be identical if wrap_gfw == Val{true}.\neval_expression: Whether to compile any functions via eval or RuntimeGeneratedFunctions.\neval_module: If eval_expression == true, the module to eval into. Otherwise, the module in which to generate the RuntimeGeneratedFunction.\n\nsimplify: Forwarded to calculate_cost_gradient.\n\nAll other keyword arguments are forwarded to build_function_wrapper.\n\n\n\n\n\n","category":"function"},{"location":"API/codegen/#ModelingToolkit.generate_cost_hessian","page":"Code generation utilities","title":"ModelingToolkit.generate_cost_hessian","text":"generate_cost_hessian(\n    sys::System;\n    expression,\n    wrap_gfw,\n    eval_expression,\n    eval_module,\n    simplify,\n    sparse,\n    return_sparsity,\n    kwargs...\n) -> Union{Tuple{Expr, Expr}, Tuple{Tuple{Expr, Expr}, Union{Nothing, SparseArrays.SparseMatrixCSC{Float64, Int64}, Matrix{Float64}}}}\n\n\nGenerate the hessian of the cost function for a System.\n\nKeyword Arguments\n\nexpression: Val{true} if this should return an Expr (or tuple of Exprs) of the generated code. Val{false} otherwise.\nwrap_gfw: Val{true} if the returned functions should be wrapped in a callable struct to make them callable using the expected syntax. The callable struct itself is internal API. If expression == Val{true}, the returned expression will construct the callable struct. If this function returns a tuple of functions/expressions, both will be identical if wrap_gfw == Val{true}.\neval_expression: Whether to compile any functions via eval or RuntimeGeneratedFunctions.\neval_module: If eval_expression == true, the module to eval into. Otherwise, the module in which to generate the RuntimeGeneratedFunction.\n\nsimplify, sparse: Forwarded to calculate_cost_hessian.\nreturn_sparsity: Whether to also return the sparsity pattern of the hessian as the second return value.\n\nAll other keyword arguments are forwarded to build_function_wrapper.\n\n\n\n\n\n","category":"function"},{"location":"API/codegen/#ModelingToolkit.generate_cons","page":"Code generation utilities","title":"ModelingToolkit.generate_cons","text":"generate_cons(\n    sys::System;\n    expression,\n    wrap_gfw,\n    eval_expression,\n    eval_module,\n    kwargs...\n) -> Union{Expr, Tuple{Expr, Expr}}\n\n\nGenerate the constraint function for a System.\n\nKeyword Arguments\n\nexpression: Val{true} if this should return an Expr (or tuple of Exprs) of the generated code. Val{false} otherwise.\nwrap_gfw: Val{true} if the returned functions should be wrapped in a callable struct to make them callable using the expected syntax. The callable struct itself is internal API. If expression == Val{true}, the returned expression will construct the callable struct. If this function returns a tuple of functions/expressions, both will be identical if wrap_gfw == Val{true}.\neval_expression: Whether to compile any functions via eval or RuntimeGeneratedFunctions.\neval_module: If eval_expression == true, the module to eval into. Otherwise, the module in which to generate the RuntimeGeneratedFunction.\n\nAll other keyword arguments are forwarded to build_function_wrapper.\n\n\n\n\n\n","category":"function"},{"location":"API/codegen/#ModelingToolkit.generate_constraint_jacobian","page":"Code generation utilities","title":"ModelingToolkit.generate_constraint_jacobian","text":"generate_constraint_jacobian(\n    sys::System;\n    expression,\n    wrap_gfw,\n    eval_expression,\n    eval_module,\n    return_sparsity,\n    simplify,\n    sparse,\n    kwargs...\n) -> Union{Expr, Tuple{Union{Expr, Tuple{Expr, Expr}}, Any}}\n\n\nGenerate the jacobian of the constraint function for a System.\n\nKeyword Arguments\n\nexpression: Val{true} if this should return an Expr (or tuple of Exprs) of the generated code. Val{false} otherwise.\nwrap_gfw: Val{true} if the returned functions should be wrapped in a callable struct to make them callable using the expected syntax. The callable struct itself is internal API. If expression == Val{true}, the returned expression will construct the callable struct. If this function returns a tuple of functions/expressions, both will be identical if wrap_gfw == Val{true}.\neval_expression: Whether to compile any functions via eval or RuntimeGeneratedFunctions.\neval_module: If eval_expression == true, the module to eval into. Otherwise, the module in which to generate the RuntimeGeneratedFunction.\n\nsimplify, sparse: Forwarded to calculate_constraint_jacobian.\nreturn_sparsity: Whether to also return the sparsity pattern of the jacobian as the second return value.\n\nAll other keyword arguments are forwarded to build_function_wrapper.\n\n\n\n\n\n","category":"function"},{"location":"API/codegen/#ModelingToolkit.generate_constraint_hessian","page":"Code generation utilities","title":"ModelingToolkit.generate_constraint_hessian","text":"generate_constraint_hessian(\n    sys::System;\n    expression,\n    wrap_gfw,\n    eval_expression,\n    eval_module,\n    return_sparsity,\n    simplify,\n    sparse,\n    kwargs...\n) -> Union{Expr, Tuple{Union{Expr, Tuple{Expr, Expr}}, Any}}\n\n\nGenerate the hessian of the constraint function for a System.\n\nKeyword Arguments\n\nexpression: Val{true} if this should return an Expr (or tuple of Exprs) of the generated code. Val{false} otherwise.\nwrap_gfw: Val{true} if the returned functions should be wrapped in a callable struct to make them callable using the expected syntax. The callable struct itself is internal API. If expression == Val{true}, the returned expression will construct the callable struct. If this function returns a tuple of functions/expressions, both will be identical if wrap_gfw == Val{true}.\neval_expression: Whether to compile any functions via eval or RuntimeGeneratedFunctions.\neval_module: If eval_expression == true, the module to eval into. Otherwise, the module in which to generate the RuntimeGeneratedFunction.\n\nsimplify, sparse: Forwarded to calculate_constraint_hessian.\nreturn_sparsity: Whether to also return the sparsity pattern of the hessian as the second return value.\n\nAll other keyword arguments are forwarded to build_function_wrapper.\n\n\n\n\n\n","category":"function"},{"location":"API/codegen/#ModelingToolkit.generate_control_jacobian","page":"Code generation utilities","title":"ModelingToolkit.generate_control_jacobian","text":"generate_control_jacobian(\n    sys::ModelingToolkit.AbstractSystem;\n    expression,\n    wrap_gfw,\n    eval_expression,\n    eval_module,\n    simplify,\n    sparse,\n    kwargs...\n) -> Union{Expr, Tuple{Expr, Expr}}\n\n\nGenerate the jacobian function of the equations of sys with respect to the inputs.\n\nKeyword arguments\n\nexpression: Val{true} if this should return an Expr (or tuple of Exprs) of the generated code. Val{false} otherwise.\nwrap_gfw: Val{true} if the returned functions should be wrapped in a callable struct to make them callable using the expected syntax. The callable struct itself is internal API. If expression == Val{true}, the returned expression will construct the callable struct. If this function returns a tuple of functions/expressions, both will be identical if wrap_gfw == Val{true}.\neval_expression: Whether to compile any functions via eval or RuntimeGeneratedFunctions.\neval_module: If eval_expression == true, the module to eval into. Otherwise, the module in which to generate the RuntimeGeneratedFunction.\n\nsimplify, sparse: Forwarded to calculate_constraint_hessian.\n\nAll other keyword arguments are forwarded to build_function_wrapper.\n\n\n\n\n\n","category":"function"},{"location":"API/codegen/#ModelingToolkit.build_explicit_observed_function","page":"Code generation utilities","title":"ModelingToolkit.build_explicit_observed_function","text":"build_explicit_observed_function(sys, ts; kwargs...) -> Function(s)\n\nGenerates a function that computes the observed value(s) ts in the system sys, while making the assumption that there are no cycles in the equations.\n\nArguments\n\nsys: The system for which to generate the function\nts: The symbolic observed values whose value should be computed\n\nKeywords\n\nreturn_inplace = false: If true and the observed value is a vector, then return both the in place and out of place methods.\nexpression = false: Generates a Julia Exprcomputing the observed value ifexpression` is true\neval_expression = false: If true and expression = false, evaluates the returned function in the module eval_module\noutput_type = Array the type of the array generated by a out-of-place vector-valued function\nparam_only = false if true, only allow the generated function to access system parameters\ninputs = nothing additinoal symbolic variables that should be provided to the generated function\ncheckbounds = true checks bounds if true when destructuring parameters\nop = Operator sets the recursion terminator for the walk done by vars to identify the variables that appear in ts. See the documentation for vars for more detail.\nthrow = true if true, throw an error when generating a function for ts that reference variables that do not exist.\nmkarray: only used if the output is an array (that is, !isscalar(ts)  and ts is not a tuple, in which case the result will always be a tuple). Called as mkarray(ts, output_type) where ts are the expressions to put in the array and output_type is the argument of the same name passed to buildexplicitobserved_function.\ncse = true: Whether to use Common Subexpression Elimination (CSE) to generate a more efficient function.\nwrap_delays = is_dde(sys): Whether to add an argument for the history function and use it to calculate all delayed variables.\n\nReturns\n\nThe return value will be either:\n\na single function f_oop if the input is a scalar or if the input is a Vector but return_inplace is false\nthe out of place and in-place functions (f_ip, f_oop) if return_inplace is true and the input is a Vector\n\nThe function(s) f_oop (and potentially f_ip) will be:\n\nRuntimeGeneratedFunctions by default,\nA Julia Expr if expression is true,\nA directly evaluated Julia function in the module eval_module if eval_expression is true and expression is false.\n\nThe signatures will be of the form g(...) with arguments:\n\noutput for in-place functions\nunknowns if param_only is false\ninputs if inputs is an array of symbolic inputs that should be available in ts \np... unconditionally; note that in the case of MTKParameters more than one parameters argument may be present, so it must be splatted\nt if the system is time-dependent; for example systems of nonlinear equations will not have t\n\nFor example, a function g(op, unknowns, p..., inputs, t) will be the in-place function generated if return_inplace is true, ts is a vector,  an array of inputs inputs is given, and param_only is false for a time-dependent system.\n\n\n\n\n\n","category":"function"},{"location":"API/codegen/#ModelingToolkit.generate_control_function","page":"Code generation utilities","title":"ModelingToolkit.generate_control_function","text":"generate_control_function(sys::ModelingToolkit.AbstractSystem, input_ap_name::Union{Symbol, Vector{Symbol}, AnalysisPoint, Vector{AnalysisPoint}}, dist_ap_name::Union{Symbol, Vector{Symbol}, AnalysisPoint, Vector{AnalysisPoint}}; system_modifier = identity, kwargs)\n\nWhen called with analysis points as input arguments, we assume that all analysis points corresponds to connections that should be opened (broken). The use case for this is to get rid of input signal blocks, such as Step or Sine, since these are useful for simulation but are not needed when using the plant model in a controller or state estimator.\n\n\n\n\n\n(f_oop, f_ip), x_sym, p_sym, io_sys = generate_control_function(\n        sys::System,\n        inputs             = unbound_inputs(sys),\n        disturbance_inputs = disturbances(sys);\n        implicit_dae       = false,\n        simplify           = false,\n    )\n\nFor a system sys with inputs (as determined by unbound_inputs or user specified), generate functions with additional input argument u\n\nThe returned functions are the out-of-place (f_oop) and in-place (f_ip) forms:\n\nf_oop : (x,u,p,t)      -> rhs\nf_ip  : (xout,x,u,p,t) -> nothing\n\nThe return values also include the chosen state-realization (the remaining unknowns) x_sym and parameters, in the order they appear as arguments to f.\n\nIf disturbance_inputs is an array of variables, the generated dynamics function will preserve any state and dynamics associated with disturbance inputs, but the disturbance inputs themselves will (by default) not be included as inputs to the generated function. The use case for this is to generate dynamics for state observers that estimate the influence of unmeasured disturbances, and thus require unknown variables for the disturbance model, but without disturbance inputs since the disturbances are not available for measurement. To add an input argument corresponding to the disturbance inputs, either include the disturbance inputs among the control inputs, or set disturbance_argument=true, in which case an additional input argument w is added to the generated function (x,u,p,t,w)->rhs.\n\nExample\n\nusing ModelingToolkit: generate_control_function, varmap_to_vars, defaults\nf, x_sym, ps = generate_control_function(sys, expression=Val{false}, simplify=false)\np = varmap_to_vars(defaults(sys), ps)\nx = varmap_to_vars(defaults(sys), x_sym)\nt = 0\nf[1](x, inputs, p, t)\n\n\n\n\n\n","category":"function"},{"location":"API/codegen/#ModelingToolkit.generate_update_A","page":"Code generation utilities","title":"ModelingToolkit.generate_update_A","text":"generate_update_A(\n    sys::System,\n    A::AbstractMatrix;\n    expression,\n    wrap_gfw,\n    eval_expression,\n    eval_module,\n    kwargs...\n) -> Union{Expr, Tuple{Expr, Expr}}\n\n\nGiven a system sys and the A from calculate_A_b generate the function that updates A given the parameter object.\n\nKeyword arguments\n\nexpression: Val{true} if this should return an Expr (or tuple of Exprs) of the generated code. Val{false} otherwise.\nwrap_gfw: Val{true} if the returned functions should be wrapped in a callable struct to make them callable using the expected syntax. The callable struct itself is internal API. If expression == Val{true}, the returned expression will construct the callable struct. If this function returns a tuple of functions/expressions, both will be identical if wrap_gfw == Val{true}.\neval_expression: Whether to compile any functions via eval or RuntimeGeneratedFunctions.\neval_module: If eval_expression == true, the module to eval into. Otherwise, the module in which to generate the RuntimeGeneratedFunction.\n\nAll other keyword arguments are forwarded to build_function_wrapper.\n\n\n\n\n\n","category":"function"},{"location":"API/codegen/#ModelingToolkit.generate_update_b","page":"Code generation utilities","title":"ModelingToolkit.generate_update_b","text":"generate_update_b(\n    sys::System,\n    b::AbstractVector;\n    expression,\n    wrap_gfw,\n    eval_expression,\n    eval_module,\n    kwargs...\n) -> Union{Expr, Tuple{Expr, Expr}}\n\n\nGiven a system sys and the b from calculate_A_b generate the function that updates b given the parameter object.\n\nKeyword arguments\n\nexpression: Val{true} if this should return an Expr (or tuple of Exprs) of the generated code. Val{false} otherwise.\nwrap_gfw: Val{true} if the returned functions should be wrapped in a callable struct to make them callable using the expected syntax. The callable struct itself is internal API. If expression == Val{true}, the returned expression will construct the callable struct. If this function returns a tuple of functions/expressions, both will be identical if wrap_gfw == Val{true}.\neval_expression: Whether to compile any functions via eval or RuntimeGeneratedFunctions.\neval_module: If eval_expression == true, the module to eval into. Otherwise, the module in which to generate the RuntimeGeneratedFunction.\n\nAll other keyword arguments are forwarded to build_function_wrapper.\n\n\n\n\n\n","category":"function"},{"location":"API/codegen/","page":"Code generation utilities","title":"Code generation utilities","text":"For functions such as jacobian calculation which require symbolic computation, there are calculate_* equivalents to obtain the symbolic result without building a function.","category":"page"},{"location":"API/codegen/#ModelingToolkit.calculate_tgrad","page":"Code generation utilities","title":"ModelingToolkit.calculate_tgrad","text":"calculate_tgrad(sys::System; simplify) -> Any\n\n\nCalculate the gradient of the equations of sys with respect to the independent variable. simplify is forwarded to Symbolics.expand_derivatives.\n\n\n\n\n\n","category":"function"},{"location":"API/codegen/#ModelingToolkit.calculate_jacobian","page":"Code generation utilities","title":"ModelingToolkit.calculate_jacobian","text":"calculate_jacobian(\n    sys::System;\n    sparse,\n    simplify,\n    dvs\n) -> Any\n\n\nCalculate the jacobian of the equations of sys.\n\nKeyword arguments\n\nsimplify, sparse: Forwarded to Symbolics.jacobian.\ndvs: The variables with respect to which the jacobian should be computed.\n\n\n\n\n\n","category":"function"},{"location":"API/codegen/#Symbolics.jacobian_sparsity","page":"Code generation utilities","title":"Symbolics.jacobian_sparsity","text":"jacobian_sparsity(\n    sys::System\n) -> SparseArrays.SparseMatrixCSC{Bool, Int64}\n\n\nReturn the sparsity pattern of the jacobian of sys as a matrix.\n\n\n\n\n\n","category":"function"},{"location":"API/codegen/#ModelingToolkit.jacobian_dae_sparsity","page":"Code generation utilities","title":"ModelingToolkit.jacobian_dae_sparsity","text":"jacobian_dae_sparsity(\n    sys::System\n) -> SparseArrays.SparseMatrixCSC{Int64, Int64}\n\n\nReturn the sparsity pattern of the DAE jacobian of sys as a matrix.\n\nSee also: generate_dae_jacobian.\n\n\n\n\n\n","category":"function"},{"location":"API/codegen/#ModelingToolkit.calculate_hessian","page":"Code generation utilities","title":"ModelingToolkit.calculate_hessian","text":"calculate_hessian(sys::System; simplify, sparse) -> Any\n\n\nReturn an array of symbolic hessians corresponding to the equations of the system.\n\nKeyword Arguments\n\nsparse: Controls whether the symbolic hessians are sparse matrices\nsimplify: Forwarded to Symbolics.hessian\n\n\n\n\n\n","category":"function"},{"location":"API/codegen/#Symbolics.hessian_sparsity","page":"Code generation utilities","title":"Symbolics.hessian_sparsity","text":"hessian_sparsity(sys::System) -> Any\n\n\nReturn the sparsity pattern of the hessian of the equations of sys.\n\n\n\n\n\n","category":"function"},{"location":"API/codegen/#ModelingToolkit.calculate_massmatrix","page":"Code generation utilities","title":"ModelingToolkit.calculate_massmatrix","text":"calculate_massmatrix(sys::System; simplify) -> Any\n\n\nCalculate the mass matrix of sys. simplify controls whether Symbolics.simplify is applied to the symbolic mass matrix. Returns a Diagonal or LinearAlgebra.I wherever possible.\n\n\n\n\n\n","category":"function"},{"location":"API/codegen/#ModelingToolkit.W_sparsity","page":"Code generation utilities","title":"ModelingToolkit.W_sparsity","text":"W_sparsity(sys::System) -> Any\n\n\nReturn the sparsity pattern of the W matrix of sys.\n\nSee also: generate_W.\n\n\n\n\n\n","category":"function"},{"location":"API/codegen/#ModelingToolkit.calculate_W_prototype","page":"Code generation utilities","title":"ModelingToolkit.calculate_W_prototype","text":"calculate_W_prototype(W_sparsity; u0, sparse) -> Any\n\n\nReturn the matrix to use as the jacobian prototype given the W-sparsity matrix of the system. This is not the same as the jacobian sparsity pattern.\n\nKeyword arguments\n\nu0: The u0 vector for the problem.\nsparse: The prototype is nothing for non-sparse matrices.\n\n\n\n\n\n","category":"function"},{"location":"API/codegen/#ModelingToolkit.calculate_cost_gradient","page":"Code generation utilities","title":"ModelingToolkit.calculate_cost_gradient","text":"calculate_cost_gradient(sys::System; simplify) -> Any\n\n\nCalculate the gradient of the consolidated cost of sys with respect to the unknowns. simplify is forwarded to Symbolics.gradient.\n\n\n\n\n\n","category":"function"},{"location":"API/codegen/#ModelingToolkit.calculate_cost_hessian","page":"Code generation utilities","title":"ModelingToolkit.calculate_cost_hessian","text":"calculate_cost_hessian(\n    sys::System;\n    sparse,\n    simplify\n) -> Union{SparseArrays.SparseMatrixCSC{Float64, Int64}, Matrix{Num}}\n\n\nCalculate the hessian of the consolidated cost of sys with respect to the unknowns. simplify is forwarded to Symbolics.hessian. sparse controls whether a sparse matrix is returned.\n\n\n\n\n\n","category":"function"},{"location":"API/codegen/#ModelingToolkit.cost_hessian_sparsity","page":"Code generation utilities","title":"ModelingToolkit.cost_hessian_sparsity","text":"cost_hessian_sparsity(\n    sys::System\n) -> Union{SparseArrays.SparseMatrixCSC{Float64, Int64}, Matrix{Float64}}\n\n\nReturn the sparsity pattern for the hessian of the cost function of sys.\n\n\n\n\n\n","category":"function"},{"location":"API/codegen/#ModelingToolkit.calculate_constraint_jacobian","page":"Code generation utilities","title":"ModelingToolkit.calculate_constraint_jacobian","text":"calculate_constraint_jacobian(\n    sys::System;\n    simplify,\n    sparse,\n    return_sparsity\n) -> Any\n\n\nReturn the jacobian of the constraints of sys with respect to unknowns.\n\nKeyword arguments\n\nsimplify, sparse: Forwarded to Symbolics.jacobian.\nreturn_sparsity: Whether to also return the sparsity pattern of the jacobian.\n\n\n\n\n\n","category":"function"},{"location":"API/codegen/#ModelingToolkit.calculate_constraint_hessian","page":"Code generation utilities","title":"ModelingToolkit.calculate_constraint_hessian","text":"calculate_constraint_hessian(\n    sys::System;\n    simplify,\n    sparse,\n    return_sparsity\n) -> Any\n\n\nReturn the hessian of the constraints of sys with respect to unknowns.\n\nKeyword arguments\n\nsimplify, sparse: Forwarded to Symbolics.hessian.\nreturn_sparsity: Whether to also return the sparsity pattern of the hessian.\n\n\n\n\n\n","category":"function"},{"location":"API/codegen/#ModelingToolkit.calculate_control_jacobian","page":"Code generation utilities","title":"ModelingToolkit.calculate_control_jacobian","text":"calculate_control_jacobian(\n    sys::ModelingToolkit.AbstractSystem;\n    sparse,\n    simplify\n) -> Any\n\n\nCalculate the jacobian of the equations of sys with respect to the inputs.\n\nKeyword arguments\n\nsimplify, sparse: Forwarded to Symbolics.jacobian.\n\n\n\n\n\n","category":"function"},{"location":"API/codegen/#ModelingToolkit.calculate_A_b","page":"Code generation utilities","title":"ModelingToolkit.calculate_A_b","text":"calculate_A_b(\n    sys::System;\n    sparse\n) -> Tuple{Union{SparseArrays.SparseMatrixCSC{Any, Int64}, Matrix{Any}}, Any}\n\n\nReturn matrix A and vector b such that the system sys can be represented as A * x = b where x is unknowns(sys). Errors if the system is not affine.\n\nKeyword arguments\n\nsparse: return a sparse A.\n\n\n\n\n\n","category":"function"},{"location":"API/codegen/","page":"Code generation utilities","title":"Code generation utilities","text":"All code generation eventually calls build_function_wrapper.","category":"page"},{"location":"examples/tearing_parallelism/#Exposing-More-Parallelism-By-Tearing-Algebraic-Equations-in-Systems","page":"Exposing More Parallelism By Tearing Algebraic Equations in Systems","title":"Exposing More Parallelism By Tearing Algebraic Equations in Systems","text":"","category":"section"},{"location":"examples/tearing_parallelism/","page":"Exposing More Parallelism By Tearing Algebraic Equations in Systems","title":"Exposing More Parallelism By Tearing Algebraic Equations in Systems","text":"Sometimes it can be very non-trivial to parallelize a system. In this tutorial, we will demonstrate how to make use of mtkcompile to expose more parallelism in the solution process and parallelize the resulting simulation.","category":"page"},{"location":"examples/tearing_parallelism/#The-Component-Library","page":"Exposing More Parallelism By Tearing Algebraic Equations in Systems","title":"The Component Library","text":"","category":"section"},{"location":"examples/tearing_parallelism/","page":"Exposing More Parallelism By Tearing Algebraic Equations in Systems","title":"Exposing More Parallelism By Tearing Algebraic Equations in Systems","text":"The following tutorial will use the following set of components describing electrical circuits:","category":"page"},{"location":"examples/tearing_parallelism/","page":"Exposing More Parallelism By Tearing Algebraic Equations in Systems","title":"Exposing More Parallelism By Tearing Algebraic Equations in Systems","text":"using ModelingToolkit, OrdinaryDiffEq\nusing ModelingToolkit: t_nounits as t, D_nounits as D\n\n# Basic electric components\n@connector function Pin(; name)\n    @variables v(t)=1.0 i(t)=1.0 [connect=Flow]\n    System(Equation[], t, [v, i], [], name = name)\nend\n\nfunction Ground(; name)\n    @named g = Pin()\n    eqs = [g.v ~ 0]\n    compose(System(eqs, t, [], [], name = name), g)\nend\n\nfunction ConstantVoltage(; name, V = 1.0)\n    val = V\n    @named p = Pin()\n    @named n = Pin()\n    @parameters V = V\n    eqs = [V ~ p.v - n.v\n           0 ~ p.i + n.i]\n    compose(System(eqs, t, [], [V], name = name), p, n)\nend\n\n@connector function HeatPort(; name)\n    @variables T(t)=293.15 Q_flow(t)=0.0 [connect=Flow]\n    System(Equation[], t, [T, Q_flow], [], name = name)\nend\n\nfunction HeatingResistor(; name, R = 1.0, TAmbient = 293.15, alpha = 1.0)\n    @named p = Pin()\n    @named n = Pin()\n    @named h = HeatPort()\n    @variables v(t) RTherm(t)\n    @parameters R=R TAmbient=TAmbient alpha=alpha\n    eqs = [RTherm ~ R * (1 + alpha * (h.T - TAmbient))\n           v ~ p.i * RTherm\n           h.Q_flow ~ -v * p.i # -LossPower\n           v ~ p.v - n.v\n           0 ~ p.i + n.i]\n    compose(System(eqs, t, [v, RTherm], [R, TAmbient, alpha],\n            name = name), p, n, h)\nend\n\nfunction HeatCapacitor(; name, rho = 8050, V = 1, cp = 460, TAmbient = 293.15)\n    @parameters rho=rho V=V cp=cp\n    C = rho * V * cp\n    @named h = HeatPort()\n    eqs = [\n        D(h.T) ~ h.Q_flow / C\n    ]\n    compose(System(eqs, t, [], [rho, V, cp],\n            name = name), h)\nend\n\nfunction Capacitor(; name, C = 1.0)\n    @named p = Pin()\n    @named n = Pin()\n    @variables v(t) = 0.0\n    @parameters C = C\n    eqs = [v ~ p.v - n.v\n           0 ~ p.i + n.i\n           D(v) ~ p.i / C]\n    compose(System(eqs, t, [v], [C],\n            name = name), p, n)\nend\n\nfunction parallel_rc_model(i; name, source, ground, R, C)\n    resistor = HeatingResistor(name = Symbol(:resistor, i), R = R)\n    capacitor = Capacitor(name = Symbol(:capacitor, i), C = C)\n    heat_capacitor = HeatCapacitor(name = Symbol(:heat_capacitor, i))\n\n    rc_eqs = [connect(source.p, resistor.p)\n              connect(resistor.n, capacitor.p)\n              connect(capacitor.n, source.n, ground.g)\n              connect(resistor.h, heat_capacitor.h)]\n\n    compose(System(rc_eqs, t, name = Symbol(name, i)),\n        [resistor, capacitor, source, ground, heat_capacitor])\nend","category":"page"},{"location":"examples/tearing_parallelism/#The-Model","page":"Exposing More Parallelism By Tearing Algebraic Equations in Systems","title":"The Model","text":"","category":"section"},{"location":"examples/tearing_parallelism/","page":"Exposing More Parallelism By Tearing Algebraic Equations in Systems","title":"Exposing More Parallelism By Tearing Algebraic Equations in Systems","text":"Assuming that the components are defined, our model is 50 resistors and capacitors connected in parallel. Thus following the acausal components tutorial, we can connect a bunch of RC components as follows:","category":"page"},{"location":"examples/tearing_parallelism/","page":"Exposing More Parallelism By Tearing Algebraic Equations in Systems","title":"Exposing More Parallelism By Tearing Algebraic Equations in Systems","text":"V = 2.0\n@named source = ConstantVoltage(V = V)\n@named ground = Ground()\nN = 50\nRs = 10 .^ range(0, stop = -4, length = N)\nCs = 10 .^ range(-3, stop = 0, length = N)\nrc_systems = map(1:N) do i\n    parallel_rc_model(i; name = :rc, source = source, ground = ground, R = Rs[i], C = Cs[i])\nend;\n@variables E(t) = 0.0\neqs = [\n    D(E) ~ sum(((i, sys),) -> getproperty(sys, Symbol(:resistor, i)).h.Q_flow,\n    enumerate(rc_systems))\n]\n@named _big_rc = System(eqs, t, [E], [])\n@named big_rc = compose(_big_rc, rc_systems)","category":"page"},{"location":"examples/tearing_parallelism/","page":"Exposing More Parallelism By Tearing Algebraic Equations in Systems","title":"Exposing More Parallelism By Tearing Algebraic Equations in Systems","text":"Now let's say we want to expose a bit more parallelism via running tearing. How do we do that?","category":"page"},{"location":"examples/tearing_parallelism/","page":"Exposing More Parallelism By Tearing Algebraic Equations in Systems","title":"Exposing More Parallelism By Tearing Algebraic Equations in Systems","text":"sys = mtkcompile(big_rc)","category":"page"},{"location":"examples/tearing_parallelism/","page":"Exposing More Parallelism By Tearing Algebraic Equations in Systems","title":"Exposing More Parallelism By Tearing Algebraic Equations in Systems","text":"Done, that's it. There's no more to it.","category":"page"},{"location":"examples/tearing_parallelism/#What-Happened?","page":"Exposing More Parallelism By Tearing Algebraic Equations in Systems","title":"What Happened?","text":"","category":"section"},{"location":"examples/tearing_parallelism/","page":"Exposing More Parallelism By Tearing Algebraic Equations in Systems","title":"Exposing More Parallelism By Tearing Algebraic Equations in Systems","text":"Yes, that's a good question! Let's investigate a little bit more what had happened. If you look at the system we defined:","category":"page"},{"location":"examples/tearing_parallelism/","page":"Exposing More Parallelism By Tearing Algebraic Equations in Systems","title":"Exposing More Parallelism By Tearing Algebraic Equations in Systems","text":"length(equations(big_rc))","category":"page"},{"location":"examples/tearing_parallelism/","page":"Exposing More Parallelism By Tearing Algebraic Equations in Systems","title":"Exposing More Parallelism By Tearing Algebraic Equations in Systems","text":"You see, it started as a massive 1051 set of equations. However, after eliminating redundancies, we arrive at 151 equations:","category":"page"},{"location":"examples/tearing_parallelism/","page":"Exposing More Parallelism By Tearing Algebraic Equations in Systems","title":"Exposing More Parallelism By Tearing Algebraic Equations in Systems","text":"equations(sys)","category":"page"},{"location":"examples/tearing_parallelism/","page":"Exposing More Parallelism By Tearing Algebraic Equations in Systems","title":"Exposing More Parallelism By Tearing Algebraic Equations in Systems","text":"That's not all though. In addition, the tearing process has turned the sets of nonlinear equations into separate blocks and constructed a DAG for the dependencies between the blocks. We can use the bipartite graph functionality to dig in and investigate what this means:","category":"page"},{"location":"examples/tearing_parallelism/","page":"Exposing More Parallelism By Tearing Algebraic Equations in Systems","title":"Exposing More Parallelism By Tearing Algebraic Equations in Systems","text":"using ModelingToolkit.BipartiteGraphs\nts = TearingState(expand_connections(big_rc))\ninc_org = BipartiteGraphs.incidence_matrix(ts.structure.graph)\nblt_org = StructuralTransformations.sorted_incidence_matrix(ts, only_algeqs = true,\n    only_algvars = true)\nblt_reduced = StructuralTransformations.sorted_incidence_matrix(\n    ModelingToolkit.get_tearing_state(sys),\n    only_algeqs = true,\n    only_algvars = true)","category":"page"},{"location":"examples/tearing_parallelism/","page":"Exposing More Parallelism By Tearing Algebraic Equations in Systems","title":"Exposing More Parallelism By Tearing Algebraic Equations in Systems","text":"(Image: )","category":"page"},{"location":"examples/tearing_parallelism/","page":"Exposing More Parallelism By Tearing Algebraic Equations in Systems","title":"Exposing More Parallelism By Tearing Algebraic Equations in Systems","text":"The figure on the left is the original incidence matrix of the algebraic equations. Notice that the original formulation of the model has dependencies between different equations, and so the full set of equations must be solved together. That exposes no parallelism. However, the Block Lower Triangular (BLT) transformation exposes independent blocks. This is then further improved by the tearing process, which removes 90% of the equations and transforms the nonlinear equations into 50 independent blocks, which can now all be solved in parallel. The conclusion is that, your attempts to parallelize are neigh: performing parallelism after structural simplification greatly improves the problem that can be parallelized, so this is better than trying to do it by hand.","category":"page"},{"location":"examples/tearing_parallelism/","page":"Exposing More Parallelism By Tearing Algebraic Equations in Systems","title":"Exposing More Parallelism By Tearing Algebraic Equations in Systems","text":"After performing this, you can construct the ODEProblem and set parallel_form to use the exposed parallelism in multithreaded function constructions, but this showcases why mtkcompile is so important to that process.","category":"page"},{"location":"basics/Debugging/#Debugging","page":"Debugging","title":"Debugging","text":"","category":"section"},{"location":"basics/Debugging/","page":"Debugging","title":"Debugging","text":"Every (mortal) modeler writes models that contain mistakes or are susceptible to numerical errors in their hunt for the perfect model. Debugging such errors is part of the modeling process, and ModelingToolkit includes some functionality that helps with this.","category":"page"},{"location":"basics/Debugging/","page":"Debugging","title":"Debugging","text":"For example, consider an ODE model with \"dangerous\" functions (here √):","category":"page"},{"location":"basics/Debugging/","page":"Debugging","title":"Debugging","text":"using ModelingToolkit, OrdinaryDiffEq\nusing ModelingToolkit: t_nounits as t, D_nounits as D\n\n@variables u1(t) u2(t) u3(t)\neqs = [D(u1) ~ -√(u1), D(u2) ~ -√(u2), D(u3) ~ -√(u3)]\ndefaults = [u1 => 1.0, u2 => 2.0, u3 => 3.0]\n@named sys = System(eqs, t; defaults)\nsys = mtkcompile(sys)","category":"page"},{"location":"basics/Debugging/","page":"Debugging","title":"Debugging","text":"This problem causes the ODE solver to crash:","category":"page"},{"location":"basics/Debugging/","page":"Debugging","title":"Debugging","text":"prob = ODEProblem(sys, [], (0.0, 10.0), []);\nsol = solve(prob, Tsit5());","category":"page"},{"location":"basics/Debugging/","page":"Debugging","title":"Debugging","text":"This suggests that something went wrong, but not exactly what went wrong and where it did. In such situations, the debug_system function is helpful:","category":"page"},{"location":"basics/Debugging/","page":"Debugging","title":"Debugging","text":"dsys = debug_system(sys; functions = [sqrt]);\ndprob = ODEProblem(dsys, [], (0.0, 10.0), []);\ndsol = solve(dprob, Tsit5());","category":"page"},{"location":"basics/Debugging/","page":"Debugging","title":"Debugging","text":"Now we see that it crashed because u1 decreased so much that it became negative and outside the domain of the √ function. We could have figured that out ourselves, but it is not always so obvious for more complex models.","category":"page"},{"location":"basics/Debugging/","page":"Debugging","title":"Debugging","text":"Suppose we also want to validate that u1 + u2 >= 2.0. We can do this via the assertions functionality.","category":"page"},{"location":"basics/Debugging/","page":"Debugging","title":"Debugging","text":"@mtkcompile sys = System(eqs, t; defaults, assertions = [(u1 + u2 >= 2.0) => \"Oh no!\"])","category":"page"},{"location":"basics/Debugging/","page":"Debugging","title":"Debugging","text":"The assertions must be an iterable of pairs, where the first element is the symbolic condition and the second is a message to be logged when the condition fails. All assertions are added to the generated code and will cause the solver to reject steps that fail the assertions. For systems such as the above where the assertion is guaranteed to eventually fail, the solver will likely exit with a dtmin failure..","category":"page"},{"location":"basics/Debugging/","page":"Debugging","title":"Debugging","text":"prob = ODEProblem(sys, [], (0.0, 10.0))\nsol = solve(prob, Tsit5())","category":"page"},{"location":"basics/Debugging/","page":"Debugging","title":"Debugging","text":"We can use debug_system to log the failing assertions in each call to the RHS function.","category":"page"},{"location":"basics/Debugging/","page":"Debugging","title":"Debugging","text":"dsys = debug_system(sys; functions = []);\ndprob = ODEProblem(dsys, [], (0.0, 10.0));\ndsol = solve(dprob, Tsit5());","category":"page"},{"location":"basics/Debugging/","page":"Debugging","title":"Debugging","text":"Note the logs containing the failed assertion and corresponding message. To temporarily disable logging in a system returned from debug_system, use ModelingToolkit.ASSERTION_LOG_VARIABLE.","category":"page"},{"location":"basics/Debugging/","page":"Debugging","title":"Debugging","text":"dprob[ModelingToolkit.ASSERTION_LOG_VARIABLE] = false;\nsolve(dprob, Tsit5());","category":"page"},{"location":"basics/Debugging/#ModelingToolkit.debug_system-basics-Debugging","page":"Debugging","title":"ModelingToolkit.debug_system","text":"debug_system(sys::AbstractSystem; functions = [log, sqrt, (^), /, inv, asin, acos], error_nonfinite = true)\n\nWrap functions in sys so any error thrown in them shows helpful symbolic-numeric information about its input. If error_nonfinite, functions that output nonfinite values (like Inf or NaN) also display errors, even though the raw function itself does not throw an exception (like 1/0). For example:\n\njulia> sys = debug_system(complete(sys))\n\njulia> prob = ODEProblem(sys, [0.0, 2.0], (0.0, 1.0))\n\njulia> prob.f(prob.u0, prob.p, 0.0)\nERROR: Function /(1, sin(P(t))) output non-finite value Inf with input\n  1 => 1\n  sin(P(t)) => 0.0\n\nAdditionally, all assertions in the system are optionally logged when they fail. A new parameter is also added to the system which controls whether the message associated with each assertion will be logged when the assertion fails. This parameter defaults to true and can be toggled by symbolic indexing with ModelingToolkit.ASSERTION_LOG_VARIABLE. For example, prob.ps[ModelingToolkit.ASSERTION_LOG_VARIABLE] = false will disable logging.\n\n\n\n\n\n","category":"function"},{"location":"comparison/#Comparison-of-ModelingToolkit-vs-Equation-Based-and-Block-Modeling-Languages","page":"Comparison of ModelingToolkit vs Equation-Based and Block Modeling Languages","title":"Comparison of ModelingToolkit vs Equation-Based and Block Modeling Languages","text":"","category":"section"},{"location":"comparison/#Comparison-Against-Modelica","page":"Comparison of ModelingToolkit vs Equation-Based and Block Modeling Languages","title":"Comparison Against Modelica","text":"","category":"section"},{"location":"comparison/","page":"Comparison of ModelingToolkit vs Equation-Based and Block Modeling Languages","title":"Comparison of ModelingToolkit vs Equation-Based and Block Modeling Languages","text":"Both Modelica and ModelingToolkit.jl are acausal modeling languages.\nModelica is a language with many different implementations, such as Dymola and OpenModelica, which have differing levels of performance and can give different results on the same model. Many of the commonly used Modelica compilers are not open-source. ModelingToolkit.jl is a language with a single canonical open-source implementation.\nAll current Modelica compiler implementations are fixed and not extendable by the users from the Modelica language itself. For example, the Dymola compiler shares its symbolic processing pipeline, which is roughly equivalent to the dae_index_lowering and mtkcompile of ModelingToolkit.jl. ModelingToolkit.jl is an open and hackable transformation system which allows users to add new non-standard transformations and control the order of application.\nModelica is a declarative programming language. ModelingToolkit.jl is a declarative symbolic modeling language used from within the Julia programming language. Its programming language semantics, such as loop constructs and conditionals, can be used to more easily generate models.\nModelica is an object-oriented single dispatch language. ModelingToolkit.jl, built on Julia, uses multiple dispatch extensively to simplify code.\nMany Modelica compilers supply a GUI. ModelingToolkit.jl does not.\nModelica is designed for simulating ODE and DAE systems (which can include nonlinear dynamics). In contrast, ModelingToolkit.jl supports a much broader range of system types, including SDEs, PDEs, time-independent nonlinear systems (e.g. various forms of optimization problems) and more.","category":"page"},{"location":"comparison/#Comparison-Against-Simulink","page":"Comparison of ModelingToolkit vs Equation-Based and Block Modeling Languages","title":"Comparison Against Simulink","text":"","category":"section"},{"location":"comparison/","page":"Comparison of ModelingToolkit vs Equation-Based and Block Modeling Languages","title":"Comparison of ModelingToolkit vs Equation-Based and Block Modeling Languages","text":"Simulink is a causal modeling environment, whereas ModelingToolkit.jl is an acausal modeling environment. For an overview of the differences, consult academic reviews such as this one. In this sense, ModelingToolkit.jl is more similar to the Simscape sub-environment.\nSimulink is used from MATLAB while ModelingToolkit.jl is used from Julia. Thus any user-defined functions have the performance of their host language. For information on the performance differences between Julia and MATLAB, consult open benchmarks, which demonstrate Julia as an order of magnitude or more faster in many cases due to its JIT compilation.\nSimulink uses the MATLAB differential equation solvers, while ModelingToolkit.jl uses DifferentialEquations.jl. For a systematic comparison between the solvers, consult open benchmarks, which demonstrate two orders of magnitude performance advantage for the native Julia solvers across many benchmark problems.\nSimulink comes with a Graphical User Interface (GUI), ModelingToolkit.jl does not.\nSimulink is a proprietary software, meaning users cannot actively modify or extend the software. ModelingToolkit.jl is built in Julia and used in Julia, where users can actively extend and modify the software interactively in the REPL and contribute to its open-source repositories.\nSimulink covers ODE and DAE systems. ModelingToolkit.jl has a much more expansive set of system types, including SDEs, PDEs, optimization problems, and more.","category":"page"},{"location":"comparison/#Comparison-Against-CASADI","page":"Comparison of ModelingToolkit vs Equation-Based and Block Modeling Languages","title":"Comparison Against CASADI","text":"","category":"section"},{"location":"comparison/","page":"Comparison of ModelingToolkit vs Equation-Based and Block Modeling Languages","title":"Comparison of ModelingToolkit vs Equation-Based and Block Modeling Languages","text":"CASADI is written in C++ but used from Python/MATLAB, meaning that it cannot be directly extended by users unless they are using the C++ interface and run a local build of CASADI. ModelingToolkit.jl is both written and used from Julia, meaning that users can easily extend the library on the fly, even interactively in the REPL.\nCASADI includes limited support for Computer Algebra System (CAS) functionality, while ModelingToolkit.jl is built on the full Symbolics.jl CAS.\nCASADI supports DAE and ODE problems via SUNDIALS IDAS and CVODES. ModelingToolkit.jl supports DAE and ODE problems via DifferentialEquations.jl, of which Sundials.jl is <1% of the total available solvers and is outperformed by the native Julia solvers on the vast majority of the benchmark equations. In addition, the DifferentialEquations.jl interface is confederated, meaning that any user can dynamically extend the system to add new solvers to the interface by defining new dispatches of solve.\nCASADI's DAEBuilder does not implement efficiency transformations like tearing, which are standard in the ModelingToolkit.jl transformation pipeline.\nCASADI supports special functionality for quadratic programming problems, while ModelingToolkit only provides nonlinear programming via OptimizationSystem.\nModelingToolkit.jl integrates with its host language Julia, so Julia code can be automatically converted into ModelingToolkit expressions. Users of CASADI must explicitly create CASADI expressions.","category":"page"},{"location":"comparison/#Comparison-Against-Modia.jl","page":"Comparison of ModelingToolkit vs Equation-Based and Block Modeling Languages","title":"Comparison Against Modia.jl","text":"","category":"section"},{"location":"comparison/","page":"Comparison of ModelingToolkit vs Equation-Based and Block Modeling Languages","title":"Comparison of ModelingToolkit vs Equation-Based and Block Modeling Languages","text":"Modia.jl uses Julia's expression objects for representing its equations. ModelingToolkit.jl uses Symbolics.jl, and thus the Julia expressions follow Julia semantics and can be manipulated using a computer algebra system (CAS).\nModia's compilation pipeline is similar to the Dymola symbolic processing pipeline with some improvements. ModelingToolkit.jl has an open transformation pipeline that allows for users to extend and reorder transformation passes, where mtkcompile is an adaptation of the Modia.jl-improved alias elimination and tearing algorithms.\nBoth Modia and ModelingToolkit generate DAEProblem and ODEProblem forms for solving with DifferentialEquations.jl.\nModelingToolkit.jl integrates with its host language Julia, so Julia code can be automatically converted into ModelingToolkit expressions. Users of Modia must explicitly create Modia expressions.\nModia covers DAE systems. ModelingToolkit.jl has a much more expansive set of system types, including SDEs, PDEs, optimization problems, and more.","category":"page"},{"location":"comparison/#Comparison-Against-Causal.jl","page":"Comparison of ModelingToolkit vs Equation-Based and Block Modeling Languages","title":"Comparison Against Causal.jl","text":"","category":"section"},{"location":"comparison/","page":"Comparison of ModelingToolkit vs Equation-Based and Block Modeling Languages","title":"Comparison of ModelingToolkit vs Equation-Based and Block Modeling Languages","text":"Causal.jl is a causal modeling environment, whereas ModelingToolkit.jl is an acausal modeling environment. For an overview of the differences, consult academic reviews such as this one.\nBoth ModelingToolkit.jl and Causal.jl use DifferentialEquations.jl as the backend solver library.\nCausal.jl lets one add arbitrary equation systems to a given node, and allow the output to effect the next node. This means an SDE may drive an ODE. These two portions are solved with different solver methods in tandem. In ModelingToolkit.jl, such connections promote the whole system to an SDE. This results in better accuracy and stability, though in some cases it can be less performant.\nCausal.jl, similar to Simulink, breaks algebraic loops via inexact heuristics. ModelingToolkit.jl treats algebraic loops exactly through algebraic equations in the generated model.","category":"page"},{"location":"examples/sparse_jacobians/#Automated-Sparse-Analytical-Jacobians","page":"Automated Sparse Analytical Jacobians","title":"Automated Sparse Analytical Jacobians","text":"","category":"section"},{"location":"examples/sparse_jacobians/","page":"Automated Sparse Analytical Jacobians","title":"Automated Sparse Analytical Jacobians","text":"In many cases where you have large stiff differential equations, getting a sparse Jacobian can be essential for performance. In this tutorial, we will show how to use modelingtoolkitize to regenerate an ODEProblem code with the analytical solution to the sparse Jacobian, along with the sparsity pattern required by DifferentialEquations.jl's solvers to specialize the solving process.","category":"page"},{"location":"examples/sparse_jacobians/","page":"Automated Sparse Analytical Jacobians","title":"Automated Sparse Analytical Jacobians","text":"First, let's start out with an implementation of the 2-dimensional Brusselator partial differential equation discretized using finite differences:","category":"page"},{"location":"examples/sparse_jacobians/","page":"Automated Sparse Analytical Jacobians","title":"Automated Sparse Analytical Jacobians","text":"using OrdinaryDiffEq, ModelingToolkit\n\nconst N = 32\nconst xyd_brusselator = range(0, stop = 1, length = N)\nbrusselator_f(x, y, t) = (((x - 0.3)^2 + (y - 0.6)^2) <= 0.1^2) * (t >= 1.1) * 5.0\nlimit(a, N) = a == N + 1 ? 1 : a == 0 ? N : a\nfunction brusselator_2d_loop(du, u, p, t)\n    A, B, alpha, dx = p\n    alpha = alpha / dx^2\n    @inbounds for I in CartesianIndices((N, N))\n        i, j = Tuple(I)\n        x, y = xyd_brusselator[I[1]], xyd_brusselator[I[2]]\n        ip1, im1, jp1,\n        jm1 = limit(i + 1, N), limit(i - 1, N), limit(j + 1, N),\n        limit(j - 1, N)\n        du[i,\n            j,\n            1] = alpha * (u[im1, j, 1] + u[ip1, j, 1] + u[i, jp1, 1] + u[i, jm1, 1] -\n                  4u[i, j, 1]) +\n                 B + u[i, j, 1]^2 * u[i, j, 2] - (A + 1) * u[i, j, 1] +\n                 brusselator_f(x, y, t)\n        du[i,\n            j,\n            2] = alpha * (u[im1, j, 2] + u[ip1, j, 2] + u[i, jp1, 2] + u[i, jm1, 2] -\n                  4u[i, j, 2]) +\n                 A * u[i, j, 1] - u[i, j, 1]^2 * u[i, j, 2]\n    end\nend\np = (3.4, 1.0, 10.0, step(xyd_brusselator))\n\nfunction init_brusselator_2d(xyd)\n    N = length(xyd)\n    u = zeros(N, N, 2)\n    for I in CartesianIndices((N, N))\n        x = xyd[I[1]]\n        y = xyd[I[2]]\n        u[I, 1] = 22 * (y * (1 - y))^(3 / 2)\n        u[I, 2] = 27 * (x * (1 - x))^(3 / 2)\n    end\n    u\nend\nu0 = init_brusselator_2d(xyd_brusselator)\nprob = ODEProblem(brusselator_2d_loop, u0, (0.0, 11.5), p)","category":"page"},{"location":"examples/sparse_jacobians/","page":"Automated Sparse Analytical Jacobians","title":"Automated Sparse Analytical Jacobians","text":"Now let's use modelingtoolkitize to generate the symbolic version:","category":"page"},{"location":"examples/sparse_jacobians/","page":"Automated Sparse Analytical Jacobians","title":"Automated Sparse Analytical Jacobians","text":"@mtkcompile sys = modelingtoolkitize(prob);\nnothing # hide","category":"page"},{"location":"examples/sparse_jacobians/","page":"Automated Sparse Analytical Jacobians","title":"Automated Sparse Analytical Jacobians","text":"Now we regenerate the problem using jac=true for the analytical Jacobian and sparse=true to make it sparse:","category":"page"},{"location":"examples/sparse_jacobians/","page":"Automated Sparse Analytical Jacobians","title":"Automated Sparse Analytical Jacobians","text":"sparseprob = ODEProblem(sys, Pair[], (0.0, 11.5), jac = true, sparse = true)","category":"page"},{"location":"examples/sparse_jacobians/","page":"Automated Sparse Analytical Jacobians","title":"Automated Sparse Analytical Jacobians","text":"Hard? No! How much did that help?","category":"page"},{"location":"examples/sparse_jacobians/","page":"Automated Sparse Analytical Jacobians","title":"Automated Sparse Analytical Jacobians","text":"using BenchmarkTools\n@btime solve(prob, save_everystep = false);\nreturn nothing # hide","category":"page"},{"location":"examples/sparse_jacobians/","page":"Automated Sparse Analytical Jacobians","title":"Automated Sparse Analytical Jacobians","text":"@btime solve(sparseprob, save_everystep = false);\nreturn nothing # hide","category":"page"},{"location":"examples/sparse_jacobians/","page":"Automated Sparse Analytical Jacobians","title":"Automated Sparse Analytical Jacobians","text":"Notice though that the analytical solution to the Jacobian can be quite expensive. Thus in some cases we may only want to get the sparsity pattern. In this case, we can simply do:","category":"page"},{"location":"examples/sparse_jacobians/","page":"Automated Sparse Analytical Jacobians","title":"Automated Sparse Analytical Jacobians","text":"sparsepatternprob = ODEProblem(sys, Pair[], (0.0, 11.5), sparse = true)\n@btime solve(sparsepatternprob, save_everystep = false);\nreturn nothing # hide","category":"page"},{"location":"tutorials/SampledData/#Clocks-and-Sampled-Data-Systems","page":"Clocks and Sampled-Data Systems","title":"Clocks and Sampled-Data Systems","text":"","category":"section"},{"location":"tutorials/SampledData/","page":"Clocks and Sampled-Data Systems","title":"Clocks and Sampled-Data Systems","text":"A sampled-data system contains both continuous-time and discrete-time components, such as a continuous-time plant model and a discrete-time control system. ModelingToolkit supports the modeling and simulation of sampled-data systems by means of clocks.","category":"page"},{"location":"tutorials/SampledData/","page":"Clocks and Sampled-Data Systems","title":"Clocks and Sampled-Data Systems","text":"danger: Experimental\nThe sampled-data interface is currently experimental and at any time subject to breaking changes not respecting semantic versioning.","category":"page"},{"location":"tutorials/SampledData/","page":"Clocks and Sampled-Data Systems","title":"Clocks and Sampled-Data Systems","text":"note: Negative shifts\nThe initial release of the sampled-data interface only supports negative shifts.","category":"page"},{"location":"tutorials/SampledData/","page":"Clocks and Sampled-Data Systems","title":"Clocks and Sampled-Data Systems","text":"A clock can be seen as an event source, i.e., when the clock ticks, an event is generated. In response to the event the discrete-time logic is executed, for example, a control signal is computed. For basic modeling of sampled-data systems, the user does not have to interact with clocks explicitly, instead, the modeling is performed using the operators","category":"page"},{"location":"tutorials/SampledData/","page":"Clocks and Sampled-Data Systems","title":"Clocks and Sampled-Data Systems","text":"Sample\nHold\nShiftIndex","category":"page"},{"location":"tutorials/SampledData/","page":"Clocks and Sampled-Data Systems","title":"Clocks and Sampled-Data Systems","text":"When a continuous-time variable x is sampled using xd = Sample(dt)(x), the result is a discrete-time variable xd that is defined and updated whenever the clock ticks. xd is only defined when the clock ticks, which it does with an interval of dt. If dt is unspecified, the tick rate of the clock associated with xd is inferred from the context in which xd appears. Any variable taking part in the same equation as xd is inferred to belong to the same discrete partition as xd, i.e., belonging to the same clock. A system may contain multiple different discrete-time partitions, each with a unique clock. This allows for modeling of multi-rate systems and discrete-time processes located on different computers etc.","category":"page"},{"location":"tutorials/SampledData/","page":"Clocks and Sampled-Data Systems","title":"Clocks and Sampled-Data Systems","text":"To make a discrete-time variable available to the continuous partition, the Hold operator is used. xc = Hold(xd) creates a continuous-time variable xc that is updated whenever the clock associated with xd ticks, and holds its value constant between ticks.","category":"page"},{"location":"tutorials/SampledData/","page":"Clocks and Sampled-Data Systems","title":"Clocks and Sampled-Data Systems","text":"The operators Sample and Hold are thus providing the interface between continuous and discrete partitions.","category":"page"},{"location":"tutorials/SampledData/","page":"Clocks and Sampled-Data Systems","title":"Clocks and Sampled-Data Systems","text":"The ShiftIndex operator is used to refer to past and future values of discrete-time variables. The example below illustrates its use, implementing the discrete-time system","category":"page"},{"location":"tutorials/SampledData/","page":"Clocks and Sampled-Data Systems","title":"Clocks and Sampled-Data Systems","text":"beginalign\n    x(k+1) = 05x(k) + u(k)  \n    y(k) = x(k)\nendalign","category":"page"},{"location":"tutorials/SampledData/","page":"Clocks and Sampled-Data Systems","title":"Clocks and Sampled-Data Systems","text":"using ModelingToolkit\nusing ModelingToolkit: t_nounits as t\n@variables x(t) y(t) u(t)\ndt = 0.1                # Sample interval\nclock = Clock(dt)    # A periodic clock with tick rate dt\nk = ShiftIndex(clock)\n\neqs = [\n    x(k) ~ 0.5x(k - 1) + u(k - 1),\n    y ~ x\n]","category":"page"},{"location":"tutorials/SampledData/","page":"Clocks and Sampled-Data Systems","title":"Clocks and Sampled-Data Systems","text":"A few things to note in this basic example:","category":"page"},{"location":"tutorials/SampledData/","page":"Clocks and Sampled-Data Systems","title":"Clocks and Sampled-Data Systems","text":"The equation x(k+1) = 0.5x(k) + u(k) has been rewritten in terms of negative shifts since positive shifts are not yet supported.\nx and u are automatically inferred to be discrete-time variables, since they appear in an equation with a discrete-time ShiftIndex k.\ny is also automatically inferred to be a discrete-time-time variable, since it appears in an equation with another discrete-time variable x. x,u,y all belong to the same discrete-time partition, i.e., they are all updated at the same instantaneous point in time at which the clock ticks.\nThe equation y ~ x does not use any shift index, this is equivalent to y(k) ~ x(k), i.e., discrete-time variables without shift index are assumed to refer to the variable at the current time step.\nThe equation x(k) ~ 0.5x(k-1) + u(k-1) indicates how x is updated, i.e., what the value of x will be at the current time step in terms of the past value. The output y, is given by the value of x at the current time step, i.e., y(k) ~ x(k). If this logic was implemented in an imperative programming style, the logic would thus be","category":"page"},{"location":"tutorials/SampledData/","page":"Clocks and Sampled-Data Systems","title":"Clocks and Sampled-Data Systems","text":"function discrete_step(x, u)\n    x = 0.5x + u # x is updated to a new value, i.e., x(k) is computed\n    y = x # y is assigned the current value of x, y(k) = x(k)\n    return x, y # The state x now refers to x at the current time step, x(k), and y equals x, y(k) = x(k)\nend","category":"page"},{"location":"tutorials/SampledData/","page":"Clocks and Sampled-Data Systems","title":"Clocks and Sampled-Data Systems","text":"An alternative and equivalent way of writing the same system is","category":"page"},{"location":"tutorials/SampledData/","page":"Clocks and Sampled-Data Systems","title":"Clocks and Sampled-Data Systems","text":"eqs = [\n    x(k + 1) ~ 0.5x(k) + u(k),\n    y(k) ~ x(k)\n]","category":"page"},{"location":"tutorials/SampledData/","page":"Clocks and Sampled-Data Systems","title":"Clocks and Sampled-Data Systems","text":"but the use of positive time shifts is not yet supported. Instead, we shifted all indices by -1 above, resulting in exactly the same difference equations. However, the next system is not equivalent to the previous one:","category":"page"},{"location":"tutorials/SampledData/","page":"Clocks and Sampled-Data Systems","title":"Clocks and Sampled-Data Systems","text":"eqs = [\n    x(k) ~ 0.5x(k - 1) + u(k),\n    y ~ x\n]","category":"page"},{"location":"tutorials/SampledData/","page":"Clocks and Sampled-Data Systems","title":"Clocks and Sampled-Data Systems","text":"In this last example, u(k) refers to the input at the new time point k., this system is equivalent to","category":"page"},{"location":"tutorials/SampledData/","page":"Clocks and Sampled-Data Systems","title":"Clocks and Sampled-Data Systems","text":"eqs = [\n    x(k+1) ~ 0.5x(k) + u(k+1),\n    y(k) ~ x(k)\n]","category":"page"},{"location":"tutorials/SampledData/#Higher-order-shifts","page":"Clocks and Sampled-Data Systems","title":"Higher-order shifts","text":"","category":"section"},{"location":"tutorials/SampledData/","page":"Clocks and Sampled-Data Systems","title":"Clocks and Sampled-Data Systems","text":"The expression x(k-1) refers to the value of x at the previous clock tick. Similarly, x(k-2) refers to the value of x at the clock tick before that. In general, x(k-n) refers to the value of x at the nth clock tick before the current one. As an example, the Z-domain transfer function","category":"page"},{"location":"tutorials/SampledData/","page":"Clocks and Sampled-Data Systems","title":"Clocks and Sampled-Data Systems","text":"H(z) = dfracb_2 z^2 + b_1 z + b_0a_2 z^2 + a_1 z + a_0","category":"page"},{"location":"tutorials/SampledData/","page":"Clocks and Sampled-Data Systems","title":"Clocks and Sampled-Data Systems","text":"may thus be modeled as","category":"page"},{"location":"tutorials/SampledData/","page":"Clocks and Sampled-Data Systems","title":"Clocks and Sampled-Data Systems","text":"t = ModelingToolkit.t_nounits\n@variables y(t) [description = \"Output\"] u(t) [description = \"Input\"]\nk = ShiftIndex(Clock(dt))\neqs = [\n    a2 * y(k) + a1 * y(k - 1) + a0 * y(k - 2) ~ b2 * u(k) + b1 * u(k - 1) + b0 * u(k - 2)\n]","category":"page"},{"location":"tutorials/SampledData/","page":"Clocks and Sampled-Data Systems","title":"Clocks and Sampled-Data Systems","text":"(see also ModelingToolkitStandardLibrary for a discrete-time transfer-function component.)","category":"page"},{"location":"tutorials/SampledData/#Initial-conditions","page":"Clocks and Sampled-Data Systems","title":"Initial conditions","text":"","category":"section"},{"location":"tutorials/SampledData/","page":"Clocks and Sampled-Data Systems","title":"Clocks and Sampled-Data Systems","text":"The initial condition of discrete-time variables is defined using the ShiftIndex operator, for example","category":"page"},{"location":"tutorials/SampledData/","page":"Clocks and Sampled-Data Systems","title":"Clocks and Sampled-Data Systems","text":"ODEProblem(model, [x(k) => 1.0], (0.0, 10.0))","category":"page"},{"location":"tutorials/SampledData/","page":"Clocks and Sampled-Data Systems","title":"Clocks and Sampled-Data Systems","text":"If higher-order shifts are present, the corresponding initial conditions must be specified, e.g., the presence of the equation","category":"page"},{"location":"tutorials/SampledData/","page":"Clocks and Sampled-Data Systems","title":"Clocks and Sampled-Data Systems","text":"x(k) = x(k - 1) + x(k - 2)","category":"page"},{"location":"tutorials/SampledData/","page":"Clocks and Sampled-Data Systems","title":"Clocks and Sampled-Data Systems","text":"requires specification of the initial condition for both x(k-1) and x(k-2).","category":"page"},{"location":"tutorials/SampledData/#Multiple-clocks","page":"Clocks and Sampled-Data Systems","title":"Multiple clocks","text":"","category":"section"},{"location":"tutorials/SampledData/","page":"Clocks and Sampled-Data Systems","title":"Clocks and Sampled-Data Systems","text":"Multi-rate systems are easy to model using multiple different clocks. The following set of equations is valid, and defines two different discrete-time partitions, each with its own clock:","category":"page"},{"location":"tutorials/SampledData/","page":"Clocks and Sampled-Data Systems","title":"Clocks and Sampled-Data Systems","text":"yd1 ~ Sample(dt1)(y)\nud1 ~ kp * (Sample(dt1)(r) - yd1)\nyd2 ~ Sample(dt2)(y)\nud2 ~ kp * (Sample(dt2)(r) - yd2)","category":"page"},{"location":"tutorials/SampledData/","page":"Clocks and Sampled-Data Systems","title":"Clocks and Sampled-Data Systems","text":"yd1 and ud1 belong to the same clock which ticks with an interval of dt1, while yd2 and ud2 belong to a different clock which ticks with an interval of dt2. The two clocks are not synchronized, i.e., they are not guaranteed to tick at the same point in time, even if one tick interval is a rational multiple of the other. Mechanisms for synchronization of clocks are not yet implemented.","category":"page"},{"location":"tutorials/SampledData/#Accessing-discrete-time-variables-in-the-solution","page":"Clocks and Sampled-Data Systems","title":"Accessing discrete-time variables in the solution","text":"","category":"section"},{"location":"tutorials/SampledData/#A-complete-example","page":"Clocks and Sampled-Data Systems","title":"A complete example","text":"","category":"section"},{"location":"tutorials/SampledData/","page":"Clocks and Sampled-Data Systems","title":"Clocks and Sampled-Data Systems","text":"Below, we model a simple continuous first-order system called plant that is controlled using a discrete-time controller controller. The reference signal is filtered using a discrete-time filter filt before being fed to the controller.","category":"page"},{"location":"tutorials/SampledData/","page":"Clocks and Sampled-Data Systems","title":"Clocks and Sampled-Data Systems","text":"using ModelingToolkit, Plots, OrdinaryDiffEq\nusing ModelingToolkit: t_nounits as t\nusing ModelingToolkit: D_nounits as D\ndt = 0.5 # Sample interval\n@variables r(t)\nclock = Clock(dt)\nk = ShiftIndex(clock)\n\nfunction plant(; name)\n    @variables x(t)=1 u(t)=0 y(t)=0\n    eqs = [D(x) ~ -x + u\n           y ~ x]\n    System(eqs, t; name = name)\nend\n\nfunction filt(; name) # Reference filter\n    @variables x(t)=0 u(t)=0 y(t)=0\n    a = 1 / exp(dt)\n    eqs = [x(k) ~ a * x(k - 1) + (1 - a) * u(k)\n           y ~ x]\n    System(eqs, t, name = name)\nend\n\nfunction controller(kp; name)\n    @variables y(t)=0 r(t)=0 ud(t)=0 yd(t)=0\n    @parameters kp = kp\n    eqs = [yd ~ Sample(y)\n           ud ~ kp * (r - yd)]\n    System(eqs, t; name = name)\nend\n\n@named f = filt()\n@named c = controller(1)\n@named p = plant()\n\nconnections = [r ~ sin(t)          # reference signal\n               f.u ~ r             # reference to filter input\n               f.y ~ c.r           # filtered reference to controller reference\n               Hold(c.ud) ~ p.u    # controller output to plant input (zero-order-hold)\n               p.y ~ c.y]          # plant output to controller feedback\n\n@named cl = System(connections, t, systems = [f, c, p])","category":"page"},{"location":"tutorials/SampledData/#ModelingToolkit.Sample-tutorials-SampledData","page":"Clocks and Sampled-Data Systems","title":"ModelingToolkit.Sample","text":"struct Sample <: Symbolics.Operator\n\nRepresents a sample operator. A discrete-time signal is created by sampling a continuous-time signal.\n\nConstructors\n\nSample(clock::Union{TimeDomain, InferredTimeDomain} = InferredDiscrete()) Sample(dt::Real)\n\nSample(x::Num), with a single argument, is shorthand for Sample()(x).\n\nFields\n\nclock\n\nExamples\n\njulia> using Symbolics\n\njulia> t = ModelingToolkit.t_nounits\n\njulia> Δ = Sample(0.01)\n(::Sample) (generic function with 2 methods)\n\n\n\n\n\n","category":"type"},{"location":"tutorials/SampledData/#ModelingToolkit.Hold-tutorials-SampledData","page":"Clocks and Sampled-Data Systems","title":"ModelingToolkit.Hold","text":"struct Hold <: Symbolics.Operator\n\nRepresents a hold operator. A continuous-time signal is produced by holding a discrete-time signal x with zero-order hold.\n\ncont_x = Hold()(disc_x)\n\n\n\n\n\n","category":"type"},{"location":"tutorials/SampledData/#ModelingToolkit.ShiftIndex-tutorials-SampledData","page":"Clocks and Sampled-Data Systems","title":"ModelingToolkit.ShiftIndex","text":"ShiftIndex\n\nThe ShiftIndex operator allows you to index a signal and obtain a shifted discrete-time signal. If the signal is continuous-time, the signal is sampled before shifting.\n\nExamples\n\njulia> t = ModelingToolkit.t_nounits;\n\njulia> @variables x(t);\n\njulia> k = ShiftIndex(t, 0.1);\n\njulia> x(k)      # no shift\nx(t)\n\njulia> x(k+1)    # shift\nShift(1)(x(t))\n\n\n\n\n\n","category":"type"},{"location":"tutorials/initialization/#initialization","page":"Initialization of Systems","title":"Initialization of Systems","text":"","category":"section"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"While for simple numerical ODEs choosing an initial condition can be an easy affair, with ModelingToolkit's more general differential-algebraic equation (DAE) system there is more care needed due to the flexibility of the solver state. In this tutorial we will walk through the functionality involved in initialization of System and the diagnostics to better understand and debug the initialization problem.","category":"page"},{"location":"tutorials/initialization/#Primer-on-Initialization-of-Differential-Algebraic-Equations","page":"Initialization of Systems","title":"Primer on Initialization of Differential-Algebraic Equations","text":"","category":"section"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"Before getting started, let's do a brief walkthrough of the mathematical principles of initialization of DAE systems. Take a DAE written in semi-explicit form:","category":"page"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"beginaligned\n    x^prime = f(xyt) \n    0 = g(xyt)\nendaligned","category":"page"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"where x are the differential variables and y are the algebraic variables. An initial condition u0 = x(t_0) y(t_0) is said to be consistent if g(x(t_0)y(t_0)t_0) = 0.","category":"page"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"For ODEs, this is trivially satisfied. However, for more complicated systems it may not be easy to know how to choose the variables such that all of the conditions are satisfied. This is even more complicated when taking into account ModelingToolkit's simplification engine, given that variables can be eliminated and equations can be changed. If this happens, how do you know how to initialize the system?","category":"page"},{"location":"tutorials/initialization/#Initialization-By-Example:-The-Cartesian-Pendulum","page":"Initialization of Systems","title":"Initialization By Example: The Cartesian Pendulum","text":"","category":"section"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"To illustrate how to perform the initialization, let's take a look at the Cartesian pendulum:","category":"page"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"using ModelingToolkit, OrdinaryDiffEq, Plots\nusing ModelingToolkit: t_nounits as t, D_nounits as D\n\n@parameters g\n@variables x(t) y(t) [state_priority = 10] λ(t)\neqs = [D(D(x)) ~ λ * x\n       D(D(y)) ~ λ * y - g\n       x^2 + y^2 ~ 1]\n@mtkcompile pend = System(eqs, t)","category":"page"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"While we defined the system using second derivatives and a length constraint, the structural simplification system improved the numerics of the system to be solvable using the dummy derivative technique, which results in 3 algebraic equations and 2 differential equations. In this case, the differential equations with respect to y and D(y), though it could have just as easily have been x and D(x). How do you initialize such a system if you don't know in advance what variables may defined the equation's state?","category":"page"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"To see how the system works, let's start the pendulum in the far right position, i.e. x(0) = 1 and y(0) = 0. We can do this by:","category":"page"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"prob = ODEProblem(pend, [x => 1, y => 0, g => 1], (0.0, 1.5), guesses = [λ => 1])","category":"page"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"This solves via:","category":"page"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"sol = solve(prob, Rodas5P())\nplot(sol, idxs = (x, y))","category":"page"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"and we can check it satisfies our conditions via:","category":"page"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"conditions = getfield.(equations(pend)[3:end], :rhs)","category":"page"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"[sol[conditions][1]; sol[x][1] - 1; sol[y][1]]","category":"page"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"Notice that we set [x => 1, y => 0] as our initial conditions and [λ => 1] as our guess. The difference is that the initial conditions are required to be satisfied, while the guesses are simply a guess for what the initial value might be. Every variable must have either an initial condition or a guess, and thus since we did not know what λ would be we set it to 1 and let the initialization scheme find the correct value for λ. Indeed, the value for λ at the initial time is not 1:","category":"page"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"sol[λ][1]","category":"page"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"We can similarly choose λ = 0 and solve for y to start the system:","category":"page"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"prob = ODEProblem(pend, [x => 1, λ => 0, g => 1], (0.0, 1.5); guesses = [y => 1])\nsol = solve(prob, Rodas5P())\nplot(sol, idxs = (x, y))","category":"page"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"or choose to satisfy derivative conditions:","category":"page"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"prob = ODEProblem(\n    pend, [x => 1, D(y) => 0, g => 1], (0.0, 1.5); guesses = [λ => 0, y => 1])\nsol = solve(prob, Rodas5P())\nplot(sol, idxs = (x, y))","category":"page"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"Notice that since a derivative condition is given, we are required to give a guess for y.","category":"page"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"We can also directly give equations to be satisfied at the initial point by using the initialization_eqs keyword argument, for example:","category":"page"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"prob = ODEProblem(pend, [x => 1, g => 1], (0.0, 1.5); guesses = [λ => 0, y => 1],\n    initialization_eqs = [y ~ 0])\nsol = solve(prob, Rodas5P())\nplot(sol, idxs = (x, y))","category":"page"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"Additionally, note that the initial conditions are allowed to be functions of other variables and parameters:","category":"page"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"prob = ODEProblem(\n    pend, [x => 1, D(y) => g, g => 1], (0.0, 3.0); guesses = [λ => 0, y => 1])\nsol = solve(prob, Rodas5P())\nplot(sol, idxs = (x, y))","category":"page"},{"location":"tutorials/initialization/#Determinability:-Underdetermined-and-Overdetermined-Systems","page":"Initialization of Systems","title":"Determinability: Underdetermined and Overdetermined Systems","text":"","category":"section"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"For this system we have 3 conditions to satisfy:","category":"page"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"conditions = getfield.(equations(pend)[3:end], :rhs)","category":"page"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"when we initialize with","category":"page"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"prob = ODEProblem(pend, [x => 1, y => 0, g => 1], (0.0, 1.5); guesses = [y => 0, λ => 1])","category":"page"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"we have two extra conditions to satisfy, x ~ 1 and y ~ 0 at the initial point. That gives 5 equations for 5 variables and thus the system is well-formed. What happens if that's not the case?","category":"page"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"prob = ODEProblem(pend, [x => 1, g => 1], (0.0, 1.5); guesses = [y => 0, λ => 1])","category":"page"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"Here we have 4 equations for 5 unknowns (note: the warning is post-simplification of the nonlinear system, which solves the trivial x ~ 1 equation analytical and thus says 3 equations for 4 unknowns). This warning thus lets you know the system is underdetermined and thus the solution is not necessarily unique. It can still be solved:","category":"page"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"sol = solve(prob, Rodas5P())\nplot(sol, idxs = (x, y))","category":"page"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"and the found initial condition satisfies all constraints which were given. In the opposite direction, we may have an overdetermined system:","category":"page"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"prob = ODEProblem(\n    pend, [x => 1, y => 0.0, D(y) => 0, g => 1], (0.0, 1.5); guesses = [λ => 1])","category":"page"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"Can that be solved?","category":"page"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"sol = solve(prob, Rodas5P())\nplot(sol, idxs = (x, y))","category":"page"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"Indeed since we saw D(y) = 0 at the initial point above, it turns out that this solution is solvable with the chosen initial conditions. However, for overdetermined systems we often aren't that lucky. If the set of initial conditions cannot be satisfied, then you will get a SciMLBase.ReturnCode.InitialFailure:","category":"page"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"prob = ODEProblem(\n    pend, [x => 1, y => 0.0, D(y) => 2.0, λ => 1, g => 1], (0.0, 1.5); guesses = [λ => 1])\nsol = solve(prob, Rodas5P())","category":"page"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"What this means is that the initial condition finder failed to find an initial condition. While this can be sometimes due to numerical error (which is then helped by picking guesses closer to the correct value), most circumstances of this come from ill-formed models. Especially if your system is overdetermined and you receive an InitialFailure, the initial conditions may not be analytically satisfiable!. In our case here, if you sit down with a pen and paper long enough you will see that λ = 0 is required for this equation, but since we chose λ = 1 we end up with a set of equations that are impossible to satisfy.","category":"page"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"note: Note\nIf you would prefer to have an error instead of a warning in the context of non-fully determined systems, pass the keyword argument fully_determined = true into the problem constructor. Additionally, any warning about not being fully determined can be suppressed via passing warn_initialize_determined = false.","category":"page"},{"location":"tutorials/initialization/#Constant-constraints-in-initialization","page":"Initialization of Systems","title":"Constant constraints in initialization","text":"","category":"section"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"Consider the pendulum system again:","category":"page"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"equations(pend)\nobserved(pend)","category":"page"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"Suppose we want to solve the same system with multiple different initial y-velocities from a given position.","category":"page"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"prob = ODEProblem(\n    pend, [x => 1, D(y) => 0, g => 1], (0.0, 1.5); guesses = [λ => 0, y => 1, x => 1])\nsol1 = solve(prob, Rodas5P())","category":"page"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"sol1[D(y), 1]","category":"page"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"Repeatedly re-creating the ODEProblem with different values of D(y) and x or repeatedly calling remake is slow. Instead, for any variable => constant constraint in the ODEProblem initialization (whether provided to the ODEProblem constructor or a default value) we can update the constant value. ModelingToolkit refers to these values using the Initial operator. For example:","category":"page"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"prob.ps[[Initial(x), Initial(D(y))]]","category":"page"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"To solve with a different starting y-velocity, we can simply do","category":"page"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"prob.ps[Initial(D(y))] = -0.1\nsol2 = solve(prob, Rodas5P())","category":"page"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"sol2[D(y), 1]","category":"page"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"Note that this only applies for constant constraints for the current ODEProblem. For example, D(x) does not have a constant constraint - it is solved for by initialization. Thus, mutating Initial(D(x)) does not have any effect:","category":"page"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"sol2[D(x), 1]\nprob.ps[Initial(D(x))] = 1.0\nsol3 = solve(prob, Rodas5P())\nsol3[D(x), 1]","category":"page"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"To enforce this constraint, we would have to remake the problem (or construct a new one).","category":"page"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"prob2 = remake(prob; u0 = [y => 0.0, D(x) => 0.0, x => nothing, D(y) => nothing]);\nsol4 = solve(prob2, Rodas5P())\nsol4[D(x), 1]","category":"page"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"Note the need to provide x => nothing, D(y) => nothing to override the previously provided initial conditions. Since remake is a partial update, the constraints provided to it are merged with the ones already present in the problem. Existing constraints can be removed by providing a value of nothing.","category":"page"},{"location":"tutorials/initialization/#Initialization-of-parameters","page":"Initialization of Systems","title":"Initialization of parameters","text":"","category":"section"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"Parameters may also be treated as unknowns in the initialization system. Doing so works almost identically to the standard case. For a parameter to be an initialization unknown (henceforth referred to as \"solved parameter\") it must represent a floating point number (have a symtype of Real or <:AbstractFloat) or an array of such numbers. Additionally, it must have a guess and one of the following conditions must be satisfied:","category":"page"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"The value of the parameter as passed to ODEProblem is an expression involving other variables/parameters. For example, if [p => 2q + x] is passed to ODEProblem. In this case, p ~ 2q + x is used as an equation during initialization.\nThe parameter has a default (and no value for it is given to ODEProblem, since that is condition 1). The default will be used as an equation during initialization.\nThe parameter has a default of missing. If ODEProblem is given a value for this parameter, it is used as an equation during initialization (whether the value is an expression or not).\nODEProblem is given a value of missing for the parameter. If the parameter has a default, it will be used as an equation during initialization.","category":"page"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"All parameter dependencies (where the dependent parameter is a floating point number or array thereof) also become equations during initialization, and the dependent parameters become unknowns.","category":"page"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"remake will reconstruct the initialization system and problem, given the new constraints provided to it. The new values will be combined with the original variable-value mapping provided to ODEProblem and used to construct the initialization problem.","category":"page"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"The variable on the left hand side of all parameter dependencies also has an Initial variant, which is used if a constant constraint is provided for the variable.","category":"page"},{"location":"tutorials/initialization/#Parameter-initialization-by-example","page":"Initialization of Systems","title":"Parameter initialization by example","text":"","category":"section"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"Consider the following system, where the sum of two unknowns is a constant parameter total.","category":"page"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"using ModelingToolkit, OrdinaryDiffEq # hidden\nusing ModelingToolkit: t_nounits as t, D_nounits as D # hidden\n\n@variables x(t) y(t)\n@parameters total\n@mtkcompile sys = System([D(x) ~ -x, total ~ x + y], t;\n    defaults = [total => missing], guesses = [total => 1.0])","category":"page"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"Given any two of x, y and total we can determine the remaining variable.","category":"page"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"prob = ODEProblem(sys, [x => 1.0, y => 2.0], (0.0, 1.0))\ninteg = init(prob, Tsit5())\n@assert integ.ps[total] ≈ 3.0 # hide\ninteg.ps[total]","category":"page"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"Suppose we want to re-create this problem, but now solve for x given total and y:","category":"page"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"prob2 = remake(prob; u0 = [y => 1.0], p = [total => 4.0])\ninitsys = prob2.f.initializeprob.f.sys","category":"page"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"The system is now overdetermined. In fact:","category":"page"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"[equations(initsys); observed(initsys)]","category":"page"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"The system can never be satisfied and will always lead to an InitialFailure. This is due to the aforementioned behavior of retaining the original variable-value mapping provided to ODEProblem. To fix this, we pass x => nothing to remake to remove its retained value.","category":"page"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"prob2 = remake(prob; u0 = [y => 1.0, x => nothing], p = [total => 4.0])\ninitsys = prob2.f.initializeprob.f.sys","category":"page"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"The system is fully determined, and the equations are solvable.","category":"page"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"[equations(initsys); observed(initsys)]","category":"page"},{"location":"tutorials/initialization/#Diving-Deeper:-Constructing-the-Initialization-System","page":"Initialization of Systems","title":"Diving Deeper: Constructing the Initialization System","text":"","category":"section"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"To get a better sense of the initialization system and to help debug it, you can construct the initialization system directly. The initialization system is a NonlinearSystem which requires the system-level information and the additional nonlinear equations being tagged to the system.","category":"page"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"isys = generate_initializesystem(pend; op = [x => 1.0, y => 0.0], guesses = [λ => 1])","category":"page"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"We can inspect what its equations and unknown values are:","category":"page"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"equations(isys)","category":"page"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"unknowns(isys)","category":"page"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"Notice that all initial conditions are treated as initial equations. Additionally, for systems with observables, those observables are too treated as initial equations. We can see the resulting simplified system via the command:","category":"page"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"isys = mtkcompile(isys; fully_determined = false)","category":"page"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"Note fully_determined=false allows for the simplification to occur when the number of equations does not match the number of unknowns, which we can use to investigate our overdetermined system:","category":"page"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"isys = ModelingToolkit.generate_initializesystem(\n    pend; op = [x => 1, y => 0.0, D(y) => 2.0, λ => 1], guesses = [λ => 1])","category":"page"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"isys = mtkcompile(isys; fully_determined = false)","category":"page"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"equations(isys)","category":"page"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"unknowns(isys)","category":"page"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"observed(isys)","category":"page"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"After simplification we see that we have 5 equatinos to solve with 3 variables, and the system that is given is not solvable.","category":"page"},{"location":"tutorials/initialization/#Numerical-Isolation:-InitializationProblem","page":"Initialization of Systems","title":"Numerical Isolation: InitializationProblem","text":"","category":"section"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"To inspect the numerics of the initialization problem, we can use the InitializationProblem constructor which acts just like an ODEProblem or NonlinearProblem constructor, but creates the special initialization system for a given sys. This is done as follows:","category":"page"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"iprob = ModelingToolkit.InitializationProblem(pend, 0.0,\n    [x => 1, y => 0.0, D(y) => 2.0, λ => 1, g => 1], guesses = [λ => 1])","category":"page"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"We can see that because the system is overdetermined we receive a NonlinearLeastSquaresProblem, solvable by NonlinearSolve.jl. Using NonlinearSolve we can recreate the initialization solve directly:","category":"page"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"using NonlinearSolve\nsol = solve(iprob)","category":"page"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"note: Note\nFor more information on solving NonlinearProblems and NonlinearLeastSquaresProblems, check out the NonlinearSolve.jl tutorials!.","category":"page"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"We can see that the default solver stalls","category":"page"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"sol.stats","category":"page"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"after doing many iterations, showing that it tried to compute but could not find a valid solution. Trying other solvers:","category":"page"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"sol = solve(iprob, GaussNewton())","category":"page"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"gives the same issue, indicating that the chosen initialization system is unsatisfiable. We can check the residuals:","category":"page"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"sol.resid","category":"page"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"to see the problem is not equation 2 but other equations in the system. Meanwhile, changing some of the conditions:","category":"page"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"iprob = ModelingToolkit.InitializationProblem(pend, 0.0,\n    [x => 1, y => 0.0, D(y) => 0.0, λ => 0, g => 1], guesses = [λ => 1])","category":"page"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"gives a NonlinearLeastSquaresProblem which can be solved:","category":"page"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"sol = solve(iprob)","category":"page"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"sol.resid","category":"page"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"In comparison, if we have a well-conditioned system:","category":"page"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"iprob = ModelingToolkit.InitializationProblem(pend, 0.0,\n    [x => 1, y => 0.0, g => 1], guesses = [λ => 1])","category":"page"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"notice that we instead obtained a NonlinearSystem. In this case we have to use different solvers which can take advantage of the fact that the Jacobian is square.","category":"page"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"sol = solve(iprob)","category":"page"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"sol = solve(iprob, TrustRegion())","category":"page"},{"location":"tutorials/initialization/#More-Features-of-the-Initialization-System:-Steady-State-and-Observable-Initialization","page":"Initialization of Systems","title":"More Features of the Initialization System: Steady-State and Observable Initialization","text":"","category":"section"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"Let's take a Lotka-Volterra system:","category":"page"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"@variables x(t) y(t) z(t)\n@parameters α=1.5 β=1.0 γ=3.0 δ=1.0\n\neqs = [D(x) ~ α * x - β * x * y\n       D(y) ~ -γ * y + δ * x * y\n       z ~ x + y]\n\n@named sys = System(eqs, t)\nsimpsys = mtkcompile(sys)\ntspan = (0.0, 10.0)","category":"page"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"Using the derivative initializations, we can set the ODE to start at the steady state by initializing the derivatives to zero:","category":"page"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"prob = ODEProblem(simpsys, [D(x) => 0.0, D(y) => 0.0], tspan, guesses = [x => 1, y => 1])\nsol = solve(prob, Tsit5(), abstol = 1e-16)","category":"page"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"Notice that this is a \"numerical zero\", not an exact zero, and thus the solution will leave the steady state in this instance because it's an unstable steady state.","category":"page"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"Additionally, notice that in this setup we have an observable z ~ x + y. If we instead know the initial condition for the observable we can use that directly:","category":"page"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"prob = ODEProblem(simpsys, [D(x) => 0.0, z => 2.0], tspan, guesses = [x => 1, y => 1])\nsol = solve(prob, Tsit5())","category":"page"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"We can check that indeed the solution does satisfy that D(x) = 0 at the start:","category":"page"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"sol[α * x - β * x * y]","category":"page"},{"location":"tutorials/initialization/","page":"Initialization of Systems","title":"Initialization of Systems","text":"plot(sol)","category":"page"},{"location":"tutorials/initialization/#Summary-of-Initialization-API","page":"Initialization of Systems","title":"Summary of Initialization API","text":"","category":"section"},{"location":"tutorials/initialization/#ModelingToolkit.Initial-tutorials-initialization","page":"Initialization of Systems","title":"ModelingToolkit.Initial","text":"Initial(x)\n\nThe Initial operator. Used by initialization to store constant constraints on variables of a system. See the documentation section on initialization for more information.\n\n\n\n\n\n","category":"type"},{"location":"tutorials/initialization/#ModelingToolkit.isinitial-tutorials-initialization","page":"Initialization of Systems","title":"ModelingToolkit.isinitial","text":"Returns true if the parameter p is of the form Initial(x).\n\n\n\n\n\n","category":"function"},{"location":"tutorials/initialization/#ModelingToolkit.generate_initializesystem-tutorials-initialization","page":"Initialization of Systems","title":"ModelingToolkit.generate_initializesystem","text":"generate_initializesystem(\n    sys::ModelingToolkit.AbstractSystem;\n    time_dependent_init,\n    kwargs...\n) -> System\n\n\nGenerate the initialization system for sys. The initialization system is a system of nonlinear equations that solve for the full set of initial conditions of sys given specified constraints.\n\nThe initialization system can be of two types: time-dependent and time-independent. Time-dependent initialization systems solve for the initial values of unknowns as well as the values of solvable parameters of the system. Time-independent initialization systems only solve for solvable parameters of the system.\n\nKeyword arguments\n\ntime_dependent_init: Whether to create an initialization system for a time-dependent system. A time-dependent initialization requires a time-dependent sys, but a time- independent initialization can be created regardless.\nop: The operating point of user-specified initial conditions of variables in sys.\ninitialization_eqs: Additional initialization equations to use apart from those in initialization_equations(sys).\nguesses: Additional guesses to use apart from those in guesses(sys).\ndefault_dd_guess: Default guess for dummy derivative variables in time-dependent initialization.\nalgebraic_only: If false, does not use initialization equations (provided via the keyword or part of the system) to construct initialization.\ncheck_defguess: Whether to error when a variable does not have a default or guess despite ModelingToolkit expecting it to.\nname: The name of the initialization system.\n\nAll other keyword arguments are forwarded to the System constructor.\n\n\n\n\n\n","category":"function"},{"location":"tutorials/initialization/#ModelingToolkit.initialization_equations-tutorials-initialization","page":"Initialization of Systems","title":"ModelingToolkit.initialization_equations","text":"initialization_equations(\n    sys::ModelingToolkit.AbstractSystem\n) -> Any\n\n\nGet the initialization equations of the system sys and its subsystems.\n\nSee also guesses, defaults and ModelingToolkit.get_initialization_eqs.\n\n\n\n\n\n","category":"function"},{"location":"tutorials/initialization/#ModelingToolkit.guesses-tutorials-initialization","page":"Initialization of Systems","title":"ModelingToolkit.guesses","text":"guesses(sys::ModelingToolkit.AbstractSystem) -> Any\n\n\nGet the guesses for variables in the initialization system of the system sys and its subsystems.\n\nSee also initialization_equations and ModelingToolkit.get_guesses.\n\n\n\n\n\n","category":"function"},{"location":"tutorials/initialization/#ModelingToolkit.defaults-tutorials-initialization","page":"Initialization of Systems","title":"ModelingToolkit.defaults","text":"defaults(sys::ModelingToolkit.AbstractSystem) -> Any\n\n\nGet the default values of the system sys and its subsystems. If they are not explicitly provided, variables and parameters are initialized to these values.\n\nSee also initialization_equations and ModelingToolkit.get_defaults.\n\n\n\n\n\n","category":"function"},{"location":"basics/Events/#events","page":"Event Handling and Callback Functions","title":"Event Handling and Callback Functions","text":"","category":"section"},{"location":"basics/Events/","page":"Event Handling and Callback Functions","title":"Event Handling and Callback Functions","text":"ModelingToolkit provides several ways to represent system events, which enable system state or parameters to be changed when certain conditions are satisfied, or can be used to detect discontinuities. These events are ultimately converted into DifferentialEquations.jl ContinuousCallbacks or DiscreteCallbacks, or into more specialized callback types from the DiffEqCallbacks.jl library.","category":"page"},{"location":"basics/Events/","page":"Event Handling and Callback Functions","title":"Event Handling and Callback Functions","text":"Systems and SDESystems accept keyword arguments continuous_events and discrete_events to symbolically encode continuous or discrete callbacks. JumpSystems currently support only discrete_events. Continuous events are applied when a given condition becomes zero, with root finding used to determine the time at which a zero crossing occurred. Discrete events are applied when a condition tested after each timestep evaluates to true. See the DifferentialEquations docs for more detail.","category":"page"},{"location":"basics/Events/","page":"Event Handling and Callback Functions","title":"Event Handling and Callback Functions","text":"Events involve both a condition function (for the zero crossing or truth test), and an affect function (for determining how to update the system when the event occurs). These can both be specified symbolically, but a more general functional affect representation is also allowed, as described below.","category":"page"},{"location":"basics/Events/#Symbolic-Callback-Semantics","page":"Event Handling and Callback Functions","title":"Symbolic Callback Semantics","text":"","category":"section"},{"location":"basics/Events/","page":"Event Handling and Callback Functions","title":"Event Handling and Callback Functions","text":"In callbacks, there is a distinction between values of the unknowns and parameters before the callback, and the desired values after the callback. In MTK, this is provided by the Pre operator. For example, if we would like to add 1 to an unknown x in a callback, the equation would look like the following:","category":"page"},{"location":"basics/Events/","page":"Event Handling and Callback Functions","title":"Event Handling and Callback Functions","text":"x ~ Pre(x) + 1","category":"page"},{"location":"basics/Events/","page":"Event Handling and Callback Functions","title":"Event Handling and Callback Functions","text":"Non Pre-d values will be interpreted as values after the callback. As such, writing","category":"page"},{"location":"basics/Events/","page":"Event Handling and Callback Functions","title":"Event Handling and Callback Functions","text":"x ~ x + 1","category":"page"},{"location":"basics/Events/","page":"Event Handling and Callback Functions","title":"Event Handling and Callback Functions","text":"will be interpreted as an algebraic equation to be satisfied after the callback. Since this equation obviously cannot be satisfied, an error will result.","category":"page"},{"location":"basics/Events/","page":"Event Handling and Callback Functions","title":"Event Handling and Callback Functions","text":"Callbacks must maintain the consistency of DAEs, meaning that they must satisfy all the algebraic equations of the system after their update. However, the affect equations often do not fully specify which unknowns/parameters should be modified to maintain consistency. To make this clear, MTK uses the following rules:","category":"page"},{"location":"basics/Events/","page":"Event Handling and Callback Functions","title":"Event Handling and Callback Functions","text":"All unknowns are treated as modifiable by the callback. In order to enforce that an unknown x remains the same, one can add x ~ Pre(x) to the affect equations.\nAll parameters are treated as un-modifiable, unless they are declared as discrete_parameters to the callback. In order to be a discrete parameter, the parameter must be time-dependent (the terminology discretes here means discrete variables).","category":"page"},{"location":"basics/Events/","page":"Event Handling and Callback Functions","title":"Event Handling and Callback Functions","text":"For example, consider the following system.","category":"page"},{"location":"basics/Events/","page":"Event Handling and Callback Functions","title":"Event Handling and Callback Functions","text":"@variables x(t) y(t)\n@parameters p(t)\n@mtkcompile sys = System([x * y ~ p, D(x) ~ 0], t)\nevent = [t == 1] => [x ~ Pre(x) + 1]","category":"page"},{"location":"basics/Events/","page":"Event Handling and Callback Functions","title":"Event Handling and Callback Functions","text":"By default what will happen is that x will increase by 1, p will remain constant, and y will change in order to compensate the increase in x. But what if we wanted to keep y constant and change p instead? We could use the callback constructor as follows:","category":"page"},{"location":"basics/Events/","page":"Event Handling and Callback Functions","title":"Event Handling and Callback Functions","text":"event = SymbolicDiscreteCallback(\n    [t == 1] => [x ~ Pre(x) + 1, y ~ Pre(y)], discrete_parameters = [p])","category":"page"},{"location":"basics/Events/","page":"Event Handling and Callback Functions","title":"Event Handling and Callback Functions","text":"This way, we enforce that y will remain the same, and p will change.","category":"page"},{"location":"basics/Events/","page":"Event Handling and Callback Functions","title":"Event Handling and Callback Functions","text":"warning: Warning\nSymbolic affects come with the guarantee that the state after the callback will be consistent. However, when using general functional affects or imperative affects one must be more careful. In particular, one can pass in reinitializealg as a keyword arg to the callback constructor to re-initialize the system. This will default to SciMLBase.NoInit() in the case of symbolic affects and SciMLBase.CheckInit() in the case of functional affects. This keyword should not be provided if the affect is purely symbolic.","category":"page"},{"location":"basics/Events/#Continuous-Events","page":"Event Handling and Callback Functions","title":"Continuous Events","text":"","category":"section"},{"location":"basics/Events/","page":"Event Handling and Callback Functions","title":"Event Handling and Callback Functions","text":"The basic purely symbolic continuous event interface to encode one continuous event is","category":"page"},{"location":"basics/Events/","page":"Event Handling and Callback Functions","title":"Event Handling and Callback Functions","text":"AbstractSystem(eqs, _...; continuous_events::Vector{Equation})\nAbstractSystem(eqs, _...; continuous_events::Pair{Vector{Equation}, Vector{Equation}})","category":"page"},{"location":"basics/Events/","page":"Event Handling and Callback Functions","title":"Event Handling and Callback Functions","text":"In the former, equations that evaluate to 0 will represent conditions that should be detected by the integrator, for example to force stepping to times of discontinuities. The latter allow modeling of events that have an effect on the state, where the first entry in the Pair is a vector of equations describing event conditions, and the second vector of equations describes the effect on the state. Each affect equation must be of the form","category":"page"},{"location":"basics/Events/","page":"Event Handling and Callback Functions","title":"Event Handling and Callback Functions","text":"single_unknown_variable ~ expression_involving_any_variables_or_parameters","category":"page"},{"location":"basics/Events/","page":"Event Handling and Callback Functions","title":"Event Handling and Callback Functions","text":"or","category":"page"},{"location":"basics/Events/","page":"Event Handling and Callback Functions","title":"Event Handling and Callback Functions","text":"single_parameter ~ expression_involving_any_variables_or_parameters","category":"page"},{"location":"basics/Events/","page":"Event Handling and Callback Functions","title":"Event Handling and Callback Functions","text":"In this basic interface, multiple variables can be changed in one event, or multiple parameters, but not a mix of parameters and variables. The latter can be handled via more general functional affects.","category":"page"},{"location":"basics/Events/","page":"Event Handling and Callback Functions","title":"Event Handling and Callback Functions","text":"Finally, multiple events can be encoded via a Vector{Pair{Vector{Equation}, Vector{Equation}}}.","category":"page"},{"location":"basics/Events/#Example:-Friction","page":"Event Handling and Callback Functions","title":"Example: Friction","text":"","category":"section"},{"location":"basics/Events/","page":"Event Handling and Callback Functions","title":"Event Handling and Callback Functions","text":"The system below illustrates how continuous events can be used to model Coulomb friction","category":"page"},{"location":"basics/Events/","page":"Event Handling and Callback Functions","title":"Event Handling and Callback Functions","text":"using ModelingToolkit, OrdinaryDiffEq, Plots\nusing ModelingToolkit: t_nounits as t, D_nounits as D\n\nfunction UnitMassWithFriction(k; name)\n    @variables x(t)=0 v(t)=0\n    eqs = [D(x) ~ v\n           D(v) ~ sin(t) - k * sign(v)]\n    System(eqs, t; continuous_events = [v ~ 0], name) # when v = 0 there is a discontinuity\nend\n@mtkcompile m = UnitMassWithFriction(0.7)\nprob = ODEProblem(m, Pair[], (0, 10pi))\nsol = solve(prob, Tsit5())\nplot(sol)","category":"page"},{"location":"basics/Events/#Example:-Bouncing-ball","page":"Event Handling and Callback Functions","title":"Example: Bouncing ball","text":"","category":"section"},{"location":"basics/Events/","page":"Event Handling and Callback Functions","title":"Event Handling and Callback Functions","text":"In the documentation for DifferentialEquations, we have an example where a bouncing ball is simulated using callbacks which have an affect! on the state. We can model the same system using ModelingToolkit like this","category":"page"},{"location":"basics/Events/","page":"Event Handling and Callback Functions","title":"Event Handling and Callback Functions","text":"@variables x(t)=1 v(t)=0\n\nroot_eqs = [x ~ 0]  # the event happens at the ground x(t) = 0\naffect = [v ~ -Pre(v)] # the effect is that the velocity changes sign\n\n@mtkcompile ball = System(\n    [D(x) ~ v\n     D(v) ~ -9.8], t; continuous_events = root_eqs => affect) # equation => affect\n\ntspan = (0.0, 5.0)\nprob = ODEProblem(ball, Pair[], tspan)\nsol = solve(prob, Tsit5())\n@assert 0 <= minimum(sol[x]) <= 1e-10 # the ball never went through the floor but got very close\nplot(sol)","category":"page"},{"location":"basics/Events/#Test-bouncing-ball-in-2D-with-walls","page":"Event Handling and Callback Functions","title":"Test bouncing ball in 2D with walls","text":"","category":"section"},{"location":"basics/Events/","page":"Event Handling and Callback Functions","title":"Event Handling and Callback Functions","text":"Multiple events? No problem! This example models a bouncing ball in 2D that is enclosed by two walls at y = pm 15.","category":"page"},{"location":"basics/Events/","page":"Event Handling and Callback Functions","title":"Event Handling and Callback Functions","text":"@variables x(t)=1 y(t)=0 vx(t)=0 vy(t)=2\n\ncontinuous_events = [[x ~ 0] => [vx ~ -Pre(vx)]\n                     [y ~ -1.5, y ~ 1.5] => [vy ~ -Pre(vy)]]\n\n@mtkcompile ball = System(\n    [\n        D(x) ~ vx,\n        D(y) ~ vy,\n        D(vx) ~ -9.8 - 0.1vx, # gravity + some small air resistance\n        D(vy) ~ -0.1vy\n    ], t; continuous_events)\n\ntspan = (0.0, 10.0)\nprob = ODEProblem(ball, Pair[], tspan)\n\nsol = solve(prob, Tsit5())\n@assert 0 <= minimum(sol[x]) <= 1e-10 # the ball never went through the floor but got very close\n@assert minimum(sol[y]) >= -1.5 # check wall conditions\n@assert maximum(sol[y]) <= 1.5  # check wall conditions\n\ntv = sort([LinRange(0, 10, 200); sol.t])\nplot(sol(tv)[y], sol(tv)[x], line_z = tv)\nvline!([-1.5, 1.5], l = (:black, 5), primary = false)\nhline!([0], l = (:black, 5), primary = false)","category":"page"},{"location":"basics/Events/#func_affects","page":"Event Handling and Callback Functions","title":"Generalized functional affect support","text":"","category":"section"},{"location":"basics/Events/","page":"Event Handling and Callback Functions","title":"Event Handling and Callback Functions","text":"In some instances, a more flexible response to events is needed, which cannot be encapsulated by symbolic equations. For example, a component may implement complex behavior that is inconvenient or impossible to represent symbolically. ModelingToolkit therefore supports regular Julia functions as affects: instead of one or more equations, an affect is defined as a tuple:","category":"page"},{"location":"basics/Events/","page":"Event Handling and Callback Functions","title":"Event Handling and Callback Functions","text":"[x ~ 0] => (affect!, [v, x], [p, q], [discretes...], ctx)","category":"page"},{"location":"basics/Events/","page":"Event Handling and Callback Functions","title":"Event Handling and Callback Functions","text":"where, affect! is a Julia function with the signature: affect!(integ, u, p, ctx); [u,v] and [p,q] are the symbolic unknowns (variables) and parameters that are accessed by affect!, respectively; discretes are the parameters modified by affect!, if any; and ctx is any context that is passed to affect! as the ctx argument.","category":"page"},{"location":"basics/Events/","page":"Event Handling and Callback Functions","title":"Event Handling and Callback Functions","text":"affect! receives a DifferentialEquations.jl integrator as its first argument, which can then be used to access unknowns and parameters that are provided in the u and p arguments (implemented as NamedTuples). The integrator can also be manipulated more generally to control solution behavior, see the integrator interface documentation. In affect functions, we have that","category":"page"},{"location":"basics/Events/","page":"Event Handling and Callback Functions","title":"Event Handling and Callback Functions","text":"function affect!(integ, u, p, ctx)\n    # integ.t is the current time\n    # integ.u[u.v] is the value of the unknown `v` above\n    # integ.ps[p.q] is the value of the parameter `q` above\nend","category":"page"},{"location":"basics/Events/","page":"Event Handling and Callback Functions","title":"Event Handling and Callback Functions","text":"When accessing variables of a sub-system, it can be useful to rename them (alternatively, an affect function may be reused in different contexts):","category":"page"},{"location":"basics/Events/","page":"Event Handling and Callback Functions","title":"Event Handling and Callback Functions","text":"[x ~ 0] => (affect!, [resistor₊v => :v, x], [p, q => :p2], [], ctx)","category":"page"},{"location":"basics/Events/","page":"Event Handling and Callback Functions","title":"Event Handling and Callback Functions","text":"Here, the symbolic variable resistor₊v is passed as v while the symbolic parameter q has been renamed p2.","category":"page"},{"location":"basics/Events/","page":"Event Handling and Callback Functions","title":"Event Handling and Callback Functions","text":"As an example, here is the bouncing ball example from above using the functional affect interface:","category":"page"},{"location":"basics/Events/","page":"Event Handling and Callback Functions","title":"Event Handling and Callback Functions","text":"sts = @variables x(t), v(t)\npar = @parameters g = 9.8\nbb_eqs = [D(x) ~ v\n          D(v) ~ -g]\n\nfunction bb_affect!(mod, obs, integ, ctx)\n    return (; v = -mod.v)\nend\n\nreflect = [x ~ 0] => (bb_affect!, (; v))\n\n@mtkcompile bb_sys = System(bb_eqs, t, sts, par,\n    continuous_events = reflect)\n\nu0 = [v => 0.0, x => 1.0]\n\nbb_prob = ODEProblem(bb_sys, u0, (0, 5.0))\nbb_sol = solve(bb_prob, Tsit5())\n\nplot(bb_sol)","category":"page"},{"location":"basics/Events/#Discrete-Events","page":"Event Handling and Callback Functions","title":"Discrete Events","text":"","category":"section"},{"location":"basics/Events/","page":"Event Handling and Callback Functions","title":"Event Handling and Callback Functions","text":"In addition to continuous events, discrete events are also supported. The general interface to represent a collection of discrete events is","category":"page"},{"location":"basics/Events/","page":"Event Handling and Callback Functions","title":"Event Handling and Callback Functions","text":"AbstractSystem(eqs, _...; discrete_events = [condition1 => affect1, condition2 => affect2])","category":"page"},{"location":"basics/Events/","page":"Event Handling and Callback Functions","title":"Event Handling and Callback Functions","text":"where conditions are symbolic expressions that should evaluate to true when an individual affect should be executed. Here affect1 and affect2 are each either a vector of one or more symbolic equations, or a functional affect, just as for continuous events. As before, for any one event the symbolic affect equations can either all change unknowns (i.e. variables) or all change parameters, but one cannot currently mix unknown variable and parameter changes within one individual event.","category":"page"},{"location":"basics/Events/#Example:-Injecting-cells-into-a-population","page":"Event Handling and Callback Functions","title":"Example: Injecting cells into a population","text":"","category":"section"},{"location":"basics/Events/","page":"Event Handling and Callback Functions","title":"Event Handling and Callback Functions","text":"Suppose we have a population of N(t) cells that can grow and die, and at time t1 we want to inject M more cells into the population. We can model this by","category":"page"},{"location":"basics/Events/","page":"Event Handling and Callback Functions","title":"Event Handling and Callback Functions","text":"@parameters M tinject α(t)\n@variables N(t)\nDₜ = Differential(t)\neqs = [Dₜ(N) ~ α - N]\n\n# at time tinject we inject M cells\ninjection = (t == tinject) => [N ~ Pre(N) + M]\n\nu0 = [N => 0.0]\ntspan = (0.0, 20.0)\np = [α => 100.0, tinject => 10.0, M => 50]\n@mtkcompile osys = System(eqs, t, [N], [α, M, tinject]; discrete_events = injection)\noprob = ODEProblem(osys, u0, tspan, p)\nsol = solve(oprob, Tsit5(); tstops = 10.0)\nplot(sol)","category":"page"},{"location":"basics/Events/","page":"Event Handling and Callback Functions","title":"Event Handling and Callback Functions","text":"Notice, with generic discrete events that we want to occur at one or more fixed times, we need to also set the tstops keyword argument to solve to ensure the integrator stops at that time. In the next section, we show how one can avoid this by using a preset-time callback.","category":"page"},{"location":"basics/Events/","page":"Event Handling and Callback Functions","title":"Event Handling and Callback Functions","text":"Note that more general logical expressions can be built, for example, suppose we want the event to occur at that time only if the solution is smaller than 50% of its steady-state value (which is 100). We can encode this by modifying the event to","category":"page"},{"location":"basics/Events/","page":"Event Handling and Callback Functions","title":"Event Handling and Callback Functions","text":"injection = ((t == tinject) & (N < 50)) => [N ~ Pre(N) + M]\n\n@mtkcompile osys = System(eqs, t, [N], [M, tinject, α]; discrete_events = injection)\noprob = ODEProblem(osys, u0, tspan, p)\nsol = solve(oprob, Tsit5(); tstops = 10.0)\nplot(sol)","category":"page"},{"location":"basics/Events/","page":"Event Handling and Callback Functions","title":"Event Handling and Callback Functions","text":"Since the solution is not smaller than half its steady-state value at the event time, the event condition now returns false. Here we used logical and, &, instead of the short-circuiting logical and, &&, as currently the latter cannot be used within symbolic expressions.","category":"page"},{"location":"basics/Events/","page":"Event Handling and Callback Functions","title":"Event Handling and Callback Functions","text":"Let's now also add a drug at time tkill that turns off production of new cells, modeled by setting α = 0.0. Since this is a parameter we must explicitly set it as discrete_parameters.","category":"page"},{"location":"basics/Events/","page":"Event Handling and Callback Functions","title":"Event Handling and Callback Functions","text":"@parameters tkill\n\n# we reset the first event to just occur at tinject\ninjection = (t == tinject) => [N ~ Pre(N) + M]\n\n# at time tkill we turn off production of cells\nkilling = ModelingToolkit.SymbolicDiscreteCallback(\n    (t == tkill) => [α ~ 0.0]; discrete_parameters = α, iv = t)\n\ntspan = (0.0, 30.0)\np = [α => 100.0, tinject => 10.0, M => 50, tkill => 20.0]\n@mtkcompile osys = System(eqs, t, [N], [α, M, tinject, tkill];\n    discrete_events = [injection, killing])\noprob = ODEProblem(osys, u0, tspan, p)\nsol = solve(oprob, Tsit5(); tstops = [10.0, 20.0])\nplot(sol)","category":"page"},{"location":"basics/Events/#Periodic-and-preset-time-events","page":"Event Handling and Callback Functions","title":"Periodic and preset-time events","text":"","category":"section"},{"location":"basics/Events/","page":"Event Handling and Callback Functions","title":"Event Handling and Callback Functions","text":"Two important subclasses of discrete events are periodic and preset-time events.","category":"page"},{"location":"basics/Events/","page":"Event Handling and Callback Functions","title":"Event Handling and Callback Functions","text":"A preset-time event is triggered at specific set times, which can be passed in a vector like","category":"page"},{"location":"basics/Events/","page":"Event Handling and Callback Functions","title":"Event Handling and Callback Functions","text":"discrete_events = [[1.0, 4.0] => [v ~ -Pre(v)]]","category":"page"},{"location":"basics/Events/","page":"Event Handling and Callback Functions","title":"Event Handling and Callback Functions","text":"This will change the sign of v only at t = 1.0 and t = 4.0.","category":"page"},{"location":"basics/Events/","page":"Event Handling and Callback Functions","title":"Event Handling and Callback Functions","text":"As such, our last example with treatment and killing could instead be modeled by","category":"page"},{"location":"basics/Events/","page":"Event Handling and Callback Functions","title":"Event Handling and Callback Functions","text":"injection = [10.0] => [N ~ Pre(N) + M]\nkilling = ModelingToolkit.SymbolicDiscreteCallback(\n    [20.0] => [α ~ 0.0], discrete_parameters = α, iv = t)\n\np = [α => 100.0, M => 50]\n@mtkcompile osys = System(eqs, t, [N], [α, M];\n    discrete_events = [injection, killing])\noprob = ODEProblem(osys, u0, tspan, p)\nsol = solve(oprob, Tsit5())\nplot(sol)","category":"page"},{"location":"basics/Events/","page":"Event Handling and Callback Functions","title":"Event Handling and Callback Functions","text":"Notice, one advantage of using a preset-time event is that one does not need to also specify tstops in the call to solve.","category":"page"},{"location":"basics/Events/","page":"Event Handling and Callback Functions","title":"Event Handling and Callback Functions","text":"A periodic event is triggered at fixed intervals (e.g. every Δt seconds). To specify a periodic interval, pass the interval as the condition for the event. For example,","category":"page"},{"location":"basics/Events/","page":"Event Handling and Callback Functions","title":"Event Handling and Callback Functions","text":"discrete_events = [1.0 => [v ~ -Pre(v)]]","category":"page"},{"location":"basics/Events/","page":"Event Handling and Callback Functions","title":"Event Handling and Callback Functions","text":"will change the sign of v at t = 1.0, 2.0, ...","category":"page"},{"location":"basics/Events/","page":"Event Handling and Callback Functions","title":"Event Handling and Callback Functions","text":"Finally, we note that to specify an event at precisely one time, say 2.0 below, one must still use a vector","category":"page"},{"location":"basics/Events/","page":"Event Handling and Callback Functions","title":"Event Handling and Callback Functions","text":"discrete_events = [[2.0] => [v ~ -Pre(v)]]","category":"page"},{"location":"basics/Events/#save_discretes","page":"Event Handling and Callback Functions","title":"Saving discrete values","text":"","category":"section"},{"location":"basics/Events/","page":"Event Handling and Callback Functions","title":"Event Handling and Callback Functions","text":"Time-dependent parameters which are updated in callbacks are termed as discrete variables. ModelingToolkit enables automatically saving the timeseries of these discrete variables, and indexing the solution object to obtain the saved timeseries. Consider the following example:","category":"page"},{"location":"basics/Events/","page":"Event Handling and Callback Functions","title":"Event Handling and Callback Functions","text":"@variables x(t)\n@parameters c(t)\n\nev = ModelingToolkit.SymbolicDiscreteCallback(\n    1.0 => [c ~ Pre(c) + 1], discrete_parameters = c, iv = t)\n@mtkcompile sys = System(\n    D(x) ~ c * cos(x), t, [x], [c]; discrete_events = [ev])\n\nprob = ODEProblem(sys, [x => 0.0], (0.0, 2pi), [c => 1.0])\nsol = solve(prob, Tsit5())\nsol[c]","category":"page"},{"location":"basics/Events/","page":"Event Handling and Callback Functions","title":"Event Handling and Callback Functions","text":"The solution object can also be interpolated with the discrete variables","category":"page"},{"location":"basics/Events/","page":"Event Handling and Callback Functions","title":"Event Handling and Callback Functions","text":"sol([1.0, 2.0], idxs = [c, c * cos(x)])","category":"page"},{"location":"basics/Events/","page":"Event Handling and Callback Functions","title":"Event Handling and Callback Functions","text":"Note that only time-dependent parameters that are explicitly passed as discrete_parameters will be saved. If we repeat the above example with c not a discrete_parameter:","category":"page"},{"location":"basics/Events/","page":"Event Handling and Callback Functions","title":"Event Handling and Callback Functions","text":"@variables x(t)\n@parameters c(t)\n\n@mtkcompile sys = System(\n    D(x) ~ c * cos(x), t, [x], [c]; discrete_events = [1.0 => [c ~ Pre(c) + 1]])\n\nprob = ODEProblem(sys, [x => 0.0], (0.0, 2pi), [c => 1.0])\nsol = solve(prob, Tsit5())\nsol.ps[c] # sol[c] will error, since `c` is not a timeseries value","category":"page"},{"location":"basics/Events/","page":"Event Handling and Callback Functions","title":"Event Handling and Callback Functions","text":"It can be seen that the timeseries for c is not saved.","category":"page"},{"location":"basics/Events/#imp_affects","page":"Event Handling and Callback Functions","title":"(Experimental) Imperative affects","text":"","category":"section"},{"location":"basics/Events/","page":"Event Handling and Callback Functions","title":"Event Handling and Callback Functions","text":"The ImperativeAffect can be used as an alternative to the aforementioned functional affect form. Note that ImperativeAffect is still experimental; to emphasize this, we do not export it and it should be included as ModelingToolkit.ImperativeAffect. ImperativeAffect aims to simplify the manipulation of system state.","category":"page"},{"location":"basics/Events/","page":"Event Handling and Callback Functions","title":"Event Handling and Callback Functions","text":"We will use two examples to describe ImperativeAffect: a simple heater and a quadrature encoder. These examples will also demonstrate advanced usage of ModelingToolkit.SymbolicContinuousCallback, the low-level interface of the tuple form converts into that allows control over the SciMLBase-level event that is generated for a continuous event.","category":"page"},{"location":"basics/Events/#heater_events","page":"Event Handling and Callback Functions","title":"Heater","text":"","category":"section"},{"location":"basics/Events/","page":"Event Handling and Callback Functions","title":"Event Handling and Callback Functions","text":"Bang-bang control of a heater connected to a leaky plant requires hysteresis in order to prevent rapid control oscillation.","category":"page"},{"location":"basics/Events/","page":"Event Handling and Callback Functions","title":"Event Handling and Callback Functions","text":"@variables temp(t)\nparams = @parameters furnace_on_threshold=0.5 furnace_off_threshold=0.7 furnace_power=1.0 leakage=0.1 furnace_on(t)::Bool=false\neqs = [\n    D(temp) ~ furnace_on * furnace_power - temp^2 * leakage\n]","category":"page"},{"location":"basics/Events/","page":"Event Handling and Callback Functions","title":"Event Handling and Callback Functions","text":"Our plant is simple. We have a heater that's turned on and off by the time-indexed parameter furnace_on which adds furnace_power forcing to the system when enabled. We then leak heat proportional to leakage as a function of the square of the current temperature.","category":"page"},{"location":"basics/Events/","page":"Event Handling and Callback Functions","title":"Event Handling and Callback Functions","text":"We need a controller with hysteresis to control the plant. We wish the furnace to turn on when the temperature is below furnace_on_threshold and off when above furnace_off_threshold, while maintaining its current state in between. To do this, we create two continuous callbacks:","category":"page"},{"location":"basics/Events/","page":"Event Handling and Callback Functions","title":"Event Handling and Callback Functions","text":"using Setfield\nfurnace_disable = ModelingToolkit.SymbolicContinuousCallback(\n    [temp ~ furnace_off_threshold],\n    ModelingToolkit.ImperativeAffect(modified = (; furnace_on)) do x, o, c, i\n        @set! x.furnace_on = false\n    end)\nfurnace_enable = ModelingToolkit.SymbolicContinuousCallback(\n    [temp ~ furnace_on_threshold],\n    ModelingToolkit.ImperativeAffect(modified = (; furnace_on)) do x, o, c, i\n        @set! x.furnace_on = true\n    end)","category":"page"},{"location":"basics/Events/","page":"Event Handling and Callback Functions","title":"Event Handling and Callback Functions","text":"We're using the explicit form of SymbolicContinuousCallback here, though so far we aren't using anything that's not possible with the implicit interface. You can also write","category":"page"},{"location":"basics/Events/","page":"Event Handling and Callback Functions","title":"Event Handling and Callback Functions","text":"[temp ~\n furnace_off_threshold] => ModelingToolkit.ImperativeAffect(modified = (;\n    furnace_on)) do x, o, i, c\n    @set! x.furnace_on = false\nend","category":"page"},{"location":"basics/Events/","page":"Event Handling and Callback Functions","title":"Event Handling and Callback Functions","text":"and it would work the same.","category":"page"},{"location":"basics/Events/","page":"Event Handling and Callback Functions","title":"Event Handling and Callback Functions","text":"The ImperativeAffect is the larger change in this example. ImperativeAffect has the constructor signature","category":"page"},{"location":"basics/Events/","page":"Event Handling and Callback Functions","title":"Event Handling and Callback Functions","text":"ImperativeAffect(f::Function; modified::NamedTuple, observed::NamedTuple, ctx)","category":"page"},{"location":"basics/Events/","page":"Event Handling and Callback Functions","title":"Event Handling and Callback Functions","text":"that accepts the function to call, a named tuple of both the names of and symbolic values representing values in the system to be modified, a named tuple of the values that are merely observed (that is, used from the system but not modified), and a context that's passed to the affect function.","category":"page"},{"location":"basics/Events/","page":"Event Handling and Callback Functions","title":"Event Handling and Callback Functions","text":"In our example, each event merely changes whether the furnace is on or off. Accordingly, we pass a modified tuple (; furnace_on) (creating a NamedTuple equivalent to (furnace_on = furnace_on)). ImperativeAffect will then evaluate this before calling our function to fill out all of the numerical values, then apply them back to the system once our affect function returns. Furthermore, it will check that it is possible to do this assignment.","category":"page"},{"location":"basics/Events/","page":"Event Handling and Callback Functions","title":"Event Handling and Callback Functions","text":"The function given to ImperativeAffect needs to have the signature:","category":"page"},{"location":"basics/Events/","page":"Event Handling and Callback Functions","title":"Event Handling and Callback Functions","text":"f(modified::NamedTuple, observed::NamedTuple, ctx, integrator)::NamedTuple","category":"page"},{"location":"basics/Events/","page":"Event Handling and Callback Functions","title":"Event Handling and Callback Functions","text":"The function f will be called with observed and modified NamedTuples that are derived from their respective NamedTuple definitions. In our example, if furnace_on is false, then the value of the x that's passed in as modified will be (furnace_on = false). The modified values should be passed out in the same format: to set furnace_on to true we need to return a tuple (furnace_on = true). The examples does this with Setfield, recreating the result tuple before returning it; the returned tuple may optionally be missing values as well, in which case those values will not be written back to the problem.","category":"page"},{"location":"basics/Events/","page":"Event Handling and Callback Functions","title":"Event Handling and Callback Functions","text":"Accordingly, we can now interpret the ImperativeAffect definitions to mean that when temp = furnace_off_threshold we will write furnace_on = false back to the system, and when temp = furnace_on_threshold we will write furnace_on = true back to the system.","category":"page"},{"location":"basics/Events/","page":"Event Handling and Callback Functions","title":"Event Handling and Callback Functions","text":"@named sys = System(\n    eqs, t, [temp], params; continuous_events = [furnace_disable, furnace_enable])\nss = mtkcompile(sys)\nprob = ODEProblem(ss, [temp => 0.0, furnace_on => true], (0.0, 10.0))\nsol = solve(prob, Tsit5())\nplot(sol)\nhline!([sol.ps[furnace_off_threshold], sol.ps[furnace_on_threshold]],\n    l = (:black, 1), primary = false)","category":"page"},{"location":"basics/Events/","page":"Event Handling and Callback Functions","title":"Event Handling and Callback Functions","text":"Here we see exactly the desired hysteresis. The heater starts on until the temperature hits furnace_off_threshold. The temperature then bleeds away until furnace_on_threshold at which point the furnace turns on again until furnace_off_threshold and so on and so forth. The controller is effectively regulating the temperature of the plant.","category":"page"},{"location":"basics/Events/#quadrature","page":"Event Handling and Callback Functions","title":"Quadrature Encoder","text":"","category":"section"},{"location":"basics/Events/","page":"Event Handling and Callback Functions","title":"Event Handling and Callback Functions","text":"For a more complex application we'll look at modeling a quadrature encoder attached to a shaft spinning at a constant speed. Traditionally, a quadrature encoder is built out of a code wheel that interrupts the sensors at constant intervals and two sensors slightly out of phase with one another. A state machine can take the pattern of pulses produced by the two sensors and determine the number of steps that the shaft has spun. The state machine takes the new value from each sensor and the old values and decodes them into the direction that the wheel has spun in this step.","category":"page"},{"location":"basics/Events/","page":"Event Handling and Callback Functions","title":"Event Handling and Callback Functions","text":"@variables theta(t) omega(t)\nparams = @parameters qA=0 qB=0 hA=0 hB=0 cnt::Int=0\neqs = [D(theta) ~ omega\n       omega ~ 1.0]","category":"page"},{"location":"basics/Events/","page":"Event Handling and Callback Functions","title":"Event Handling and Callback Functions","text":"Our continuous-time system is extremely simple. We have two unknown variables theta for the angle of the shaft and omega for the rate at which it's spinning. We then have parameters for the state machine qA, qB, hA, hB (corresponding to the current quadrature of the A/B sensors and the historical ones) and a step count cnt.","category":"page"},{"location":"basics/Events/","page":"Event Handling and Callback Functions","title":"Event Handling and Callback Functions","text":"We'll then implement the decoder as a simple Julia function.","category":"page"},{"location":"basics/Events/","page":"Event Handling and Callback Functions","title":"Event Handling and Callback Functions","text":"function decoder(oldA, oldB, newA, newB)\n    state = (oldA, oldB, newA, newB)\n    if state == (0, 0, 1, 0) || state == (1, 0, 1, 1) || state == (1, 1, 0, 1) ||\n       state == (0, 1, 0, 0)\n        return 1\n    elseif state == (0, 0, 0, 1) || state == (0, 1, 1, 1) || state == (1, 1, 1, 0) ||\n           state == (1, 0, 0, 0)\n        return -1\n    elseif state == (0, 0, 0, 0) || state == (0, 1, 0, 1) || state == (1, 0, 1, 0) ||\n           state == (1, 1, 1, 1)\n        return 0\n    else\n        return 0 # err is interpreted as no movement\n    end\nend","category":"page"},{"location":"basics/Events/","page":"Event Handling and Callback Functions","title":"Event Handling and Callback Functions","text":"Based on the current and old state, this function will return 1 if the wheel spun in the positive direction, -1 if in the negative, and 0 otherwise.","category":"page"},{"location":"basics/Events/","page":"Event Handling and Callback Functions","title":"Event Handling and Callback Functions","text":"The encoder state advances when the occlusion begins or ends. We model the code wheel as simply detecting when cos(100*theta) is 0; if we're at a positive edge of the 0 crossing, then we interpret that as occlusion (so the discrete qA goes to 1). Otherwise, if cos is going negative, we interpret that as lack of occlusion (so the discrete goes to 0). The decoder function is then invoked to update the count with this new information.","category":"page"},{"location":"basics/Events/","page":"Event Handling and Callback Functions","title":"Event Handling and Callback Functions","text":"We can implement this in one of two ways: using edge sign detection or right root finding. For exposition, we will implement each sensor differently.","category":"page"},{"location":"basics/Events/","page":"Event Handling and Callback Functions","title":"Event Handling and Callback Functions","text":"For sensor A, we're using the edge detection method. By providing a different affect to SymbolicContinuousCallback's affect_neg argument, we can specify different behaviour for the negative crossing vs. the positive crossing of the root. In our encoder, we interpret this as occlusion or nonocclusion of the sensor, update the internal state, and tick the decoder.","category":"page"},{"location":"basics/Events/","page":"Event Handling and Callback Functions","title":"Event Handling and Callback Functions","text":"qAevt = ModelingToolkit.SymbolicContinuousCallback([cos(100 * theta) ~ 0],\n    ModelingToolkit.ImperativeAffect((; qA, hA, hB, cnt), (; qB)) do x, o, c, i\n        @set! x.hA = x.qA\n        @set! x.hB = o.qB\n        @set! x.qA = 1\n        @set! x.cnt += decoder(x.hA, x.hB, x.qA, o.qB)\n        x\n    end,\n    affect_neg = ModelingToolkit.ImperativeAffect(\n        (; qA, hA, hB, cnt), (; qB)) do x, o, c, i\n        @set! x.hA = x.qA\n        @set! x.hB = o.qB\n        @set! x.qA = 0\n        @set! x.cnt += decoder(x.hA, x.hB, x.qA, o.qB)\n        x\n    end)","category":"page"},{"location":"basics/Events/","page":"Event Handling and Callback Functions","title":"Event Handling and Callback Functions","text":"The other way we can implement a sensor is by changing the root find. Normally, we use left root finding; the affect will be invoked instantaneously before the root is crossed. This makes it trickier to figure out what the new state is. Instead, we can use right root finding:","category":"page"},{"location":"basics/Events/","page":"Event Handling and Callback Functions","title":"Event Handling and Callback Functions","text":"qBevt = ModelingToolkit.SymbolicContinuousCallback([cos(100 * theta - π / 2) ~ 0],\n    ModelingToolkit.ImperativeAffect((; qB, hA, hB, cnt), (; qA, theta)) do x, o, c, i\n        @set! x.hA = o.qA\n        @set! x.hB = x.qB\n        @set! x.qB = clamp(sign(cos(100 * o.theta - π / 2)), 0.0, 1.0)\n        @set! x.cnt += decoder(x.hA, x.hB, o.qA, x.qB)\n        x\n    end; rootfind = SciMLBase.RightRootFind)","category":"page"},{"location":"basics/Events/","page":"Event Handling and Callback Functions","title":"Event Handling and Callback Functions","text":"Here, sensor B is located π / 2 behind sensor A in angular space, so we're adjusting our trigger function accordingly. We here ask for right root finding on the callback, so we know that the value of said function will have the \"new\" sign rather than the old one. Thus, we can determine the new state of the sensor from the sign of the indicator function evaluated at the affect activation point, with -1 mapped to 0.","category":"page"},{"location":"basics/Events/","page":"Event Handling and Callback Functions","title":"Event Handling and Callback Functions","text":"We can now simulate the encoder.","category":"page"},{"location":"basics/Events/","page":"Event Handling and Callback Functions","title":"Event Handling and Callback Functions","text":"@named sys = System(\n    eqs, t, [theta, omega], params; continuous_events = [qAevt, qBevt])\nss = mtkcompile(sys)\nprob = ODEProblem(ss, [theta => 0.0], (0.0, pi))\nsol = solve(prob, Tsit5(); dtmax = 0.01)\nsol.ps[cnt]","category":"page"},{"location":"basics/Events/","page":"Event Handling and Callback Functions","title":"Event Handling and Callback Functions","text":"cos(100*theta) will have 200 crossings in the half rotation we've gone through, so the encoder would notionally count 200 steps. Our encoder counts 198 steps (it loses one step to initialization and one step due to the final state falling squarely on an edge).","category":"page"},{"location":"examples/higher_order/#Automatic-Transformation-of-Nth-Order-ODEs-to-1st-Order-ODEs","page":"Automatic Transformation of Nth Order ODEs to 1st Order ODEs","title":"Automatic Transformation of Nth Order ODEs to 1st Order ODEs","text":"","category":"section"},{"location":"examples/higher_order/","page":"Automatic Transformation of Nth Order ODEs to 1st Order ODEs","title":"Automatic Transformation of Nth Order ODEs to 1st Order ODEs","text":"ModelingToolkit has a system for transformations of mathematical systems. These transformations allow for symbolically changing the representation of the model to problems that are easier to numerically solve. One simple to demonstrate transformation, is mtkcompile, which does a lot of tricks, one being the transformation that turns an Nth order ODE into N coupled 1st order ODEs.","category":"page"},{"location":"examples/higher_order/","page":"Automatic Transformation of Nth Order ODEs to 1st Order ODEs","title":"Automatic Transformation of Nth Order ODEs to 1st Order ODEs","text":"To see this, let's define a second order riff on the Lorenz equations. We utilize the derivative operator twice here to define the second order:","category":"page"},{"location":"examples/higher_order/","page":"Automatic Transformation of Nth Order ODEs to 1st Order ODEs","title":"Automatic Transformation of Nth Order ODEs to 1st Order ODEs","text":"using ModelingToolkit, OrdinaryDiffEq\nusing ModelingToolkit: t_nounits as t, D_nounits as D\n\n@mtkmodel SECOND_ORDER begin\n    @parameters begin\n        σ = 28.0\n        ρ = 10.0\n        β = 8 / 3\n    end\n    @variables begin\n        x(t) = 1.0\n        y(t) = 0.0\n        z(t) = 0.0\n    end\n    @equations begin\n        D(D(x)) ~ σ * (y - x)\n        D(y) ~ x * (ρ - z) - y\n        D(z) ~ x * y - β * z\n    end\nend\n@mtkcompile sys = SECOND_ORDER()","category":"page"},{"location":"examples/higher_order/","page":"Automatic Transformation of Nth Order ODEs to 1st Order ODEs","title":"Automatic Transformation of Nth Order ODEs to 1st Order ODEs","text":"The second order ODE has been automatically transformed to two first order ODEs.","category":"page"},{"location":"examples/higher_order/","page":"Automatic Transformation of Nth Order ODEs to 1st Order ODEs","title":"Automatic Transformation of Nth Order ODEs to 1st Order ODEs","text":"Note that we could've used an alternative syntax for 2nd order, i.e. D = Differential(t)^2 and then D(x) would be the second derivative, and this syntax extends to N-th order. Also, we can use * or ∘ to compose Differentials, like Differential(t) * Differential(x).","category":"page"},{"location":"examples/higher_order/","page":"Automatic Transformation of Nth Order ODEs to 1st Order ODEs","title":"Automatic Transformation of Nth Order ODEs to 1st Order ODEs","text":"Now let's transform this into the System of first order components. We do this by calling mtkcompile:","category":"page"},{"location":"examples/higher_order/","page":"Automatic Transformation of Nth Order ODEs to 1st Order ODEs","title":"Automatic Transformation of Nth Order ODEs to 1st Order ODEs","text":"Now we can directly numerically solve the lowered system. Note that, following the original problem, the solution requires knowing the initial condition for both x and D(x). The former already got assigned a default value in the @mtkmodel, but we still have to provide a value for the latter.","category":"page"},{"location":"examples/higher_order/","page":"Automatic Transformation of Nth Order ODEs to 1st Order ODEs","title":"Automatic Transformation of Nth Order ODEs to 1st Order ODEs","text":"u0 = [D(sys.x) => 2.0]\ntspan = (0.0, 100.0)\nprob = ODEProblem(sys, u0, tspan, jac = true)\nsol = solve(prob, Tsit5())\nusing Plots\nplot(sol, idxs = (sys.x, sys.y))","category":"page"},{"location":"basics/Linearization/#linearization","page":"Linearization","title":"Linearization","text":"","category":"section"},{"location":"basics/Linearization/","page":"Linearization","title":"Linearization","text":"A nonlinear dynamical system with state (differential and algebraic) x and input signals u","category":"page"},{"location":"basics/Linearization/","page":"Linearization","title":"Linearization","text":"M dot x = f(x u)","category":"page"},{"location":"basics/Linearization/","page":"Linearization","title":"Linearization","text":"can be linearized using the function linearize to produce a linear statespace system on the form","category":"page"},{"location":"basics/Linearization/","page":"Linearization","title":"Linearization","text":"beginaligned\ndot x = Ax + Bu\ny = Cx + Du\nendaligned","category":"page"},{"location":"basics/Linearization/","page":"Linearization","title":"Linearization","text":"The linearize function expects the user to specify the inputs u and the outputs y using the syntax shown in the example below. The system model is not supposed to be simplified before calling linearize:","category":"page"},{"location":"basics/Linearization/#Example","page":"Linearization","title":"Example","text":"","category":"section"},{"location":"basics/Linearization/","page":"Linearization","title":"Linearization","text":"using ModelingToolkit\nusing ModelingToolkit: t_nounits as t, D_nounits as D\n@variables x(t)=0 y(t) u(t) r(t)=0\n@parameters kp = 1\n\neqs = [u ~ kp * (r - y) # P controller\n       D(x) ~ -x + u    # First-order plant\n       y ~ x]           # Output equation\n\n@named sys = System(eqs, t) # Do not call @mtkcompile when linearizing\nmatrices, simplified_sys = linearize(sys, [r], [y]) # Linearize from r to y\nmatrices","category":"page"},{"location":"basics/Linearization/","page":"Linearization","title":"Linearization","text":"The named tuple matrices contains the matrices of the linear statespace representation, while simplified_sys is an System that, among other things, indicates the unknown variable order in the linear system through","category":"page"},{"location":"basics/Linearization/","page":"Linearization","title":"Linearization","text":"using ModelingToolkit: inputs, outputs\n[unknowns(simplified_sys); inputs(simplified_sys); outputs(simplified_sys)]","category":"page"},{"location":"basics/Linearization/","page":"Linearization","title":"Linearization","text":"note: Inputs must be unconnected\nThe model above has 4 variables but only three equations, there is no equation specifying the value of r since r is an input. This means that only unbalanced models can be linearized, or in other words, models that are balanced and can be simulated cannot be linearized. To learn more about this, see How to linearize a ModelingToolkit model (YouTube). Also see ModelingToolkitStandardLibrary: Linear analysis for utilities that make linearization of completed models easier.","category":"page"},{"location":"basics/Linearization/","page":"Linearization","title":"Linearization","text":"note: Un-simplified system\nLinearization expects sys to be un-simplified, i.e., mtkcompile or @mtkcompile should not be called on the system before linearizing.","category":"page"},{"location":"basics/Linearization/#Operating-point","page":"Linearization","title":"Operating point","text":"","category":"section"},{"location":"basics/Linearization/","page":"Linearization","title":"Linearization","text":"The operating point to linearize around can be specified with the keyword argument op like this: op = Dict(x => 1, r => 2). The operating point may include specification of unknown variables, input variables and parameters. For variables that are not specified in op, the default value specified in the model will be used if available, if no value is specified, an error is thrown.","category":"page"},{"location":"basics/Linearization/#Batch-linearization-and-algebraic-variables","page":"Linearization","title":"Batch linearization and algebraic variables","text":"","category":"section"},{"location":"basics/Linearization/","page":"Linearization","title":"Linearization","text":"If linearization is to be performed around multiple operating points, the simplification of the system has to be carried out a single time only. To facilitate this, the lower-level function ModelingToolkit.linearization_function is available. This function further allows you to obtain separate Jacobians for the differential and algebraic parts of the model. For ODE models without algebraic equations, the statespace representation above is available from the output of linearization_function as A, B, C, D = f_x, f_u, h_x, h_u.","category":"page"},{"location":"basics/Linearization/","page":"Linearization","title":"Linearization","text":"All variables that will be fixed by an operating point must be provided in the operating point to linearization_function. For example, if the operating points fix the value of x, y and z then an operating point with constant values for these variables (e.g. Dict(x => 1.0, y => 1.0, z => 1.0)) must be provided. The constant values themselves do not matter and can be changed by subsequent operating points.","category":"page"},{"location":"basics/Linearization/","page":"Linearization","title":"Linearization","text":"One approach to batch linearization would be to call linearize in a loop, providing a different operating point each time. For example:","category":"page"},{"location":"basics/Linearization/","page":"Linearization","title":"Linearization","text":"using ModelingToolkitStandardLibrary\nusing ModelingToolkitStandardLibrary.Blocks\n\n@parameters k=10 k3=2 c=1\n@variables x(t)=0 [bounds = (-0.5, 1.5)]\n@variables v(t) = 0\n\n@named y = Blocks.RealOutput()\n@named u = Blocks.RealInput()\n\neqs = [D(x) ~ v\n       D(v) ~ -k * x - k3 * x^3 - c * v + 10u.u\n       y.u ~ x]\n\n@named duffing = System(eqs, t, systems = [y, u], defaults = [u.u => 0])\n\n# pass a constant value for `x`, since it is the variable we will change in operating points\nlinfun, simplified_sys = linearization_function(duffing, [u.u], [y.u]; op = Dict(x => NaN));\n\nprintln(linearize(simplified_sys, linfun; op = Dict(x => 1.0)))\nprintln(linearize(simplified_sys, linfun; op = Dict(x => 0.0)))\n\n@time linearize(simplified_sys, linfun; op = Dict(x => 0.0))\n\nnothing # hide","category":"page"},{"location":"basics/Linearization/","page":"Linearization","title":"Linearization","text":"However, this route is still expensive since it has to repeatedly process the symbolic map provided to op. linearize is simply a wrapper for creating and solving a ModelingToolkit.LinearizationProblem. This object is symbolically indexable, and can thus integrate with SymbolicIndexingInterface.jl for fast updates.","category":"page"},{"location":"basics/Linearization/","page":"Linearization","title":"Linearization","text":"using SymbolicIndexingInterface\n\n# The second argument is the value of the independent variable `t`.\nlinprob = LinearizationProblem(linfun, 1.0)\n# It can be mutated\nlinprob.t = 0.0\n# create a setter function to update `x` efficiently\nsetter! = setu(linprob, x)\n\nfunction fast_linearize!(problem, setter!, value)\n    setter!(problem, value)\n    solve(problem)\nend\n\nprintln(fast_linearize!(linprob, setter!, 1.0))\nprintln(fast_linearize!(linprob, setter!, 0.0))\n\n@time fast_linearize!(linprob, setter!, 1.0)\n\nnothing # hide","category":"page"},{"location":"basics/Linearization/","page":"Linearization","title":"Linearization","text":"Note that linprob above can be interacted with similar to a normal ODEProblem.","category":"page"},{"location":"basics/Linearization/","page":"Linearization","title":"Linearization","text":"prob[x]\nprob[x] = 1.5\nprob[x]","category":"page"},{"location":"basics/Linearization/#Symbolic-linearization","page":"Linearization","title":"Symbolic linearization","text":"","category":"section"},{"location":"basics/Linearization/","page":"Linearization","title":"Linearization","text":"The function ModelingToolkit.linearize_symbolic works similar to ModelingToolkit.linearize but returns symbolic rather than numeric Jacobians. Symbolic linearization have several limitations and no all systems that can be linearized numerically can be linearized symbolically.","category":"page"},{"location":"basics/Linearization/#Input-derivatives","page":"Linearization","title":"Input derivatives","text":"","category":"section"},{"location":"basics/Linearization/","page":"Linearization","title":"Linearization","text":"Physical systems are always proper, i.e., they do not differentiate causal inputs. However, ModelingToolkit allows you to model non-proper systems, such as inverse models, and may sometimes fail to find a realization of a proper system on proper form. In these situations, linearize may throw an error mentioning","category":"page"},{"location":"basics/Linearization/","page":"Linearization","title":"Linearization","text":"Input derivatives appeared in expressions (-g_z\\g_u != 0)","category":"page"},{"location":"basics/Linearization/","page":"Linearization","title":"Linearization","text":"This means that to simulate this system, some order of derivatives of the input is required. To allow linearize to proceed in this situation, one may pass the keyword argument allow_input_derivatives = true, in which case the resulting model will have twice as many inputs, 2n_u, where the last n_u inputs correspond to dot u.","category":"page"},{"location":"basics/Linearization/","page":"Linearization","title":"Linearization","text":"If the modeled system is actually proper (but MTK failed to find a proper realization), further numerical simplification can be applied to the resulting statespace system to obtain a proper form. Such simplification is currently available in the package ControlSystemsMTK.","category":"page"},{"location":"basics/Linearization/#Tools-for-linear-analysis","page":"Linearization","title":"Tools for linear analysis","text":"","category":"section"},{"location":"basics/Linearization/","page":"Linearization","title":"Linearization","text":"ModelingToolkit contains a set of tools for more advanced linear analysis. These can be used to make it easier to work with and analyze causal models, such as control and signal-processing systems.","category":"page"},{"location":"basics/Linearization/","page":"Linearization","title":"Linearization","text":"Also see ControlSystemsMTK.jl for an interface to ControlSystems.jl that contains tools for linear analysis and frequency-domain analysis.","category":"page"},{"location":"basics/Linearization/#Docstrings","page":"Linearization","title":"Docstrings","text":"","category":"section"},{"location":"basics/Linearization/","page":"Linearization","title":"Linearization","text":"Pages = [\"Linearization.md\"]","category":"page"},{"location":"basics/Linearization/#ModelingToolkit.linearize-basics-Linearization","page":"Linearization","title":"ModelingToolkit.linearize","text":"(; A, B, C, D), simplified_sys, extras = linearize(sys, inputs, outputs;    t=0.0, op = Dict(), allow_input_derivatives = false, zero_dummy_der=false, kwargs...)\n(; A, B, C, D), extras                 = linearize(simplified_sys, lin_fun; t=0.0, op = Dict(), allow_input_derivatives = false, zero_dummy_der=false)\n\nLinearize sys between inputs and outputs, both vectors of variables. Return a NamedTuple with the matrices of a linear statespace representation on the form\n\nbeginaligned\nx = Ax + Bu\ny = Cx + Du\nendaligned\n\nThe first signature automatically calls linearization_function internally, while the second signature expects the outputs of linearization_function as input.\n\nop denotes the operating point around which to linearize. If none is provided, the default values of sys are used.\n\nIf allow_input_derivatives = false, an error will be thrown if input derivatives (u) appear as inputs in the linearized equations. If input derivatives are allowed, the returned B matrix will be of double width, corresponding to the input [u; u̇].\n\nzero_dummy_der can be set to automatically set the operating point to zero for all dummy derivatives.\n\nThe return value extras is a NamedTuple (; x, p, t) containing the result of the initialization problem that was solved to determine the operating point.\n\nSee also linearization_function which provides a lower-level interface, linearize_symbolic and ModelingToolkit.reorder_unknowns.\n\nSee extended help for an example.\n\nThe implementation and notation follows that of \"Linear Analysis Approach for Modelica Models\", Allain et al. 2009\n\nExtended help\n\nThis example builds the following feedback interconnection and linearizes it from the input of F to the output of P.\n\n\n  r ┌─────┐       ┌─────┐     ┌─────┐\n───►│     ├──────►│     │  u  │     │\n    │  F  │       │  C  ├────►│  P  │ y\n    └─────┘     ┌►│     │     │     ├─┬─►\n                │ └─────┘     └─────┘ │\n                │                     │\n                └─────────────────────┘\n\nusing ModelingToolkit\nusing ModelingToolkit: t_nounits as t, D_nounits as D\nfunction plant(; name)\n    @variables x(t) = 1\n    @variables u(t)=0 y(t)=0\n    eqs = [D(x) ~ -x + u\n           y ~ x]\n    System(eqs, t; name = name)\nend\n\nfunction ref_filt(; name)\n    @variables x(t)=0 y(t)=0\n    @variables u(t)=0 [input = true]\n    eqs = [D(x) ~ -2 * x + u\n           y ~ x]\n    System(eqs, t, name = name)\nend\n\nfunction controller(kp; name)\n    @variables y(t)=0 r(t)=0 u(t)=0\n    @parameters kp = kp\n    eqs = [\n        u ~ kp * (r - y),\n    ]\n    System(eqs, t; name = name)\nend\n\n@named f = ref_filt()\n@named c = controller(1)\n@named p = plant()\n\nconnections = [f.y ~ c.r # filtered reference to controller reference\n               c.u ~ p.u # controller output to plant input\n               p.y ~ c.y]\n\n@named cl = System(connections, t, systems = [f, c, p])\n\nlsys0, ssys = linearize(cl, [f.u], [p.x])\ndesired_order = [f.x, p.x]\nlsys = ModelingToolkit.reorder_unknowns(lsys0, unknowns(ssys), desired_order)\n\n@assert lsys.A == [-2 0; 1 -2]\n@assert lsys.B == [1; 0;;]\n@assert lsys.C == [0 1]\n@assert lsys.D[] == 0\n\n## Symbolic linearization\nlsys_sym, _ = ModelingToolkit.linearize_symbolic(cl, [f.u], [p.x])\n\n@assert substitute(lsys_sym.A, ModelingToolkit.defaults(cl)) == lsys.A\n\n\n\n\n\n","category":"function"},{"location":"basics/Linearization/#ModelingToolkit.linearize_symbolic-basics-Linearization","page":"Linearization","title":"ModelingToolkit.linearize_symbolic","text":"(; A, B, C, D), simplified_sys = linearize_symbolic(sys::AbstractSystem, inputs, outputs; simplify = false, allow_input_derivatives = false, kwargs...)\n\nSimilar to linearize, but returns symbolic matrices A,B,C,D rather than numeric. While linearize uses ForwardDiff to perform the linearization, this function uses Symbolics.jacobian.\n\nSee linearize for a description of the arguments.\n\nExtended help\n\nThe named tuple returned as the first argument additionally contains the jacobians f_x, f_z, g_x, g_z, f_u, g_u, h_x, h_z, h_u of\n\nbeginaligned\nx = f(x z u) \n0 = g(x z u) \ny = h(x z u)\nendaligned\n\nwhere x are differential unknown variables, z algebraic variables, u inputs and y outputs.\n\n\n\n\n\n","category":"function"},{"location":"basics/Linearization/#ModelingToolkit.linearization_function-basics-Linearization","page":"Linearization","title":"ModelingToolkit.linearization_function","text":"lin_fun, simplified_sys = linearization_function(sys::AbstractSystem, inputs, outputs; simplify = false, initialize = true, initialization_solver_alg = TrustRegion(), kwargs...)\n\nReturn a function that linearizes the system sys. The function linearize provides a higher-level and easier to use interface.\n\nlin_fun is a function (variables, p, t) -> (; f_x, f_z, g_x, g_z, f_u, g_u, h_x, h_z, h_u), i.e., it returns a NamedTuple with the Jacobians of f,g,h for the nonlinear sys (technically for simplified_sys) on the form\n\nbeginaligned\nx = f(x z u) \n0 = g(x z u) \ny = h(x z u)\nendaligned\n\nwhere x are differential unknown variables, z algebraic variables, u inputs and y outputs. To obtain a linear statespace representation, see linearize. The input argument variables is a vector defining the operating point, corresponding to unknowns(simplified_sys) and p is a vector corresponding to the parameters of simplified_sys. Note: all variables in inputs have been converted to parameters in simplified_sys.\n\nThe simplified_sys has undergone mtkcompile and had any occurring input or output variables replaced with the variables provided in arguments inputs and outputs. The unknowns of this system also indicate the order of the unknowns that holds for the linearized matrices.\n\nArguments:\n\nsys: A System of ODEs. This function will automatically apply simplification passes on sys and return the resulting simplified_sys.\ninputs: A vector of variables that indicate the inputs of the linearized input-output model.\noutputs: A vector of variables that indicate the outputs of the linearized input-output model.\nsimplify: Apply simplification in tearing.\ninitialize: If true, a check is performed to ensure that the operating point is consistent (satisfies algebraic equations). If the op is not consistent, initialization is performed.\ninitialization_solver_alg: A NonlinearSolve algorithm to use for solving for a feasible set of state and algebraic variables that satisfies the specified operating point.\nautodiff: An ADType supported by DifferentiationInterface.jl to use for calculating the necessary jacobians. Defaults to using AutoForwardDiff()\nkwargs: Are passed on to find_solvables!\n\nSee also linearize which provides a higher-level interface.\n\n\n\n\n\n","category":"function"},{"location":"basics/Linearization/#ModelingToolkit.LinearizationProblem-basics-Linearization","page":"Linearization","title":"ModelingToolkit.LinearizationProblem","text":"mutable struct LinearizationProblem{F<:ModelingToolkit.LinearizationFunction, T}\n\nA struct representing a linearization operation to be performed. Can be symbolically indexed to efficiently update the operating point for multiple linearizations in a loop. The value of the independent variable can be set by mutating the .t field of this struct.\n\n\n\n\n\n","category":"type"},{"location":"basics/DependencyGraphs/#Dependency-Graphs","page":"Dependency Graphs","title":"Dependency Graphs","text":"","category":"section"},{"location":"basics/DependencyGraphs/#Types","page":"Dependency Graphs","title":"Types","text":"","category":"section"},{"location":"basics/DependencyGraphs/#ModelingToolkit.BipartiteGraphs.BipartiteGraph","page":"Dependency Graphs","title":"ModelingToolkit.BipartiteGraphs.BipartiteGraph","text":"mutable struct BipartiteGraph{I<:Integer, M} <: Graphs.AbstractGraph{I<:Integer}\n\nA bipartite graph representation between two, possibly distinct, sets of vertices (source and dependencies). Maps source vertices, labelled 1:N₁, to vertices on which they depend (labelled 1:N₂).\n\nFields\n\nne\nfadjlist\nbadjlist\nmetadata\n\nExample\n\nusing ModelingToolkit\n\nne = 4\nsrcverts = 1:4\ndepverts = 1:2\n\n# six source vertices\nfadjlist = [[1],[1],[2],[2],[1],[1,2]]\n\n# two vertices they depend on\nbadjlist = [[1,2,5,6],[3,4,6]]\n\nbg = BipartiteGraph(7, fadjlist, badjlist)\n\n\n\n\n\n","category":"type"},{"location":"basics/DependencyGraphs/#Utility-functions-for-BiPartiteGraphs","page":"Dependency Graphs","title":"Utility functions for BiPartiteGraphs","text":"","category":"section"},{"location":"basics/DependencyGraphs/#Base.isequal","page":"Dependency Graphs","title":"Base.isequal","text":"Base.isequal(bg1::BipartiteGraph{T}, bg2::BipartiteGraph{T}) where {T <: Integer}\n\nTest whether two BipartiteGraphs are equal.\n\n\n\n\n\n","category":"function"},{"location":"basics/DependencyGraphs/#Functions-for-calculating-dependency-graphs","page":"Dependency Graphs","title":"Functions for calculating dependency graphs","text":"","category":"section"},{"location":"basics/DependencyGraphs/#ModelingToolkit.equation_dependencies","page":"Dependency Graphs","title":"ModelingToolkit.equation_dependencies","text":"equation_dependencies(sys::AbstractSystem; variables = unknowns(sys))\n\nGiven an AbstractSystem calculate for each equation the variables it depends on.\n\nNotes:\n\nVariables that are not in variables are filtered out.\nget_variables! is used to determine the variables within a given equation.\nreturns a Vector{Vector{Variable}}() mapping the index of an equation to the variables it depends on.\n\nExample:\n\nusing ModelingToolkit\nusing ModelingToolkit: t_nounits as t\n@parameters β γ κ η\n@variables S(t) I(t) R(t)\n\nrate₁ = β * S * I\nrate₂ = γ * I + t\naffect₁ = [S ~ S - 1, I ~ I + 1]\naffect₂ = [I ~ I - 1, R ~ R + 1]\nj₁ = ModelingToolkit.ConstantRateJump(rate₁, affect₁)\nj₂ = ModelingToolkit.VariableRateJump(rate₂, affect₂)\n\n# create a JumpSystem using these jumps\n@named jumpsys = JumpSystem([j₁, j₂], t, [S, I, R], [β, γ])\n\n# dependency of each jump rate function on unknown variables\nequation_dependencies(jumpsys)\n\n# dependency of each jump rate function on parameters\nequation_dependencies(jumpsys, variables = parameters(jumpsys))\n\n\n\n\n\n","category":"function"},{"location":"basics/DependencyGraphs/#ModelingToolkit.asgraph","page":"Dependency Graphs","title":"ModelingToolkit.asgraph","text":"asgraph(eqdeps, vtois)\n\nConvert a collection of equation dependencies, for example as returned by equation_dependencies, to a BipartiteGraph.\n\nNotes:\n\nvtois should provide a Dict like mapping from each Variable dependency in eqdeps to the integer idx of the variable to use in the graph.\n\nExample: Continuing the example started in equation_dependencies\n\ndigr = asgraph(equation_dependencies(jumpsys),\n               Dict(s => i for (i, s) in enumerate(unknowns(jumpsys))))\n\n\n\n\n\nasgraph(sys::AbstractSystem; variables = unknowns(sys),\n        variablestoids = Dict(convert(Variable, v) => i for (i, v) in enumerate(variables)))\n\nConvert an AbstractSystem to a BipartiteGraph mapping the index of equations to the indices of variables they depend on.\n\nNotes:\n\nDefaults for kwargs creating a mapping from equations(sys) to unknowns(sys) they depend on.\nvariables should provide the list of variables to use for generating the dependency graph.\nvariablestoids should provide Dict like mapping from a Variable to its Int index within variables.\n\nExample: Continuing the example started in equation_dependencies\n\ndigr = asgraph(jumpsys)\n\n\n\n\n\n","category":"function"},{"location":"basics/DependencyGraphs/#ModelingToolkit.variable_dependencies","page":"Dependency Graphs","title":"ModelingToolkit.variable_dependencies","text":"variable_dependencies(sys::AbstractSystem; variables = unknowns(sys),\n                      variablestoids = nothing)\n\nFor each variable, determine the equations that modify it and return as a BipartiteGraph.\n\nNotes:\n\nDependencies are returned as a BipartiteGraph mapping variable indices to the indices of equations that modify them.\nvariables denotes the list of variables to determine dependencies for.\nvariablestoids denotes a Dict mapping Variables to their Int index in variables.\n\nExample: Continuing the example of equation_dependencies\n\nvariable_dependencies(jumpsys)\n\n\n\n\n\n","category":"function"},{"location":"basics/DependencyGraphs/#ModelingToolkit.asdigraph","page":"Dependency Graphs","title":"ModelingToolkit.asdigraph","text":"asdigraph(g::BipartiteGraph, sys::AbstractSystem; variables = unknowns(sys),\n          equationsfirst = true)\n\nConvert a BipartiteGraph to a LightGraph.SimpleDiGraph.\n\nNotes:\n\nThe resulting SimpleDiGraph unifies the two sets of vertices (equations and then unknowns in the case it comes from asgraph), producing one ordered set of integer vertices (SimpleDiGraph does not support two distinct collections of vertices, so they must be merged).\nvariables gives the variables that g are associated with (usually the unknowns of a system).\nequationsfirst (default is true) gives whether the BipartiteGraph gives a mapping from equations to variables they depend on (true), as calculated by asgraph, or whether it gives a mapping from variables to the equations that modify them, as calculated by variable_dependencies.\n\nExample: Continuing the example in asgraph\n\ndg = asdigraph(digr, jumpsys)\n\n\n\n\n\n","category":"function"},{"location":"basics/DependencyGraphs/#ModelingToolkit.eqeq_dependencies","page":"Dependency Graphs","title":"ModelingToolkit.eqeq_dependencies","text":"eqeq_dependencies(eqdeps::BipartiteGraph{T},\n                  vardeps::BipartiteGraph{T}) where {T <: Integer}\n\nCalculate a LightGraph.SimpleDiGraph that maps each equation to equations they depend on.\n\nNotes:\n\nThe fadjlist of the SimpleDiGraph maps from an equation to the equations that modify variables it depends on.\nThe badjlist of the SimpleDiGraph maps from an equation to equations that depend on variables it modifies.\n\nExample: Continuing the example of equation_dependencies\n\neqeqdep = eqeq_dependencies(asgraph(jumpsys), variable_dependencies(jumpsys))\n\n\n\n\n\n","category":"function"},{"location":"basics/DependencyGraphs/#ModelingToolkit.varvar_dependencies","page":"Dependency Graphs","title":"ModelingToolkit.varvar_dependencies","text":"function varvar_dependencies(eqdeps::BipartiteGraph{T},\n                             vardeps::BipartiteGraph{T}) where {T <: Integer}\n    eqeq_dependencies(vardeps, eqdeps)\nend\n\nCalculate a LightGraph.SimpleDiGraph that maps each variable to variables they depend on.\n\nNotes:\n\nThe fadjlist of the SimpleDiGraph maps from a variable to the variables that depend on it.\nThe badjlist of the SimpleDiGraph maps from a variable to variables on which it depends.\n\nExample: Continuing the example of equation_dependencies\n\nvarvardep = varvar_dependencies(asgraph(jumpsys), variable_dependencies(jumpsys))\n\n\n\n\n\n","category":"function"},{"location":"basics/DependencyGraphs/#Miscellaneous","page":"Dependency Graphs","title":"Miscellaneous","text":"","category":"section"},{"location":"basics/DependencyGraphs/#ModelingToolkit.map_variables_to_equations","page":"Dependency Graphs","title":"ModelingToolkit.map_variables_to_equations","text":"map_variables_to_equations(\n    sys::ModelingToolkit.AbstractSystem;\n    rename_dummy_derivatives\n) -> Dict{Union{Num, SymbolicUtils.BasicSymbolic}, Equation}\n\n\nGiven a system that has been simplified via mtkcompile, return a Dict mapping variables of the system to equations that are used to solve for them. This includes observed variables.\n\nKeyword Arguments\n\nrename_dummy_derivatives: Whether to rename dummy derivative variable keys into their Differential forms. For example, this would turn the key yˍt(t) into Differential(t)(y(t)).\n\n\n\n\n\n","category":"function"},{"location":"getting_started/odes/#getting_started_ode","page":"Building ODEs and DAEs with ModelingToolkit.jl","title":"Building ODEs and DAEs with ModelingToolkit.jl","text":"","category":"section"},{"location":"getting_started/odes/","page":"Building ODEs and DAEs with ModelingToolkit.jl","title":"Building ODEs and DAEs with ModelingToolkit.jl","text":"This is an introductory tutorial for ModelingToolkit.jl (MTK). We will demonstrate the basics of the package by demontrating how to build systems of Ordinary Differential Equations (ODEs) and Differential-Algebraic Equations (DAEs).","category":"page"},{"location":"getting_started/odes/#Installing-ModelingToolkit","page":"Building ODEs and DAEs with ModelingToolkit.jl","title":"Installing ModelingToolkit","text":"","category":"section"},{"location":"getting_started/odes/","page":"Building ODEs and DAEs with ModelingToolkit.jl","title":"Building ODEs and DAEs with ModelingToolkit.jl","text":"To install ModelingToolkit, use the Julia package manager. This can be done as follows:","category":"page"},{"location":"getting_started/odes/","page":"Building ODEs and DAEs with ModelingToolkit.jl","title":"Building ODEs and DAEs with ModelingToolkit.jl","text":"using Pkg\nPkg.add(\"ModelingToolkit\")","category":"page"},{"location":"getting_started/odes/#The-end-goal","page":"Building ODEs and DAEs with ModelingToolkit.jl","title":"The end goal","text":"","category":"section"},{"location":"getting_started/odes/","page":"Building ODEs and DAEs with ModelingToolkit.jl","title":"Building ODEs and DAEs with ModelingToolkit.jl","text":"TODO","category":"page"},{"location":"getting_started/odes/#Basics-of-MTK","page":"Building ODEs and DAEs with ModelingToolkit.jl","title":"Basics of MTK","text":"","category":"section"},{"location":"getting_started/odes/","page":"Building ODEs and DAEs with ModelingToolkit.jl","title":"Building ODEs and DAEs with ModelingToolkit.jl","text":"ModelingToolkit.jl is a symbolic-numeric system. This means it allows specifying a model (such as an ODE) in a similar way to how it would be written on paper. Let's start with a simple example. The system to be modeled is a first-order lag element:","category":"page"},{"location":"getting_started/odes/","page":"Building ODEs and DAEs with ModelingToolkit.jl","title":"Building ODEs and DAEs with ModelingToolkit.jl","text":"dotx = fracf(t) - x(t)tau","category":"page"},{"location":"getting_started/odes/","page":"Building ODEs and DAEs with ModelingToolkit.jl","title":"Building ODEs and DAEs with ModelingToolkit.jl","text":"Here, t is the independent variable (time), x(t) is the (scalar) unknown variable, f(t) is an external forcing function, and tau is a parameter.","category":"page"},{"location":"getting_started/odes/","page":"Building ODEs and DAEs with ModelingToolkit.jl","title":"Building ODEs and DAEs with ModelingToolkit.jl","text":"For simplicity, we will start off by setting the forcing function to a constant 1. Every ODE has a single independent variable. MTK has a common definition for time t and the derivative with respect to it.","category":"page"},{"location":"getting_started/odes/","page":"Building ODEs and DAEs with ModelingToolkit.jl","title":"Building ODEs and DAEs with ModelingToolkit.jl","text":"using ModelingToolkit\nusing ModelingToolkit: t_nounits as t, D_nounits as D","category":"page"},{"location":"getting_started/odes/","page":"Building ODEs and DAEs with ModelingToolkit.jl","title":"Building ODEs and DAEs with ModelingToolkit.jl","text":"Next, we declare the (dependent) variables and the parameters of our model:","category":"page"},{"location":"getting_started/odes/","page":"Building ODEs and DAEs with ModelingToolkit.jl","title":"Building ODEs and DAEs with ModelingToolkit.jl","text":"@variables x(t)\n@parameters τ","category":"page"},{"location":"getting_started/odes/","page":"Building ODEs and DAEs with ModelingToolkit.jl","title":"Building ODEs and DAEs with ModelingToolkit.jl","text":"Note the syntax x(t). We must declare that the variable x is a function of the independent variable t. Next, we define the equations of the system:","category":"page"},{"location":"getting_started/odes/","page":"Building ODEs and DAEs with ModelingToolkit.jl","title":"Building ODEs and DAEs with ModelingToolkit.jl","text":"eqs = [D(x) ~ (1 - x) / τ]","category":"page"},{"location":"getting_started/odes/","page":"Building ODEs and DAEs with ModelingToolkit.jl","title":"Building ODEs and DAEs with ModelingToolkit.jl","text":"Since = is reserved as the assignment operator, MTK uses ~ to denote equality between expressions. Now we must consolidate all of this information about our system of ODEs into ModelingToolkit's System type.","category":"page"},{"location":"getting_started/odes/","page":"Building ODEs and DAEs with ModelingToolkit.jl","title":"Building ODEs and DAEs with ModelingToolkit.jl","text":"sys = System(eqs, t, [x], [τ]; name = :sys)","category":"page"},{"location":"getting_started/odes/","page":"Building ODEs and DAEs with ModelingToolkit.jl","title":"Building ODEs and DAEs with ModelingToolkit.jl","text":"The System constructor accepts a Vector{Equation} as the first argument, followed by the independent variable, a list of dependent variables, and a list of parameters. Every system must be given a name via the name keyword argument. Most of the time, we want to name our system the same as the variable it is assigned to. The @named macro helps with this:","category":"page"},{"location":"getting_started/odes/","page":"Building ODEs and DAEs with ModelingToolkit.jl","title":"Building ODEs and DAEs with ModelingToolkit.jl","text":"@named sys = System(eqs, t, [x], [τ])","category":"page"},{"location":"getting_started/odes/","page":"Building ODEs and DAEs with ModelingToolkit.jl","title":"Building ODEs and DAEs with ModelingToolkit.jl","text":"Additionally, it may become inconvenient to specify all variables and parameters every time a system is created. MTK allows omitting these arguments, and will automatically infer them from the equations.","category":"page"},{"location":"getting_started/odes/","page":"Building ODEs and DAEs with ModelingToolkit.jl","title":"Building ODEs and DAEs with ModelingToolkit.jl","text":"@named sys = System(eqs, t)","category":"page"},{"location":"getting_started/odes/","page":"Building ODEs and DAEs with ModelingToolkit.jl","title":"Building ODEs and DAEs with ModelingToolkit.jl","text":"Our system is not quite ready for simulation yet. First, we must use the mtkcompile function which transforms the system into a form that MTK can handle. For our trivial system, this does not do much.","category":"page"},{"location":"getting_started/odes/","page":"Building ODEs and DAEs with ModelingToolkit.jl","title":"Building ODEs and DAEs with ModelingToolkit.jl","text":"simp_sys = mtkcompile(sys)","category":"page"},{"location":"getting_started/odes/","page":"Building ODEs and DAEs with ModelingToolkit.jl","title":"Building ODEs and DAEs with ModelingToolkit.jl","text":"Since building and simplifying a system is a common workflow, MTK provides the @mtkcompile macro for convenience.","category":"page"},{"location":"getting_started/odes/","page":"Building ODEs and DAEs with ModelingToolkit.jl","title":"Building ODEs and DAEs with ModelingToolkit.jl","text":"@mtkcompile sys = System(eqs, t)","category":"page"},{"location":"getting_started/odes/","page":"Building ODEs and DAEs with ModelingToolkit.jl","title":"Building ODEs and DAEs with ModelingToolkit.jl","text":"We can now build an ODEProblem from the system. ModelingToolkit generates the necessary code for numerical ODE solvers to solve this system. We need to provide an initial value for the variable x and a value for the parameter p, as well as the time span for which to simulate the system.","category":"page"},{"location":"getting_started/odes/","page":"Building ODEs and DAEs with ModelingToolkit.jl","title":"Building ODEs and DAEs with ModelingToolkit.jl","text":"prob = ODEProblem(sys, [x => 0.0, τ => 3.0], (0.0, 10.0))","category":"page"},{"location":"getting_started/odes/","page":"Building ODEs and DAEs with ModelingToolkit.jl","title":"Building ODEs and DAEs with ModelingToolkit.jl","text":"Here, we are saying that x should start at 0.0, τ should be 3.0 and the system should be simulated from t = 0.0 to t = 10.0. To solve the system, we must import a solver.","category":"page"},{"location":"getting_started/odes/","page":"Building ODEs and DAEs with ModelingToolkit.jl","title":"Building ODEs and DAEs with ModelingToolkit.jl","text":"using OrdinaryDiffEq\n\nsol = solve(prob)","category":"page"},{"location":"getting_started/odes/","page":"Building ODEs and DAEs with ModelingToolkit.jl","title":"Building ODEs and DAEs with ModelingToolkit.jl","text":"OrdinaryDiffEq.jl contains a large number of numerical solvers. It also comes with a default solver which is used when calling solve(prob) and is capable of handling a large variety of systems.","category":"page"},{"location":"getting_started/odes/","page":"Building ODEs and DAEs with ModelingToolkit.jl","title":"Building ODEs and DAEs with ModelingToolkit.jl","text":"We can obtain the timeseries of x by indexing the solution with the symbolic variable:","category":"page"},{"location":"getting_started/odes/","page":"Building ODEs and DAEs with ModelingToolkit.jl","title":"Building ODEs and DAEs with ModelingToolkit.jl","text":"sol[x]","category":"page"},{"location":"getting_started/odes/","page":"Building ODEs and DAEs with ModelingToolkit.jl","title":"Building ODEs and DAEs with ModelingToolkit.jl","text":"We can even obtain timeseries of complicated expressions involving the symbolic variables in the model","category":"page"},{"location":"getting_started/odes/","page":"Building ODEs and DAEs with ModelingToolkit.jl","title":"Building ODEs and DAEs with ModelingToolkit.jl","text":"sol[(1 - x) / τ]","category":"page"},{"location":"getting_started/odes/","page":"Building ODEs and DAEs with ModelingToolkit.jl","title":"Building ODEs and DAEs with ModelingToolkit.jl","text":"Perhaps more interesting is a plot of the solution. This can easily be achieved using Plots.jl.","category":"page"},{"location":"getting_started/odes/","page":"Building ODEs and DAEs with ModelingToolkit.jl","title":"Building ODEs and DAEs with ModelingToolkit.jl","text":"using Plots\n\nplot(sol)","category":"page"},{"location":"getting_started/odes/","page":"Building ODEs and DAEs with ModelingToolkit.jl","title":"Building ODEs and DAEs with ModelingToolkit.jl","text":"Similarly, we can plot different expressions:","category":"page"},{"location":"getting_started/odes/","page":"Building ODEs and DAEs with ModelingToolkit.jl","title":"Building ODEs and DAEs with ModelingToolkit.jl","text":"plot(sol; idxs = (1 - x) / τ)","category":"page"},{"location":"tutorials/acausal_components/#acausal","page":"Acausal Component-Based Modeling","title":"Acausal Component-Based Modeling","text":"","category":"section"},{"location":"tutorials/acausal_components/","page":"Acausal Component-Based Modeling","title":"Acausal Component-Based Modeling","text":"In this tutorial, we will build a hierarchical acausal component-based model of the RC circuit. The RC circuit is a simple example where we connect a resistor and a capacitor. Kirchhoff's laws are then applied to state equalities between currents and voltages. This specifies a differential-algebraic equation (DAE) system, where the algebraic equations are given by the constraints and equalities between different component variables. We then simplify this to an ODE by eliminating the equalities before solving. Let's see this in action.","category":"page"},{"location":"tutorials/acausal_components/","page":"Acausal Component-Based Modeling","title":"Acausal Component-Based Modeling","text":"note: Note\nThis tutorial teaches how to build the entire RC circuit from scratch. However, to simulate electric components with more ease, check out the ModelingToolkitStandardLibrary.jl which includes a tutorial for simulating RC circuits with pre-built components","category":"page"},{"location":"tutorials/acausal_components/#Copy-Paste-Example","page":"Acausal Component-Based Modeling","title":"Copy-Paste Example","text":"","category":"section"},{"location":"tutorials/acausal_components/","page":"Acausal Component-Based Modeling","title":"Acausal Component-Based Modeling","text":"using ModelingToolkit, Plots, OrdinaryDiffEq\nusing ModelingToolkit: t_nounits as t, D_nounits as D\n\n@connector Pin begin\n    v(t)\n    i(t), [connect = Flow]\nend\n\n@mtkmodel Ground begin\n    @components begin\n        g = Pin()\n    end\n    @equations begin\n        g.v ~ 0\n    end\nend\n\n@mtkmodel OnePort begin\n    @components begin\n        p = Pin()\n        n = Pin()\n    end\n    @variables begin\n        v(t)\n        i(t)\n    end\n    @equations begin\n        v ~ p.v - n.v\n        0 ~ p.i + n.i\n        i ~ p.i\n    end\nend\n\n@mtkmodel Resistor begin\n    @extend OnePort()\n    @parameters begin\n        R = 1.0 # Sets the default resistance\n    end\n    @equations begin\n        v ~ i * R\n    end\nend\n\n@mtkmodel Capacitor begin\n    @extend OnePort()\n    @parameters begin\n        C = 1.0\n    end\n    @equations begin\n        D(v) ~ i / C\n    end\nend\n\n@mtkmodel ConstantVoltage begin\n    @extend OnePort()\n    @parameters begin\n        V = 1.0\n    end\n    @equations begin\n        V ~ v\n    end\nend\n\n@mtkmodel RCModel begin\n    @description \"A circuit with a constant voltage source, resistor and capacitor connected in series.\"\n    @components begin\n        resistor = Resistor(R = 1.0)\n        capacitor = Capacitor(C = 1.0)\n        source = ConstantVoltage(V = 1.0)\n        ground = Ground()\n    end\n    @equations begin\n        connect(source.p, resistor.p)\n        connect(resistor.n, capacitor.p)\n        connect(capacitor.n, source.n)\n        connect(capacitor.n, ground.g)\n    end\nend\n\n@mtkcompile rc_model = RCModel(resistor.R = 2.0)\nu0 = [\n    rc_model.capacitor.v => 0.0\n]\nprob = ODEProblem(rc_model, u0, (0, 10.0))\nsol = solve(prob)\nplot(sol)","category":"page"},{"location":"tutorials/acausal_components/#Explanation","page":"Acausal Component-Based Modeling","title":"Explanation","text":"","category":"section"},{"location":"tutorials/acausal_components/","page":"Acausal Component-Based Modeling","title":"Acausal Component-Based Modeling","text":"We wish to build the following RC circuit by building individual components and connecting the pins:","category":"page"},{"location":"tutorials/acausal_components/","page":"Acausal Component-Based Modeling","title":"Acausal Component-Based Modeling","text":"(Image: )","category":"page"},{"location":"tutorials/acausal_components/#Building-the-Component-Library","page":"Acausal Component-Based Modeling","title":"Building the Component Library","text":"","category":"section"},{"location":"tutorials/acausal_components/","page":"Acausal Component-Based Modeling","title":"Acausal Component-Based Modeling","text":"For each of our components, we use ModelingToolkit Model that emits an System. At the top, we start with defining the fundamental qualities of an electric circuit component. At every input and output pin, a circuit component has two values: the current at the pin and the voltage. Thus we define the Pin component (connector) to simply be the values there. Whenever two Pins in a circuit are connected together, the system satisfies Kirchhoff's laws, i.e. that currents sum to zero and voltages across the pins are equal. [connect = Flow] informs MTK that currents ought to sum to zero, and by default, variables are equal in a connection.","category":"page"},{"location":"tutorials/acausal_components/","page":"Acausal Component-Based Modeling","title":"Acausal Component-Based Modeling","text":"@connector Pin begin\n    v(t)\n    i(t), [connect = Flow]\nend","category":"page"},{"location":"tutorials/acausal_components/","page":"Acausal Component-Based Modeling","title":"Acausal Component-Based Modeling","text":"Note that this is an incompletely specified System: it cannot be simulated on its own because the equations for v(t) and i(t) are unknown. Instead, this just gives a common syntax for receiving this pair with some default values. One can then construct a Pin using the @named helper macro:","category":"page"},{"location":"tutorials/acausal_components/","page":"Acausal Component-Based Modeling","title":"Acausal Component-Based Modeling","text":"@named mypin1 = Pin()","category":"page"},{"location":"tutorials/acausal_components/","page":"Acausal Component-Based Modeling","title":"Acausal Component-Based Modeling","text":"Next, we build our ground node. A ground node is just a pin that is connected to a constant voltage reservoir, typically taken to be V = 0. Thus to define this component, we generate an System with a Pin subcomponent and specify that the voltage in such a Pin is equal to zero. This gives:","category":"page"},{"location":"tutorials/acausal_components/","page":"Acausal Component-Based Modeling","title":"Acausal Component-Based Modeling","text":"@mtkmodel Ground begin\n    @components begin\n        g = Pin()\n    end\n    @equations begin\n        g.v ~ 0\n    end\nend","category":"page"},{"location":"tutorials/acausal_components/","page":"Acausal Component-Based Modeling","title":"Acausal Component-Based Modeling","text":"Next we build a OnePort: an abstraction for all simple electric component with two pins. The voltage difference between the positive pin and the negative pin is the voltage of the component, the current between two pins must sum to zero, and the current of the component equals to the current of the positive pin.","category":"page"},{"location":"tutorials/acausal_components/","page":"Acausal Component-Based Modeling","title":"Acausal Component-Based Modeling","text":"@mtkmodel OnePort begin\n    @components begin\n        p = Pin()\n        n = Pin()\n    end\n    @variables begin\n        v(t)\n        i(t)\n    end\n    @equations begin\n        v ~ p.v - n.v\n        0 ~ p.i + n.i\n        i ~ p.i\n    end\nend","category":"page"},{"location":"tutorials/acausal_components/","page":"Acausal Component-Based Modeling","title":"Acausal Component-Based Modeling","text":"Next we build a resistor. A resistor is an object that has two Pins, the positive and the negative pins, and follows Ohm's law: v = i*r. The voltage of the resistor is given as the voltage difference across the two pins, while by conservation of charge we know that the current in must equal the current out, which means (no matter the direction of the current flow) the sum of the currents must be zero. This leads to our resistor equations:","category":"page"},{"location":"tutorials/acausal_components/","page":"Acausal Component-Based Modeling","title":"Acausal Component-Based Modeling","text":"@mtkmodel Resistor begin\n    @extend OnePort()\n    @parameters begin\n        R = 1.0\n    end\n    @equations begin\n        v ~ i * R\n    end\nend","category":"page"},{"location":"tutorials/acausal_components/","page":"Acausal Component-Based Modeling","title":"Acausal Component-Based Modeling","text":"Notice that we have created this system with a default parameter R for the resistor's resistance. By doing so, if the resistance of this resistor is not overridden by a higher level default or overridden at ODEProblem construction time, this will be the value of the resistance. Also, note the use of @extend. For the Resistor, we want to simply inherit OnePort's equations and unknowns and extend them with a new equation. Note that v, i are not namespaced as oneport.v or oneport.i.","category":"page"},{"location":"tutorials/acausal_components/","page":"Acausal Component-Based Modeling","title":"Acausal Component-Based Modeling","text":"Using our knowledge of circuits, we similarly construct the Capacitor:","category":"page"},{"location":"tutorials/acausal_components/","page":"Acausal Component-Based Modeling","title":"Acausal Component-Based Modeling","text":"@mtkmodel Capacitor begin\n    @extend OnePort()\n    @parameters begin\n        C = 1.0\n    end\n    @equations begin\n        D(v) ~ i / C\n    end\nend","category":"page"},{"location":"tutorials/acausal_components/","page":"Acausal Component-Based Modeling","title":"Acausal Component-Based Modeling","text":"Now we want to build a constant voltage electric source term. We can think of this as similarly being a two pin object, where the object itself is kept at a constant voltage, essentially generating the electric current. We would then model this as:","category":"page"},{"location":"tutorials/acausal_components/","page":"Acausal Component-Based Modeling","title":"Acausal Component-Based Modeling","text":"@mtkmodel ConstantVoltage begin\n    @extend OnePort()\n    @parameters begin\n        V = 1.0\n    end\n    @equations begin\n        V ~ v\n    end\nend","category":"page"},{"location":"tutorials/acausal_components/","page":"Acausal Component-Based Modeling","title":"Acausal Component-Based Modeling","text":"Note that as we are extending only v from OnePort, it is explicitly specified as a tuple.","category":"page"},{"location":"tutorials/acausal_components/#Connecting-and-Simulating-Our-Electric-Circuit","page":"Acausal Component-Based Modeling","title":"Connecting and Simulating Our Electric Circuit","text":"","category":"section"},{"location":"tutorials/acausal_components/","page":"Acausal Component-Based Modeling","title":"Acausal Component-Based Modeling","text":"Now we are ready to simulate our circuit. Let's build our four components: a resistor, capacitor, source, and ground term. For simplicity, we will make all of our parameter values 1.0. As resistor, capacitor, source lists R, C, V in their argument list, they are promoted as arguments of RCModel as resistor.R, capacitor.C, source.V","category":"page"},{"location":"tutorials/acausal_components/","page":"Acausal Component-Based Modeling","title":"Acausal Component-Based Modeling","text":"@mtkmodel RCModel begin\n    @description \"A circuit with a constant voltage source, resistor and capacitor connected in series.\"\n    @components begin\n        resistor = Resistor(R = 1.0)\n        capacitor = Capacitor(C = 1.0)\n        source = ConstantVoltage(V = 1.0)\n        ground = Ground()\n    end\n    @equations begin\n        connect(source.p, resistor.p)\n        connect(resistor.n, capacitor.p)\n        connect(capacitor.n, source.n)\n        connect(capacitor.n, ground.g)\n    end\nend","category":"page"},{"location":"tutorials/acausal_components/","page":"Acausal Component-Based Modeling","title":"Acausal Component-Based Modeling","text":"We can create a RCModel component with @named. And using subcomponent_name.parameter we can set the parameters or defaults values of variables of subcomponents.","category":"page"},{"location":"tutorials/acausal_components/","page":"Acausal Component-Based Modeling","title":"Acausal Component-Based Modeling","text":"@mtkcompile rc_model = RCModel(resistor.R = 2.0)","category":"page"},{"location":"tutorials/acausal_components/","page":"Acausal Component-Based Modeling","title":"Acausal Component-Based Modeling","text":"This model is acausal because we have not specified anything about the causality of the model. We have simply specified what is true about each of the variables. This forms a system of differential-algebraic equations (DAEs) which define the evolution of each unknown of the system. The equations are:","category":"page"},{"location":"tutorials/acausal_components/","page":"Acausal Component-Based Modeling","title":"Acausal Component-Based Modeling","text":"equations(expand_connections(rc_model))","category":"page"},{"location":"tutorials/acausal_components/","page":"Acausal Component-Based Modeling","title":"Acausal Component-Based Modeling","text":"the unknowns are:","category":"page"},{"location":"tutorials/acausal_components/","page":"Acausal Component-Based Modeling","title":"Acausal Component-Based Modeling","text":"unknowns(rc_model)","category":"page"},{"location":"tutorials/acausal_components/","page":"Acausal Component-Based Modeling","title":"Acausal Component-Based Modeling","text":"and the parameters are:","category":"page"},{"location":"tutorials/acausal_components/","page":"Acausal Component-Based Modeling","title":"Acausal Component-Based Modeling","text":"parameters(rc_model)","category":"page"},{"location":"tutorials/acausal_components/","page":"Acausal Component-Based Modeling","title":"Acausal Component-Based Modeling","text":"The observed equations are:","category":"page"},{"location":"tutorials/acausal_components/","page":"Acausal Component-Based Modeling","title":"Acausal Component-Based Modeling","text":"observed(rc_model)","category":"page"},{"location":"tutorials/acausal_components/#Solving-this-System","page":"Acausal Component-Based Modeling","title":"Solving this System","text":"","category":"section"},{"location":"tutorials/acausal_components/","page":"Acausal Component-Based Modeling","title":"Acausal Component-Based Modeling","text":"We are left with a system of only two equations with two unknown variables. One of the equations is a differential equation, while the other is an algebraic equation. We can then give the values for the initial conditions of our unknowns, and solve the system by converting it to an ODEProblem in mass matrix form and solving it with an ODEProblem mass matrix DAE solver. This is done as follows:","category":"page"},{"location":"tutorials/acausal_components/","page":"Acausal Component-Based Modeling","title":"Acausal Component-Based Modeling","text":"u0 = [rc_model.capacitor.v => 0.0]\n\nprob = ODEProblem(rc_model, u0, (0, 10.0))\nsol = solve(prob)\nplot(sol)","category":"page"},{"location":"tutorials/acausal_components/","page":"Acausal Component-Based Modeling","title":"Acausal Component-Based Modeling","text":"By default, this plots only the unknown variables that had to be solved for. However, what if we wanted to plot the timeseries of a different variable? Do not worry, that information was not thrown away! Instead, transformations like mtkcompile simply change unknown variables into observables which are defined by observed equations.","category":"page"},{"location":"tutorials/acausal_components/","page":"Acausal Component-Based Modeling","title":"Acausal Component-Based Modeling","text":"observed(rc_model)","category":"page"},{"location":"tutorials/acausal_components/","page":"Acausal Component-Based Modeling","title":"Acausal Component-Based Modeling","text":"These are explicit algebraic equations which can then be used to reconstruct the required variables on the fly. This leads to dramatic computational savings because implicitly solving an ODE scales like O(n^3), so making there be as few unknowns as possible is good!","category":"page"},{"location":"tutorials/acausal_components/","page":"Acausal Component-Based Modeling","title":"Acausal Component-Based Modeling","text":"The solution object can be accessed via its symbols. For example, let's retrieve the voltage of the resistor over time:","category":"page"},{"location":"tutorials/acausal_components/","page":"Acausal Component-Based Modeling","title":"Acausal Component-Based Modeling","text":"sol[rc_model.resistor.v]","category":"page"},{"location":"tutorials/acausal_components/","page":"Acausal Component-Based Modeling","title":"Acausal Component-Based Modeling","text":"or we can plot the timeseries of the resistor's voltage:","category":"page"},{"location":"tutorials/acausal_components/","page":"Acausal Component-Based Modeling","title":"Acausal Component-Based Modeling","text":"plot(sol, idxs = [rc_model.resistor.v])","category":"page"},{"location":"tutorials/acausal_components/","page":"Acausal Component-Based Modeling","title":"Acausal Component-Based Modeling","text":"Although it may be more confusing than helpful here, we can of course also plot all unknown and observed variables together:","category":"page"},{"location":"tutorials/acausal_components/","page":"Acausal Component-Based Modeling","title":"Acausal Component-Based Modeling","text":"plot(sol, idxs = [unknowns(rc_model); observables(rc_model)])","category":"page"},{"location":"tutorials/parameter_identifiability/#Parameter-Identifiability-in-ODE-Models","page":"Parameter Identifiability in ODE Models","title":"Parameter Identifiability in ODE Models","text":"","category":"section"},{"location":"tutorials/parameter_identifiability/","page":"Parameter Identifiability in ODE Models","title":"Parameter Identifiability in ODE Models","text":"Ordinary differential equations are commonly used for modeling real-world processes. The problem of parameter identifiability is one of the key design challenges for mathematical models. A parameter is said to be identifiable if one can recover its value from experimental data. Structural identifiability is a theoretical property of a model that answers this question. In this tutorial, we will show how to use StructuralIdentifiability.jl with ModelingToolkit.jl to assess identifiability of parameters in ODE models. The theory behind StructuralIdentifiability.jl is presented in paper [4].","category":"page"},{"location":"tutorials/parameter_identifiability/","page":"Parameter Identifiability in ODE Models","title":"Parameter Identifiability in ODE Models","text":"We will start by illustrating local identifiability in which a parameter is known up to finitely many values, and then proceed to determining global identifiability, that is, which parameters can be identified uniquely.","category":"page"},{"location":"tutorials/parameter_identifiability/","page":"Parameter Identifiability in ODE Models","title":"Parameter Identifiability in ODE Models","text":"The package has a standalone data structure for ordinary differential equations, but is also compatible with System type from ModelingToolkit.jl.","category":"page"},{"location":"tutorials/parameter_identifiability/#Local-Identifiability","page":"Parameter Identifiability in ODE Models","title":"Local Identifiability","text":"","category":"section"},{"location":"tutorials/parameter_identifiability/#Input-System","page":"Parameter Identifiability in ODE Models","title":"Input System","text":"","category":"section"},{"location":"tutorials/parameter_identifiability/","page":"Parameter Identifiability in ODE Models","title":"Parameter Identifiability in ODE Models","text":"We will consider the following model:","category":"page"},{"location":"tutorials/parameter_identifiability/","page":"Parameter Identifiability in ODE Models","title":"Parameter Identifiability in ODE Models","text":"begincases\nfracdx_4dt = - frack_5 x_4k_6 + x_4\nfracdx_5dt = frack_5 x_4k_6 + x_4 - frack_7 x_5(k_8 + x_5 + x_6)\nfracdx_6dt = frack_7 x_5(k_8 + x_5 + x_6) - frack_9  x_6  (k_10 - x_6) k_10\nfracdx_7dt = frack_9  x_6  (k_10 - x_6) k_10\ny_1 = x_4\ny_2 = x_5endcases","category":"page"},{"location":"tutorials/parameter_identifiability/","page":"Parameter Identifiability in ODE Models","title":"Parameter Identifiability in ODE Models","text":"This model describes the biohydrogenation[1] process[2] with unknown initial conditions.","category":"page"},{"location":"tutorials/parameter_identifiability/#Using-the-System-object","page":"Parameter Identifiability in ODE Models","title":"Using the System object","text":"","category":"section"},{"location":"tutorials/parameter_identifiability/","page":"Parameter Identifiability in ODE Models","title":"Parameter Identifiability in ODE Models","text":"To define the ode system in Julia, we use ModelingToolkit.jl.","category":"page"},{"location":"tutorials/parameter_identifiability/","page":"Parameter Identifiability in ODE Models","title":"Parameter Identifiability in ODE Models","text":"We first define the parameters, variables, differential equations and the output equations.","category":"page"},{"location":"tutorials/parameter_identifiability/","page":"Parameter Identifiability in ODE Models","title":"Parameter Identifiability in ODE Models","text":"using StructuralIdentifiability, ModelingToolkit\nusing ModelingToolkit: t_nounits as t, D_nounits as D\n\n@mtkmodel Biohydrogenation begin\n    @variables begin\n        x4(t)\n        x5(t)\n        x6(t)\n        x7(t)\n        y1(t), [output = true]\n        y2(t), [output = true]\n    end\n    @parameters begin\n        k5\n        k6\n        k7\n        k8\n        k9\n        k10\n    end\n    # define equations\n    @equations begin\n        D(x4) ~ -k5 * x4 / (k6 + x4)\n        D(x5) ~ k5 * x4 / (k6 + x4) - k7 * x5 / (k8 + x5 + x6)\n        D(x6) ~ k7 * x5 / (k8 + x5 + x6) - k9 * x6 * (k10 - x6) / k10\n        D(x7) ~ k9 * x6 * (k10 - x6) / k10\n        y1 ~ x4\n        y2 ~ x5\n    end\nend\n\n# define the system\n@mtkcompile de = Biohydrogenation()","category":"page"},{"location":"tutorials/parameter_identifiability/","page":"Parameter Identifiability in ODE Models","title":"Parameter Identifiability in ODE Models","text":"After that, we are ready to check the system for local identifiability:","category":"page"},{"location":"tutorials/parameter_identifiability/","page":"Parameter Identifiability in ODE Models","title":"Parameter Identifiability in ODE Models","text":"# query local identifiability\n# we pass the ode-system\nlocal_id_all = assess_local_identifiability(de, prob_threshold = 0.99)","category":"page"},{"location":"tutorials/parameter_identifiability/","page":"Parameter Identifiability in ODE Models","title":"Parameter Identifiability in ODE Models","text":"We can see that all unknowns (except x_7) and all parameters are locally identifiable with probability 0.99.","category":"page"},{"location":"tutorials/parameter_identifiability/","page":"Parameter Identifiability in ODE Models","title":"Parameter Identifiability in ODE Models","text":"Let's try to check specific parameters and their combinations","category":"page"},{"location":"tutorials/parameter_identifiability/","page":"Parameter Identifiability in ODE Models","title":"Parameter Identifiability in ODE Models","text":"to_check = [de.k5, de.k7, de.k10 / de.k9, de.k5 + de.k6]\nlocal_id_some = assess_local_identifiability(\n    de, funcs_to_check = to_check, prob_threshold = 0.99)","category":"page"},{"location":"tutorials/parameter_identifiability/","page":"Parameter Identifiability in ODE Models","title":"Parameter Identifiability in ODE Models","text":"Notice that in this case, everything (except the unknown variable x_7) is locally identifiable, including combinations such as k_10k_9 k_5+k_6","category":"page"},{"location":"tutorials/parameter_identifiability/#Global-Identifiability","page":"Parameter Identifiability in ODE Models","title":"Global Identifiability","text":"","category":"section"},{"location":"tutorials/parameter_identifiability/","page":"Parameter Identifiability in ODE Models","title":"Parameter Identifiability in ODE Models","text":"In this part tutorial, let us cover an example problem of querying the ODE for globally identifiable parameters.","category":"page"},{"location":"tutorials/parameter_identifiability/#Input-System-2","page":"Parameter Identifiability in ODE Models","title":"Input System","text":"","category":"section"},{"location":"tutorials/parameter_identifiability/","page":"Parameter Identifiability in ODE Models","title":"Parameter Identifiability in ODE Models","text":"Let us consider the following four-dimensional model with two outputs:","category":"page"},{"location":"tutorials/parameter_identifiability/","page":"Parameter Identifiability in ODE Models","title":"Parameter Identifiability in ODE Models","text":"begincases\nx_1(t) = -b  x_1(t) + frac1  c + x_4(t)\nx_2(t) = alpha  x_1(t) - beta  x_2(t)\nx_3(t) = gamma  x_2(t) - delta  x_3(t)\nx_4(t) = sigma  x_4(t)  frac(gamma x_2(t) - delta x_3(t)) x_3(t)\ny(t) = x_1(t)\nendcases","category":"page"},{"location":"tutorials/parameter_identifiability/","page":"Parameter Identifiability in ODE Models","title":"Parameter Identifiability in ODE Models","text":"We will run a global identifiability check on this enzyme dynamics[3] model. We will use the default settings: the probability of correctness will be p=0.99 and we are interested in identifiability of all possible parameters.","category":"page"},{"location":"tutorials/parameter_identifiability/","page":"Parameter Identifiability in ODE Models","title":"Parameter Identifiability in ODE Models","text":"Global identifiability needs information about local identifiability first, but the function we chose here will take care of that extra step for us.","category":"page"},{"location":"tutorials/parameter_identifiability/","page":"Parameter Identifiability in ODE Models","title":"Parameter Identifiability in ODE Models","text":"using StructuralIdentifiability, ModelingToolkit\nusing ModelingToolkit: t_nounits as t, D_nounits as D\n\n@mtkmodel GoodwinOsc begin\n    @parameters begin\n        b\n        c\n        α\n        β\n        γ\n        δ\n        σ\n    end\n    @variables begin\n        x1(t)\n        x2(t)\n        x3(t)\n        x4(t)\n        y(t), [output = true]\n        y2(t), [output = true]\n    end\n    @equations begin\n        D(x1) ~ -b * x1 + 1 / (c + x4)\n        D(x2) ~ α * x1 - β * x2\n        D(x3) ~ γ * x2 - δ * x3\n        D(x4) ~ σ * x4 * (γ * x2 - δ * x3) / x3\n        y ~ x1 + x2\n        y2 ~ x2\n    end\nend\n\n@named ode = GoodwinOsc()\n\nglobal_id = assess_identifiability(ode)","category":"page"},{"location":"tutorials/parameter_identifiability/","page":"Parameter Identifiability in ODE Models","title":"Parameter Identifiability in ODE Models","text":"We can see that only parameters a, g are unidentifiable, and everything else can be uniquely recovered.","category":"page"},{"location":"tutorials/parameter_identifiability/","page":"Parameter Identifiability in ODE Models","title":"Parameter Identifiability in ODE Models","text":"Let us consider the same system but with two inputs, and we will find out identifiability with probability 0.9 for parameters c and b:","category":"page"},{"location":"tutorials/parameter_identifiability/","page":"Parameter Identifiability in ODE Models","title":"Parameter Identifiability in ODE Models","text":"using StructuralIdentifiability, ModelingToolkit\nusing ModelingToolkit: t_nounits as t, D_nounits as D\n\n@mtkmodel GoodwinOscillator begin\n    @parameters begin\n        b\n        c\n        α\n        β\n        γ\n        δ\n        σ\n    end\n    @variables begin\n        x1(t)\n        x2(t)\n        x3(t)\n        x4(t)\n        y(t), [output = true]\n        y2(t), [output = true]\n        u1(t), [input = true]\n        u2(t), [input = true]\n    end\n    @equations begin\n        D(x1) ~ -b * x1 + 1 / (c + x4)\n        D(x2) ~ α * x1 - β * x2 - u1\n        D(x3) ~ γ * x2 - δ * x3 + u2\n        D(x4) ~ σ * x4 * (γ * x2 - δ * x3) / x3\n        y ~ x1 + x2\n        y2 ~ x2\n    end\nend\n\n@mtkcompile ode = GoodwinOscillator()\n\n# check only 2 parameters\nto_check = [ode.b, ode.c]\n\nglobal_id = assess_identifiability(ode, funcs_to_check = to_check, prob_threshold = 0.9)","category":"page"},{"location":"tutorials/parameter_identifiability/","page":"Parameter Identifiability in ODE Models","title":"Parameter Identifiability in ODE Models","text":"Both parameters b, c are globally identifiable with probability 0.9 in this case.","category":"page"},{"location":"tutorials/parameter_identifiability/","page":"Parameter Identifiability in ODE Models","title":"Parameter Identifiability in ODE Models","text":"[1]: R. Munoz-Tamayo, L. Puillet, J.B. Daniel, D. Sauvant, O. Martin, M. Taghipoor, P. Blavy Review: To be or not to be an identifiable model. Is this a relevant question in animal science modelling?, Animal, Vol 12 (4), 701-712, 2018. The model is the ODE system (3) in Supplementary Material 2, initial conditions are assumed to be unknown.","category":"page"},{"location":"tutorials/parameter_identifiability/","page":"Parameter Identifiability in ODE Models","title":"Parameter Identifiability in ODE Models","text":"[2]: Moate P.J., Boston R.C., Jenkins T.C. and Lean I.J., Kinetics of Ruminal Lipolysis of Triacylglycerol and Biohydrogenationof Long-Chain Fatty Acids: New Insights from Old Data, Journal of Dairy Science 91, 731–742, 2008","category":"page"},{"location":"tutorials/parameter_identifiability/","page":"Parameter Identifiability in ODE Models","title":"Parameter Identifiability in ODE Models","text":"[3]: Goodwin, B.C. Oscillatory behavior in enzymatic control processes, Advances in Enzyme Regulation, Vol 3 (C), 425-437, 1965","category":"page"},{"location":"tutorials/parameter_identifiability/","page":"Parameter Identifiability in ODE Models","title":"Parameter Identifiability in ODE Models","text":"[4]: Dong, R., Goodbrake, C., Harrington, H. A., & Pogudin, G. Computing input-output projections of dynamical models with applications to structural identifiability. arXiv preprint arXiv:2111.00991.","category":"page"},{"location":"basics/Validation/#units","page":"Model Validation and Units","title":"Model Validation and Units","text":"","category":"section"},{"location":"basics/Validation/","page":"Model Validation and Units","title":"Model Validation and Units","text":"ModelingToolkit.jl provides extensive functionality for model validation and unit checking. This is done by providing metadata to the variable types and then running the validation functions which identify malformed systems and non-physical equations. This approach provides high performance and compatibility with numerical solvers.","category":"page"},{"location":"basics/Validation/#Assigning-Units","page":"Model Validation and Units","title":"Assigning Units","text":"","category":"section"},{"location":"basics/Validation/","page":"Model Validation and Units","title":"Model Validation and Units","text":"Units may be assigned with the following syntax.","category":"page"},{"location":"basics/Validation/","page":"Model Validation and Units","title":"Model Validation and Units","text":"using ModelingToolkit, DynamicQuantities\n@independent_variables t [unit = u\"s\"]\n@variables x(t) [unit = u\"m\"] g(t) w(t) [unit = u\"Hz\"]\n\n@parameters(t, [unit = u\"s\"])\n@variables(x(t), [unit = u\"m\"], g(t), w(t), [unit = u\"Hz\"])\n\n@parameters begin\n    t, [unit = u\"s\"]\nend\n@variables(begin\n    x(t), [unit = u\"m\"],\n    g(t),\n    w(t), [unit = u\"Hz\"]\nend)\n\n# Simultaneously set default value (use plain numbers, not quantities)\n@variables x=10 [unit = u\"m\"]\n\n# Symbolic array: unit applies to all elements\n@variables x[1:3] [unit = u\"m\"]","category":"page"},{"location":"basics/Validation/","page":"Model Validation and Units","title":"Model Validation and Units","text":"Do not use quantities such as  1u\"s\", 1/u\"s\" or u\"1/s\" as these will result in errors; instead use u\"s\", u\"s^-1\", or u\"s\"^-1.","category":"page"},{"location":"basics/Validation/#Unit-Validation-and-Inspection","page":"Model Validation and Units","title":"Unit Validation & Inspection","text":"","category":"section"},{"location":"basics/Validation/","page":"Model Validation and Units","title":"Model Validation and Units","text":"Unit validation of equations happens automatically when creating a system. However, for debugging purposes, one may wish to validate the equations directly using validate.","category":"page"},{"location":"basics/Validation/#ModelingToolkit.validate","page":"Model Validation and Units","title":"ModelingToolkit.validate","text":"Returns true iff units of equations are valid.\n\n\n\n\n\n","category":"function"},{"location":"basics/Validation/","page":"Model Validation and Units","title":"Model Validation and Units","text":"Inside, validate uses get_unit, which may be directly applied to any term. Note that validate will not throw an error in the event of incompatible units, but get_unit will. If you would rather receive a warning instead of an error, use safe_get_unit which will yield nothing in the event of an error. Unit agreement is tested with ModelingToolkit.equivalent(u1,u2).","category":"page"},{"location":"basics/Validation/#ModelingToolkit.get_unit","page":"Model Validation and Units","title":"ModelingToolkit.get_unit","text":"Find the unit of a symbolic item.\n\n\n\n\n\n","category":"function"},{"location":"basics/Validation/","page":"Model Validation and Units","title":"Model Validation and Units","text":"Example usage below. Note that ModelingToolkit does not force unit conversions to preferred units in the event of nonstandard combinations – it merely checks that the equations are consistent.","category":"page"},{"location":"basics/Validation/","page":"Model Validation and Units","title":"Model Validation and Units","text":"using ModelingToolkit, DynamicQuantities\n@independent_variables t [unit = u\"ms\"]\n@parameters τ [unit = u\"ms\"]\n@variables E(t) [unit = u\"kJ\"] P(t) [unit = u\"MW\"]\nD = Differential(t)\neqs = [D(E) ~ P - E / τ,\n    0 ~ P]\nModelingToolkit.validate(eqs)","category":"page"},{"location":"basics/Validation/","page":"Model Validation and Units","title":"Model Validation and Units","text":"ModelingToolkit.validate(eqs[1])","category":"page"},{"location":"basics/Validation/","page":"Model Validation and Units","title":"Model Validation and Units","text":"try\n    ModelingToolkit.get_unit(eqs[1].rhs)\ncatch e\n    showerror(stdout, e)\nend","category":"page"},{"location":"basics/Validation/","page":"Model Validation and Units","title":"Model Validation and Units","text":"An example of an inconsistent system: at present, ModelingToolkit requires that the units of all terms in an equation or sum to be equal-valued (ModelingToolkit.equivalent(u1,u2)), rather than simply dimensionally consistent. In the future, the validation stage may be upgraded to support the insertion of conversion factors into the equations.","category":"page"},{"location":"basics/Validation/","page":"Model Validation and Units","title":"Model Validation and Units","text":"using ModelingToolkit, DynamicQuantities\n@independent_variables t [unit = u\"ms\"]\n@parameters τ [unit = u\"ms\"]\n@variables E(t) [unit = u\"J\"] P(t) [unit = u\"MW\"]\nD = Differential(t)\neqs = [D(E) ~ P - E / τ,\n    0 ~ P]\nModelingToolkit.validate(eqs) #Returns false while displaying a warning message","category":"page"},{"location":"basics/Validation/#User-Defined-Registered-Functions-and-Types","page":"Model Validation and Units","title":"User-Defined Registered Functions and Types","text":"","category":"section"},{"location":"basics/Validation/","page":"Model Validation and Units","title":"Model Validation and Units","text":"In order to validate user-defined types and registered functions, specialize get_unit.  Single-parameter calls to get_unit expect an object type, while two-parameter calls expect a function type as the first argument, and a vector of arguments as the second argument.","category":"page"},{"location":"basics/Validation/","page":"Model Validation and Units","title":"Model Validation and Units","text":"using ModelingToolkit, DynamicQuantities\nusing ModelingToolkit: t_nounits as t, D_nounits as D\n# Composite type parameter in registered function\nstruct NewType\n    f::Any\nend\n@register_symbolic dummycomplex(complex::Num, scalar)\ndummycomplex(complex, scalar) = complex.f - scalar\n\nc = NewType(1)\nModelingToolkit.get_unit(x::NewType) = ModelingToolkit.get_unit(x.f)\nfunction ModelingToolkit.get_unit(op::typeof(dummycomplex), args)\n    argunits = ModelingToolkit.get_unit.(args)\n    ModelingToolkit.get_unit(-, args)\nend\n\nsts = @variables a(t)=0 [unit = u\"cm\"]\nps = @parameters s=-1 [unit=u\"cm\"] c=c [unit=u\"cm\"]\neqs = [D(a) ~ dummycomplex(c, s);]\nsys = System(\n    eqs, t, [sts...;], [ps...;], name = :sys, checks = ~ModelingToolkit.CheckUnits)\nsys_simple = mtkcompile(sys)","category":"page"},{"location":"basics/Validation/#DynamicQuantities-Literals","page":"Model Validation and Units","title":"DynamicQuantities Literals","text":"","category":"section"},{"location":"basics/Validation/","page":"Model Validation and Units","title":"Model Validation and Units","text":"In order for a function to work correctly during both validation & execution, the function must be unit-agnostic. That is, no unitful literals may be used. Any unitful quantity must either be a parameter or variable. For example, these equations will not validate successfully.","category":"page"},{"location":"basics/Validation/","page":"Model Validation and Units","title":"Model Validation and Units","text":"using ModelingToolkit, DynamicQuantities\n@independent_variables t [unit = u\"ms\"]\n@variables E(t) [unit = u\"J\"] P(t) [unit = u\"MW\"]\nD = Differential(t)\neqs = [D(E) ~ P - E / 1u\"ms\"]\nModelingToolkit.validate(eqs) #Returns false while displaying a warning message\n\nmyfunc(E) = E / 1u\"ms\"\neqs = [D(E) ~ P - myfunc(E)]\nModelingToolkit.validate(eqs) #Returns false while displaying a warning message","category":"page"},{"location":"basics/Validation/","page":"Model Validation and Units","title":"Model Validation and Units","text":"Instead, they should be parameterized:","category":"page"},{"location":"basics/Validation/","page":"Model Validation and Units","title":"Model Validation and Units","text":"using ModelingToolkit, DynamicQuantities\n@independent_variables t [unit = u\"ms\"]\n@parameters τ [unit = u\"ms\"]\n@variables E(t) [unit = u\"kJ\"] P(t) [unit = u\"MW\"]\nD = Differential(t)\neqs = [D(E) ~ P - E / τ]\nModelingToolkit.validate(eqs) #Returns true","category":"page"},{"location":"basics/Validation/","page":"Model Validation and Units","title":"Model Validation and Units","text":"myfunc(E, τ) = E / τ\neqs = [D(E) ~ P - myfunc(E, τ)]\nModelingToolkit.validate(eqs) #Returns true","category":"page"},{"location":"basics/Validation/","page":"Model Validation and Units","title":"Model Validation and Units","text":"It is recommended not to circumvent unit validation by specializing user-defined functions on DynamicQuantities arguments vs. Numbers. This both fails to take advantage of validate for ensuring correctness, and may cause in errors in the future when ModelingToolkit is extended to support eliminating DynamicQuantities literals from functions.","category":"page"},{"location":"basics/Validation/#Other-Restrictions","page":"Model Validation and Units","title":"Other Restrictions","text":"","category":"section"},{"location":"basics/Validation/","page":"Model Validation and Units","title":"Model Validation and Units","text":"Unitful provides non-scalar units such as dBm, °C, etc. At this time, ModelingToolkit only supports scalar quantities. Additionally, angular degrees (°) are not supported because trigonometric functions will treat plain numerical values as radians, which would lead systems validated using degrees to behave erroneously when being solved.","category":"page"},{"location":"basics/Validation/#Troubleshooting-and-Gotchas","page":"Model Validation and Units","title":"Troubleshooting & Gotchas","text":"","category":"section"},{"location":"basics/Validation/","page":"Model Validation and Units","title":"Model Validation and Units","text":"If a system fails to validate due to unit issues, at least one warning message will appear, including a line number as well as the unit types and expressions that were in conflict. Some system constructors re-order equations before the unit checking can be done, in which case the equation numbers may be inaccurate. The printed expression that the problem resides in is always correctly shown.","category":"page"},{"location":"basics/Validation/","page":"Model Validation and Units","title":"Model Validation and Units","text":"Symbolic exponents for unitful variables are supported (ex: P^γ in thermodynamics). However, this means that ModelingToolkit cannot reduce such expressions to DynamicQuantities.Quantity subtypes at validation time because the exponent value is not available. In this case ModelingToolkit.get_unit is type-unstable, yielding a symbolic result, which can still be checked for symbolic equality with ModelingToolkit.equivalent.","category":"page"},{"location":"basics/Validation/#Parameter-and-Initial-Condition-Values","page":"Model Validation and Units","title":"Parameter & Initial Condition Values","text":"","category":"section"},{"location":"basics/Validation/","page":"Model Validation and Units","title":"Model Validation and Units","text":"Parameter and initial condition values are supplied to problem constructors as plain numbers, with the understanding that they have been converted to the appropriate units. This is done for simplicity of interfacing with optimization solvers. Some helper function for dealing with value maps:","category":"page"},{"location":"basics/Validation/","page":"Model Validation and Units","title":"Model Validation and Units","text":"function remove_units(p::Dict)\n    Dict(k => Unitful.ustrip(ModelingToolkit.get_unit(k), v) for (k, v) in p)\nend\nadd_units(p::Dict) = Dict(k => v * ModelingToolkit.get_unit(k) for (k, v) in p)","category":"page"},{"location":"basics/Validation/","page":"Model Validation and Units","title":"Model Validation and Units","text":"Recommended usage:","category":"page"},{"location":"basics/Validation/","page":"Model Validation and Units","title":"Model Validation and Units","text":"pars = @parameters τ [unit = u\"ms\"]\np = Dict(τ => 1u\"ms\")\nODEProblem(sys, remove_units(u0), tspan, remove_units(p))","category":"page"},{"location":"tutorials/bifurcation_diagram_computation/#bifurcation_diagrams","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"","category":"section"},{"location":"tutorials/bifurcation_diagram_computation/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"Bifurcation diagrams describes how, for a dynamic system, the quantity and quality of its steady states changes with a parameter's value. These can be computed through the BifurcationKit.jl package. ModelingToolkit provides a simple interface for creating BifurcationKit compatible BifurcationProblems from NonlinearSystems and Systems. All the features provided by BifurcationKit can then be applied to these systems. This tutorial provides a brief introduction for these features, with BifurcationKit.jl providing a more extensive documentation.","category":"page"},{"location":"tutorials/bifurcation_diagram_computation/#Creating-a-BifurcationProblem","page":"Bifurcation Diagrams","title":"Creating a BifurcationProblem","text":"","category":"section"},{"location":"tutorials/bifurcation_diagram_computation/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"Let us first consider a simple NonlinearSystem:","category":"page"},{"location":"tutorials/bifurcation_diagram_computation/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"using ModelingToolkit\nusing ModelingToolkit: t_nounits as t, D_nounits as D\n\n@variables x(t) y(t)\n@parameters μ α\neqs = [0 ~ μ * x - x^3 + α * y,\n    0 ~ -y]\n@mtkcompile nsys = System(eqs, [x, y], [μ, α])","category":"page"},{"location":"tutorials/bifurcation_diagram_computation/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"we wish to compute a bifurcation diagram for this system as we vary the parameter μ. For this, we need to provide the following information:","category":"page"},{"location":"tutorials/bifurcation_diagram_computation/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"The system for which we wish to compute the bifurcation diagram (nsys).\nThe parameter which we wish to vary (μ).\nThe parameter set for which we want to compute the bifurcation diagram.\nAn initial guess of the state of the system for which there is a steady state at our provided parameter value.\nThe variable which value we wish to plot in the bifurcation diagram (this argument is optional, if not provided, BifurcationKit default plot functions are used).","category":"page"},{"location":"tutorials/bifurcation_diagram_computation/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"We declare this additional information:","category":"page"},{"location":"tutorials/bifurcation_diagram_computation/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"bif_par = μ\np_start = [μ => -1.0, α => 1.0]\nu0_guess = [x => 1.0, y => 1.0]\nplot_var = x;","category":"page"},{"location":"tutorials/bifurcation_diagram_computation/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"For the initial state guess (u0_guess), typically any value can be provided, however, read BifurcatioKit's documentation for more details.","category":"page"},{"location":"tutorials/bifurcation_diagram_computation/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"We can now create our BifurcationProblem, which can be provided as input to BifurcationKit's various functions.","category":"page"},{"location":"tutorials/bifurcation_diagram_computation/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"using BifurcationKit\nbprob = BifurcationProblem(nsys,\n    u0_guess,\n    p_start,\n    bif_par;\n    plot_var = plot_var,\n    jac = false)","category":"page"},{"location":"tutorials/bifurcation_diagram_computation/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"Here, the jac argument (by default set to true) sets whenever to provide BifurcationKit with a Jacobian or not.","category":"page"},{"location":"tutorials/bifurcation_diagram_computation/#Computing-a-bifurcation-diagram","page":"Bifurcation Diagrams","title":"Computing a bifurcation diagram","text":"","category":"section"},{"location":"tutorials/bifurcation_diagram_computation/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"Let us consider the BifurcationProblem from the last section. If we wish to compute the corresponding bifurcation diagram we must first declare various settings used by BifurcationKit to compute the diagram. These are stored in a ContinuationPar structure (which also contain a NewtonPar structure).","category":"page"},{"location":"tutorials/bifurcation_diagram_computation/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"p_span = (-4.0, 6.0)\nopts_br = ContinuationPar(nev = 2,\n    p_min = p_span[1],\n    p_max = p_span[2])","category":"page"},{"location":"tutorials/bifurcation_diagram_computation/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"Here, p_span sets the interval over which we wish to compute the diagram.","category":"page"},{"location":"tutorials/bifurcation_diagram_computation/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"Next, we can use this as input to our bifurcation diagram, and then plot it.","category":"page"},{"location":"tutorials/bifurcation_diagram_computation/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"bf = bifurcationdiagram(bprob, PALC(), 2, (args...) -> opts_br; bothside = true)","category":"page"},{"location":"tutorials/bifurcation_diagram_computation/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"Here, the value 2 sets how sub-branches of the diagram that BifurcationKit should compute. Generally, for bifurcation diagrams, it is recommended to use the bothside=true argument.","category":"page"},{"location":"tutorials/bifurcation_diagram_computation/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"using Plots\nplot(bf;\n    putspecialptlegend = false,\n    markersize = 2,\n    plotfold = false,\n    xguide = \"μ\",\n    yguide = \"x\")","category":"page"},{"location":"tutorials/bifurcation_diagram_computation/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"Here, the system exhibits a pitchfork bifurcation at μ=0.0.","category":"page"},{"location":"tutorials/bifurcation_diagram_computation/#Using-System-inputs","page":"Bifurcation Diagrams","title":"Using System inputs","text":"","category":"section"},{"location":"tutorials/bifurcation_diagram_computation/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"It is also possible to use Systems (rather than NonlinearSystems) as input to BifurcationProblem. Here follows a brief such example.","category":"page"},{"location":"tutorials/bifurcation_diagram_computation/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"using BifurcationKit, ModelingToolkit, Plots\nusing ModelingToolkit: t_nounits as t, D_nounits as D\n\n@variables x(t) y(t)\n@parameters μ\neqs = [D(x) ~ μ * x - y - x * (x^2 + y^2),\n    D(y) ~ x + μ * y - y * (x^2 + y^2)]\n@mtkcompile osys = System(eqs, t)\n\nbif_par = μ\nplot_var = x\np_start = [μ => 1.0]\nu0_guess = [x => 0.0, y => 0.0]\n\nbprob = BifurcationProblem(osys,\n    u0_guess,\n    p_start,\n    bif_par;\n    plot_var = plot_var,\n    jac = false)\n\np_span = (-3.0, 3.0)\nopts_br = ContinuationPar(nev = 2,\n    p_max = p_span[2], p_min = p_span[1])\n\nbf = bifurcationdiagram(bprob, PALC(), 2, (args...) -> opts_br; bothside = true)\nusing Plots\nplot(bf;\n    putspecialptlegend = false,\n    markersize = 2,\n    plotfold = false,\n    xguide = \"μ\",\n    yguide = \"x\")","category":"page"},{"location":"tutorials/bifurcation_diagram_computation/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"Here, the value of x in the steady state does not change, however, at μ=0 a Hopf bifurcation occur and the steady state turn unstable.","category":"page"},{"location":"tutorials/bifurcation_diagram_computation/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"We compute the branch of periodic orbits which is nearby the Hopf Bifurcation. We thus provide the branch bf.γ, the index of the Hopf point we want to branch from: 2 in this case and a method PeriodicOrbitOCollProblem(20, 5) to compute periodic orbits.","category":"page"},{"location":"tutorials/bifurcation_diagram_computation/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"br_po = continuation(bf.γ, 2, opts_br,\n    PeriodicOrbitOCollProblem(20, 5);)\n\nplot(bf; putspecialptlegend = false,\n    markersize = 2,\n    plotfold = false,\n    xguide = \"μ\",\n    yguide = \"x\")\nplot!(br_po, xguide = \"μ\", yguide = \"x\", label = \"Maximum of periodic orbit\")","category":"page"},{"location":"tutorials/bifurcation_diagram_computation/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"Let's see how to plot the periodic solution we just computed:","category":"page"},{"location":"tutorials/bifurcation_diagram_computation/","page":"Bifurcation Diagrams","title":"Bifurcation Diagrams","text":"sol = get_periodic_orbit(br_po, 10)\nplot(sol.t, sol[1, :], yguide = \"x\", xguide = \"time\", label = \"\")","category":"page"},{"location":"basics/MTKLanguage/#mtk_language","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","text":"","category":"section"},{"location":"basics/MTKLanguage/#MTK-Model","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"MTK Model","text":"","category":"section"},{"location":"basics/MTKLanguage/","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","text":"MTK represents components and connectors with Model.","category":"page"},{"location":"basics/MTKLanguage/#ModelingToolkit.Model","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"ModelingToolkit.Model","text":"struct Model{F, S}\n\nModelingToolkit component or connector with metadata\n\nFields\n\nf: The constructor that returns System.\nstructure: The dictionary with metadata like keyword arguments (:kwargs), base system this Model extends (:extend), sub-components of the Model (:components), variables (:variables), parameters (:parameters), structural parameters (:structural_parameters) and equations (:equations).\n\nisconnector: This flag is true when the Model is a connector and is false when it is a component\n\n\n\n\n\n","category":"type"},{"location":"basics/MTKLanguage/#Components","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"Components","text":"","category":"section"},{"location":"basics/MTKLanguage/","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","text":"Components are models from various domains. These models contain unknowns and their equations.","category":"page"},{"location":"basics/MTKLanguage/#mtkmodel","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"Defining components with @mtkmodel","text":"","category":"section"},{"location":"basics/MTKLanguage/","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","text":"@mtkmodel is a convenience macro to define components. It returns ModelingToolkit.Model, which includes a system constructor (System by default), a structure dictionary with metadata, and flag isconnector which is set to false.","category":"page"},{"location":"basics/MTKLanguage/#What-can-an-MTK-Model-definition-have?","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"What can an MTK-Model definition have?","text":"","category":"section"},{"location":"basics/MTKLanguage/","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","text":"@mtkmodel definition contains begin blocks of","category":"page"},{"location":"basics/MTKLanguage/","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","text":"@description: for describing the whole system with a human-readable string\n@components: for listing sub-components of the system\n@constants: for declaring constants\n@defaults: for passing defaults to the system\n@equations: for the list of equations\n@extend: for extending a base system and unpacking its unknowns\n@icon : for embedding the model icon\n@parameters: for specifying the symbolic parameters\n@structural_parameters: for specifying non-symbolic parameters\n@variables: for specifying the unknowns\n@continuous_events: for specifying a list of continuous events\n@discrete_events: for specifying a list of discrete events","category":"page"},{"location":"basics/MTKLanguage/","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","text":"Let's explore these in more detail with the following example:","category":"page"},{"location":"basics/MTKLanguage/","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","text":"using ModelingToolkit\nusing ModelingToolkit: t\n\n@mtkmodel ModelA begin\n    @description \"A component with parameters `k` and `k_array`.\"\n    @parameters begin\n        k\n        k_array[1:2]\n    end\nend\n\n@mtkmodel ModelB begin\n    @description \"A component with parameters `p1` and `p2`.\"\n    @parameters begin\n        p1 = 1.0, [description = \"Parameter of ModelB\"]\n        p2 = 1.0, [description = \"Parameter of ModelB\"]\n    end\nend\n\n@mtkmodel ModelC begin\n    @description \"A bigger system that contains many more things.\"\n    @icon \"https://github.com/SciML/SciMLDocs/blob/main/docs/src/assets/logo.png\"\n    @constants begin\n        c::Int = 1, [description = \"Example constant.\"]\n    end\n    @structural_parameters begin\n        f = sin\n        N = 2\n        M = 3\n    end\n    begin\n        v_var = 1.0\n    end\n    @variables begin\n        v(t) = v_var\n        v_array(t)[1:N, 1:M]\n        v_for_defaults(t)\n    end\n    @extend ModelB(p1 = 1)\n    @components begin\n        model_a = ModelA(; k_array)\n        model_array_a = [ModelA(; k = i) for i in 1:N]\n        model_array_b = for i in 1:N\n            k = i^2\n            ModelA(; k)\n        end\n    end\n    @equations begin\n        model_a.k ~ f(v)\n    end\n    @defaults begin\n        v_for_defaults => 2.0\n    end\nend","category":"page"},{"location":"basics/MTKLanguage/#@description","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"@description","text":"","category":"section"},{"location":"basics/MTKLanguage/","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","text":"A documenting String that summarizes and explains what the model is.","category":"page"},{"location":"basics/MTKLanguage/#@icon","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"@icon","text":"","category":"section"},{"location":"basics/MTKLanguage/","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","text":"An icon can be embedded in 3 ways:","category":"page"},{"location":"basics/MTKLanguage/","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","text":"URI\nPath to a valid image-file.<br> It can be an absolute path. Or, a path relative to an icon directory; which is DEPOT_PATH[1]/mtk_icons by default and can be changed by setting ENV[\"MTK_ICONS_DIR\"].<br> Internally, it is saved in the File URI scheme.","category":"page"},{"location":"basics/MTKLanguage/","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","text":"@mtkmodel WithPathtoIcon begin\n    @icon \"/home/user/.julia/dev/mtk_icons/icon.png\"\n    # Rest of the model definition\nend","category":"page"},{"location":"basics/MTKLanguage/","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","text":"Inlined SVG.","category":"page"},{"location":"basics/MTKLanguage/","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","text":"@mtkmodel WithInlinedSVGIcon begin\n    @icon \"\"\"<svg height=\"100\" width=\"100\">\n    <circle cx=\"50\" cy=\"50\" r=\"40\" stroke=\"green\" fill=\"none\" stroke-width=\"3\"/>\n    </svg>\n    \"\"\"\n    # Rest of the model definition\nend","category":"page"},{"location":"basics/MTKLanguage/#@structural_parameters-begin-block","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"@structural_parameters begin block","text":"","category":"section"},{"location":"basics/MTKLanguage/","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","text":"This block is for non symbolic input arguments. These are for inputs that usually are not meant to be part of components; but influence how they are defined. One can list inputs like boolean flags, functions etc... here.\nWhenever default values are specified, unlike parameters/variables, they are reflected in the keyword argument list.","category":"page"},{"location":"basics/MTKLanguage/#@constants-begin-block","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"@constants begin block","text":"","category":"section"},{"location":"basics/MTKLanguage/","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","text":"Declare constants in the model definition.\nThe values of these can't be changed by the user.\nThis works similar to symbolic constants described here","category":"page"},{"location":"basics/MTKLanguage/#@parameters-and-@variables-begin-block","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"@parameters and @variables begin block","text":"","category":"section"},{"location":"basics/MTKLanguage/","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","text":"Parameters and variables are declared with respective begin blocks.\nVariables must be functions of an independent variable.\nOptionally, initial guess and metadata can be specified for these parameters and variables. See ModelB in the above example.\nAlong with creating parameters and variables, keyword arguments of same name with default value nothing are created.\nWhenever a parameter or variable has initial value, for example v(t) = 0.0, a symbolic variable named v with initial value 0.0 and a keyword argument v, with default value nothing are created. <br> This way, users can optionally pass new value of v while creating a component.","category":"page"},{"location":"basics/MTKLanguage/","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","text":"julia> @mtkcompile model_c1 = ModelC(; v = 2.0);\n\njulia> ModelingToolkit.getdefault(model_c1.v)\n2.0","category":"page"},{"location":"basics/MTKLanguage/#@extend-statement","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"@extend statement","text":"","category":"section"},{"location":"basics/MTKLanguage/","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","text":"One or more partial systems can be extended in a higher system with @extend statements. This can be done in two ways:","category":"page"},{"location":"basics/MTKLanguage/","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","text":"@extend PartialSystem(var1 = value1)\nThis is the recommended way of extending a base system.\nThe default values for the arguments of the base system can be declared in the @extend statement.\nNote that all keyword arguments of the base system are added as the keyword arguments of the main system.\n@extend var_to_unpack1, var_to_unpack2 = partial_sys = PartialSystem(var1 = value1)\nIn this method: explicitly list the variables that should be unpacked, provide a name for the partial system and declare the base system.\nNote that only the arguments listed out in the declaration of the base system (here: var1) are added as the keyword arguments of the higher system.","category":"page"},{"location":"basics/MTKLanguage/#@components-begin-block","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"@components begin block","text":"","category":"section"},{"location":"basics/MTKLanguage/","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","text":"Declare the subcomponents within @components begin block.\nArray of components can be declared with a for loop or a list comprehension.\nThe arguments in these subcomponents are promoted as keyword arguments as subcomponent_name__argname with nothing as default value.\nWhenever components are created with @named macro, these can be accessed with . operator as subcomponent_name.argname\nIn the above example, as k of model_a isn't listed while defining the sub-component in ModelC, its default value can't be modified by users. While k_array can be set as:","category":"page"},{"location":"basics/MTKLanguage/","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","text":"using ModelingToolkit: getdefault\n\n@mtkcompile model_c3 = ModelC(; model_a.k_array = [1.0, 2.0])\n\ngetdefault(model_c3.model_a.k_array[1])\n# 1.0\ngetdefault(model_c3.model_a.k_array[2])\n# 2.0","category":"page"},{"location":"basics/MTKLanguage/#@equations-begin-block","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"@equations begin block","text":"","category":"section"},{"location":"basics/MTKLanguage/","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","text":"List all the equations here","category":"page"},{"location":"basics/MTKLanguage/#@defaults-begin-block","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"@defaults begin block","text":"","category":"section"},{"location":"basics/MTKLanguage/","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","text":"Default values can be passed as pairs.\nThis is equivalent to passing defaults argument to the system.","category":"page"},{"location":"basics/MTKLanguage/#@continuous_events-begin-block","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"@continuous_events begin block","text":"","category":"section"},{"location":"basics/MTKLanguage/","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","text":"Defining continuous events as described here.\nIf this block is not defined in the model, no continuous events will be added.\nDiscrete parameters and other keyword arguments should be specified in a vector, as seen below.","category":"page"},{"location":"basics/MTKLanguage/","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","text":"using ModelingToolkit\nusing ModelingToolkit: t\n\n@mtkmodel M begin\n    @parameters begin\n        k(t)\n    end\n    @variables begin\n        x(t)\n        y(t)\n    end\n    @equations begin\n        x ~ k * D(x)\n        D(y) ~ -k\n    end\n    @continuous_events begin\n        [x ~ 1.5] => [x ~ 5, y ~ 5]\n        [t ~ 4] => [x ~ 10]\n        [t ~ 5] => [k ~ 3], [discrete_parameters = k]\n    end\nend","category":"page"},{"location":"basics/MTKLanguage/#@discrete_events-begin-block","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"@discrete_events begin block","text":"","category":"section"},{"location":"basics/MTKLanguage/","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","text":"Defining discrete events as described here.\nIf this block is not defined in the model, no discrete events will be added.\nDiscrete parameters and other keyword arguments should be specified in a vector, as seen below.","category":"page"},{"location":"basics/MTKLanguage/","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","text":"using ModelingToolkit\n\n@mtkmodel M begin\n    @parameters begin\n        k(t)\n    end\n    @variables begin\n        x(t)\n        y(t)\n    end\n    @equations begin\n        x ~ k * D(x)\n        D(y) ~ -k\n    end\n    @discrete_events begin\n        (t == 1.5) => [x ~ Pre(x) + 5, y ~ 5]\n        (t == 2.5) => [k ~ Pre(k) * 2], [discrete_parameters = k]\n    end\nend","category":"page"},{"location":"basics/MTKLanguage/#A-begin-block","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"A begin block","text":"","category":"section"},{"location":"basics/MTKLanguage/","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","text":"Any other Julia operations can be included with dedicated begin blocks.","category":"page"},{"location":"basics/MTKLanguage/#Setting-the-type-of-system:","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"Setting the type of system:","text":"","category":"section"},{"location":"basics/MTKLanguage/","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","text":"By default @mtkmodel returns an System. Different types of system can be defined with the following syntax:","category":"page"},{"location":"basics/MTKLanguage/","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","text":"@mtkmodel ModelName::SystemType begin\n    ...\nend\n","category":"page"},{"location":"basics/MTKLanguage/#Connectors","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"Connectors","text":"","category":"section"},{"location":"basics/MTKLanguage/","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","text":"Connectors are special models that can be used to connect different components together. MTK provides 3 distinct connectors:","category":"page"},{"location":"basics/MTKLanguage/","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","text":"DomainConnector: A connector which has only one unknown which is of Flow type, specified by [connect = Flow].\nStreamConnector: A connector which has atleast one stream variable, specified by [connect = Stream]. A StreamConnector must have exactly one flow variable.\nRegularConnector: Connectors that don't fall under above categories.","category":"page"},{"location":"basics/MTKLanguage/#connector","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"Defining connectors with @connector","text":"","category":"section"},{"location":"basics/MTKLanguage/","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","text":"@connector returns ModelingToolkit.Model. It includes a constructor that returns a connector system (System by default), a structure dictionary with metadata, and flag isconnector which is set to true.","category":"page"},{"location":"basics/MTKLanguage/","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","text":"A simple connector can be defined with syntax similar to following example:","category":"page"},{"location":"basics/MTKLanguage/","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","text":"using ModelingToolkit\nusing ModelingToolkit: t\n\n@connector Pin begin\n    v(t) = 0.0, [description = \"Voltage\"]\n    i(t), [connect = Flow]\nend","category":"page"},{"location":"basics/MTKLanguage/","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","text":"Variables (as functions of independent variable) are listed out in the definition. These variables can optionally have initial values and metadata like description, connect and so on. For more details on setting metadata, check out Symbolic Metadata.","category":"page"},{"location":"basics/MTKLanguage/","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","text":"Similar to @mtkmodel, @connector accepts begin blocks of @components, @equations, @extend, @parameters, @structural_parameters, @variables. These keywords mean the same as described above for @mtkmodel. For example, the following HydraulicFluid connector is defined with parameters, variables and equations.","category":"page"},{"location":"basics/MTKLanguage/","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","text":"@connector HydraulicFluid begin\n    @parameters begin\n        ρ = 997\n        β = 2.09e9\n        μ = 0.0010016\n        n = 1\n        let_gas = 1\n        ρ_gas = 0.0073955\n        p_gas = -1000\n    end\n    @variables begin\n        dm(t) = 0.0, [connect = Flow]\n    end\n    @equations begin\n        dm ~ 0\n    end\nend","category":"page"},{"location":"basics/MTKLanguage/","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","text":"note: Note\nFor more examples of usage, checkout ModelingToolkitStandardLibrary.jl","category":"page"},{"location":"basics/MTKLanguage/#model_structure","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"More on Model.structure","text":"","category":"section"},{"location":"basics/MTKLanguage/","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","text":"structure stores metadata that describes composition of a model. It includes:","category":"page"},{"location":"basics/MTKLanguage/","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","text":":components: The list of sub-components in the form of [[name, subcomponentname],...].\n:constants: Dictionary of constants mapped to its metadata.\n:defaults: Dictionary of variables and default values specified in the @defaults.\n:extend: The list of extended unknowns, parameters and components, name given to the base system, and name of the base system. When multiple extend statements are present, latter two are returned as lists.\n:structural_parameters: Dictionary of structural parameters mapped to their metadata.\n:parameters: Dictionary of symbolic parameters mapped to their metadata. For parameter arrays, length is added to the metadata as :size.\n:variables: Dictionary of symbolic variables mapped to their metadata. For variable arrays, length is added to the metadata as :size.\n:kwargs: Dictionary of keyword arguments mapped to their metadata.\n:independent_variable: Independent variable, which is added while generating the Model.\n:equations: List of equations (represented as strings).","category":"page"},{"location":"basics/MTKLanguage/","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","text":"For example, the structure of ModelC is:","category":"page"},{"location":"basics/MTKLanguage/","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","text":"julia> ModelC.structure\nDict{Symbol, Any} with 10 entries:\n  :components            => Any[Union{Expr, Symbol}[:model_a, :ModelA], Union{Expr, Symbol}[:model_array_a, :ModelA, :(1:N)], Union{Expr, Symbol}[:model_array_b, :ModelA, :(1:N)]]\n  :variables             => Dict{Symbol, Dict{Symbol, Any}}(:v=>Dict(:default=>:v_var, :type=>Real), :v_array=>Dict(:value=>nothing, :type=>Real, :size=>(:N, :M)), :v_for_defaults=>Dict(:type=>Real))\n  :icon                  => URI(\"https://github.com/SciML/SciMLDocs/blob/main/docs/src/assets/logo.png\")\n  :kwargs                => Dict{Symbol, Dict}(:f=>Dict(:value=>:sin), :p2=>Dict(:value=>NoValue()), :N=>Dict(:value=>2), :M=>Dict(:value=>3), :v=>Dict{Symbol, Any}(:value=>:v_var, :type=>Real), :v_array=>Dict{Symbol, Any}(:value=>nothing, :type=>Real, :size=>(:N, :M)), :v_for_defaults=>Dict{Symbol, Union{Nothing, DataType}}(:value=>nothing, :type=>Real), :p1=>Dict(:value=>1))\n  :structural_parameters => Dict{Symbol, Dict}(:f=>Dict(:value=>:sin), :N=>Dict(:value=>2), :M=>Dict(:value=>3))\n  :independent_variable  => :t\n  :constants             => Dict{Symbol, Dict}(:c=>Dict{Symbol, Any}(:value=>1, :type=>Int64, :description=>\"Example constant.\"))\n  :extend                => Any[[:p2, :p1], Symbol(\"#mtkmodel__anonymous__ModelB\"), :ModelB]\n  :defaults              => Dict{Symbol, Any}(:v_for_defaults=>2.0)\n  :equations             => Any[\"model_a.k ~ f(v)\"]","category":"page"},{"location":"basics/MTKLanguage/#Different-ways-to-define-symbolics-arrays:","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"Different ways to define symbolics arrays:","text":"","category":"section"},{"location":"basics/MTKLanguage/","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","text":"@mtkmodel supports symbolics arrays in both @parameters and @variables. Using a structural parameters, symbolic arrays of arbitrary lengths can be defined. Refer the following example for different ways to define symbolic arrays.","category":"page"},{"location":"basics/MTKLanguage/","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","text":"@mtkmodel ModelWithArrays begin\n    @structural_parameters begin\n        N = 2\n        M = 3\n    end\n    @parameters begin\n        p1[1:4]\n        p2[1:N]\n        p3[1:N,\n            1:M] = 10,\n        [description = \"A multi-dimensional array of arbitrary length with description\"]\n        (p4[1:N, 1:M] = 10),\n        [description = \"An alternate syntax for p3 to match the syntax of vanilla parameters macro\"]\n    end\n    @variables begin\n        v1(t)[1:2] = 10, [description = \"An array of variable `v1`\"]\n        v2(t)[1:3] = [1, 2, 3]\n    end\nend","category":"page"},{"location":"basics/MTKLanguage/","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","text":"The size of symbolic array can be accessed via :size key, along with other metadata (refer More on Model.structure) of the symbolic variable.","category":"page"},{"location":"basics/MTKLanguage/","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","text":"julia> ModelWithArrays.structure\nDict{Symbol, Any} with 5 entries:\n    :variables => Dict{Symbol, Dict{Symbol, Any}}(:v2 => Dict(:value => :([1, 2, 3]), :type => Real, :size => (3,)), :v1 => Dict(:value => :v1, :type => Real, :description => \"An array of variable `v1`\", :size => (2,)))\n    :kwargs => Dict{Symbol, Dict}(:p2 => Dict{Symbol, Any}(:value => nothing, :type => Real, :size => (:N,)), :v1 => Dict{Symbol, Any}(:value => :v1, :type => Real, :description => \"An array of variable `v1`\", :size => (2,)), :N => Dict(:value => 2), :M => Dict(:value => 3), :p4 => Dict{Symbol, Any}(:value => 10, :type => Real, :description => \"An alternate syntax for p3 to match the syntax of vanilla parameters macro\", :size => (:N, :M)), :v2 => Dict{Symbol, Any}(:value => :([1, 2, 3]), :type => Real, :size => (3,)), :p1 => Dict{Symbol, Any}(:value => nothing, :type => Real, :size => (4,)), :p3 => Dict{Symbol, Any}(:value => :p3, :type => Real, :description => \"A multi-dimensional array of arbitrary length with description\", :size => (:N, :M)))\n    :structural_parameters => Dict{Symbol, Dict}(:N => Dict(:value => 2), :M => Dict(:value => 3))\n    :independent_variable => :t\n    :parameters => Dict{Symbol, Dict{Symbol, Any}}(:p2 => Dict(:value => nothing, :type => Real, :size => (:N,)), :p4 => Dict(:value => 10, :type => Real, :description => \"An alternate syntax for p3 to match the syntax of vanilla parameters macro\", :size => (:N, :M)), :p1 => Dict(:value => nothing, :type => Real, :size => (4,)), :p3 => Dict(:value => :p3, :type => Real, :description => \"A multi-dimensional array of arbitrary length with description\", :size => (:N, :M)))), false)","category":"page"},{"location":"basics/MTKLanguage/#Using-conditional-statements","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"Using conditional statements","text":"","category":"section"},{"location":"basics/MTKLanguage/#Conditional-elements-of-the-system","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"Conditional elements of the system","text":"","category":"section"},{"location":"basics/MTKLanguage/","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","text":"Both @mtkmodel and @connector support conditionally defining parameters, variables, equations, and components.","category":"page"},{"location":"basics/MTKLanguage/","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","text":"The if-elseif-else statements can be used inside @equations, @parameters, @variables, @components.","category":"page"},{"location":"basics/MTKLanguage/","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","text":"using ModelingToolkit\nusing ModelingToolkit: t\n\n@mtkmodel C begin end\n\n@mtkmodel BranchInsideTheBlock begin\n    @structural_parameters begin\n        flag = true\n    end\n    @parameters begin\n        if flag\n            a1\n        else\n            a2\n        end\n    end\n    @components begin\n        if flag\n            sys1 = C()\n        else\n            sys2 = C()\n        end\n    end\nend","category":"page"},{"location":"basics/MTKLanguage/","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","text":"Alternatively, the @equations, @parameters, @variables, @components can be used inside the if-elseif-else statements.","category":"page"},{"location":"basics/MTKLanguage/","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","text":"@mtkmodel BranchOutsideTheBlock begin\n    @structural_parameters begin\n        flag = true\n    end\n    if flag\n        @parameters begin\n            a1\n        end\n        @components begin\n            sys1 = C()\n        end\n        @equations begin\n            a1 ~ 0\n        end\n    else\n        @parameters begin\n            a2\n        end\n        @equations begin\n            a2 ~ 0\n        end\n    end\n    @defaults begin\n        a1 => 10\n    end\nend","category":"page"},{"location":"basics/MTKLanguage/","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","text":"The conditional parts are reflected in the structure. For BranchOutsideTheBlock, the metadata is:","category":"page"},{"location":"basics/MTKLanguage/","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","text":"julia> BranchOutsideTheBlock.structure\nDict{Symbol, Any} with 7 entries:\n  :components            => Any[(:if, :flag, Vector{Union{Expr, Symbol}}[[:sys1, :C]], Any[])]\n  :kwargs                => Dict{Symbol, Dict}(:flag=>Dict{Symbol, Bool}(:value=>1))\n  :structural_parameters => Dict{Symbol, Dict}(:flag=>Dict{Symbol, Bool}(:value=>1))\n  :independent_variable  => t\n  :parameters            => Dict{Symbol, Dict{Symbol, Any}}(:a2 => Dict(:type=>AbstractArray{Real}, :condition=>(:if, :flag, Dict{Symbol, Any}(:kwargs=>Dict{Any, Any}(:a1=>Dict{Symbol, Union{Nothing, DataType}}(:value=>nothing, :type=>Real)), :parameters=>Any[Dict{Symbol, Dict{Symbol, Any}}(:a1=>Dict(:type=>AbstractArray{Real}))]), Dict{Symbol, Any}(:variables=>Any[Dict{Symbol, Dict{Symbol, Any}}()], :kwargs=>Dict{Any, Any}(:a2=>Dict{Symbol, Union{Nothing, DataType}}(:value=>nothing, :type=>Real)), :parameters=>Any[Dict{Symbol, Dict{Symbol, Any}}(:a2=>Dict(:type=>AbstractArray{Real}))]))), :a1 => Dict(:type=>AbstractArray{Real}, :condition=>(:if, :flag, Dict{Symbol, Any}(:kwargs=>Dict{Any, Any}(:a1=>Dict{Symbol, Union{Nothing, DataType}}(:value=>nothing, :type=>Real)), :parameters=>Any[Dict{Symbol, Dict{Symbol, Any}}(:a1=>Dict(:type=>AbstractArray{Real}))]), Dict{Symbol, Any}(:variables=>Any[Dict{Symbol, Dict{Symbol, Any}}()], :kwargs=>Dict{Any, Any}(:a2=>Dict{Symbol, Union{Nothing, DataType}}(:value=>nothing, :type=>Real)), :parameters=>Any[Dict{Symbol, Dict{Symbol, Any}}(:a2=>Dict(:type=>AbstractArray{Real}))]))))\n  :defaults              => Dict{Symbol, Any}(:a1=>10)\n  :equations             => Any[(:if, :flag, [\"a1 ~ 0\"], [\"a2 ~ 0\"])]","category":"page"},{"location":"basics/MTKLanguage/","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","text":"Conditional entries are entered in the format of (branch, condition, [case when it is true], [case when it is false]); where branch is either :if or :elseif.<br> The [case when it is false] is either an empty vector or nothing when only if branch is present; it is a vector or dictionary whenever else branch is present; it is a conditional tuple whenever elseif branches are present.","category":"page"},{"location":"basics/MTKLanguage/","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","text":"For the conditional components and equations these condition tuples are added directly, while for parameters and variables these are added as :condition metadata.","category":"page"},{"location":"basics/MTKLanguage/#Conditional-initial-guess-of-symbolic-variables","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"Conditional initial guess of symbolic variables","text":"","category":"section"},{"location":"basics/MTKLanguage/","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","text":"Using ternary operator or if-elseif-else statement, conditional initial guesses can be assigned to parameters and variables.","category":"page"},{"location":"basics/MTKLanguage/","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","text":"@mtkmodel DefaultValues begin\n    @structural_parameters begin\n        flag = true\n    end\n    @parameters begin\n        p = flag ? 1 : 2\n    end\nend","category":"page"},{"location":"basics/MTKLanguage/#Build-structurally-simplified-models:","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"Build structurally simplified models:","text":"","category":"section"},{"location":"basics/MTKLanguage/","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","text":"@mtkcompile builds an instance of a component and returns a structurally simplied system.","category":"page"},{"location":"basics/MTKLanguage/","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","text":"@mtkcompile sys = CustomModel()","category":"page"},{"location":"basics/MTKLanguage/","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","text":"This is equivalent to:","category":"page"},{"location":"basics/MTKLanguage/","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","text":"@named model = CustomModel()\nsys = mtkcompile(model)","category":"page"},{"location":"basics/MTKLanguage/","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","text":"Pass keyword arguments to mtkcompile using the following syntax:","category":"page"},{"location":"basics/MTKLanguage/","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","text":"@mtkcompile sys=CustomModel() fully_determined=false","category":"page"},{"location":"basics/MTKLanguage/","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","text":"This is equivalent to:","category":"page"},{"location":"basics/MTKLanguage/","page":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","title":"ModelingToolkit Language: Modeling with @mtkmodel, @connectors and @mtkcompile","text":"@named model = CustomModel()\nsys = mtkcompile(model; fully_determined = false)","category":"page"}]
}
