<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Linearization · ModelingToolkit.jl</title><meta name="title" content="Linearization · ModelingToolkit.jl"/><meta property="og:title" content="Linearization · ModelingToolkit.jl"/><meta property="twitter:title" content="Linearization · ModelingToolkit.jl"/><meta name="description" content="Documentation for ModelingToolkit.jl."/><meta property="og:description" content="Documentation for ModelingToolkit.jl."/><meta property="twitter:description" content="Documentation for ModelingToolkit.jl."/><meta property="og:url" content="https://docs.sciml.ai/ModelingToolkit/stable/basics/Linearization/"/><meta property="twitter:url" content="https://docs.sciml.ai/ModelingToolkit/stable/basics/Linearization/"/><link rel="canonical" href="https://docs.sciml.ai/ModelingToolkit/stable/basics/Linearization/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="ModelingToolkit.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">ModelingToolkit.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../tutorials/ode_modeling/">Getting Started with ModelingToolkit.jl</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/acausal_components/">Acausal Component-Based Modeling</a></li><li><a class="tocitem" href="../../tutorials/nonlinear/">Modeling Nonlinear Systems</a></li><li><a class="tocitem" href="../../tutorials/initialization/">Initialization of Systems</a></li><li><a class="tocitem" href="../../tutorials/optimization/">Modeling Optimization Problems</a></li><li><a class="tocitem" href="../../tutorials/modelingtoolkitize/">Modelingtoolkitize: Automatically Translating Numerical to Symbolic Code</a></li><li><a class="tocitem" href="../../tutorials/programmatically_generating/">Programmatically Generating and Scripting Systems</a></li><li><a class="tocitem" href="../../tutorials/stochastic_diffeq/">Modeling with Stochasticity</a></li><li><a class="tocitem" href="../../tutorials/dynamic_optimization/">Solving Dynamic Optimization Problems</a></li><li><a class="tocitem" href="../../tutorials/discrete_system/">(Experimental) Modeling Discrete Systems</a></li><li><a class="tocitem" href="../../tutorials/parameter_identifiability/">Parameter Identifiability in ODE Models</a></li><li><a class="tocitem" href="../../tutorials/change_independent_variable/">Changing the independent variable of ODEs</a></li><li><a class="tocitem" href="../../tutorials/bifurcation_diagram_computation/">Bifurcation Diagrams</a></li><li><a class="tocitem" href="../../tutorials/attractors/">Multi- and Nonlocal- Continuation</a></li><li><a class="tocitem" href="../../tutorials/SampledData/">Clocks and Sampled-Data Systems</a></li><li><a class="tocitem" href="../../tutorials/domain_connections/">Domains</a></li><li><a class="tocitem" href="../../tutorials/callable_params/">Callable parameters and interpolating data</a></li><li><a class="tocitem" href="../../tutorials/linear_analysis/">Linear Analysis</a></li><li><a class="tocitem" href="../../tutorials/disturbance_modeling/">Disturbance and input modeling modeling</a></li><li><a class="tocitem" href="../../tutorials/fmi/">Importing FMUs</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><input class="collapse-toggle" id="menuitem-4-1" type="checkbox"/><label class="tocitem" for="menuitem-4-1"><span class="docs-label">Basic Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/higher_order/">Automatic Transformation of Nth Order ODEs to 1st Order ODEs</a></li><li><a class="tocitem" href="../../examples/spring_mass/">Component-Based Modeling of a Spring-Mass System</a></li><li><a class="tocitem" href="../../examples/modelingtoolkitize_index_reduction/">Automated Index Reduction of DAEs</a></li><li><a class="tocitem" href="../../examples/remake/">Optimizing through an ODE solve and re-creating MTK Problems</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-2" type="checkbox"/><label class="tocitem" for="menuitem-4-2"><span class="docs-label">Advanced Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/tearing_parallelism/">Exposing More Parallelism By Tearing Algebraic Equations in Systems</a></li><li><a class="tocitem" href="../../examples/sparse_jacobians/">Automated Sparse Analytical Jacobians</a></li><li><a class="tocitem" href="../../examples/perturbation/">Symbolic-Numeric Perturbation Theory for ODEs</a></li></ul></li></ul></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../../API/System/">The <code>System</code> type</a></li><li><a class="tocitem" href="../../API/variables/">Symbolic variables and variable metadata</a></li><li><a class="tocitem" href="../../API/model_building/">Model building reference</a></li><li><a class="tocitem" href="../../API/problems/">Building and solving numerical problems</a></li><li><a class="tocitem" href="../../API/dynamic_opt/">-</a></li><li><a class="tocitem" href="../../API/codegen/">Code generation utilities</a></li><li><a class="tocitem" href="../../API/PDESystem/">PDESystem</a></li></ul></li><li><span class="tocitem">Basics</span><ul><li><a class="tocitem" href="../Composition/">Composing Models and Building Reusable Components</a></li><li><a class="tocitem" href="../Events/">Event Handling and Callback Functions</a></li><li class="is-active"><a class="tocitem" href>Linearization</a><ul class="internal"><li><a class="tocitem" href="#Example"><span>Example</span></a></li><li><a class="tocitem" href="#Operating-point"><span>Operating point</span></a></li><li><a class="tocitem" href="#Batch-linearization-and-algebraic-variables"><span>Batch linearization and algebraic variables</span></a></li><li><a class="tocitem" href="#Symbolic-linearization"><span>Symbolic linearization</span></a></li><li><a class="tocitem" href="#Input-derivatives"><span>Input derivatives</span></a></li><li><a class="tocitem" href="#Tools-for-linear-analysis"><span>Tools for linear analysis</span></a></li><li><a class="tocitem" href="#Docstrings"><span>Docstrings</span></a></li></ul></li><li><a class="tocitem" href="../InputOutput/">Input output</a></li><li><a class="tocitem" href="../MTKLanguage/">ModelingToolkit Language: Modeling with <code>@mtkmodel</code>, <code>@connectors</code> and <code>@mtkcompile</code></a></li><li><a class="tocitem" href="../Validation/">Model Validation and Units</a></li><li><a class="tocitem" href="../Debugging/">Debugging</a></li><li><a class="tocitem" href="../DependencyGraphs/">Dependency Graphs</a></li><li><a class="tocitem" href="../Precompilation/">Working with Precompilation and Binary Building</a></li><li><a class="tocitem" href="../FAQ/">Frequently Asked Questions</a></li></ul></li><li><a class="tocitem" href="../../comparison/">Comparison of ModelingToolkit vs Equation-Based and Block Modeling Languages</a></li><li><a class="tocitem" href="../../internals/">Internal Details</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Basics</a></li><li class="is-active"><a href>Linearization</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Linearization</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SciML/ModelingToolkit.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SciML/ModelingToolkit.jl/blob/master/docs/src/basics/Linearization.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="linearization"><a class="docs-heading-anchor" href="#linearization">Linearization</a><a id="linearization-1"></a><a class="docs-heading-anchor-permalink" href="#linearization" title="Permalink"></a></h1><p>A nonlinear dynamical system with state (differential and algebraic) <span>$x$</span> and input signals <span>$u$</span></p><p class="math-container">\[M \dot x = f(x, u)\]</p><p>can be linearized using the function <a href="../../API/problems/#ModelingToolkit.linearize"><code>linearize</code></a> to produce a linear statespace system on the form</p><p class="math-container">\[\begin{aligned}
\dot x &amp;= Ax + Bu\\
y &amp;= Cx + Du
\end{aligned}\]</p><p>The <code>linearize</code> function expects the user to specify the inputs <span>$u$</span> and the outputs <span>$y$</span> using the syntax shown in the example below. The system model is <em>not</em> supposed to be simplified before calling <code>linearize</code>:</p><h2 id="Example"><a class="docs-heading-anchor" href="#Example">Example</a><a id="Example-1"></a><a class="docs-heading-anchor-permalink" href="#Example" title="Permalink"></a></h2><pre><code class="language-julia hljs">using ModelingToolkit
using ModelingToolkit: t_nounits as t, D_nounits as D
@variables x(t)=0 y(t) u(t) r(t)=0
@parameters kp = 1

eqs = [u ~ kp * (r - y) # P controller
       D(x) ~ -x + u    # First-order plant
       y ~ x]           # Output equation

@named sys = System(eqs, t) # Do not call @mtkcompile when linearizing
matrices, simplified_sys = linearize(sys, [r], [y]) # Linearize from r to y
matrices</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(A = [-2.0;;], B = [1.0;;], C = [1.0;;], D = [0.0;;])</code></pre><p>The named tuple <code>matrices</code> contains the matrices of the linear statespace representation, while <code>simplified_sys</code> is an <code>System</code> that, among other things, indicates the unknown variable order in the linear system through</p><pre><code class="language-julia hljs">using ModelingToolkit: inputs, outputs
[unknowns(simplified_sys); inputs(simplified_sys); outputs(simplified_sys)]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{Any}:
 x(t)
 r(t)
 y(t)</code></pre><div class="admonition is-info" id="Inputs-must-be-unconnected-e3c0e27c92b8e631"><header class="admonition-header">Inputs must be unconnected<a class="admonition-anchor" href="#Inputs-must-be-unconnected-e3c0e27c92b8e631" title="Permalink"></a></header><div class="admonition-body"><p>The model above has 4 variables but only three equations, there is no equation specifying the value of <code>r</code> since <code>r</code> is an input. This means that only unbalanced models can be linearized, or in other words, models that are balanced and can be simulated <em>cannot</em> be linearized. To learn more about this, see <a href="https://www.youtube.com/watch?v=-XOux-2XDGI&amp;t=395s">How to linearize a ModelingToolkit model (YouTube)</a>. Also see <a href="https://docs.sciml.ai/ModelingToolkit/stable/tutorials/linear_analysis/">ModelingToolkitStandardLibrary: Linear analysis</a> for utilities that make linearization of completed models easier.</p></div></div><div class="admonition is-info" id="Un-simplified-system-74c0acbfc4c8e94e"><header class="admonition-header">Un-simplified system<a class="admonition-anchor" href="#Un-simplified-system-74c0acbfc4c8e94e" title="Permalink"></a></header><div class="admonition-body"><p>Linearization expects <code>sys</code> to be un-simplified, i.e., <code>mtkcompile</code> or <code>@mtkcompile</code> should not be called on the system before linearizing.</p></div></div><h2 id="Operating-point"><a class="docs-heading-anchor" href="#Operating-point">Operating point</a><a id="Operating-point-1"></a><a class="docs-heading-anchor-permalink" href="#Operating-point" title="Permalink"></a></h2><p>The operating point to linearize around can be specified with the keyword argument <code>op</code> like this: <code>op = Dict(x =&gt; 1, r =&gt; 2)</code>. The operating point may include specification of unknown variables, input variables and parameters. For variables that are not specified in <code>op</code>, the default value specified in the model will be used if available, if no value is specified, an error is thrown.</p><h2 id="Batch-linearization-and-algebraic-variables"><a class="docs-heading-anchor" href="#Batch-linearization-and-algebraic-variables">Batch linearization and algebraic variables</a><a id="Batch-linearization-and-algebraic-variables-1"></a><a class="docs-heading-anchor-permalink" href="#Batch-linearization-and-algebraic-variables" title="Permalink"></a></h2><p>If linearization is to be performed around multiple operating points, the simplification of the system has to be carried out a single time only. To facilitate this, the lower-level function <a href="../../API/problems/#ModelingToolkit.linearization_function"><code>ModelingToolkit.linearization_function</code></a> is available. This function further allows you to obtain separate Jacobians for the differential and algebraic parts of the model. For ODE models without algebraic equations, the statespace representation above is available from the output of <code>linearization_function</code> as <code>A, B, C, D = f_x, f_u, h_x, h_u</code>.</p><p>All variables that will be fixed by an operating point <em>must</em> be provided in the operating point to <code>linearization_function</code>. For example, if the operating points fix the value of <code>x</code>, <code>y</code> and <code>z</code> then an operating point with constant values for these variables (e.g. <code>Dict(x =&gt; 1.0, y =&gt; 1.0, z =&gt; 1.0)</code>) must be provided. The constant values themselves do not matter and can be changed by subsequent operating points.</p><p>One approach to batch linearization would be to call <code>linearize</code> in a loop, providing a different operating point each time. For example:</p><pre><code class="language-julia hljs">using ModelingToolkitStandardLibrary
using ModelingToolkitStandardLibrary.Blocks

@parameters k=10 k3=2 c=1
@variables x(t)=0 [bounds = (-0.5, 1.5)]
@variables v(t) = 0

@named y = Blocks.RealOutput()
@named u = Blocks.RealInput()

eqs = [D(x) ~ v
       D(v) ~ -k * x - k3 * x^3 - c * v + 10u.u
       y.u ~ x]

@named duffing = System(eqs, t, systems = [y, u], defaults = [u.u =&gt; 0])

# pass a constant value for `x`, since it is the variable we will change in operating points
linfun, simplified_sys = linearization_function(duffing, [u.u], [y.u]; op = Dict(x =&gt; NaN));

println(linearize(simplified_sys, linfun; op = Dict(x =&gt; 1.0)))
println(linearize(simplified_sys, linfun; op = Dict(x =&gt; 0.0)))

@time linearize(simplified_sys, linfun; op = Dict(x =&gt; 0.0))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(A = [-1.0 -16.0; 1.0 0.0], B = [10.0; 0.0;;], C = [0.0 1.0], D = [0.0;;])
(A = [-1.0 -10.0; 1.0 0.0], B = [10.0; 0.0;;], C = [0.0 1.0], D = [0.0;;])
  0.000354 seconds (745 allocations: 27.031 KiB)</code></pre><p>However, this route is still expensive since it has to repeatedly process the symbolic map provided to <code>op</code>. <code>linearize</code> is simply a wrapper for creating and solving a <a href="../../API/problems/#ModelingToolkit.LinearizationProblem"><code>ModelingToolkit.LinearizationProblem</code></a>. This object is symbolically indexable, and can thus integrate with SymbolicIndexingInterface.jl for fast updates.</p><pre><code class="language-julia hljs">using SymbolicIndexingInterface

# The second argument is the value of the independent variable `t`.
linprob = LinearizationProblem(linfun, 1.0)
# It can be mutated
linprob.t = 0.0
# create a setter function to update `x` efficiently
setter! = setu(linprob, x)

function fast_linearize!(problem, setter!, value)
    setter!(problem, value)
    solve(problem)
end

println(fast_linearize!(linprob, setter!, 1.0))
println(fast_linearize!(linprob, setter!, 0.0))

@time fast_linearize!(linprob, setter!, 1.0)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(A = [-1.0 -10.0; 1.0 0.0], B = [10.0; 0.0;;], C = [0.0 1.0], D = [0.0;;])
(A = [-1.0 -10.0; 1.0 0.0], B = [10.0; 0.0;;], C = [0.0 1.0], D = [0.0;;])
  0.000100 seconds (65 allocations: 5.875 KiB)</code></pre><p>Note that <code>linprob</code> above can be interacted with similar to a normal <code>ODEProblem</code>.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; prob[x]</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `prob` not defined</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; prob[x] = 1.5</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `prob` not defined</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; prob[x]</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `prob` not defined</code></pre><h2 id="Symbolic-linearization"><a class="docs-heading-anchor" href="#Symbolic-linearization">Symbolic linearization</a><a id="Symbolic-linearization-1"></a><a class="docs-heading-anchor-permalink" href="#Symbolic-linearization" title="Permalink"></a></h2><p>The function <a href="#ModelingToolkit.linearize_symbolic-basics-Linearization"><code>ModelingToolkit.linearize_symbolic</code></a> works similar to <a href="../../API/problems/#ModelingToolkit.linearize"><code>ModelingToolkit.linearize</code></a> but returns symbolic rather than numeric Jacobians. Symbolic linearization have several limitations and no all systems that can be linearized numerically can be linearized symbolically.</p><h2 id="Input-derivatives"><a class="docs-heading-anchor" href="#Input-derivatives">Input derivatives</a><a id="Input-derivatives-1"></a><a class="docs-heading-anchor-permalink" href="#Input-derivatives" title="Permalink"></a></h2><p>Physical systems are always <em>proper</em>, i.e., they do not differentiate causal inputs. However, ModelingToolkit allows you to model non-proper systems, such as inverse models, and may sometimes fail to find a realization of a proper system on proper form. In these situations, <code>linearize</code> may throw an error mentioning</p><pre><code class="nohighlight hljs">Input derivatives appeared in expressions (-g_z\g_u != 0)</code></pre><p>This means that to simulate this system, some order of derivatives of the input is required. To allow <code>linearize</code> to proceed in this situation, one may pass the keyword argument <code>allow_input_derivatives = true</code>, in which case the resulting model will have twice as many inputs, <span>$2n_u$</span>, where the last <span>$n_u$</span> inputs correspond to <span>$\dot u$</span>.</p><p>If the modeled system is actually proper (but MTK failed to find a proper realization), further numerical simplification can be applied to the resulting statespace system to obtain a proper form. Such simplification is currently available in the package <a href="https://juliacontrol.github.io/ControlSystemsMTK.jl/dev/#Internals:-Transformation-of-non-proper-models-to-proper-statespace-form">ControlSystemsMTK</a>.</p><h2 id="Tools-for-linear-analysis"><a class="docs-heading-anchor" href="#Tools-for-linear-analysis">Tools for linear analysis</a><a id="Tools-for-linear-analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Tools-for-linear-analysis" title="Permalink"></a></h2><p>ModelingToolkit contains a set of <a href="https://docs.sciml.ai/ModelingToolkit/stable/tutorials/linear_analysis/">tools for more advanced linear analysis</a>. These can be used to make it easier to work with and analyze causal models, such as control and signal-processing systems.</p><p>Also see <a href="https://juliacontrol.github.io/ControlSystemsMTK.jl/dev/">ControlSystemsMTK.jl</a> for an interface to <a href="https://github.com/JuliaControl/ControlSystems.jl">ControlSystems.jl</a> that contains tools for linear analysis and frequency-domain analysis.</p><h2 id="Docstrings"><a class="docs-heading-anchor" href="#Docstrings">Docstrings</a><a id="Docstrings-1"></a><a class="docs-heading-anchor-permalink" href="#Docstrings" title="Permalink"></a></h2><ul></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.linearize-basics-Linearization" href="#ModelingToolkit.linearize-basics-Linearization"><code>ModelingToolkit.linearize</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">(; A, B, C, D), simplified_sys = linearize(sys, inputs, outputs;    t=0.0, op = Dict(), allow_input_derivatives = false, zero_dummy_der=false, kwargs...)
(; A, B, C, D)                 = linearize(simplified_sys, lin_fun; t=0.0, op = Dict(), allow_input_derivatives = false, zero_dummy_der=false)</code></pre><p>Linearize <code>sys</code> between <code>inputs</code> and <code>outputs</code>, both vectors of variables. Return a NamedTuple with the matrices of a linear statespace representation on the form</p><p class="math-container">\[\begin{aligned}
ẋ &amp;= Ax + Bu\\
y &amp;= Cx + Du
\end{aligned}\]</p><p>The first signature automatically calls <a href="../../API/problems/#ModelingToolkit.linearization_function"><code>linearization_function</code></a> internally, while the second signature expects the outputs of <a href="../../API/problems/#ModelingToolkit.linearization_function"><code>linearization_function</code></a> as input.</p><p><code>op</code> denotes the operating point around which to linearize. If none is provided, the default values of <code>sys</code> are used.</p><p>If <code>allow_input_derivatives = false</code>, an error will be thrown if input derivatives (<span>$u̇$</span>) appear as inputs in the linearized equations. If input derivatives are allowed, the returned <code>B</code> matrix will be of double width, corresponding to the input <code>[u; u̇]</code>.</p><p><code>zero_dummy_der</code> can be set to automatically set the operating point to zero for all dummy derivatives.</p><p>See also <a href="../../API/problems/#ModelingToolkit.linearization_function"><code>linearization_function</code></a> which provides a lower-level interface, <a href="#ModelingToolkit.linearize_symbolic-basics-Linearization"><code>linearize_symbolic</code></a> and <a href="../../API/problems/#ModelingToolkit.reorder_unknowns"><code>ModelingToolkit.reorder_unknowns</code></a>.</p><p>See extended help for an example.</p><p>The implementation and notation follows that of <a href="https://ep.liu.se/ecp/043/075/ecp09430097.pdf">&quot;Linear Analysis Approach for Modelica Models&quot;, Allain et al. 2009</a></p><p><strong>Extended help</strong></p><p>This example builds the following feedback interconnection and linearizes it from the input of <code>F</code> to the output of <code>P</code>.</p><pre><code class="nohighlight hljs">
  r ┌─────┐       ┌─────┐     ┌─────┐
───►│     ├──────►│     │  u  │     │
    │  F  │       │  C  ├────►│  P  │ y
    └─────┘     ┌►│     │     │     ├─┬─►
                │ └─────┘     └─────┘ │
                │                     │
                └─────────────────────┘</code></pre><pre><code class="language-julia hljs">using ModelingToolkit
using ModelingToolkit: t_nounits as t, D_nounits as D
function plant(; name)
    @variables x(t) = 1
    @variables u(t)=0 y(t)=0
    eqs = [D(x) ~ -x + u
           y ~ x]
    System(eqs, t; name = name)
end

function ref_filt(; name)
    @variables x(t)=0 y(t)=0
    @variables u(t)=0 [input = true]
    eqs = [D(x) ~ -2 * x + u
           y ~ x]
    System(eqs, t, name = name)
end

function controller(kp; name)
    @variables y(t)=0 r(t)=0 u(t)=0
    @parameters kp = kp
    eqs = [
        u ~ kp * (r - y),
    ]
    System(eqs, t; name = name)
end

@named f = ref_filt()
@named c = controller(1)
@named p = plant()

connections = [f.y ~ c.r # filtered reference to controller reference
               c.u ~ p.u # controller output to plant input
               p.y ~ c.y]

@named cl = System(connections, t, systems = [f, c, p])

lsys0, ssys = linearize(cl, [f.u], [p.x])
desired_order = [f.x, p.x]
lsys = ModelingToolkit.reorder_unknowns(lsys0, unknowns(ssys), desired_order)

@assert lsys.A == [-2 0; 1 -2]
@assert lsys.B == [1; 0;;]
@assert lsys.C == [0 1]
@assert lsys.D[] == 0

## Symbolic linearization
lsys_sym, _ = ModelingToolkit.linearize_symbolic(cl, [f.u], [p.x])

@assert substitute(lsys_sym.A, ModelingToolkit.defaults(cl)) == lsys.A</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/8c1e372d90617d62106a5b43261ffc70bb027bd3/src/linearization.jl#L620-L718">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.linearize_symbolic-basics-Linearization" href="#ModelingToolkit.linearize_symbolic-basics-Linearization"><code>ModelingToolkit.linearize_symbolic</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">(; A, B, C, D), simplified_sys = linearize_symbolic(sys::AbstractSystem, inputs, outputs; simplify = false, allow_input_derivatives = false, kwargs...)</code></pre><p>Similar to <a href="../../API/problems/#ModelingToolkit.linearize"><code>linearize</code></a>, but returns symbolic matrices <code>A,B,C,D</code> rather than numeric. While <code>linearize</code> uses ForwardDiff to perform the linearization, this function uses <code>Symbolics.jacobian</code>.</p><p>See <a href="../../API/problems/#ModelingToolkit.linearize"><code>linearize</code></a> for a description of the arguments.</p><p><strong>Extended help</strong></p><p>The named tuple returned as the first argument additionally contains the jacobians <code>f_x, f_z, g_x, g_z, f_u, g_u, h_x, h_z, h_u</code> of</p><p class="math-container">\[\begin{aligned}
ẋ &amp;= f(x, z, u) \\
0 &amp;= g(x, z, u) \\
y &amp;= h(x, z, u)
\end{aligned}\]</p><p>where <code>x</code> are differential unknown variables, <code>z</code> algebraic variables, <code>u</code> inputs and <code>y</code> outputs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/8c1e372d90617d62106a5b43261ffc70bb027bd3/src/linearization.jl#L479-L496">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.linearization_function-basics-Linearization" href="#ModelingToolkit.linearization_function-basics-Linearization"><code>ModelingToolkit.linearization_function</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lin_fun, simplified_sys = linearization_function(sys::AbstractSystem, inputs, outputs; simplify = false, initialize = true, initialization_solver_alg = TrustRegion(), kwargs...)</code></pre><p>Return a function that linearizes the system <code>sys</code>. The function <a href="../../API/problems/#ModelingToolkit.linearize"><code>linearize</code></a> provides a higher-level and easier to use interface.</p><p><code>lin_fun</code> is a function <code>(variables, p, t) -&gt; (; f_x, f_z, g_x, g_z, f_u, g_u, h_x, h_z, h_u)</code>, i.e., it returns a NamedTuple with the Jacobians of <code>f,g,h</code> for the nonlinear <code>sys</code> (technically for <code>simplified_sys</code>) on the form</p><p class="math-container">\[\begin{aligned}
ẋ &amp;= f(x, z, u) \\
0 &amp;= g(x, z, u) \\
y &amp;= h(x, z, u)
\end{aligned}\]</p><p>where <code>x</code> are differential unknown variables, <code>z</code> algebraic variables, <code>u</code> inputs and <code>y</code> outputs. To obtain a linear statespace representation, see <a href="../../API/problems/#ModelingToolkit.linearize"><code>linearize</code></a>. The input argument <code>variables</code> is a vector defining the operating point, corresponding to <code>unknowns(simplified_sys)</code> and <code>p</code> is a vector corresponding to the parameters of <code>simplified_sys</code>. Note: all variables in <code>inputs</code> have been converted to parameters in <code>simplified_sys</code>.</p><p>The <code>simplified_sys</code> has undergone <a href="../../API/model_building/#ModelingToolkit.mtkcompile"><code>mtkcompile</code></a> and had any occurring input or output variables replaced with the variables provided in arguments <code>inputs</code> and <code>outputs</code>. The unknowns of this system also indicate the order of the unknowns that holds for the linearized matrices.</p><p><strong>Arguments:</strong></p><ul><li><code>sys</code>: A <a href="../../API/System/#ModelingToolkit.System"><code>System</code></a> of ODEs. This function will automatically apply simplification passes on <code>sys</code> and return the resulting <code>simplified_sys</code>.</li><li><code>inputs</code>: A vector of variables that indicate the inputs of the linearized input-output model.</li><li><code>outputs</code>: A vector of variables that indicate the outputs of the linearized input-output model.</li><li><code>simplify</code>: Apply simplification in tearing.</li><li><code>initialize</code>: If true, a check is performed to ensure that the operating point is consistent (satisfies algebraic equations). If the op is not consistent, initialization is performed.</li><li><code>initialization_solver_alg</code>: A NonlinearSolve algorithm to use for solving for a feasible set of state and algebraic variables that satisfies the specified operating point.</li><li><code>autodiff</code>: An <code>ADType</code> supported by DifferentiationInterface.jl to use for calculating the necessary jacobians. Defaults to using <code>AutoForwardDiff()</code></li><li><code>kwargs</code>: Are passed on to <code>find_solvables!</code></li></ul><p>See also <a href="../../API/problems/#ModelingToolkit.linearize"><code>linearize</code></a> which provides a higher-level interface.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/8c1e372d90617d62106a5b43261ffc70bb027bd3/src/linearization.jl#L1-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.LinearizationProblem-basics-Linearization" href="#ModelingToolkit.LinearizationProblem-basics-Linearization"><code>ModelingToolkit.LinearizationProblem</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mutable struct LinearizationProblem{F&lt;:ModelingToolkit.LinearizationFunction, T}</code></pre><p>A struct representing a linearization operation to be performed. Can be symbolically indexed to efficiently update the operating point for multiple linearizations in a loop. The value of the independent variable can be set by mutating the <code>.t</code> field of this struct.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/8c1e372d90617d62106a5b43261ffc70bb027bd3/src/linearization.jl#L376-L382">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../Events/">« Event Handling and Callback Functions</a><a class="docs-footer-nextpage" href="../InputOutput/">Input output »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.12.0 on <span class="colophon-date" title="Wednesday 11 June 2025 10:06">Wednesday 11 June 2025</span>. Using Julia version 1.10.9.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
