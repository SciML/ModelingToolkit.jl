<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Symbolic-Numeric Perturbation Theory for ODEs ¬∑ ModelingToolkit.jl</title><meta name="title" content="Symbolic-Numeric Perturbation Theory for ODEs ¬∑ ModelingToolkit.jl"/><meta property="og:title" content="Symbolic-Numeric Perturbation Theory for ODEs ¬∑ ModelingToolkit.jl"/><meta property="twitter:title" content="Symbolic-Numeric Perturbation Theory for ODEs ¬∑ ModelingToolkit.jl"/><meta name="description" content="Documentation for ModelingToolkit.jl."/><meta property="og:description" content="Documentation for ModelingToolkit.jl."/><meta property="twitter:description" content="Documentation for ModelingToolkit.jl."/><meta property="og:url" content="https://docs.sciml.ai/ModelingToolkit/stable/examples/perturbation/"/><meta property="twitter:url" content="https://docs.sciml.ai/ModelingToolkit/stable/examples/perturbation/"/><link rel="canonical" href="https://docs.sciml.ai/ModelingToolkit/stable/examples/perturbation/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="ModelingToolkit.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">ModelingToolkit.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../tutorials/ode_modeling/">Getting Started with ModelingToolkit.jl</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/acausal_components/">Acausal Component-Based Modeling</a></li><li><a class="tocitem" href="../../tutorials/nonlinear/">Modeling Nonlinear Systems</a></li><li><a class="tocitem" href="../../tutorials/initialization/">Initialization of ODESystems</a></li><li><a class="tocitem" href="../../tutorials/optimization/">Modeling Optimization Problems</a></li><li><a class="tocitem" href="../../tutorials/modelingtoolkitize/">Modelingtoolkitize: Automatically Translating Numerical to Symbolic Code</a></li><li><a class="tocitem" href="../../tutorials/programmatically_generating/">Programmatically Generating and Scripting ODESystems</a></li><li><a class="tocitem" href="../../tutorials/stochastic_diffeq/">Modeling with Stochasticity</a></li><li><a class="tocitem" href="../../tutorials/discrete_system/">(Experimental) Modeling Discrete Systems</a></li><li><a class="tocitem" href="../../tutorials/parameter_identifiability/">Parameter Identifiability in ODE Models</a></li><li><a class="tocitem" href="../../tutorials/bifurcation_diagram_computation/">Bifurcation Diagrams</a></li><li><a class="tocitem" href="../../tutorials/SampledData/">Clocks and Sampled-Data Systems</a></li><li><a class="tocitem" href="../../tutorials/domain_connections/">Domains</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><input class="collapse-toggle" id="menuitem-4-1" type="checkbox"/><label class="tocitem" for="menuitem-4-1"><span class="docs-label">Basic Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../higher_order/">Automatic Transformation of Nth Order ODEs to 1st Order ODEs</a></li><li><a class="tocitem" href="../spring_mass/">Component-Based Modeling of a Spring-Mass System</a></li><li><a class="tocitem" href="../modelingtoolkitize_index_reduction/">Automated Index Reduction of DAEs</a></li><li><a class="tocitem" href="../parsing/">Parsing Expressions into Solvable Systems</a></li><li><a class="tocitem" href="../remake/">Optimizing through an ODE solve and re-creating MTK Problems</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-2" type="checkbox" checked/><label class="tocitem" for="menuitem-4-2"><span class="docs-label">Advanced Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../tearing_parallelism/">Exposing More Parallelism By Tearing Algebraic Equations in ODESystems</a></li><li><a class="tocitem" href="../sparse_jacobians/">Automated Sparse Analytical Jacobians</a></li><li class="is-active"><a class="tocitem" href>Symbolic-Numeric Perturbation Theory for ODEs</a><ul class="internal"><li><a class="tocitem" href="#Prelims"><span>Prelims</span></a></li><li><a class="tocitem" href="#The-Trajectory-of-a-Ball!"><span>The Trajectory of a Ball!</span></a></li><li><a class="tocitem" href="#A-Weakly-Nonlinear-Oscillator"><span>A Weakly Nonlinear Oscillator</span></a></li></ul></li></ul></li></ul></li><li><span class="tocitem">Basics</span><ul><li><a class="tocitem" href="../../basics/AbstractSystem/">The AbstractSystem Interface</a></li><li><a class="tocitem" href="../../basics/ContextualVariables/">Contextual Variable Types</a></li><li><a class="tocitem" href="../../basics/Variable_metadata/">Symbolic Metadata</a></li><li><a class="tocitem" href="../../basics/Composition/">Composing Models and Building Reusable Components</a></li><li><a class="tocitem" href="../../basics/Events/">Event Handling and Callback Functions</a></li><li><a class="tocitem" href="../../basics/Linearization/">Linearization</a></li><li><a class="tocitem" href="../../basics/InputOutput/">Input output</a></li><li><a class="tocitem" href="../../basics/MTKLanguage/">ModelingToolkit Language: Modeling with <code>@mtkmodel</code>, <code>@connectors</code> and <code>@mtkbuild</code></a></li><li><a class="tocitem" href="../../basics/Validation/">Model Validation and Units</a></li><li><a class="tocitem" href="../../basics/DependencyGraphs/">Dependency Graphs</a></li><li><a class="tocitem" href="../../basics/Precompilation/">Working with Precompilation and Binary Building</a></li><li><a class="tocitem" href="../../basics/FAQ/">Frequently Asked Questions</a></li></ul></li><li><span class="tocitem">System Types</span><ul><li><a class="tocitem" href="../../systems/ODESystem/">ODESystem</a></li><li><a class="tocitem" href="../../systems/SDESystem/">SDESystem</a></li><li><a class="tocitem" href="../../systems/JumpSystem/">JumpSystem</a></li><li><a class="tocitem" href="../../systems/NonlinearSystem/">NonlinearSystem</a></li><li><a class="tocitem" href="../../systems/OptimizationSystem/">OptimizationSystem</a></li><li><a class="tocitem" href="../../systems/PDESystem/">PDESystem</a></li></ul></li><li><a class="tocitem" href="../../comparison/">Comparison of ModelingToolkit vs Equation-Based and Block Modeling Languages</a></li><li><a class="tocitem" href="../../internals/">Internal Details</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li><a class="is-disabled">Advanced Examples</a></li><li class="is-active"><a href>Symbolic-Numeric Perturbation Theory for ODEs</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Symbolic-Numeric Perturbation Theory for ODEs</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SciML/ModelingToolkit.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ÔÇõ</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SciML/ModelingToolkit.jl/blob/master/docs/src/examples/perturbation.md" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="perturb_diff"><a class="docs-heading-anchor" href="#perturb_diff">Symbolic-Numeric Perturbation Theory for ODEs</a><a id="perturb_diff-1"></a><a class="docs-heading-anchor-permalink" href="#perturb_diff" title="Permalink"></a></h1><h2 id="Prelims"><a class="docs-heading-anchor" href="#Prelims">Prelims</a><a id="Prelims-1"></a><a class="docs-heading-anchor-permalink" href="#Prelims" title="Permalink"></a></h2><p>In the previous tutorial, <a href="https://symbolics.juliasymbolics.org/stable/examples/perturbation/">Mixed Symbolic-Numeric Perturbation Theory</a>, we discussed how to solve algebraic equations using <strong>Symbolics.jl</strong>. Here, our goal is to extend the method to differential equations. First, we import the following helper functions that were introduced in <a href="@ref perturb_alg">Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations</a>:</p><pre><code class="language-julia hljs">using Symbolics, SymbolicUtils

def_taylor(x, ps) = sum([a * x^i for (i, a) in enumerate(ps)])
def_taylor(x, ps, p‚ÇÄ) = p‚ÇÄ + def_taylor(x, ps)

function collect_powers(eq, x, ns; max_power = 100)
    eq = substitute(expand(eq), Dict(x^j =&gt; 0 for j in (last(ns) + 1):max_power))

    eqs = []
    for i in ns
        powers = Dict(x^j =&gt; (i == j ? 1 : 0) for j in 1:last(ns))
        push!(eqs, substitute(eq, powers))
    end
    eqs
end

function solve_coef(eqs, ps)
    vals = Dict()

    for i in 1:length(ps)
        eq = substitute(eqs[i], vals)
        vals[ps[i]] = Symbolics.symbolic_linear_solve(eq ~ 0, ps[i])
    end
    vals
end</code></pre><h2 id="The-Trajectory-of-a-Ball!"><a class="docs-heading-anchor" href="#The-Trajectory-of-a-Ball!">The Trajectory of a Ball!</a><a id="The-Trajectory-of-a-Ball!-1"></a><a class="docs-heading-anchor-permalink" href="#The-Trajectory-of-a-Ball!" title="Permalink"></a></h2><p>In the first two examples, we applied the perturbation method to algebraic problems. However, the main power of the perturbation method is to solve differential equations (usually ODEs, but also occasionally PDEs). Surprisingly, the main procedure developed to solve algebraic problems works well for differential equations. In fact, we will use the same two helper functions, <code>collect_powers</code> and <code>solve_coef</code>. The main difference is in the way we expand the dependent variables. For algebraic problems, the coefficients of <span>$\epsilon$</span> are constants; whereas, for differential equations, they are functions of the dependent variable (usually time).</p><p>As the first ODE example, we have chosen a simple and well-behaved problem, which is a variation of a standard first-year physics problem: what is the trajectory of an object (say, a ball, or a rocket) thrown vertically at velocity <span>$v$</span> from the surface of a planet? Assuming a constant acceleration of gravity, <span>$g$</span>, every burgeoning physicist knows the answer: <span>$x(t) = x(0) + vt - \frac{1}{2}gt^2$</span>. However, what happens if <span>$g$</span> is not constant? Specifically, <span>$g$</span> is inversely proportional to the distant from the center of the planet. If <span>$v$</span> is large and the projectile travels a large fraction of the radius of the planet, the assumption of constant gravity does not hold anymore. However, unless <span>$v$</span> is large compared to the escape velocity, the correction is usually small. After simplifications and change of variables to dimensionless, the problem becomes</p><p class="math-container">\[  \ddot{x}(t) = -\frac{1}{(1 + \epsilon x(t))^2}\]</p><p>with the initial conditions <span>$x(0) = 0$</span>, and <span>$\dot{x}(0) = 1$</span>. Note that for <span>$\epsilon = 0$</span>, this equation transforms back to the standard one. Let&#39;s start with defining the variables</p><pre><code class="language-julia hljs">using ModelingToolkit: t_nounits as t, D_nounits as D
n = 3
@variables œµ y[1:n](t) ‚àÇ‚àÇy[1:n](t)</code></pre><p>Next, we define <span>$x$</span>.</p><pre><code class="language-julia hljs">x = def_taylor(œµ, y[3:end], y[2])</code></pre><p>We need the second derivative of <code>x</code>. It may seem that we can do this using <code>Differential(t)</code>; however, this operation needs to wait for a few steps because we need to manipulate the differentials as separate variables. Instead, we define dummy variables <code>‚àÇ‚àÇy</code> as the placeholder for the second derivatives and define</p><pre><code class="language-julia hljs">‚àÇ‚àÇx = def_taylor(œµ, ‚àÇ‚àÇy[3:end], ‚àÇ‚àÇy[2])</code></pre><p>as the second derivative of <code>x</code>. After rearrangement, our governing equation is <span>$\ddot{x}(t)(1 + \epsilon x(t))^{-2} + 1 = 0$</span>, or</p><pre><code class="language-julia hljs">eq = ‚àÇ‚àÇx * (1 + œµ * x)^2 + 1</code></pre><p>The next two steps are the same as the ones for algebraic equations (note that we pass <code>1:n</code> to <code>collect_powers</code> because the zeroth order term is needed here)</p><pre><code class="language-julia hljs">eqs = collect_powers(eq, œµ, 1:n)</code></pre><p>and,</p><pre><code class="language-julia hljs">vals = solve_coef(eqs, ‚àÇ‚àÇy)</code></pre><p>Our system of ODEs is forming. Now is the time to convert <code>‚àÇ‚àÇ</code>s to the correct <strong>Symbolics.jl</strong> form by substitution:</p><pre><code class="language-julia hljs">subs = Dict(‚àÇ‚àÇy[i] =&gt; D(D(y[i])) for i in eachindex(y))
eqs = [substitute(first(v), subs) ~ substitute(last(v), subs) for v in vals]</code></pre><p>We are nearly there! From this point on, the rest is standard ODE solving procedures. Potentially, we can use a symbolic ODE solver to find a closed form solution to this problem. However, <strong>Symbolics.jl</strong> currently does not support this functionality. Instead, we solve the problem numerically. We form an <code>ODESystem</code>, lower the order (convert second derivatives to first), generate an <code>ODEProblem</code> (after passing the correct initial conditions), and, finally, solve it.</p><pre><code class="language-julia hljs">using ModelingToolkit, DifferentialEquations

@mtkbuild sys = ODESystem(eqs, t)
unknowns(sys)</code></pre><pre><code class="language-julia hljs"># the initial conditions
# everything is zero except the initial velocity
u0 = zeros(2n + 2)
u0[3] = 1.0   # y‚ÇÄÀçt

prob = ODEProblem(sys, u0, (0, 3.0))
sol = solve(prob; dtmax = 0.01)</code></pre><p>Finally, we calculate the solution to the problem as a function of <code>œµ</code> by substituting the solution to the ODE system back into the defining equation for <code>x</code>. Note that <code>ùúÄ</code> is a number, compared to <code>œµ</code>, which is a symbolic variable.</p><pre><code class="language-julia hljs">X = ùúÄ -&gt; sum([ùúÄ^(i - 1) * sol[y[i]] for i in eachindex(y)])</code></pre><p>Using <code>X</code>, we can plot the trajectory for a range of <span>$ùúÄ$</span>s.</p><pre><code class="language-julia hljs">using Plots

plot(sol.t, hcat([X(ùúÄ) for ùúÄ in 0.0:0.1:0.5]...))</code></pre><p>As expected, as <code>ùúÄ</code> becomes larger (meaning the gravity is less with altitude), the object goes higher and stays up for a longer duration. Of course, we could have solved the problem directly using as ODE solver. One of the benefits of the perturbation method is that we need to run the ODE solver only once and then can just calculate the answer for different values of <code>ùúÄ</code>; whereas, if we had used the direct method, we would need to run the solver once for each value of <code>ùúÄ</code>.</p><h2 id="A-Weakly-Nonlinear-Oscillator"><a class="docs-heading-anchor" href="#A-Weakly-Nonlinear-Oscillator">A Weakly Nonlinear Oscillator</a><a id="A-Weakly-Nonlinear-Oscillator-1"></a><a class="docs-heading-anchor-permalink" href="#A-Weakly-Nonlinear-Oscillator" title="Permalink"></a></h2><p>For the next example, we have chosen a simple example from a very important class of problems, the nonlinear oscillators. As we will see, perturbation theory has difficulty providing a good solution to this problem, but the process is instructive. This example closely follows the chapter 7.6 of <em>Nonlinear Dynamics and Chaos</em> by Steven Strogatz.</p><p>The goal is to solve <span>$\ddot{x} + 2\epsilon\dot{x} + x = 0$</span>, where the dot signifies time-derivatives and the initial conditions are <span>$x(0) = 0$</span> and <span>$\dot{x}(0) = 1$</span>. If <span>$\epsilon = 0$</span>, the problem reduces to the simple linear harmonic oscillator with the exact solution <span>$x(t) = \sin(t)$</span>. We follow the same steps as the previous example.</p><pre><code class="language-julia hljs">n = 3
@variables œµ t y[1:n](t) ‚àÇy[1:n] ‚àÇ‚àÇy[1:n]
x = def_taylor(œµ, y[3:end], y[2])
‚àÇx = def_taylor(œµ, ‚àÇy[3:end], ‚àÇy[2])
‚àÇ‚àÇx = def_taylor(œµ, ‚àÇ‚àÇy[3:end], ‚àÇ‚àÇy[2])</code></pre><p>This time we also need the first derivative terms. Continuing,</p><pre><code class="language-julia hljs">eq = ‚àÇ‚àÇx + 2 * œµ * ‚àÇx + x
eqs = collect_powers(eq, œµ, 0:n)
vals = solve_coef(eqs, ‚àÇ‚àÇy)</code></pre><p>Next, we need to replace <code>‚àÇ</code>s and <code>‚àÇ‚àÇ</code>s with their <strong>Symbolics.jl</strong> counterparts:</p><pre><code class="language-julia hljs">subs1 = Dict(‚àÇy[i] =&gt; D(y[i]) for i in eachindex(y))
subs2 = Dict(‚àÇ‚àÇy[i] =&gt; D(D(y[i])) for i in eachindex(y))
subs = subs1 ‚à™ subs2
eqs = [substitute(first(v), subs) ~ substitute(last(v), subs) for v in vals]</code></pre><p>We continue with converting &#39;eqs&#39; to an <code>ODEProblem</code>, solving it, and finally plot the results against the exact solution to the original problem, which is <span>$x(t, \epsilon) = (1 - \epsilon)^{-1/2} e^{-\epsilon t} \sin((1- \epsilon^2)^{1/2}t)$</span>,</p><pre><code class="language-julia hljs">@mtkbuild sys = ODESystem(eqs, t)</code></pre><pre><code class="language-julia hljs"># the initial conditions
u0 = zeros(2n + 2)
u0[3] = 1.0   # y‚ÇÄÀçt

prob = ODEProblem(sys, u0, (0, 50.0))
sol = solve(prob; dtmax = 0.01)

X = ùúÄ -&gt; sum([ùúÄ^(i - 1) * sol[y[i]] for i in eachindex(y)])
T = sol.t
Y = ùúÄ -&gt; exp.(-ùúÄ * T) .* sin.(sqrt(1 - ùúÄ^2) * T) / sqrt(1 - ùúÄ^2)    # exact solution

plot(sol.t, [Y(0.1), X(0.1)])</code></pre><p>The figure is similar to Figure 7.6.2 in <em>Nonlinear Dynamics and Chaos</em>. The two curves fit well for the first couple of cycles, but then the perturbation method curve diverges from the true solution. The main reason is that the problem has two or more time-scales that introduce secular terms in the solution. One solution is to explicitly account for the two time scales and use an analytic method called <em>two-timing</em>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../sparse_jacobians/">¬´ Automated Sparse Analytical Jacobians</a><a class="docs-footer-nextpage" href="../../basics/AbstractSystem/">The AbstractSystem Interface ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Thursday 3 October 2024 19:48">Thursday 3 October 2024</span>. Using Julia version 1.10.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
