<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Automated Index Reduction of DAEs · ModelingToolkit.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://mtk.sciml.ai/stable/mtkitize_tutorials/modelingtoolkitize_index_reduction/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="ModelingToolkit.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">ModelingToolkit.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Symbolic Modeling Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/ode_modeling/">Composing Ordinary Differential Equations</a></li><li><a class="tocitem" href="../../tutorials/spring_mass/">Component-Based Modeling a Spring-Mass System</a></li><li><a class="tocitem" href="../../tutorials/acausal_components/">Acausal Component-Based Modeling the RC Circuit</a></li><li><a class="tocitem" href="../../tutorials/higher_order/">Automatic Transformation of Nth Order ODEs to 1st Order ODEs</a></li><li><a class="tocitem" href="../../tutorials/tearing_parallelism/">Exposing More Parallelism By Tearing Algebraic Equations in ODESystems</a></li><li><a class="tocitem" href="../../tutorials/nonlinear/">Modeling Nonlinear Systems</a></li><li><a class="tocitem" href="../../tutorials/optimization/">Modeling Optimization Problems</a></li><li><a class="tocitem" href="../../tutorials/stochastic_diffeq/">Modeling with Stochasticity</a></li><li><a class="tocitem" href="../../tutorials/nonlinear_optimal_control/">Nonlinear Optimal Control</a></li></ul></li><li><span class="tocitem">ModelingToolkitize Tutorials</span><ul><li><a class="tocitem" href="../modelingtoolkitize/">Automatically Accelerating ODEProblem Code</a></li><li class="is-active"><a class="tocitem" href>Automated Index Reduction of DAEs</a><ul class="internal"><li><a class="tocitem" href="#Copy-Pastable-Example"><span>Copy-Pastable Example</span></a></li><li><a class="tocitem" href="#Explanation"><span>Explanation</span></a></li></ul></li></ul></li><li><span class="tocitem">Basics</span><ul><li><a class="tocitem" href="../../basics/AbstractSystem/">The AbstractSystem Interface</a></li><li><a class="tocitem" href="../../basics/ContextualVariables/">Contextual Variable Types</a></li><li><a class="tocitem" href="../../basics/Composition/">Composing Models and Building Reusable Components</a></li><li><a class="tocitem" href="../../basics/Validation/">Model Validation and Units</a></li><li><a class="tocitem" href="../../basics/DependencyGraphs/">Dependency Graphs</a></li><li><a class="tocitem" href="../../basics/FAQ/">Frequently Asked Questions</a></li></ul></li><li><span class="tocitem">System Types</span><ul><li><a class="tocitem" href="../../systems/ODESystem/">ODESystem</a></li><li><a class="tocitem" href="../../systems/SDESystem/">SDESystem</a></li><li><a class="tocitem" href="../../systems/JumpSystem/">JumpSystem</a></li><li><a class="tocitem" href="../../systems/NonlinearSystem/">NonlinearSystem</a></li><li><a class="tocitem" href="../../systems/OptimizationSystem/">OptimizationSystem</a></li><li><a class="tocitem" href="../../systems/ControlSystem/">ControlSystem</a></li><li><a class="tocitem" href="../../systems/PDESystem/">PDESystem</a></li></ul></li><li><a class="tocitem" href="../../comparison/">Comparison of ModelingToolkit vs Equation-Based Modeling Languages</a></li><li><a class="tocitem" href="../../internals/">Internal Details</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">ModelingToolkitize Tutorials</a></li><li class="is-active"><a href>Automated Index Reduction of DAEs</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Automated Index Reduction of DAEs</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/SciML/ModelingToolkit.jl/blob/master/docs/src/mtkitize_tutorials/modelingtoolkitize_index_reduction.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Automated-Index-Reduction-of-DAEs"><a class="docs-heading-anchor" href="#Automated-Index-Reduction-of-DAEs">Automated Index Reduction of DAEs</a><a id="Automated-Index-Reduction-of-DAEs-1"></a><a class="docs-heading-anchor-permalink" href="#Automated-Index-Reduction-of-DAEs" title="Permalink"></a></h1><p>In many cases one may accidentally write down a DAE that is not easily solvable by numerical methods. In this tutorial we will walk through an example of a pendulum which accidentally generates an index-3 DAE, and show how to use the <code>modelingtoolkitize</code> to correct the model definition before solving.</p><h2 id="Copy-Pastable-Example"><a class="docs-heading-anchor" href="#Copy-Pastable-Example">Copy-Pastable Example</a><a id="Copy-Pastable-Example-1"></a><a class="docs-heading-anchor-permalink" href="#Copy-Pastable-Example" title="Permalink"></a></h2><pre><code class="language-julia hljs">using ModelingToolkit
using LinearAlgebra
using OrdinaryDiffEq
using Plots

function pendulum!(du, u, p, t)
    x, dx, y, dy, T = u
    g, L = p
    du[1] = dx
    du[2] = T*x
    du[3] = dy
    du[4] = T*y - g
    du[5] = x^2 + y^2 - L^2
    return nothing
end
pendulum_fun! = ODEFunction(pendulum!, mass_matrix=Diagonal([1,1,1,1,0]))
u0 = [1.0, 0, 0, 0, 0]
p = [9.8, 1]
tspan = (0, 10.0)
pendulum_prob = ODEProblem(pendulum_fun!, u0, tspan, p)
traced_sys = modelingtoolkitize(pendulum_prob)
pendulum_sys = structural_simplify(traced_sys)
prob = ODAEProblem(pendulum_sys, Pair[], tspan)
sol = solve(prob, Tsit5(),abstol=1e-8,reltol=1e-8)
plot(sol, vars=states(traced_sys))</code></pre><h2 id="Explanation"><a class="docs-heading-anchor" href="#Explanation">Explanation</a><a id="Explanation-1"></a><a class="docs-heading-anchor-permalink" href="#Explanation" title="Permalink"></a></h2><h3 id="Attempting-to-Solve-the-Equation"><a class="docs-heading-anchor" href="#Attempting-to-Solve-the-Equation">Attempting to Solve the Equation</a><a id="Attempting-to-Solve-the-Equation-1"></a><a class="docs-heading-anchor-permalink" href="#Attempting-to-Solve-the-Equation" title="Permalink"></a></h3><p>In this tutorial we will look at the pendulum system:</p><p class="math-container">\[\begin{aligned}
    x^\prime &amp;= v_x\\
    v_x^\prime &amp;= Tx\\
    y^\prime &amp;= v_y\\
    v_y^\prime &amp;= Ty - g\\
    0 &amp;= x^2 + y^2 - L^2
\end{aligned}\]</p><p>As a good DifferentialEquations.jl user, one would follow <a href="https://diffeq.sciml.ai/stable/tutorials/advanced_ode_example/#Handling-Mass-Matrices">the mass matrix DAE tutorial</a> to arrive at code for simulating the model:</p><pre><code class="language-julia hljs">using OrdinaryDiffEq, LinearAlgebra
function pendulum!(du, u, p, t)
    x, dx, y, dy, T = u
    g, L = p
    du[1] = dx; du[2] = T*x
    du[3] = dy; du[4] = T*y - g
    du[5] = x^2 + y^2 - L^2
end
pendulum_fun! = ODEFunction(pendulum!, mass_matrix=Diagonal([1,1,1,1,0]))
u0 = [1.0, 0, 0, 0, 0]; p = [9.8, 1]; tspan = (0, 10.0)
pendulum_prob = ODEProblem(pendulum_fun!, u0, tspan, p)
solve(pendulum_prob,Rodas4())</code></pre><p>However, one will quickly be greeted with the unfortunate message:</p><pre><code class="language-julia hljs">┌ Warning: First function call produced NaNs. Exiting.
└ @ OrdinaryDiffEq C:\Users\accou\.julia\packages\OrdinaryDiffEq\yCczp\src\initdt.jl:76
┌ Warning: Automatic dt set the starting dt as NaN, causing instability.
└ @ OrdinaryDiffEq C:\Users\accou\.julia\packages\OrdinaryDiffEq\yCczp\src\solve.jl:485
┌ Warning: NaN dt detected. Likely a NaN value in the state, parameters, or derivative value caused this outcome.
└ @ SciMLBase C:\Users\accou\.julia\packages\SciMLBase\DrPil\src\integrator_interface.jl:325</code></pre><p>Did you implement the DAE incorrectly? No. Is the solver broken? No.</p><h3 id="Understanding-DAE-Index"><a class="docs-heading-anchor" href="#Understanding-DAE-Index">Understanding DAE Index</a><a id="Understanding-DAE-Index-1"></a><a class="docs-heading-anchor-permalink" href="#Understanding-DAE-Index" title="Permalink"></a></h3><p>It turns out that this is a property of the DAE that we are attempting to solve. This kind of DAE is known as an index-3 DAE. For a complete discussion of DAE index, see <a href="http://www.scholarpedia.org/article/Differential-algebraic_equations">this article</a>. Essentially the issue here is that we have 4 differential variables (<span>$x$</span>, <span>$v_x$</span>, <span>$y$</span>, <span>$v_y$</span>) and one algebraic variable <span>$T$</span> (which we can know because there is no <code>D(T)</code> term in the equations). An index-1 DAE always satisfies that the Jacobian of the algebraic equations is non-singular. Here, the first 4 equations are differential equations, with the last term the algebraic relationship. However, the partial derivative of <code>x^2 + y^2 - L^2</code> w.r.t. <code>T</code> is zero, and thus the Jacobian of the algebraic equations is the zero matrix and thus it&#39;s singular. This is a very quick way to see whether the DAE is index 1!</p><p>The problem with higher order DAEs is that the matrices used in Newton solves are singular or close to singular when applied to such problems. Because of this fact, the nonlinear solvers (or Rosenbrock methods) break down, making them difficult to solve. The classic paper <a href="https://epubs.siam.org/doi/10.1137/0903023">DAEs are not ODEs</a> goes into detail on this and shows that many methods are no longer convergent when index is higher than one. So it&#39;s not necessarily the fault of the solver or the implementation: this is known.</p><p>But that&#39;s not a satisfying answer, so what do you do about it?</p><h3 id="Transforming-Higher-Order-DAEs-to-Index-1-DAEs"><a class="docs-heading-anchor" href="#Transforming-Higher-Order-DAEs-to-Index-1-DAEs">Transforming Higher Order DAEs to Index-1 DAEs</a><a id="Transforming-Higher-Order-DAEs-to-Index-1-DAEs-1"></a><a class="docs-heading-anchor-permalink" href="#Transforming-Higher-Order-DAEs-to-Index-1-DAEs" title="Permalink"></a></h3><p>It turns out that higher order DAEs can be transformed into lower order DAEs. <a href="https://courses.seas.harvard.edu/courses/am205/g_act/dae_notes.pdf">If you differentiate the last equation two times and perform a substitution, you can arrive at the following set of equations</a>:</p><p class="math-container">\[\begin{aligned}
x^\prime =&amp; v_x \\
v_x^\prime =&amp; x T \\
y^\prime =&amp; v_y \\
v_y^\prime =&amp; y T - g \\
0 =&amp; 2 \left(v_x^{2} + v_y^{2} + y ( y T - g ) + T x^2 \right)
\end{aligned}\]</p><p>Note that this is mathematically-equivalent to the equation that we had before, but the Jacobian w.r.t. <code>T</code> of the algebraic equation is no longer zero because of the substitution. This means that if you wrote down this version of the model it will be index-1 and solve correctly! In fact, this is how DAE index is commonly defined: the number of differentiations it takes to transform the DAE into an ODE, where an ODE is an index-0 DAE by substituting out all of the algebraic relationships.</p><h3 id="Automating-the-Index-Reduction"><a class="docs-heading-anchor" href="#Automating-the-Index-Reduction">Automating the Index Reduction</a><a id="Automating-the-Index-Reduction-1"></a><a class="docs-heading-anchor-permalink" href="#Automating-the-Index-Reduction" title="Permalink"></a></h3><p>However, requiring the user to sit there and work through this process on potentially millions of equations is an unfathomable mental overhead. But, we can avoid this by using methods like <a href="https://ptolemy.berkeley.edu/projects/embedded/eecsx44/lectures/Spring2013/modelica-dae-part-2.pdf">the Pantelides algorithm</a> for automatically performing this reduction to index 1. While this requires the ModelingToolkit symbolic form, we use <code>modelingtoolkitize</code> to transform the numerical code into symbolic code, run <code>dae_index_lowering</code> lowering, then transform back to numerical code with <code>ODEProblem</code>, and solve with a numerical solver. Let&#39;s try that out:</p><pre><code class="language-julia hljs">traced_sys = modelingtoolkitize(pendulum_prob)
pendulum_sys = structural_simplify(dae_index_lowering(traced_sys))
prob = ODEProblem(pendulum_sys, Pair[], tspan)
sol = solve(prob, Rodas4())

using Plots
plot(sol, vars=states(traced_sys))</code></pre><p><img src="https://user-images.githubusercontent.com/1814174/110587364-9524b400-8141-11eb-91c7-4e56ce4fa20b.png" alt/></p><p>Note that plotting using <code>states(traced_sys)</code> is done so that any variables which are symbolically eliminated, or any variable reorderings done for enhanced parallelism/performance, still show up in the resulting plot and the plot is shown in the same order as the original numerical code.</p><p>Note that we can even go a little bit further. If we use the <code>ODAEProblem</code> constructor, we can remove the algebraic equations from the states of the system and fully transform the index-3 DAE into an index-0 ODE which can be solved via an explicit Runge-Kutta method:</p><pre><code class="language-julia hljs">traced_sys = modelingtoolkitize(pendulum_prob)
pendulum_sys = structural_simplify(dae_index_lowering(traced_sys))
prob = ODAEProblem(pendulum_sys, Pair[], tspan)
sol = solve(prob, Tsit5(),abstol=1e-8,reltol=1e-8)
plot(sol, vars=states(traced_sys))</code></pre><p><img src="https://user-images.githubusercontent.com/1814174/110587362-9524b400-8141-11eb-8b77-d940f108ae72.png" alt/></p><p>And there you go: this has transformed the model from being too hard to solve with implicit DAE solvers, to something that is easily solved with explicit Runge-Kutta methods for non-stiff equations.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../modelingtoolkitize/">« Automatically Accelerating ODEProblem Code</a><a class="docs-footer-nextpage" href="../../basics/AbstractSystem/">The AbstractSystem Interface »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Monday 8 November 2021 16:33">Monday 8 November 2021</span>. Using Julia version 1.6.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
