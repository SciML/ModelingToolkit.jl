<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Model building reference · ModelingToolkit.jl</title><meta name="title" content="Model building reference · ModelingToolkit.jl"/><meta property="og:title" content="Model building reference · ModelingToolkit.jl"/><meta property="twitter:title" content="Model building reference · ModelingToolkit.jl"/><meta name="description" content="Documentation for ModelingToolkit.jl."/><meta property="og:description" content="Documentation for ModelingToolkit.jl."/><meta property="twitter:description" content="Documentation for ModelingToolkit.jl."/><meta property="og:url" content="https://docs.sciml.ai/ModelingToolkit/stable/API/model_building/"/><meta property="twitter:url" content="https://docs.sciml.ai/ModelingToolkit/stable/API/model_building/"/><link rel="canonical" href="https://docs.sciml.ai/ModelingToolkit/stable/API/model_building/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="ModelingToolkit.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">ModelingToolkit.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../tutorials/ode_modeling/">Getting Started with ModelingToolkit.jl</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/acausal_components/">Acausal Component-Based Modeling</a></li><li><a class="tocitem" href="../../tutorials/nonlinear/">Modeling Nonlinear Systems</a></li><li><a class="tocitem" href="../../tutorials/initialization/">Initialization of Systems</a></li><li><a class="tocitem" href="../../tutorials/optimization/">Modeling Optimization Problems</a></li><li><a class="tocitem" href="../../tutorials/modelingtoolkitize/">Modelingtoolkitize: Automatically Translating Numerical to Symbolic Code</a></li><li><a class="tocitem" href="../../tutorials/programmatically_generating/">Programmatically Generating and Scripting Systems</a></li><li><a class="tocitem" href="../../tutorials/stochastic_diffeq/">Modeling with Stochasticity</a></li><li><a class="tocitem" href="../../tutorials/dynamic_optimization/">Solving Dynamic Optimization Problems</a></li><li><a class="tocitem" href="../../tutorials/discrete_system/">(Experimental) Modeling Discrete Systems</a></li><li><a class="tocitem" href="../../tutorials/parameter_identifiability/">Parameter Identifiability in ODE Models</a></li><li><a class="tocitem" href="../../tutorials/change_independent_variable/">Changing the independent variable of ODEs</a></li><li><a class="tocitem" href="../../tutorials/bifurcation_diagram_computation/">Bifurcation Diagrams</a></li><li><a class="tocitem" href="../../tutorials/attractors/">Multi- and Nonlocal- Continuation</a></li><li><a class="tocitem" href="../../tutorials/SampledData/">Clocks and Sampled-Data Systems</a></li><li><a class="tocitem" href="../../tutorials/domain_connections/">Domains</a></li><li><a class="tocitem" href="../../tutorials/callable_params/">Callable parameters and interpolating data</a></li><li><a class="tocitem" href="../../tutorials/linear_analysis/">Linear Analysis</a></li><li><a class="tocitem" href="../../tutorials/disturbance_modeling/">Disturbance and input modeling modeling</a></li><li><a class="tocitem" href="../../tutorials/fmi/">Importing FMUs</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><input class="collapse-toggle" id="menuitem-4-1" type="checkbox"/><label class="tocitem" for="menuitem-4-1"><span class="docs-label">Basic Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/higher_order/">Automatic Transformation of Nth Order ODEs to 1st Order ODEs</a></li><li><a class="tocitem" href="../../examples/spring_mass/">Component-Based Modeling of a Spring-Mass System</a></li><li><a class="tocitem" href="../../examples/modelingtoolkitize_index_reduction/">Automated Index Reduction of DAEs</a></li><li><a class="tocitem" href="../../examples/remake/">Optimizing through an ODE solve and re-creating MTK Problems</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-2" type="checkbox"/><label class="tocitem" for="menuitem-4-2"><span class="docs-label">Advanced Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/tearing_parallelism/">Exposing More Parallelism By Tearing Algebraic Equations in Systems</a></li><li><a class="tocitem" href="../../examples/sparse_jacobians/">Automated Sparse Analytical Jacobians</a></li><li><a class="tocitem" href="../../examples/perturbation/">Symbolic-Numeric Perturbation Theory for ODEs</a></li></ul></li></ul></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../System/">The <code>System</code> type</a></li><li><a class="tocitem" href="../variables/">Symbolic variables and variable metadata</a></li><li class="is-active"><a class="tocitem" href>Model building reference</a><ul class="internal"><li><a class="tocitem" href="#Hierarchical-model-composition"><span>Hierarchical model composition</span></a></li><li><a class="tocitem" href="#System-simplification"><span>System simplification</span></a></li><li><a class="tocitem" href="#Event-handling"><span>Event handling</span></a></li><li><a class="tocitem" href="#Modelingtoolkitize"><span>Modelingtoolkitize</span></a></li><li><a class="tocitem" href="#Using-FMUs"><span>Using FMUs</span></a></li><li><a class="tocitem" href="#Model-transformations"><span>Model transformations</span></a></li><li><a class="tocitem" href="#Hybrid-systems"><span>Hybrid systems</span></a></li></ul></li><li><a class="tocitem" href="../problems/">Building and solving numerical problems</a></li><li><a class="tocitem" href="../dynamic_opt/">Dynamic Optimization Solvers</a></li><li><a class="tocitem" href="../codegen/">Code generation utilities</a></li><li><a class="tocitem" href="../PDESystem/">PDESystem</a></li></ul></li><li><span class="tocitem">Basics</span><ul><li><a class="tocitem" href="../../basics/Composition/">Composing Models and Building Reusable Components</a></li><li><a class="tocitem" href="../../basics/Events/">Event Handling and Callback Functions</a></li><li><a class="tocitem" href="../../basics/Linearization/">Linearization</a></li><li><a class="tocitem" href="../../basics/InputOutput/">Input output</a></li><li><a class="tocitem" href="../../basics/MTKLanguage/">ModelingToolkit Language: Modeling with <code>@mtkmodel</code>, <code>@connectors</code> and <code>@mtkcompile</code></a></li><li><a class="tocitem" href="../../basics/Validation/">Model Validation and Units</a></li><li><a class="tocitem" href="../../basics/Debugging/">Debugging</a></li><li><a class="tocitem" href="../../basics/DependencyGraphs/">Dependency Graphs</a></li><li><a class="tocitem" href="../../basics/Precompilation/">Working with Precompilation and Binary Building</a></li><li><a class="tocitem" href="../../basics/FAQ/">Frequently Asked Questions</a></li></ul></li><li><a class="tocitem" href="../../comparison/">Comparison of ModelingToolkit vs Equation-Based and Block Modeling Languages</a></li><li><a class="tocitem" href="../../internals/">Internal Details</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API</a></li><li class="is-active"><a href>Model building reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Model building reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SciML/ModelingToolkit.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SciML/ModelingToolkit.jl/blob/master/docs/src/API/model_building.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="model_building_api"><a class="docs-heading-anchor" href="#model_building_api">Model building reference</a><a id="model_building_api-1"></a><a class="docs-heading-anchor-permalink" href="#model_building_api" title="Permalink"></a></h1><p>This page lists functionality and utilities related to building hierarchical models. It is recommended to read the page on the <a href="../System/#System_type"><code>System</code></a> before this.</p><h2 id="Hierarchical-model-composition"><a class="docs-heading-anchor" href="#Hierarchical-model-composition">Hierarchical model composition</a><a id="Hierarchical-model-composition-1"></a><a class="docs-heading-anchor-permalink" href="#Hierarchical-model-composition" title="Permalink"></a></h2><p>The <code>System</code> data structure can represent a tree-like hierarchy of systems for building models from composable blocks. The <a href="../System/#ModelingToolkit.get_systems"><code>ModelingToolkit.get_systems</code></a> function can be used for querying the subsystems of a system. The <code>@component</code> macro should be used when writing building blocks for model composition.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.@component" href="#ModelingToolkit.@component"><code>ModelingToolkit.@component</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Mark a system constructor function as building a component. For example,</p><pre><code class="language-julia hljs">@component function AddOne(; name)
    @variables in(t) out(t)
    eqs = [out ~ in + 1]
    return System(eqs, t, [in, out], []; name)
end</code></pre><p>ModelingToolkit systems are either components or connectors. Components define dynamics of the model. Connectors are used to connect components together. See the <a href="#model_building_api">Model building reference</a> section of the documentation for more information.</p><p>See also: <a href="#ModelingToolkit.@connector"><code>@connector</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/7393a3dc3700232d599c194dcc5d2359c5b06980/src/systems/abstractsystem.jl#L2265-L2284">source</a></section></article><p>Every constructor function should build either a component or a connector. Components define the dynamics of the system. Connectors are used to connect components together and propagate information between them. See also <a href="#ModelingToolkit.@connector"><code>@connector</code></a>.</p><h3 id="Scoping-of-variables"><a class="docs-heading-anchor" href="#Scoping-of-variables">Scoping of variables</a><a id="Scoping-of-variables-1"></a><a class="docs-heading-anchor-permalink" href="#Scoping-of-variables" title="Permalink"></a></h3><p>When building hierarchical systems, is is often necessary to pass variables from a parent system to the subsystems. If done naively, this will result in the child system assuming it &quot;owns&quot; the variables passed to it and any occurrences of those variables in the child system will be namespaced. To prevent this, ModelingToolkit has the concept of variable scope. The scope allows specifying which system a variable belongs to relative to the system in which it is used.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.LocalScope" href="#ModelingToolkit.LocalScope"><code>ModelingToolkit.LocalScope</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct LocalScope &lt;: SymScope</code></pre><p>The default scope of a variable. It belongs to the system whose equations it is involved in and is namespaced by every level of the hierarchy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/7393a3dc3700232d599c194dcc5d2359c5b06980/src/systems/abstractsystem.jl#L969-L974">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.ParentScope" href="#ModelingToolkit.ParentScope"><code>ModelingToolkit.ParentScope</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct ParentScope &lt;: SymScope</code></pre><p>Denotes that the variable does not belong to the system whose equations it is involved in. It is not namespaced by this system. In the immediate parent of this system, the scope of this variable is given by <code>parent</code>.</p><p><strong>Fields</strong></p><ul><li><code>parent::SymScope</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/7393a3dc3700232d599c194dcc5d2359c5b06980/src/systems/abstractsystem.jl#L995-L1005">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.GlobalScope" href="#ModelingToolkit.GlobalScope"><code>ModelingToolkit.GlobalScope</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct GlobalScope &lt;: SymScope</code></pre><p>Denotes that a variable belongs to the root system in the hierarchy, regardless of which equations of subsystems in the hierarchy it is involved in. Variables with this scope are never namespaced and only added to the unknowns/parameters of a system when calling <code>complete</code> or <code>mtkcompile</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/7393a3dc3700232d599c194dcc5d2359c5b06980/src/systems/abstractsystem.jl#L1029-L1036">source</a></section></article><p>Note that the scopes must be applied to <em>individual variables</em> and not expressions. For example, <code>ParentScope(x + y)</code> is incorrect. Instead, <code>ParentScope(x) + ParentScope(y)</code> is the correct usage. Applying the same scope (more generally, the same function) to all variables in an expression is a common task, and ModelingToolkit exposes a utility for the same:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.apply_to_variables" href="#ModelingToolkit.apply_to_variables"><code>ModelingToolkit.apply_to_variables</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">apply_to_variables(f, ex) -&gt; Any
</code></pre><p>Apply function <code>f</code> to each variable in expression <code>ex</code>. <code>f</code> should be a function that takes a variable and returns the replacement to use. A &quot;variable&quot; in this context refers to a symbolic quantity created directly from a variable creation macro such as <a href="@ref"><code>Symbolics.@variables</code></a>, <a href="../variables/#ModelingToolkit.@independent_variables"><code>@independent_variables</code></a>, <a href="../variables/#ModelingToolkit.@parameters"><code>@parameters</code></a>, <a href="../variables/#ModelingToolkit.@constants"><code>@constants</code></a> or <a href="../variables/#ModelingToolkit.@brownians"><code>@brownians</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/7393a3dc3700232d599c194dcc5d2359c5b06980/src/systems/abstractsystem.jl#L941-L949">source</a></section></article><p>It is still tedious to manually use <code>apply_to_variables</code> on any symbolic expression passed to a subsystem. The <code>@named</code> macro automatically wraps all symbolic arguments in <code>ParentScope</code> and uses the identifier being assigned as the name of the system.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.@named" href="#ModelingToolkit.@named"><code>ModelingToolkit.@named</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">@named y = foo(x)
@named y[1:10] = foo(x)
@named begin
    y[1:10] = foo(x)
    z = foo(x)
end # returns `[y; z]`
@named y 1:10 i -&gt; foo(x*i)  # This is not recommended</code></pre><p>Pass the LHS name to the model. When it&#39;s calling anything that&#39;s not an AbstractSystem, it wraps all keyword arguments in <code>default_to_parentscope</code> so that namespacing works intuitively when passing a symbolic default into a component.</p><p>Examples:</p><pre><code class="language-julia-repl hljs">julia&gt; using ModelingToolkit

julia&gt; foo(i; name) = (; i, name)
foo (generic function with 1 method)

julia&gt; x = 41
41

julia&gt; @named y = foo(x)
(i = 41, name = :y)

julia&gt; @named y[1:3] = foo(x)
3-element Vector{NamedTuple{(:i, :name), Tuple{Int64, Symbol}}}:
 (i = 41, name = :y_1)
 (i = 41, name = :y_2)
 (i = 41, name = :y_3)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/7393a3dc3700232d599c194dcc5d2359c5b06980/src/systems/abstractsystem.jl#L2146-L2180">source</a></section></article><h3 id="Exploring-the-tree-structure"><a class="docs-heading-anchor" href="#Exploring-the-tree-structure">Exploring the tree structure</a><a id="Exploring-the-tree-structure-1"></a><a class="docs-heading-anchor-permalink" href="#Exploring-the-tree-structure" title="Permalink"></a></h3><p>The <code>System</code> type implements the <code>AbstractTrees</code> interface. This can be used to explore the hierarchical structure.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.hierarchy" href="#ModelingToolkit.hierarchy"><code>ModelingToolkit.hierarchy</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">hierarchy(sys::AbstractSystem; describe = false, bold = describe, kwargs...)</code></pre><p>Print a tree of a system&#39;s hierarchy of subsystems.</p><p><strong>Keyword arguments</strong></p><ul><li><code>describe</code>: Whether to also print the description of each subsystem, if present.</li><li><code>bold</code>: Whether to print the name of the system in <strong>bold</strong> font.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/7393a3dc3700232d599c194dcc5d2359c5b06980/src/systems/abstractsystem.jl#L2425-L2434">source</a></section></article><h3 id="connect_semantics"><a class="docs-heading-anchor" href="#connect_semantics">Connection semantics</a><a id="connect_semantics-1"></a><a class="docs-heading-anchor-permalink" href="#connect_semantics" title="Permalink"></a></h3><p>ModelingToolkit implements connection semantics similar to those in the <a href="https://specification.modelica.org/maint/3.6/connectors-and-connections.html">Modelica specification</a>. We do not support the concept of <code>inner</code> and <code>outer</code> elements or <code>expandable</code> connectors. Connectors in ModelingToolkit are systems with the appropriate metadata added via the <code>@connector</code> macro.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.connect" href="#ModelingToolkit.connect"><code>ModelingToolkit.connect</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">connect(
    sys1::ModelingToolkit.AbstractSystem,
    sys2::ModelingToolkit.AbstractSystem,
    syss::ModelingToolkit.AbstractSystem...
) -&gt; Equation
</code></pre><p>Connect multiple connectors created via <code>@connector</code>. All connected connectors must be unique.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/7393a3dc3700232d599c194dcc5d2359c5b06980/src/systems/connectors.jl#L19-L24">source</a></section><section><div><pre><code class="language-julia hljs">connect(
    var1::Union{Num, SymbolicUtils.BasicSymbolic, Symbolics.Arr},
    var2::Union{Num, SymbolicUtils.BasicSymbolic, Symbolics.Arr},
    vars::Union{Num, SymbolicUtils.BasicSymbolic, Symbolics.Arr}...
) -&gt; Equation
</code></pre><p>Connect multiple causal variables. The first variable must be an output, and all subsequent variables must be inputs. The statement <code>connect(var1, var2, var3, ...)</code> expands to:</p><pre><code class="language-julia hljs">var1 ~ var2
var1 ~ var3
# ...</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/7393a3dc3700232d599c194dcc5d2359c5b06980/src/systems/connectors.jl#L239-L250">source</a></section><section><div><pre><code class="language-julia hljs">connect(output_connector, ap_name::Symbol, input_connector; verbose = true)
connect(output_connector, ap::AnalysisPoint, input_connector; verbose = true)</code></pre><p>Connect <code>output_connector</code> and <code>input_connector</code> with an <a href="../../tutorials/disturbance_modeling/#ModelingToolkit.AnalysisPoint-Tuple{Symbol}-tutorials-disturbance_modeling"><code>AnalysisPoint</code></a> inbetween. The incoming connection <code>output_connector</code> is expected to be an output connector (for example, <code>ModelingToolkitStandardLibrary.Blocks.RealOutput</code>), and vice versa.</p><p><em>PLEASE NOTE</em>: The connection is assumed to be <em>causal</em>, meaning that</p><pre><code class="language-julia hljs">@named P = FirstOrder(k = 1, T = 1)
@named C = Gain(; k = -1)
connect(C.output, :plant_input, P.input)</code></pre><p>is correct, whereas</p><pre><code class="language-julia hljs">connect(P.input, :plant_input, C.output)</code></pre><p>typically is not (unless the model is an inverse model).</p><p><strong>Arguments</strong></p><ul><li><code>output_connector</code>: An output connector</li><li><code>input_connector</code>: An input connector</li><li><code>ap</code>: An explicitly created <a href="../../tutorials/disturbance_modeling/#ModelingToolkit.AnalysisPoint-Tuple{Symbol}-tutorials-disturbance_modeling"><code>AnalysisPoint</code></a></li><li><code>ap_name</code>: If a name is given, an <a href="../../tutorials/disturbance_modeling/#ModelingToolkit.AnalysisPoint-Tuple{Symbol}-tutorials-disturbance_modeling"><code>AnalysisPoint</code></a> with the given name will be created automatically.</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>verbose</code>: Warn if an input is connected to an output (reverse causality). Silence this warning if you are analyzing an inverse model.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/7393a3dc3700232d599c194dcc5d2359c5b06980/src/systems/analysis_points.jl#L185-L221">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.domain_connect" href="#ModelingToolkit.domain_connect"><code>ModelingToolkit.domain_connect</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">domain_connect(
    sys1::ModelingToolkit.AbstractSystem,
    sys2::ModelingToolkit.AbstractSystem,
    syss::ModelingToolkit.AbstractSystem...
) -&gt; Equation
</code></pre><p>Adds a domain only connection equation, through and across state equations are not generated.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/7393a3dc3700232d599c194dcc5d2359c5b06980/src/systems/connectors.jl#L58-L62">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.@connector" href="#ModelingToolkit.@connector"><code>ModelingToolkit.@connector</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Mark a system constructor function as building a connector. For example,</p><pre><code class="language-julia hljs">@connector function ElectricalPin(; name, v = nothing, i = nothing)
    @variables begin
        v(t) = v, [description = &quot;Potential at the pin [V]&quot;]
        i(t) = i, [connect = Flow, description = &quot;Current flowing into the pin [A]&quot;]
    end
    return System(Equation[], t, [v, i], []; name)
end</code></pre><p>Since connectors only declare variables, the equivalent shorthand syntax can also be used:</p><pre><code class="language-julia hljs">@connector Pin begin
    v(t), [description = &quot;Potential at the pin [V]&quot;]
    i(t), [connect = Flow, description = &quot;Current flowing into the pin [A]&quot;]
end</code></pre><p>ModelingToolkit systems are either components or connectors. Components define dynamics of the model. Connectors are used to connect components together. See the <a href="#model_building_api">Model building reference</a> section of the documentation for more information.</p><p>See also: <a href="#ModelingToolkit.@component"><code>@component</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/7393a3dc3700232d599c194dcc5d2359c5b06980/src/systems/connectors.jl#L83-L113">source</a></section></article><p>Connections can be expanded using <code>expand_connections</code>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.expand_connections" href="#ModelingToolkit.expand_connections"><code>ModelingToolkit.expand_connections</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">expand_connections(
    sys::ModelingToolkit.AbstractSystem;
    tol
) -&gt; Any
</code></pre><p>Given a hierarchical system with <a href="#ModelingToolkit.connect"><code>connect</code></a> equations, expand the connection equations and return the new system. <code>tol</code> is the tolerance for handling the singularities in stream connection equations that happen when a flow variable approaches zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/7393a3dc3700232d599c194dcc5d2359c5b06980/src/systems/connectors.jl#L846-L852">source</a></section></article><p>Similar to the <code>stream</code> and <code>flow</code> keyword arguments in the specification, ModelingToolkit allows specifying how variables in a connector behave in a connection.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.Equality" href="#ModelingToolkit.Equality"><code>ModelingToolkit.Equality</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct Equality &lt;: ModelingToolkit.AbstractConnectType</code></pre><p>Flag which is meant to be passed to the <code>connect</code> metadata of a variable to affect how it behaves when the connector it is in is part of a <code>connect</code> equation. <code>Equality</code> is the default value and such variables when connected are made equal. For example, electric potential is equated at a junction.</p><p>For more information, refer to the <a href="#connect_semantics">Connection semantics</a> section of the docs.</p><p>See also: <a href="#ModelingToolkit.connect"><code>connect</code></a>, <a href="#ModelingToolkit.@connector"><code>@connector</code></a>, <a href="#ModelingToolkit.Flow"><code>Flow</code></a>, <a href="#ModelingToolkit.Stream"><code>Stream</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/7393a3dc3700232d599c194dcc5d2359c5b06980/src/variables.jl#L94-L107">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.Flow" href="#ModelingToolkit.Flow"><code>ModelingToolkit.Flow</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct Flow &lt;: ModelingToolkit.AbstractConnectType</code></pre><p>Flag which is meant to be passed to the <code>connect</code> metadata of a variable to affect how it behaves when the connector it is in is part of a <code>connect</code> equation. <code>Flow</code> denotes that the sum of marked variable in all connectors in the connection set must sum to zero. For example, electric current sums to zero at a junction (assuming appropriate signs are used for current flowing in and out of the function).</p><p>For more information, refer to the <a href="#connect_semantics">Connection semantics</a> section of the docs.</p><p>See also: <a href="#ModelingToolkit.connect"><code>connect</code></a>, <a href="#ModelingToolkit.@connector"><code>@connector</code></a>, <a href="#ModelingToolkit.Equality"><code>Equality</code></a>, <a href="#ModelingToolkit.Stream"><code>Stream</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/7393a3dc3700232d599c194dcc5d2359c5b06980/src/variables.jl#L109-L123">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.Stream" href="#ModelingToolkit.Stream"><code>ModelingToolkit.Stream</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct Stream &lt;: ModelingToolkit.AbstractConnectType</code></pre><p>Flag which is meant to be passed to the <code>connect</code> metadata of a variable to affect how it behaves when the connector it is in is part of a <code>connect</code> equation. <code>Stream</code> denotes that the variable is part of a special stream connector.</p><p>For more information, refer to the <a href="#connect_semantics">Connection semantics</a> section of the docs.</p><p>See also: <a href="#ModelingToolkit.connect"><code>connect</code></a>, <a href="#ModelingToolkit.@connector"><code>@connector</code></a>, <a href="#ModelingToolkit.Equality"><code>Equality</code></a>, <a href="#ModelingToolkit.Flow"><code>Flow</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/7393a3dc3700232d599c194dcc5d2359c5b06980/src/variables.jl#L125-L137">source</a></section></article><p>These are specified using the <code>connect</code> metadata. ModelingToolkit also supports <code>instream</code>. Refer to the Modelica specification on <a href="https://specification.modelica.org/maint/3.6/stream-connectors.html">Stream connectors</a> for more information.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.instream" href="#ModelingToolkit.instream"><code>ModelingToolkit.instream</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">instream(a) -&gt; SymbolicUtils.BasicSymbolic
</code></pre><p><code>instream</code> is used when modeling stream connections. It is only allowed to be used on <code>Stream</code> variables.</p><p>Refer to the <a href="#connect_semantics">Connection semantics</a> section of the docs for more information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/7393a3dc3700232d599c194dcc5d2359c5b06980/src/systems/connectors.jl#L165-L173">source</a></section></article><h3 id="System-composition-utilities"><a class="docs-heading-anchor" href="#System-composition-utilities">System composition utilities</a><a id="System-composition-utilities-1"></a><a class="docs-heading-anchor-permalink" href="#System-composition-utilities" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.extend" href="#ModelingToolkit.extend"><code>ModelingToolkit.extend</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">extend(
    sys::ModelingToolkit.AbstractSystem,
    basesys::ModelingToolkit.AbstractSystem;
    name,
    description,
    gui_metadata
) -&gt; Any
</code></pre><p>Extend <code>basesys</code> with <code>sys</code>. This can be thought of as the <code>merge</code> operation on systems. Values in <code>sys</code> take priority over duplicates in <code>basesys</code> (for example, defaults).</p><p>By default, the resulting system inherits <code>sys</code>&#39;s name and description.</p><p>The <code>&amp;</code> operator can also be used for this purpose. <code>sys &amp; basesys</code> is equivalent to <code>extend(sys, basesys)</code>.</p><p>See also <a href="#ModelingToolkit.compose"><code>compose</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/7393a3dc3700232d599c194dcc5d2359c5b06980/src/systems/abstractsystem.jl#L2473">source</a></section><section><div><pre><code class="language-julia hljs">extend(
    sys,
    basesys::Array{T&lt;:ModelingToolkit.AbstractSystem, 1}
) -&gt; Any
</code></pre><p>Extend <code>sys</code> with all systems in <code>basesys</code> in order.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/7393a3dc3700232d599c194dcc5d2359c5b06980/src/systems/abstractsystem.jl#L2533-L2537">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.compose" href="#ModelingToolkit.compose"><code>ModelingToolkit.compose</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compose(sys, systems; name)
</code></pre><p>Compose multiple systems together. This adds all of <code>systems</code> as subsystems of <code>sys</code>. The resulting system inherits the name of <code>sys</code> by default.</p><p>The <code>∘</code> operator can also be used for this purpose. <code>sys ∘ basesys</code> is equivalent to <code>compose(sys, basesys)</code>.</p><p>See also <a href="#ModelingToolkit.extend"><code>extend</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/7393a3dc3700232d599c194dcc5d2359c5b06980/src/systems/abstractsystem.jl#L2563">source</a></section><section><div><pre><code class="language-julia hljs">compose(syss...; name) -&gt; Any
</code></pre><p>Syntactic sugar for adding all systems in <code>syss</code> as the subsystems of <code>first(syss)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/7393a3dc3700232d599c194dcc5d2359c5b06980/src/systems/abstractsystem.jl#L2592-L2596">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.substitute_component" href="#ModelingToolkit.substitute_component"><code>ModelingToolkit.substitute_component</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">substitute_component(
    sys::ModelingToolkit.AbstractSystem,
    rule::Pair{T&lt;:ModelingToolkit.AbstractSystem, T&lt;:ModelingToolkit.AbstractSystem}
) -&gt; Any
</code></pre><p>Given a hierarchical system <code>sys</code> and a rule <code>lhs =&gt; rhs</code>, replace the subsystem <code>lhs</code> in <code>sys</code> by <code>rhs</code>. The <code>lhs</code> must be the namespaced version of a subsystem of <code>sys</code> (e.g. obtained via <code>sys.inner.component</code>). The <code>rhs</code> must be valid as per the following conditions:</p><ol><li><code>rhs</code> must not be namespaced.</li><li>The name of <code>rhs</code> must be the same as the unnamespaced name of <code>lhs</code>.</li><li>Neither one of <code>lhs</code> or <code>rhs</code> can be marked as complete.</li><li>Both <code>lhs</code> and <code>rhs</code> must share the same independent variable.</li><li><code>rhs</code> must contain at least all of the unknowns and parameters present in <code>lhs</code>.</li><li>Corresponding unknowns in <code>rhs</code> must share the same connection and causality (input/output) metadata as their counterparts in <code>lhs</code>.</li><li>For each subsystem of <code>lhs</code>, there must be an identically named subsystem of <code>rhs</code>. These two corresponding subsystems must satisfy conditions 3, 4, 5, 6, 7. If the subsystem of <code>lhs</code> is a connector, the corresponding subsystem of <code>rhs</code> must also be a connector of the same type.</li></ol><p><code>sys</code> also cannot be marked as complete.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/7393a3dc3700232d599c194dcc5d2359c5b06980/src/systems/abstractsystem.jl#L3280-L3302">source</a></section></article><h3 id="Flattening-systems"><a class="docs-heading-anchor" href="#Flattening-systems">Flattening systems</a><a id="Flattening-systems-1"></a><a class="docs-heading-anchor-permalink" href="#Flattening-systems" title="Permalink"></a></h3><p>The hierarchical structure can be flattened. This operation is performed during simplification.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.flatten" href="#ModelingToolkit.flatten"><code>ModelingToolkit.flatten</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">flatten(sys::System) -&gt; System
flatten(sys::System, noeqs) -&gt; System
</code></pre><p>Flatten the hierarchical structure of a system, collecting all equations, unknowns, etc. into one top-level system after namespacing appropriately.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/7393a3dc3700232d599c194dcc5d2359c5b06980/src/systems/system.jl#L700-L705">source</a></section></article><h2 id="System-simplification"><a class="docs-heading-anchor" href="#System-simplification">System simplification</a><a id="System-simplification-1"></a><a class="docs-heading-anchor-permalink" href="#System-simplification" title="Permalink"></a></h2><p><code>System</code>s can be simplified to reformulate them in a way that enables it to be solved numerically, and also perform other optimizations. This is done via the <code>mtkcompile</code> function. Connection expansion and flattening are preprocessing steps of simplification.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.mtkcompile" href="#ModelingToolkit.mtkcompile"><code>ModelingToolkit.mtkcompile</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mtkcompile(
    sys;
    additional_passes,
    simplify,
    split,
    allow_symbolic,
    allow_parameter,
    conservative,
    fully_determined,
    inputs,
    outputs,
    disturbance_inputs,
    kwargs...
)
</code></pre><p>Compile the given system into a form that ModelingToolkit can generate code for. Also performs a variety of symbolic-numeric enhancements. For ODEs, this includes processes such as order reduction, index reduction, alias elimination and tearing. A subset of the unknowns of the system may be eliminated as observables, eliminating the need for the numerical solver to solve for these variables.</p><p>Does not rely on metadata to identify variables/parameters/brownians. Instead, queries the system for which symbolic quantites belong to which category. Any variables not present in the equations of the system will be removed in this process.</p><p><strong>Keyword Arguments</strong></p><ul><li>When <code>simplify=true</code>, the <code>simplify</code> function will be applied during the tearing process.</li><li><code>allow_symbolic=false</code>, <code>allow_parameter=true</code>, and <code>conservative=false</code> limit the coefficient types during tearing. In particular, <code>conservative=true</code> limits tearing to only solve for trivial linear systems where the coefficient has the absolute value of <span>$1$</span>.</li><li><code>fully_determined=true</code> controls whether or not an error will be thrown if the number of equations don&#39;t match the number of inputs, outputs, and equations.</li><li><code>inputs</code>, <code>outputs</code> and <code>disturbance_inputs</code> are passed as keyword arguments.<code>All inputs</code> get converted to parameters and are allowed to be unconnected, allowing models where <code>n_unknowns = n_equations - n_inputs</code>.</li><li><code>sort_eqs=true</code> controls whether equations are sorted lexicographically before simplification or not.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/7393a3dc3700232d599c194dcc5d2359c5b06980/src/systems/systems.jl#L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.@mtkcompile" href="#ModelingToolkit.@mtkcompile"><code>ModelingToolkit.@mtkcompile</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Macro shorthand for building and compiling a system in one step.</p><pre><code class="language-julia hljs">@mtkcompile sys = Constructor(args...; kwargs....)</code></pre><p>Is shorthand for</p><pre><code class="language-julia hljs">@named sys = Constructor(args...; kwargs...)
sys = mtkcompile(sys)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/7393a3dc3700232d599c194dcc5d2359c5b06980/src/systems/abstractsystem.jl#L2289-L2304">source</a></section></article><p>It is also possible (though not always advisable) to build numerical problems from systems without passing them through <code>mtkcompile</code>. To do this, the system must first be marked as &quot;complete&quot; via the <code>complete</code> function. This process is used to indicate that a system will not be modified further and allows ModelingToolkit to perform any necessary preprocessing to it. <code>mtkcompile</code> calls <code>complete</code> internally.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.complete" href="#ModelingToolkit.complete"><code>ModelingToolkit.complete</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">complete(
    sys::ModelingToolkit.AbstractSystem;
    split,
    flatten,
    add_initial_parameters
) -&gt; Any
</code></pre><p>Mark a system as completed. A completed system is a system which is done being defined/modified and is ready for structural analysis or other transformations. This allows for analyses and optimizations to be performed which require knowing the global structure of the system.</p><p>One property to note is that if a system is complete, the system will no longer namespace its subsystems or variables, i.e. <code>isequal(complete(sys).v.i, v.i)</code>.</p><p>This namespacing functionality can also be toggled independently of <code>complete</code> using <a href="../System/#ModelingToolkit.toggle_namespacing"><code>toggle_namespacing</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/7393a3dc3700232d599c194dcc5d2359c5b06980/src/systems/abstractsystem.jl#L615">source</a></section></article><h3 id="Exploring-the-results-of-simplification"><a class="docs-heading-anchor" href="#Exploring-the-results-of-simplification">Exploring the results of simplification</a><a id="Exploring-the-results-of-simplification-1"></a><a class="docs-heading-anchor-permalink" href="#Exploring-the-results-of-simplification" title="Permalink"></a></h3><p>Similar to how <a href="../System/#ModelingToolkit.full_equations"><code>full_equations</code></a> returns the equations of a system with all variables eliminated during <code>mtkcompile</code> substituted, we can perform this substitution on an arbitrary expression.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.substitute_observed" href="#ModelingToolkit.substitute_observed"><code>ModelingToolkit.substitute_observed</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">substitute_observed(
    sys::ModelingToolkit.AbstractSystem,
    expr;
    simplify
) -&gt; Any
</code></pre><p>Recursively substitute the observed equations of <code>sys</code> into <code>expr</code>. If <code>simplify</code>, call <code>Symbolics.simplify</code> on the resultant expression.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/7393a3dc3700232d599c194dcc5d2359c5b06980/src/systems/abstractsystem.jl#L1509-L1514">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.empty_substitutions" href="#ModelingToolkit.empty_substitutions"><code>ModelingToolkit.empty_substitutions</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">empty_substitutions(sys) -&gt; Any
</code></pre><p>Check if any variables were eliminated from the system as part of <code>mtkcompile</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/7393a3dc3700232d599c194dcc5d2359c5b06980/src/utils.jl#L687-L691">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.get_substitutions" href="#ModelingToolkit.get_substitutions"><code>ModelingToolkit.get_substitutions</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_substitutions(sys) -&gt; Dict
</code></pre><p>Get a dictionary mapping variables eliminated from the system during <code>mtkcompile</code> to the expressions used to calculate them.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/7393a3dc3700232d599c194dcc5d2359c5b06980/src/utils.jl#L696-L701">source</a></section></article><h3 id="Experimental-simplification"><a class="docs-heading-anchor" href="#Experimental-simplification">Experimental simplification</a><a id="Experimental-simplification-1"></a><a class="docs-heading-anchor-permalink" href="#Experimental-simplification" title="Permalink"></a></h3><p>ModelingToolkit may have a variety of experimental simplification passes. These are not enabled by default, but can be used by passing to the <code>additional_passes</code> keyword argument of <code>mtkcompile</code>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.IfLifting" href="#ModelingToolkit.IfLifting"><code>ModelingToolkit.IfLifting</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>If lifting converts (nested) if statements into a series of continuous events + a logically equivalent if statement + parameters.</p><p>Lifting proceeds through the following process:</p><ul><li>rewrite comparisons to be of the form eqn [op] 0; subtract the RHS from the LHS </li><li>replace comparisons with generated parameters; for each comparison eqn [op] 0, generate an event (dependent on op) that sets the parameter</li></ul><div class="admonition is-category-warn" id="Warn-a23684f6ab0199e9"><header class="admonition-header">Warn<a class="admonition-anchor" href="#Warn-a23684f6ab0199e9" title="Permalink"></a></header><div class="admonition-body"><p>This is an experimental simplification pass. It may have bugs. Please open issues with MWEs for any bugs encountered while using this.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/7393a3dc3700232d599c194dcc5d2359c5b06980/src/systems/if_lifting.jl#L407-L418">source</a></section></article><h2 id="Event-handling"><a class="docs-heading-anchor" href="#Event-handling">Event handling</a><a id="Event-handling-1"></a><a class="docs-heading-anchor-permalink" href="#Event-handling" title="Permalink"></a></h2><p>Time-dependent systems may have several events. These are used to trigger discontinuities in the model. They compile to standard callbacks from <code>DiffEqCallbacks.jl</code>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.SymbolicContinuousCallback" href="#ModelingToolkit.SymbolicContinuousCallback"><code>ModelingToolkit.SymbolicContinuousCallback</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SymbolicContinuousCallback(eqs::Vector{Equation}, affect = nothing, iv = nothing; 
                           affect_neg = affect, initialize = nothing, finalize = nothing, rootfind = SciMLBase.LeftRootFind, alg_eqs = Equation[])</code></pre><p>A <a href="@ref SciMLBase.ContinuousCallback"><code>ContinuousCallback</code></a> specified symbolically. Takes a vector of equations <code>eq</code> as well as the positive-edge <code>affect</code> and negative-edge <code>affect_neg</code> that apply when <em>any</em> of <code>eq</code> are satisfied. By default <code>affect_neg = affect</code>; to only get rising edges specify <code>affect_neg = nothing</code>.</p><p>Assume without loss of generality that the equation is of the form <code>c(u,p,t) ~ 0</code>; we denote the integrator state as <code>i.u</code>. For compactness, we define <code>prev_sign = sign(c(u[t-1], p[t-1], t-1))</code> and <code>cur_sign = sign(c(u[t], p[t], t))</code>. A condition edge will be detected and the callback will be invoked iff <code>prev_sign * cur_sign &lt;= 0</code>. The positive edge <code>affect</code> will be triggered iff an edge is detected and if <code>prev_sign &lt; 0</code>; similarly, <code>affect_neg</code> will be triggered iff an edge is detected and <code>prev_sign &gt; 0</code>.</p><p>Inter-sample condition activation is not guaranteed; for example if we use the dirac delta function as <code>c</code> to insert a sharp discontinuity between integrator steps (which in this example would not normally be identified by adaptivity) then the condition is not guaranteed to be triggered.</p><p>Once detected the integrator will &quot;wind back&quot; through a root-finding process to identify the point when the condition became active; the method used is specified by <code>rootfind</code> from <a href="@ref"><code>SciMLBase.RootfindOpt</code></a>. If we denote the time when the condition becomes active as <code>tc</code>, the value in the integrator after windback will be:</p><ul><li><code>u[tc-epsilon], p[tc-epsilon], tc</code> if <code>LeftRootFind</code> is used,</li><li><code>u[tc+epsilon], p[tc+epsilon], tc</code> if <code>RightRootFind</code> is used,</li><li>or <code>u[t], p[t], t</code> if <code>NoRootFind</code> is used.</li></ul><p>For example, if we want to detect when an unknown variable <code>x</code> satisfies <code>x &gt; 0</code> using the condition <code>x ~ 0</code> on a positive edge (that is, <code>D(x) &gt; 0</code>), then left root finding will get us <code>x=-epsilon</code>, right root finding <code>x=epsilon</code> and no root finding will produce whatever the next step of the integrator was after it passed through 0.</p><p>Multiple callbacks in the same system with different <code>rootfind</code> operations will be grouped by their <code>rootfind</code> value into separate VectorContinuousCallbacks in the enumeration order of <code>SciMLBase.RootfindOpt</code>. This may cause some callbacks to not fire if several become active at the same instant. See the <code>SciMLBase</code> documentation for more information on the semantic rules.</p><p>Affects (i.e. <code>affect</code> and <code>affect_neg</code>) can be specified as either:</p><ul><li>A list of equations that should be applied when the callback is triggered (e.g. <code>x ~ 3, y ~ 7</code>) which must be of the form <code>unknown ~ observed value</code> where each <code>unknown</code> appears only once. Equations will be applied in the order that they appear in the vector; parameters and state updates will become immediately visible to following equations.</li><li>A tuple <code>(f!, unknowns, read_parameters, modified_parameters, ctx)</code>, where:<ul><li><code>f!</code> is a function with signature <code>(integ, u, p, ctx)</code> that is called with the integrator, a state <em>index</em> vector <code>u</code> derived from <code>unknowns</code>, a parameter <em>index</em> vector <code>p</code> derived from <code>read_parameters</code>, and the <code>ctx</code> that was given at construction time. Note that <code>ctx</code> is aliased between instances.</li><li><code>unknowns</code> is a vector of symbolic unknown variables and optionally their aliases (e.g. if the model was defined with <code>@variables x(t)</code> then a valid value for <code>unknowns</code> would be <code>[x]</code>). A variable can be aliased with a pair <code>x =&gt; :y</code>. The indices of these <code>unknowns</code> will be passed to <code>f!</code> in <code>u</code> in a named tuple; in the earlier example, if we pass <code>[x]</code> as <code>unknowns</code> then <code>f!</code> can access <code>x</code> as <code>integ.u[u.x]</code>. If no alias is specified the name of the index will be the symbol version of the variable name.</li><li><code>read_parameters</code> is a vector of the parameters that are <em>used</em> by <code>f!</code>. Their indices are passed to <code>f</code> in <code>p</code> similarly to the indices of <code>unknowns</code> passed in <code>u</code>.</li><li><code>modified_parameters</code> is a vector of the parameters that are <em>modified</em> by <code>f!</code>. Note that a parameter will not appear in <code>p</code> if it only appears in <code>modified_parameters</code>; it must appear in both <code>parameters</code> and <code>modified_parameters</code> if it is used in the affect definition.</li><li><code>ctx</code> is a user-defined context object passed to <code>f!</code> when invoked. This value is aliased for each problem.</li></ul></li><li>A <a href="#ModelingToolkit.ImperativeAffect"><code>ImperativeAffect</code></a>; refer to its documentation for details.</li></ul><p><code>reinitializealg</code> is used to set how the system will be reinitialized after the callback. </p><ul><li>Symbolic affects have reinitialization built in. In this case the algorithm will default to SciMLBase.NoInit(), and should <strong>not</strong> be provided.</li><li>Functional and imperative affects will default to SciMLBase.CheckInit(), which will error if the system is not properly reinitialized after the callback. If your system is a DAE, pass in an algorithm like SciMLBase.BrownBasicFullInit() to properly re-initialize.</li></ul><p>Initial and final affects can also be specified identically to positive and negative edge affects. Initialization affects will run as soon as the solver starts, while finalization affects will be executed after termination.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/7393a3dc3700232d599c194dcc5d2359c5b06980/src/systems/callbacks.jl#L110-L158">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.SymbolicDiscreteCallback" href="#ModelingToolkit.SymbolicDiscreteCallback"><code>ModelingToolkit.SymbolicDiscreteCallback</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SymbolicDiscreteCallback(conditions::Vector{Equation}, affect = nothing, iv = nothing;
                         initialize = nothing, finalize = nothing, alg_eqs = Equation[])</code></pre><p>A callback that triggers at the first timestep that the conditions are satisfied.</p><p>The condition can be one of: </p><ul><li>Δt::Real              - periodic events with period Δt</li><li>ts::Vector{Real}      - events trigger at these preset times given by <code>ts</code></li><li>eqs::Vector{Symbolic} - events trigger when the condition evaluates to true</li></ul><p>Arguments: </p><ul><li>iv: The independent variable of the system. This must be specified if the independent variable appears in one of the equations explicitly, as in x ~ t + 1.</li><li>alg_eqs: Algebraic equations of the system that must be satisfied after the callback occurs.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/7393a3dc3700232d599c194dcc5d2359c5b06980/src/systems/callbacks.jl#L359-L373">source</a></section></article><p>The affect functions for the above callbacks can be symbolic or user-defined functions. Symbolic affects are handled using equations as described in the <a href="../../basics/Events/#events">Events</a> section of the documentation. User-defined functions can be used via <code>ImperativeAffect</code>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.ImperativeAffect" href="#ModelingToolkit.ImperativeAffect"><code>ModelingToolkit.ImperativeAffect</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ImperativeAffect(f::Function; modified::NamedTuple, observed::NamedTuple, ctx)</code></pre><p><code>ImperativeAffect</code> is a helper for writing affect functions that will compute observed values and ensure that modified values are correctly written back into the system. The affect function <code>f</code> needs to have the signature </p><pre><code class="nohighlight hljs">    f(modified::NamedTuple, observed::NamedTuple, ctx, integrator)::NamedTuple</code></pre><p>The function <code>f</code> will be called with <code>observed</code> and <code>modified</code> <code>NamedTuple</code>s that are derived from their respective <code>NamedTuple</code> definitions. Each  declaration<code>NamedTuple</code> should map an expression to a symbol; for example if we pass <code>observed=(; x = a + b)</code> this will alias the result of executing <code>a+b</code> in the system as <code>x</code> so the value of <code>a + b</code> will be accessible as <code>observed.x</code> in <code>f</code>. <code>modified</code> currently restricts symbolic expressions to only bare variables, so only tuples of the form <code>(; x = y)</code> or <code>(; x)</code> (which aliases <code>x</code> as itself) are allowed.</p><p>The argument NamedTuples (for instance <code>(;x=y)</code>) will be populated with the declared values on function entry; if we require <code>(;x=y)</code> in <code>observed</code> and <code>y=2</code>, for example, then the NamedTuple <code>(;x=2)</code> will be passed as <code>observed</code> to the affect function <code>f</code>. </p><p>The NamedTuple returned from <code>f</code> includes the values to be written back to the system after <code>f</code> returns. For example, if we want to update the value of <code>x</code> to be the result of <code>x + y</code> we could write</p><pre><code class="nohighlight hljs">ImperativeAffect(observed=(; x_plus_y = x + y), modified=(; x)) do m, o
    @set! m.x = o.x_plus_y
end</code></pre><p>Where we use Setfield to copy the tuple <code>m</code> with a new value for <code>x</code>, then return the modified value of <code>m</code>. All values updated by the tuple must have names originally declared in <code>modified</code>; a runtime error will be produced if a value is written that does not appear in <code>modified</code>. The user can dynamically decide not to write a value back by not including it in the returned tuple, in which case the associated field will not be updated.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/7393a3dc3700232d599c194dcc5d2359c5b06980/src/systems/imperative_affect.jl#L2-L30">source</a></section></article><h2 id="Modelingtoolkitize"><a class="docs-heading-anchor" href="#Modelingtoolkitize">Modelingtoolkitize</a><a id="Modelingtoolkitize-1"></a><a class="docs-heading-anchor-permalink" href="#Modelingtoolkitize" title="Permalink"></a></h2><p>ModelingToolkit can take some numerical problems created non-symbolically and build a symbolic representation from them.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.modelingtoolkitize" href="#ModelingToolkit.modelingtoolkitize"><code>ModelingToolkit.modelingtoolkitize</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">modelingtoolkitize(
    prob::ODEProblem;
    u_names,
    p_names,
    return_symbolic_u0_p,
    kwargs...
) -&gt; Any
</code></pre><p>Convert an <code>ODEProblem</code> to a <code>ModelingToolkit.System</code>.</p><p><strong>Keyword arguments</strong></p><ul><li><code>u_names</code>: An array of names of the same size as <code>prob.u0</code> to use as the names of the unknowns of the system. The names should be given as <code>Symbol</code>s.</li><li><code>p_names</code>: A collection of names to use for parameters of the system. The collection should have keys corresponding to indexes of <code>prob.p</code>. For example, if <code>prob.p</code> is an associative container like <code>NamedTuple</code>, then <code>p_names</code> should map keys of <code>prob.p</code> to the name that the corresponding parameter should have in the returned system. The names should be given as <code>Symbol</code>s.</li><li>INTERNAL <code>return_symbolic_u0_p</code>: Also return the symbolic state and parameter objects.</li></ul><p>All other keyword arguments are forwarded to the created <code>System</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/7393a3dc3700232d599c194dcc5d2359c5b06980/src/modelingtoolkitize/odeproblem.jl#L1-L18">source</a></section><section><div><pre><code class="language-julia hljs">modelingtoolkitize(
    prob::SDEProblem;
    u_names,
    p_names,
    kwargs...
) -&gt; Any
</code></pre><p>Convert an <code>SDEProblem</code> to a <code>ModelingToolkit.System</code>.</p><p><strong>Keyword arguments</strong></p><ul><li><code>u_names</code>: an array of names of the same size as <code>prob.u0</code> to use as the names of the unknowns of the system. The names should be given as <code>Symbol</code>s.</li><li><code>p_names</code>: a collection of names to use for parameters of the system. The collection should have keys corresponding to indexes of <code>prob.p</code>. For example, if <code>prob.p</code> is an associative container like <code>NamedTuple</code>, then <code>p_names</code> should map keys of <code>prob.p</code> to the name that the corresponding parameter should have in the returned system. The names should be given as <code>Symbol</code>s.</li></ul><p>All other keyword arguments are forwarded to the created <code>System</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/7393a3dc3700232d599c194dcc5d2359c5b06980/src/modelingtoolkitize/sdeproblem.jl#L1-L17">source</a></section><section><div><pre><code class="language-julia hljs">modelingtoolkitize(
    prob::OptimizationProblem;
    u_names,
    p_names,
    kwargs...
) -&gt; System
</code></pre><p>Convert an <code>OptimizationProblem</code> to a <code>ModelingToolkit.System</code>.</p><p><strong>Keyword arguments</strong></p><ul><li><code>u_names</code>: An array of names of the same size as <code>prob.u0</code> to use as the names of the unknowns of the system. The names should be given as <code>Symbol</code>s.</li><li><code>p_names</code>: A collection of names to use for parameters of the system. The collection should have keys corresponding to indexes of <code>prob.p</code>. For example, if <code>prob.p</code> is an associative container like <code>NamedTuple</code>, then <code>p_names</code> should map keys of <code>prob.p</code> to the name that the corresponding parameter should have in the returned system. The names should be given as <code>Symbol</code>s.</li></ul><p>All other keyword arguments are forwarded to the created <code>System</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/7393a3dc3700232d599c194dcc5d2359c5b06980/src/modelingtoolkitize/optimizationproblem.jl#L1-L17">source</a></section><section><div><pre><code class="language-julia hljs">modelingtoolkitize(
    prob::Union{SciMLBase.NonlinearLeastSquaresProblem, NonlinearProblem};
    u_names,
    p_names,
    kwargs...
) -&gt; System
</code></pre><p>Convert a <code>NonlinearProblem</code> or <code>NonlinearLeastSquaresProblem</code> to a <code>ModelingToolkit.System</code>.</p><p><strong>Keyword arguments</strong></p><ul><li><code>u_names</code>: An array of names of the same size as <code>prob.u0</code> to use as the names of the unknowns of the system. The names should be given as <code>Symbol</code>s.</li><li><code>p_names</code>: A collection of names to use for parameters of the system. The collection should have keys corresponding to indexes of <code>prob.p</code>. For example, if <code>prob.p</code> is an associative container like <code>NamedTuple</code>, then <code>p_names</code> should map keys of <code>prob.p</code> to the name that the corresponding parameter should have in the returned system. The names should be given as <code>Symbol</code>s.</li></ul><p>All other keyword arguments are forwarded to the created <code>System</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/7393a3dc3700232d599c194dcc5d2359c5b06980/src/modelingtoolkitize/nonlinearproblem.jl#L1-L18">source</a></section></article><h2 id="Using-FMUs"><a class="docs-heading-anchor" href="#Using-FMUs">Using FMUs</a><a id="Using-FMUs-1"></a><a class="docs-heading-anchor-permalink" href="#Using-FMUs" title="Permalink"></a></h2><p>ModelingToolkit is capable of importing FMUs as black-box symbolic models. Currently only a subset of FMU features are supported. This functionality requires importing <code>FMI.jl</code>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.FMIComponent" href="#ModelingToolkit.FMIComponent"><code>ModelingToolkit.FMIComponent</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FMIComponent(
    ::Val{Ver};
    fmu,
    tolerance,
    communication_step_size,
    reinitializealg,
    type,
    name
)
</code></pre><p>A component that wraps an FMU loaded via FMI.jl. The FMI version (2 or 3) should be provided as a <code>Val</code> to the function. Supports Model Exchange and CoSimulation FMUs. All inputs, continuous variables and outputs must be <code>FMI.fmi2Real</code> or <code>FMI.fmi3Float64</code>. Does not support events or discrete variables in the FMU. Does not support automatic differentiation. Parameters of the FMU will have defaults corresponding to their initial values in the FMU specification. All other variables will not have a default. Hierarchical names in the FMU of the form <code>namespace.variable</code> are transformed into symbolic variables with the name <code>namespace__variable</code>.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>fmu</code>: The FMU loaded via <code>FMI.loadFMU</code>.</li><li><code>tolerance</code>: The tolerance to provide to the FMU. Not used for v3 FMUs since it is not supported by FMI.jl.</li><li><code>communication_step_size</code>: The periodic interval at which communication with CoSimulation FMUs will occur. Must be provided for CoSimulation FMU components.</li><li><code>reinitializealg</code>: The DAE initialization algorithm to use for the callback managing the FMU. For CoSimulation FMUs whose states/outputs are used in algebraic equations of the system, this needs to be an algorithm that will solve for the new algebraic variables. For example, <code>OrdinaryDiffEqCore.BrownFullBasicInit()</code>.</li><li><code>type</code>: Either <code>:ME</code> or <code>:CS</code> depending on whether <code>fmu</code> is a Model Exchange or CoSimulation FMU respectively.</li><li><code>name</code>: The name of the system.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/7393a3dc3700232d599c194dcc5d2359c5b06980/ext/MTKFMIExt.jl#L68-L94">source</a></section></article><h2 id="Model-transformations"><a class="docs-heading-anchor" href="#Model-transformations">Model transformations</a><a id="Model-transformations-1"></a><a class="docs-heading-anchor-permalink" href="#Model-transformations" title="Permalink"></a></h2><p>ModelingToolkit exposes a variety of transformations that can be applied to models to aid in symbolic analysis.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.liouville_transform" href="#ModelingToolkit.liouville_transform"><code>ModelingToolkit.liouville_transform</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">liouville_transform(sys::System; kwargs...) -&gt; System
</code></pre><p>Generates the Liouville transformed set of ODEs, which is the original ODE system with a new variable <code>trJ</code> appended, corresponding to the -tr(Jacobian). This variable is used for properties like uncertainty propagation from a given initial distribution density.</p><p>For example, if <span>$u&#39;=p*u$</span> and <code>p</code> follows a probability distribution <span>$f(p)$</span>, then the probability density of a future value with a given choice of <span>$p$</span> is computed by setting the initial <code>trJ = f(p)</code>, and the final value of <code>trJ</code> is the probability of <span>$u(t)$</span>.</p><p>Example:</p><pre><code class="language-julia hljs">using ModelingToolkit, OrdinaryDiffEq

@independent_variables t
@parameters α β γ δ
@variables x(t) y(t)
D = Differential(t)
eqs = [D(x) ~ α*x - β*x*y, D(y) ~ -δ*y + γ*x*y]
@named sys = System(eqs, t)

sys2 = liouville_transform(sys)
sys2 = complete(sys2)
u0 = [x =&gt; 1.0, y =&gt; 1.0, sys2.trJ =&gt; 1.0]
prob = ODEProblem(sys2, u0, tspan, p)
sol = solve(prob, Tsit5())</code></pre><p>Where <code>sol[3,:]</code> is the evolution of <code>trJ</code> over time.</p><p>Sources:</p><p>Probabilistic Robustness Analysis of F-16 Controller Performance: An Optimal Transport Approach</p><p>Abhishek Halder, Kooktae Lee, and Raktim Bhattacharya https://abhishekhalder.bitbucket.io/F16ACC2013Final.pdf</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/7393a3dc3700232d599c194dcc5d2359c5b06980/src/systems/diffeqs/basic_transformations.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.change_of_variables" href="#ModelingToolkit.change_of_variables"><code>ModelingToolkit.change_of_variables</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">change_of_variables(
    sys::System,
    iv,
    forward_subs,
    backward_subs;
    simplify,
    t0,
    isSDE
) -&gt; Any
</code></pre><p>Generates the set of ODEs after change of variables.</p><p>Example:</p><pre><code class="language-julia hljs">using ModelingToolkit, OrdinaryDiffEq, Test

# Change of variables: z = log(x)
# (this implies that x = exp(z) is automatically non-negative)

@independent_variables t
@parameters α
@variables x(t)
D = Differential(t)
eqs = [D(x) ~ α*x]

tspan = (0., 1.)
def = [x =&gt; 1.0, α =&gt; -0.5]

@mtkcompile sys = System(eqs, t;defaults=def)
prob = ODEProblem(sys, [], tspan)
sol = solve(prob, Tsit5())

@variables z(t)
forward_subs  = [log(x) =&gt; z]
backward_subs = [x =&gt; exp(z)]
new_sys = change_of_variables(sys, t, forward_subs, backward_subs)
@test equations(new_sys)[1] == (D(z) ~ α)

new_prob = ODEProblem(new_sys, [], tspan)
new_sol = solve(new_prob, Tsit5())

@test isapprox(new_sol[x][end], sol[x][end], atol=1e-4)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/7393a3dc3700232d599c194dcc5d2359c5b06980/src/systems/diffeqs/basic_transformations.jl#L56">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.stochastic_integral_transform" href="#ModelingToolkit.stochastic_integral_transform"><code>ModelingToolkit.stochastic_integral_transform</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">stochastic_integral_transform(
    sys::System,
    correction_factor
) -&gt; Any
</code></pre><p>Choose correction_factor=-1//2 (1//2) to convert Ito -&gt; Stratonovich (Stratonovich-&gt;Ito).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/7393a3dc3700232d599c194dcc5d2359c5b06980/src/systems/diffeqs/basic_transformations.jl#L370">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.Girsanov_transform" href="#ModelingToolkit.Girsanov_transform"><code>ModelingToolkit.Girsanov_transform</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Girsanov_transform(sys::System, u; θ0) -&gt; Any
</code></pre><p>Measure transformation method that allows for a reduction in the variance of an estimator <code>Exp(g(X_t))</code>. Input:  Original SDE system and symbolic function <code>u(t,x)</code> with scalar output that         defines the adjustable parameters <code>d</code> in the Girsanov transformation. Optional: initial         condition for <code>θ0</code>. Output: Modified SDE System with additional component <code>θ_t</code> and initial value <code>θ0</code>, as well as         the weight <code>θ_t/θ0</code> as observed equation, such that the estimator <code>Exp(g(X_t)θ_t/θ0)</code>         has a smaller variance.</p><p>Reference: Kloeden, P. E., Platen, E., &amp; Schurz, H. (2012). Numerical solution of SDE through computer experiments. Springer Science &amp; Business Media.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">using ModelingToolkit
using ModelingToolkit: t_nounits as t, D_nounits as D

@parameters α β
@variables x(t) y(t) z(t)

eqs = [D(x) ~ α*x]
noiseeqs = [β*x]

@named de = System(eqs,t,[x],[α,β]; noise_eqs = noiseeqs)

# define u (user choice)
u = x
θ0 = 0.1
g(x) = x[1]^2
demod = ModelingToolkit.Girsanov_transform(de, u; θ0=0.1)

u0modmap = [
    x =&gt; x0
]

parammap = [
    α =&gt; 1.5,
    β =&gt; 1.0
]

probmod = SDEProblem(complete(demod),u0modmap,(0.0,1.0),parammap)
ensemble_probmod = EnsembleProblem(probmod;
          output_func = (sol,i) -&gt; (g(sol[x,end])*sol[demod.weight,end],false),
          )

simmod = solve(ensemble_probmod,EM(),dt=dt,trajectories=numtraj)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/7393a3dc3700232d599c194dcc5d2359c5b06980/src/systems/diffeqs/basic_transformations.jl#L425">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.change_independent_variable" href="#ModelingToolkit.change_independent_variable"><code>ModelingToolkit.change_independent_variable</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">change_independent_variable(
    sys::System, iv, eqs = [];
    add_old_diff = false, simplify = true, fold = false
)</code></pre><p>Transform the independent variable (e.g. <span>$t$</span>) of the ODE system <code>sys</code> to a dependent variable <code>iv</code> (e.g. <span>$u(t)$</span>). The transformation is well-defined when the mapping between the new and old independent variables are one-to-one. This is satisfied if one is a strictly increasing function of the other (e.g. <span>$du(t)/dt &gt; 0$</span> or <span>$du(t)/dt &lt; 0$</span>).</p><p>Any extra equations <code>eqs</code> involving the new and old independent variables will be taken into account in the transformation.</p><p><strong>Keyword arguments</strong></p><ul><li><code>add_old_diff</code>: Whether to add a differential equation for the old independent variable in terms of the new one using the inverse function rule <span>$dt/du = 1/(du/dt)$</span>.</li><li><code>simplify</code>: Whether expanded derivative expressions are simplified. This can give a tidier transformation.</li><li><code>fold</code>: Whether internal substitutions will evaluate numerical expressions.</li></ul><p><strong>Usage before structural simplification</strong></p><p>The variable change must take place before structural simplification. In following calls to <code>mtkcompile</code>, consider passing <code>allow_symbolic = true</code> to avoid undesired constraint equations between between dummy variables.</p><p><strong>Usage with non-autonomous systems</strong></p><p>If <code>sys</code> is non-autonomous (i.e. <span>$t$</span> appears explicitly in its equations), consider passing an algebraic equation relating the new and old independent variables (e.g. <span>$t = f(u(t))$</span>). Otherwise the transformed system can be underdetermined. If an algebraic relation is not known, consider using <code>add_old_diff</code> instead.</p><p><strong>Usage with hierarchical systems</strong></p><p>It is recommended that <code>iv</code> is a non-namespaced variable in <code>sys</code>. This means it can belong to the top-level system or be a variable in a subsystem declared with <code>GlobalScope</code>.</p><p><strong>Example</strong></p><p>Consider a free fall with constant horizontal velocity. Physics naturally describes position as a function of time. By changing the independent variable, it can be reformulated for vertical position as a function of horizontal position:</p><pre><code class="language-julia hljs">julia&gt; @variables x(t) y(t);

julia&gt; @named M = System([D(D(y)) ~ -9.81, D(D(x)) ~ 0.0], t);

julia&gt; M = change_independent_variable(M, x);

julia&gt; M = mtkcompile(M; allow_symbolic = true);

julia&gt; unknowns(M)
3-element Vector{SymbolicUtils.BasicSymbolic{Real}}:
 xˍt(x)
 y(x)
 yˍx(x)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/7393a3dc3700232d599c194dcc5d2359c5b06980/src/systems/diffeqs/basic_transformations.jl#L187-L241">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.add_accumulations" href="#ModelingToolkit.add_accumulations"><code>ModelingToolkit.add_accumulations</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_accumulations(sys::System) -&gt; Any
add_accumulations(sys::System, vars) -&gt; Any
</code></pre><p>Add accumulation variables for <code>vars</code>. For every unknown <code>x</code> in <code>vars</code>, add <code>D(accumulation_x) ~ x</code> as an equation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/7393a3dc3700232d599c194dcc5d2359c5b06980/src/systems/diffeqs/basic_transformations.jl#L545-L550">source</a></section><section><div><pre><code class="language-julia hljs">add_accumulations(sys::System, vars::Vector{&lt;:Pair}) -&gt; Any
</code></pre><p>Add accumulation variables for <code>vars</code>. <code>vars</code> is a vector of pairs in the form of</p><pre><code class="language-julia hljs">[cumulative_var1 =&gt; x + y, cumulative_var2 =&gt; x^2]</code></pre><p>Then, cumulative variables <code>cumulative_var1</code> and <code>cumulative_var2</code> that computes the cumulative <code>x + y</code> and <code>x^2</code> would be added to <code>sys</code>.</p><p>All accumulation variables have a default of zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/7393a3dc3700232d599c194dcc5d2359c5b06980/src/systems/diffeqs/basic_transformations.jl#L556-L569">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.noise_to_brownians" href="#ModelingToolkit.noise_to_brownians"><code>ModelingToolkit.noise_to_brownians</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">noise_to_brownians(sys::System; names) -&gt; Any
</code></pre><p>Given a system with noise in the form of noise equation (<code>get_noise_eqs(sys) !== nothing</code>) return an equivalent system which represents the noise using brownian variables.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>names</code>: The name(s) to use for the brownian variables. If this is a <code>Symbol</code>, variables with the given name and successive numeric <code>_i</code> suffixes will be used. If a <code>Vector</code>, this must have appropriate length for the noise equations of the system. The corresponding number of brownian variables are created with the given names.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/7393a3dc3700232d599c194dcc5d2359c5b06980/src/systems/diffeqs/basic_transformations.jl#L583-L595">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.convert_system_indepvar" href="#ModelingToolkit.convert_system_indepvar"><code>ModelingToolkit.convert_system_indepvar</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">convert_system_indepvar(sys::System, t; name) -&gt; Any
</code></pre><p>Function which takes a system <code>sys</code> and an independent variable <code>t</code> and changes the independent variable of <code>sys</code> to <code>t</code>. This is different from <a href="#ModelingToolkit.change_independent_variable"><code>change_independent_variable</code></a> since this function only does a symbolic substitution of the independent variable. <code>sys</code> must not be a reduced system (<code>observed(sys)</code> must be empty). If <code>sys</code> is time-independent, this can be used to turn it into a time-dependent system.</p><p><strong>Keyword arguments</strong></p><ul><li><code>name</code>: The name of the returned system.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/7393a3dc3700232d599c194dcc5d2359c5b06980/src/systems/diffeqs/basic_transformations.jl#L637-L650">source</a></section></article><h2 id="Hybrid-systems"><a class="docs-heading-anchor" href="#Hybrid-systems">Hybrid systems</a><a id="Hybrid-systems-1"></a><a class="docs-heading-anchor-permalink" href="#Hybrid-systems" title="Permalink"></a></h2><p>Hybrid systems are dynamical systems involving one or more discrete-time subsystems. These discrete time systems follow clock semantics - they are synchronous systems and the relevant variables are only defined at points where the clock ticks.</p><p>While ModelingToolkit is unable to simplify, compile and solve such systems on its own, it has the ability to represent them. Compilation strategies can be implemented independently on top of <a href="#ModelingToolkit.mtkcompile"><code>mtkcompile</code></a> using the <code>additional_passes</code> functionality.</p><div class="admonition is-category-warn" id="Warn-cfcc0d1e548ecb4c"><header class="admonition-header">Warn<a class="admonition-anchor" href="#Warn-cfcc0d1e548ecb4c" title="Permalink"></a></header><div class="admonition-body"><p>These operators are considered experimental API.</p></div></div><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.Sample-API-model_building" href="#ModelingToolkit.Sample-API-model_building"><code>ModelingToolkit.Sample</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct Sample &lt;: Symbolics.Operator</code></pre><p>Represents a sample operator. A discrete-time signal is created by sampling a continuous-time signal.</p><p><strong>Constructors</strong></p><p><code>Sample(clock::Union{TimeDomain, InferredTimeDomain} = InferredDiscrete())</code> <code>Sample(dt::Real)</code></p><p><code>Sample(x::Num)</code>, with a single argument, is shorthand for <code>Sample()(x)</code>.</p><p><strong>Fields</strong></p><ul><li><code>clock</code></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Symbolics

julia&gt; t = ModelingToolkit.t_nounits

julia&gt; Δ = Sample(0.01)
(::Sample) (generic function with 2 methods)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/7393a3dc3700232d599c194dcc5d2359c5b06980/src/discretedomain.jl#L101">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.Hold-API-model_building" href="#ModelingToolkit.Hold-API-model_building"><code>ModelingToolkit.Hold</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct Hold &lt;: Symbolics.Operator</code></pre><p>Represents a hold operator. A continuous-time signal is produced by holding a discrete-time signal <code>x</code> with zero-order hold.</p><pre><code class="nohighlight hljs">cont_x = Hold()(disc_x)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/7393a3dc3700232d599c194dcc5d2359c5b06980/src/discretedomain.jl#L171">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.SampleTime-API-model_building" href="#ModelingToolkit.SampleTime-API-model_building"><code>ModelingToolkit.SampleTime</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">function SampleTime()</code></pre><p><code>SampleTime()</code> can be used in the equations of a hybrid system to represent time sampled at the inferred clock for that equation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/7393a3dc3700232d599c194dcc5d2359c5b06980/src/discretedomain.jl#L3-L8">source</a></section></article><p>ModelingToolkit uses the clock definition in SciMLBase</p><div class="admonition is-warning" id="Missing-docstring.-5b644a7b627cfa7a"><header class="admonition-header">Missing docstring.<a class="admonition-anchor" href="#Missing-docstring.-5b644a7b627cfa7a" title="Permalink"></a></header><div class="admonition-body"><p>Missing docstring for <code>SciMLBase.TimeDomain</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning" id="Missing-docstring.-9d5d1bc503424f92"><header class="admonition-header">Missing docstring.<a class="admonition-anchor" href="#Missing-docstring.-9d5d1bc503424f92" title="Permalink"></a></header><div class="admonition-body"><p>Missing docstring for <code>SciMLBase.Clock</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning" id="Missing-docstring.-1caad572c8c3abc2"><header class="admonition-header">Missing docstring.<a class="admonition-anchor" href="#Missing-docstring.-1caad572c8c3abc2" title="Permalink"></a></header><div class="admonition-body"><p>Missing docstring for <code>SciMLBase.SolverStepClock</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning" id="Missing-docstring.-2bfbec611e976dd8"><header class="admonition-header">Missing docstring.<a class="admonition-anchor" href="#Missing-docstring.-2bfbec611e976dd8" title="Permalink"></a></header><div class="admonition-body"><p>Missing docstring for <code>SciMLBase.Continuous</code>. Check Documenter&#39;s build log for details.</p></div></div><h3 id="State-machines"><a class="docs-heading-anchor" href="#State-machines">State machines</a><a id="State-machines-1"></a><a class="docs-heading-anchor-permalink" href="#State-machines" title="Permalink"></a></h3><p>While ModelingToolkit has the capability to represent state machines, it lacks the ability to compile and simulate them.</p><div class="admonition is-category-warn" id="Warn-c8ea01779dfc6508"><header class="admonition-header">Warn<a class="admonition-anchor" href="#Warn-c8ea01779dfc6508" title="Permalink"></a></header><div class="admonition-body"><p>This functionality is considered experimental API</p></div></div><div class="admonition is-warning" id="Missing-docstring.-93cd323bf166759a"><header class="admonition-header">Missing docstring.<a class="admonition-anchor" href="#Missing-docstring.-93cd323bf166759a" title="Permalink"></a></header><div class="admonition-body"><p>Missing docstring for <code>initial_state</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.transition" href="#ModelingToolkit.transition"><code>ModelingToolkit.transition</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">transition(from, to, cond; immediate::Bool = true, reset::Bool = true, synchronize::Bool = false, priority::Int = 1)</code></pre><p>Create a transition from state <code>from</code> to state <code>to</code> that is enabled when transitioncondition <code>cond</code> evaluates to <code>true</code>.</p><p><strong>Arguments:</strong></p><ul><li><code>from</code>: The source state of the transition.</li><li><code>to</code>: The target state of the transition.</li><li><code>cond</code>: A transition condition that evaluates to a Bool, such as <code>ticksInState() &gt;= 2</code>.</li><li><code>immediate</code>: If <code>true</code>, the transition will fire at the same tick as it becomes true, if <code>false</code>, the actions of the state are evaluated first, and the transition fires during the next tick.</li><li><code>reset</code>: If true, the destination state <code>to</code> is reset to its initial condition when the transition fires.</li><li><code>synchronize</code>: If true, the transition will only fire if all sub-state machines in the source state are in their final (terminal) state. A final state is one that has no outgoing transitions.</li><li><code>priority</code>: If a state has more than one outgoing transition, all outgoing transitions must have a unique priority. The transitions are evaluated in priority order, i.e., the transition with priority 1 is evaluated first.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/7393a3dc3700232d599c194dcc5d2359c5b06980/src/systems/state_machines.jl#L37-L50">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.activeState" href="#ModelingToolkit.activeState"><code>ModelingToolkit.activeState</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">activeState(state)</code></pre><p>When used in a finite state machine, this operator returns <code>true</code> if the queried state is active and false otherwise. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/7393a3dc3700232d599c194dcc5d2359c5b06980/src/systems/state_machines.jl#L151-L155">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.entry" href="#ModelingToolkit.entry"><code>ModelingToolkit.entry</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">entry()
entry(state)</code></pre><p>When used in a finite-state machine, this operator returns true at the first tick when the state is active, and false otherwise.</p><p>When used to query the entry of the enclosing state, the method without arguments is used, when used to query the entry of another state, the state is passed as an argument.</p><p>This can be used to perform a unique action when entering a state.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/7393a3dc3700232d599c194dcc5d2359c5b06980/src/systems/state_machines.jl#L139-L148">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.ticksInState" href="#ModelingToolkit.ticksInState"><code>ModelingToolkit.ticksInState</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ticksInState()
ticksInState(state)</code></pre><p>Get the number of ticks spent in a state in a finite state machine.</p><p>When used to query the number of ticks spent in the enclosing state, the method without arguments is used, i.e.,</p><pre><code class="language-julia hljs">@mtkmodel FSM begin
    ...
    @equations begin
        var(k+1) ~ ticksInState() &gt;= 2 ? 0.0 : var(k)
    end
end</code></pre><p>If used to query the number of ticks in another state, the state is passed as an argument.</p><p>This operator can be used in both equations and transition conditions.</p><p>See also <a href="#ModelingToolkit.timeInState"><code>timeInState</code></a> and <a href="#ModelingToolkit.entry"><code>entry</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/7393a3dc3700232d599c194dcc5d2359c5b06980/src/systems/state_machines.jl#L116-L137">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.timeInState" href="#ModelingToolkit.timeInState"><code>ModelingToolkit.timeInState</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">timeInState()
timeInState(state)</code></pre><p>Get the time (in seconds) spent in a state in a finite state machine.</p><p>When used to query the time spent in the enclosing state, the method without arguments is used, i.e.,</p><pre><code class="language-julia hljs">@mtkmodel FSM begin
    ...
    @equations begin
        var(k+1) ~ timeInState() &gt;= 2 ? 0.0 : var(k)
    end
end</code></pre><p>If used to query the residence time of another state, the state is passed as an argument.</p><p>This operator can be used in both equations and transition conditions.</p><p>See also <a href="#ModelingToolkit.ticksInState"><code>ticksInState</code></a> and <a href="#ModelingToolkit.entry"><code>entry</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/7393a3dc3700232d599c194dcc5d2359c5b06980/src/systems/state_machines.jl#L93-L114">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../variables/">« Symbolic variables and variable metadata</a><a class="docs-footer-nextpage" href="../problems/">Building and solving numerical problems »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.12.0 on <span class="colophon-date" title="Wednesday 18 June 2025 12:00">Wednesday 18 June 2025</span>. Using Julia version 1.10.9.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
