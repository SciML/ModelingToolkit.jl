<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Building and solving numerical problems · ModelingToolkit.jl</title><meta name="title" content="Building and solving numerical problems · ModelingToolkit.jl"/><meta property="og:title" content="Building and solving numerical problems · ModelingToolkit.jl"/><meta property="twitter:title" content="Building and solving numerical problems · ModelingToolkit.jl"/><meta name="description" content="Documentation for ModelingToolkit.jl."/><meta property="og:description" content="Documentation for ModelingToolkit.jl."/><meta property="twitter:description" content="Documentation for ModelingToolkit.jl."/><meta property="og:url" content="https://docs.sciml.ai/ModelingToolkit/stable/API/problems/"/><meta property="twitter:url" content="https://docs.sciml.ai/ModelingToolkit/stable/API/problems/"/><link rel="canonical" href="https://docs.sciml.ai/ModelingToolkit/stable/API/problems/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="ModelingToolkit.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">ModelingToolkit.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../tutorials/ode_modeling/">Getting Started with ModelingToolkit.jl</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/acausal_components/">Acausal Component-Based Modeling</a></li><li><a class="tocitem" href="../../tutorials/nonlinear/">Modeling Nonlinear Systems</a></li><li><a class="tocitem" href="../../tutorials/initialization/">Initialization of Systems</a></li><li><a class="tocitem" href="../../tutorials/optimization/">Modeling Optimization Problems</a></li><li><a class="tocitem" href="../../tutorials/modelingtoolkitize/">Modelingtoolkitize: Automatically Translating Numerical to Symbolic Code</a></li><li><a class="tocitem" href="../../tutorials/programmatically_generating/">Programmatically Generating and Scripting Systems</a></li><li><a class="tocitem" href="../../tutorials/stochastic_diffeq/">Modeling with Stochasticity</a></li><li><a class="tocitem" href="../../tutorials/dynamic_optimization/">Solving Dynamic Optimization Problems</a></li><li><a class="tocitem" href="../../tutorials/discrete_system/">(Experimental) Modeling Discrete Systems</a></li><li><a class="tocitem" href="../../tutorials/parameter_identifiability/">Parameter Identifiability in ODE Models</a></li><li><a class="tocitem" href="../../tutorials/change_independent_variable/">Changing the independent variable of ODEs</a></li><li><a class="tocitem" href="../../tutorials/bifurcation_diagram_computation/">Bifurcation Diagrams</a></li><li><a class="tocitem" href="../../tutorials/attractors/">Multi- and Nonlocal- Continuation</a></li><li><a class="tocitem" href="../../tutorials/SampledData/">Clocks and Sampled-Data Systems</a></li><li><a class="tocitem" href="../../tutorials/domain_connections/">Domains</a></li><li><a class="tocitem" href="../../tutorials/callable_params/">Callable parameters and interpolating data</a></li><li><a class="tocitem" href="../../tutorials/linear_analysis/">Linear Analysis</a></li><li><a class="tocitem" href="../../tutorials/disturbance_modeling/">Disturbance and input modeling modeling</a></li><li><a class="tocitem" href="../../tutorials/fmi/">Importing FMUs</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><input class="collapse-toggle" id="menuitem-4-1" type="checkbox"/><label class="tocitem" for="menuitem-4-1"><span class="docs-label">Basic Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/higher_order/">Automatic Transformation of Nth Order ODEs to 1st Order ODEs</a></li><li><a class="tocitem" href="../../examples/spring_mass/">Component-Based Modeling of a Spring-Mass System</a></li><li><a class="tocitem" href="../../examples/modelingtoolkitize_index_reduction/">Automated Index Reduction of DAEs</a></li><li><a class="tocitem" href="../../examples/remake/">Optimizing through an ODE solve and re-creating MTK Problems</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-2" type="checkbox"/><label class="tocitem" for="menuitem-4-2"><span class="docs-label">Advanced Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/tearing_parallelism/">Exposing More Parallelism By Tearing Algebraic Equations in Systems</a></li><li><a class="tocitem" href="../../examples/sparse_jacobians/">Automated Sparse Analytical Jacobians</a></li><li><a class="tocitem" href="../../examples/perturbation/">Symbolic-Numeric Perturbation Theory for ODEs</a></li></ul></li></ul></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../System/">The <code>System</code> type</a></li><li><a class="tocitem" href="../variables/">Symbolic variables and variable metadata</a></li><li><a class="tocitem" href="../model_building/">Model building reference</a></li><li class="is-active"><a class="tocitem" href>Building and solving numerical problems</a><ul class="internal"><li><a class="tocitem" href="#Dynamical-systems"><span>Dynamical systems</span></a></li><li><a class="tocitem" href="#Linear-and-Nonlinear-systems"><span>Linear and Nonlinear systems</span></a></li><li><a class="tocitem" href="#Optimization-and-optimal-control"><span>Optimization and optimal control</span></a></li><li><a class="tocitem" href="#The-state-vector-and-parameter-object"><span>The state vector and parameter object</span></a></li><li><a class="tocitem" href="#Initialization"><span>Initialization</span></a></li><li><a class="tocitem" href="#Linear-analysis"><span>Linear analysis</span></a></li></ul></li><li><a class="tocitem" href="../dynamic_opt/">Dynamic Optimization Solvers</a></li><li><a class="tocitem" href="../codegen/">Code generation utilities</a></li><li><a class="tocitem" href="../PDESystem/">PDESystem</a></li></ul></li><li><span class="tocitem">Basics</span><ul><li><a class="tocitem" href="../../basics/Composition/">Composing Models and Building Reusable Components</a></li><li><a class="tocitem" href="../../basics/Events/">Event Handling and Callback Functions</a></li><li><a class="tocitem" href="../../basics/Linearization/">Linearization</a></li><li><a class="tocitem" href="../../basics/InputOutput/">Input output</a></li><li><a class="tocitem" href="../../basics/MTKLanguage/">ModelingToolkit Language: Modeling with <code>@mtkmodel</code>, <code>@connectors</code> and <code>@mtkcompile</code></a></li><li><a class="tocitem" href="../../basics/Validation/">Model Validation and Units</a></li><li><a class="tocitem" href="../../basics/Debugging/">Debugging</a></li><li><a class="tocitem" href="../../basics/DependencyGraphs/">Dependency Graphs</a></li><li><a class="tocitem" href="../../basics/Precompilation/">Working with Precompilation and Binary Building</a></li><li><a class="tocitem" href="../../basics/FAQ/">Frequently Asked Questions</a></li></ul></li><li><a class="tocitem" href="../../comparison/">Comparison of ModelingToolkit vs Equation-Based and Block Modeling Languages</a></li><li><a class="tocitem" href="../../internals/">Internal Details</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API</a></li><li class="is-active"><a href>Building and solving numerical problems</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Building and solving numerical problems</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SciML/ModelingToolkit.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SciML/ModelingToolkit.jl/blob/master/docs/src/API/problems.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Building-and-solving-numerical-problems"><a class="docs-heading-anchor" href="#Building-and-solving-numerical-problems">Building and solving numerical problems</a><a id="Building-and-solving-numerical-problems-1"></a><a class="docs-heading-anchor-permalink" href="#Building-and-solving-numerical-problems" title="Permalink"></a></h1><p>Systems are numerically solved by building and solving the appropriate problem type. Numerical solvers expect to receive functions taking a predefeined set of arguments and returning specific values. This format of argument and return value depends on the function and the problem. ModelingToolkit is capable of compiling and generating code for a variety of such numerical problems.</p><h2 id="Dynamical-systems"><a class="docs-heading-anchor" href="#Dynamical-systems">Dynamical systems</a><a id="Dynamical-systems-1"></a><a class="docs-heading-anchor-permalink" href="#Dynamical-systems" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SciMLBase.ODEFunction" href="#SciMLBase.ODEFunction"><code>SciMLBase.ODEFunction</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SciMLBase.ODEFunction(sys::System; kwargs...)
SciMLBase.ODEFunction{iip}(sys::System; kwargs...)
SciMLBase.ODEFunction{iip, specialize}(sys::System; kwargs...)</code></pre><p>Create a <code>SciMLBase.ODEFunction</code> from the given <code>sys</code>. <code>iip</code> is a boolean indicating whether the function should be in-place. <code>specialization</code> is a <code>SciMLBase.AbstractSpecalize</code> subtype indicating the level of specialization of the SciMLBase.ODEFunction.</p><p><strong>Keyword arguments</strong></p><ul><li><p><code>u0</code>: The <code>u0</code> vector for the corresponding problem, if available. Can be obtained using <a href="#ModelingToolkit.get_u0"><code>ModelingToolkit.get_u0</code></a>.</p></li><li><p><code>p</code>: The parameter object for the corresponding problem, if available. Can be obtained using <a href="#ModelingToolkit.get_p"><code>ModelingToolkit.get_p</code></a>.</p></li><li><p><code>t</code>: The initial time for the corresponding problem, if available.</p></li><li><p><code>eval_expression</code>: Whether to compile any functions via <code>eval</code> or <code>RuntimeGeneratedFunctions</code>.</p></li><li><p><code>eval_module</code>: If <code>eval_expression == true</code>, the module to <code>eval</code> into. Otherwise, the module in which to generate the <code>RuntimeGeneratedFunction</code>.</p></li><li><p><code>checkbounds</code>: Whether to enable bounds checking in the generated code.</p></li><li><p><code>simplify</code>: Whether to <code>simplify</code> any symbolically computed jacobians/hessians/etc.</p></li><li><p><code>cse</code>: Whether to enable Common Subexpression Elimination (CSE) on the generated code. This typically improves performance of the generated code but reduces readability.</p></li><li><p><code>sparse</code>: Whether to generate jacobian/hessian/etc. functions that return/operate on sparse matrices. Also controls whether the mass matrix is sparse, wherever applicable.</p></li><li><p><code>check_compatibility</code>: Whether to check if the given system <code>sys</code> contains all the information necessary to create a <code>SciMLBase.ODEFunction</code> and no more. If disabled, assumes that <code>sys</code> at least contains the necessary information.</p></li><li><p><code>expression</code>: <code>Val{true}</code> to return an <code>Expr</code> that constructs the corresponding problem instead of the problem itself. <code>Val{false}</code> otherwise.  Constructing the expression does not support callbacks</p></li><li><p><code>jac</code>: Whether to symbolically compute and generate code for the jacobian function.</p></li><li><p><code>tgrad</code>: Whether to symbolically compute and generate code for the <code>tgrad</code> function.</p></li><li><p><code>sparsity</code>: Whether to provide symbolically compute and provide sparsity patterns for the jacobian/hessian/etc.</p></li></ul><p>All other keyword arguments are forwarded to the <code>SciMLBase.ODEFunction</code> struct constructor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/0af5a3d86d4fccdeca0acdc62f5fcecfe0faaf9e/src/problems/docs.jl#L340-L384">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SciMLBase.ODEProblem" href="#SciMLBase.ODEProblem"><code>SciMLBase.ODEProblem</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SciMLBase.SciMLBase.ODEProblem(sys::System, op, tspan::NTuple{2}; kwargs...)
SciMLBase.SciMLBase.ODEProblem{iip}(sys::System, op, tspan::NTuple{2}; kwargs...)
SciMLBase.SciMLBase.ODEProblem{iip, specialize}(sys::System, op, tspan::NTuple{2}; kwargs...)</code></pre><p>Build a <code>SciMLBase.ODEProblem</code> given a system <code>sys</code> and operating point <code>op</code>  and timespan <code>tspan</code>. <code>iip</code> is a boolean indicating whether the problem should be in-place. <code>specialization</code> is a <code>SciMLBase.AbstractSpecalize</code> subtype indicating the level of specialization of the SciMLBase.ODEFunction. The operating point should be an iterable collection of key-value pairs mapping variables/parameters in the system to the (initial) values they should take in <code>SciMLBase.ODEProblem</code>. Any values not provided will fallback to the corresponding default (if present).</p><p>ModelingToolkit will build an initialization problem where all initial values for unknowns or observables of <code>sys</code> (either explicitly provided or in defaults) will be constraints. To remove an initial condition in the defaults (without providing a replacement) give the corresponding variable a value of <code>nothing</code> in the operating point. The initialization problem will also run parameter initialization. See the <a href="../../tutorials/initialization/#initialization">Initialization</a> documentation for more information.</p><p><strong>Keyword arguments</strong></p><ul><li><p><code>eval_expression</code>: Whether to compile any functions via <code>eval</code> or <code>RuntimeGeneratedFunctions</code>.</p></li><li><p><code>eval_module</code>: If <code>eval_expression == true</code>, the module to <code>eval</code> into. Otherwise, the module in which to generate the <code>RuntimeGeneratedFunction</code>.</p></li><li><p><code>guesses</code>: The guesses for variables in the system, used as initial values for the initialization problem.</p></li><li><p><code>warn_initialize_determined</code>: Warn if the initialization system is under/over-determined.</p></li><li><p><code>initialization_eqs</code>: Extra equations to use in the initialization problem.</p></li><li><p><code>fully_determined</code>: Override whether the initialization system is fully determined.</p></li><li><p><code>use_scc</code>: Whether to use <code>SCCNonlinearProblem</code> for initialization if the system is fully determined.</p></li><li><p><code>check_initialization_units</code>: Enable or disable unit checks when constructing the initialization problem.</p></li><li><p><code>tofloat</code>: Passed to <a href="#ModelingToolkit.varmap_to_vars"><code>varmap_to_vars</code></a> when building the parameter vector of a non-split system.</p></li><li><p><code>u0_eltype</code>: The <code>eltype</code> of the <code>u0</code> vector. If <code>nothing</code>, finds the promoted floating point type from <code>op</code>.</p></li><li><p><code>u0_constructor</code>: A function to apply to the <code>u0</code> value returned from <a href="#ModelingToolkit.varmap_to_vars"><code>varmap_to_vars</code></a>. to construct the final <code>u0</code> value.</p></li><li><p><code>p_constructor</code>: A function to apply to each array buffer created when constructing the parameter object.</p></li><li><p><code>warn_cyclic_dependency</code>: Whether to emit a warning listing out cycles in initial conditions provided for unknowns and parameters.</p></li><li><p><code>circular_dependency_max_cycle_length</code>: Maximum length of cycle to check for. Only applicable if <code>warn_cyclic_dependency == true</code>.</p></li><li><p><code>circular_dependency_max_cycles</code>: Maximum number of cycles to check for. Only applicable if <code>warn_cyclic_dependency == true</code>.</p></li><li><p><code>substitution_limit</code>: The number times to substitute initial conditions into each other to attempt to arrive at a numeric value.</p></li><li><p><code>callback</code>: An extra callback or <code>CallbackSet</code> to add to the problem, in addition to the ones defined symbolically in the system.</p></li><li><p><code>check_compatibility</code>: Whether to check if the given system <code>sys</code> contains all the information necessary to create a <code>SciMLBase.ODEProblem</code> and no more. If disabled, assumes that <code>sys</code> at least contains the necessary information.</p></li><li><p><code>expression</code>: <code>Val{true}</code> to return an <code>Expr</code> that constructs the corresponding problem instead of the problem itself. <code>Val{false}</code> otherwise.  Constructing the expression does not support callbacks</p></li></ul><p>All other keyword arguments are forwarded to the SciMLBase.ODEFunction constructor.</p><p><strong>Extended docs</strong></p><p>The following API is internal and may change or be removed without notice. Its usage is highly discouraged.</p><ul><li><code>build_initializeprob</code>: If <code>false</code>, avoids building the initialization problem.</li><li><code>check_length</code>: Whether to check the number of equations along with number of unknowns and length of <code>u0</code> vector for consistency. If <code>false</code>, do not check with equations. This is forwarded to <code>check_eqs_u0</code>.</li><li><code>time_dependent_init</code>: Whether to build a time-dependent initialization for the problem. A time-dependent initialization solves for a consistent <code>u0</code>, whereas a time-independent one only runs parameter initialization.</li><li><code>algebraic_only</code>: Whether to build the initialization problem using only algebraic equations.</li><li><code>allow_incomplete</code>: Whether to allow incomplete initialization problems.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/0af5a3d86d4fccdeca0acdc62f5fcecfe0faaf9e/src/problems/docs.jl#L206-L295">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SciMLBase.DAEFunction" href="#SciMLBase.DAEFunction"><code>SciMLBase.DAEFunction</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SciMLBase.DAEFunction(sys::System; kwargs...)
SciMLBase.DAEFunction{iip}(sys::System; kwargs...)
SciMLBase.DAEFunction{iip, specialize}(sys::System; kwargs...)</code></pre><p>Create a <code>SciMLBase.DAEFunction</code> from the given <code>sys</code>. <code>iip</code> is a boolean indicating whether the function should be in-place. <code>specialization</code> is a <code>SciMLBase.AbstractSpecalize</code> subtype indicating the level of specialization of the SciMLBase.DAEFunction.</p><p><strong>Keyword arguments</strong></p><ul><li><p><code>u0</code>: The <code>u0</code> vector for the corresponding problem, if available. Can be obtained using <a href="#ModelingToolkit.get_u0"><code>ModelingToolkit.get_u0</code></a>.</p></li><li><p><code>p</code>: The parameter object for the corresponding problem, if available. Can be obtained using <a href="#ModelingToolkit.get_p"><code>ModelingToolkit.get_p</code></a>.</p></li><li><p><code>t</code>: The initial time for the corresponding problem, if available.</p></li><li><p><code>eval_expression</code>: Whether to compile any functions via <code>eval</code> or <code>RuntimeGeneratedFunctions</code>.</p></li><li><p><code>eval_module</code>: If <code>eval_expression == true</code>, the module to <code>eval</code> into. Otherwise, the module in which to generate the <code>RuntimeGeneratedFunction</code>.</p></li><li><p><code>checkbounds</code>: Whether to enable bounds checking in the generated code.</p></li><li><p><code>simplify</code>: Whether to <code>simplify</code> any symbolically computed jacobians/hessians/etc.</p></li><li><p><code>cse</code>: Whether to enable Common Subexpression Elimination (CSE) on the generated code. This typically improves performance of the generated code but reduces readability.</p></li><li><p><code>sparse</code>: Whether to generate jacobian/hessian/etc. functions that return/operate on sparse matrices. Also controls whether the mass matrix is sparse, wherever applicable.</p></li><li><p><code>check_compatibility</code>: Whether to check if the given system <code>sys</code> contains all the information necessary to create a <code>SciMLBase.DAEFunction</code> and no more. If disabled, assumes that <code>sys</code> at least contains the necessary information.</p></li><li><p><code>expression</code>: <code>Val{true}</code> to return an <code>Expr</code> that constructs the corresponding problem instead of the problem itself. <code>Val{false}</code> otherwise.  Constructing the expression does not support callbacks</p></li><li><p><code>jac</code>: Whether to symbolically compute and generate code for the jacobian function.</p></li><li><p><code>tgrad</code>: Whether to symbolically compute and generate code for the <code>tgrad</code> function.</p></li><li><p><code>sparsity</code>: Whether to provide symbolically compute and provide sparsity patterns for the jacobian/hessian/etc.</p></li></ul><p>All other keyword arguments are forwarded to the <code>SciMLBase.DAEFunction</code> struct constructor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/0af5a3d86d4fccdeca0acdc62f5fcecfe0faaf9e/src/problems/docs.jl#L340-L384">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SciMLBase.DAEProblem" href="#SciMLBase.DAEProblem"><code>SciMLBase.DAEProblem</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SciMLBase.SciMLBase.DAEProblem(sys::System, op, tspan::NTuple{2}; kwargs...)
SciMLBase.SciMLBase.DAEProblem{iip}(sys::System, op, tspan::NTuple{2}; kwargs...)
SciMLBase.SciMLBase.DAEProblem{iip, specialize}(sys::System, op, tspan::NTuple{2}; kwargs...)</code></pre><p>Build a <code>SciMLBase.DAEProblem</code> given a system <code>sys</code> and operating point <code>op</code>  and timespan <code>tspan</code>. <code>iip</code> is a boolean indicating whether the problem should be in-place. <code>specialization</code> is a <code>SciMLBase.AbstractSpecalize</code> subtype indicating the level of specialization of the SciMLBase.DAEFunction. The operating point should be an iterable collection of key-value pairs mapping variables/parameters in the system to the (initial) values they should take in <code>SciMLBase.DAEProblem</code>. Any values not provided will fallback to the corresponding default (if present).</p><p>ModelingToolkit will build an initialization problem where all initial values for unknowns or observables of <code>sys</code> (either explicitly provided or in defaults) will be constraints. To remove an initial condition in the defaults (without providing a replacement) give the corresponding variable a value of <code>nothing</code> in the operating point. The initialization problem will also run parameter initialization. See the <a href="../../tutorials/initialization/#initialization">Initialization</a> documentation for more information.</p><p><strong>Keyword arguments</strong></p><ul><li><p><code>eval_expression</code>: Whether to compile any functions via <code>eval</code> or <code>RuntimeGeneratedFunctions</code>.</p></li><li><p><code>eval_module</code>: If <code>eval_expression == true</code>, the module to <code>eval</code> into. Otherwise, the module in which to generate the <code>RuntimeGeneratedFunction</code>.</p></li><li><p><code>guesses</code>: The guesses for variables in the system, used as initial values for the initialization problem.</p></li><li><p><code>warn_initialize_determined</code>: Warn if the initialization system is under/over-determined.</p></li><li><p><code>initialization_eqs</code>: Extra equations to use in the initialization problem.</p></li><li><p><code>fully_determined</code>: Override whether the initialization system is fully determined.</p></li><li><p><code>use_scc</code>: Whether to use <code>SCCNonlinearProblem</code> for initialization if the system is fully determined.</p></li><li><p><code>check_initialization_units</code>: Enable or disable unit checks when constructing the initialization problem.</p></li><li><p><code>tofloat</code>: Passed to <a href="#ModelingToolkit.varmap_to_vars"><code>varmap_to_vars</code></a> when building the parameter vector of a non-split system.</p></li><li><p><code>u0_eltype</code>: The <code>eltype</code> of the <code>u0</code> vector. If <code>nothing</code>, finds the promoted floating point type from <code>op</code>.</p></li><li><p><code>u0_constructor</code>: A function to apply to the <code>u0</code> value returned from <a href="#ModelingToolkit.varmap_to_vars"><code>varmap_to_vars</code></a>. to construct the final <code>u0</code> value.</p></li><li><p><code>p_constructor</code>: A function to apply to each array buffer created when constructing the parameter object.</p></li><li><p><code>warn_cyclic_dependency</code>: Whether to emit a warning listing out cycles in initial conditions provided for unknowns and parameters.</p></li><li><p><code>circular_dependency_max_cycle_length</code>: Maximum length of cycle to check for. Only applicable if <code>warn_cyclic_dependency == true</code>.</p></li><li><p><code>circular_dependency_max_cycles</code>: Maximum number of cycles to check for. Only applicable if <code>warn_cyclic_dependency == true</code>.</p></li><li><p><code>substitution_limit</code>: The number times to substitute initial conditions into each other to attempt to arrive at a numeric value.</p></li><li><p><code>callback</code>: An extra callback or <code>CallbackSet</code> to add to the problem, in addition to the ones defined symbolically in the system.</p></li><li><p><code>check_compatibility</code>: Whether to check if the given system <code>sys</code> contains all the information necessary to create a <code>SciMLBase.DAEProblem</code> and no more. If disabled, assumes that <code>sys</code> at least contains the necessary information.</p></li><li><p><code>expression</code>: <code>Val{true}</code> to return an <code>Expr</code> that constructs the corresponding problem instead of the problem itself. <code>Val{false}</code> otherwise.  Constructing the expression does not support callbacks</p></li></ul><p>All other keyword arguments are forwarded to the SciMLBase.DAEFunction constructor.</p><p><strong>Extended docs</strong></p><p>The following API is internal and may change or be removed without notice. Its usage is highly discouraged.</p><ul><li><code>build_initializeprob</code>: If <code>false</code>, avoids building the initialization problem.</li><li><code>check_length</code>: Whether to check the number of equations along with number of unknowns and length of <code>u0</code> vector for consistency. If <code>false</code>, do not check with equations. This is forwarded to <code>check_eqs_u0</code>.</li><li><code>time_dependent_init</code>: Whether to build a time-dependent initialization for the problem. A time-dependent initialization solves for a consistent <code>u0</code>, whereas a time-independent one only runs parameter initialization.</li><li><code>algebraic_only</code>: Whether to build the initialization problem using only algebraic equations.</li><li><code>allow_incomplete</code>: Whether to allow incomplete initialization problems.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/0af5a3d86d4fccdeca0acdc62f5fcecfe0faaf9e/src/problems/docs.jl#L206-L295">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SciMLBase.SDEFunction" href="#SciMLBase.SDEFunction"><code>SciMLBase.SDEFunction</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SciMLBase.SDEFunction(sys::System; kwargs...)
SciMLBase.SDEFunction{iip}(sys::System; kwargs...)
SciMLBase.SDEFunction{iip, specialize}(sys::System; kwargs...)</code></pre><p>Create a <code>SciMLBase.SDEFunction</code> from the given <code>sys</code>. <code>iip</code> is a boolean indicating whether the function should be in-place. <code>specialization</code> is a <code>SciMLBase.AbstractSpecalize</code> subtype indicating the level of specialization of the SciMLBase.SDEFunction.</p><p><strong>Keyword arguments</strong></p><ul><li><p><code>u0</code>: The <code>u0</code> vector for the corresponding problem, if available. Can be obtained using <a href="#ModelingToolkit.get_u0"><code>ModelingToolkit.get_u0</code></a>.</p></li><li><p><code>p</code>: The parameter object for the corresponding problem, if available. Can be obtained using <a href="#ModelingToolkit.get_p"><code>ModelingToolkit.get_p</code></a>.</p></li><li><p><code>t</code>: The initial time for the corresponding problem, if available.</p></li><li><p><code>eval_expression</code>: Whether to compile any functions via <code>eval</code> or <code>RuntimeGeneratedFunctions</code>.</p></li><li><p><code>eval_module</code>: If <code>eval_expression == true</code>, the module to <code>eval</code> into. Otherwise, the module in which to generate the <code>RuntimeGeneratedFunction</code>.</p></li><li><p><code>checkbounds</code>: Whether to enable bounds checking in the generated code.</p></li><li><p><code>simplify</code>: Whether to <code>simplify</code> any symbolically computed jacobians/hessians/etc.</p></li><li><p><code>cse</code>: Whether to enable Common Subexpression Elimination (CSE) on the generated code. This typically improves performance of the generated code but reduces readability.</p></li><li><p><code>sparse</code>: Whether to generate jacobian/hessian/etc. functions that return/operate on sparse matrices. Also controls whether the mass matrix is sparse, wherever applicable.</p></li><li><p><code>check_compatibility</code>: Whether to check if the given system <code>sys</code> contains all the information necessary to create a <code>SciMLBase.SDEFunction</code> and no more. If disabled, assumes that <code>sys</code> at least contains the necessary information.</p></li><li><p><code>expression</code>: <code>Val{true}</code> to return an <code>Expr</code> that constructs the corresponding problem instead of the problem itself. <code>Val{false}</code> otherwise.  Constructing the expression does not support callbacks</p></li><li><p><code>jac</code>: Whether to symbolically compute and generate code for the jacobian function.</p></li><li><p><code>tgrad</code>: Whether to symbolically compute and generate code for the <code>tgrad</code> function.</p></li><li><p><code>sparsity</code>: Whether to provide symbolically compute and provide sparsity patterns for the jacobian/hessian/etc.</p></li></ul><p>All other keyword arguments are forwarded to the <code>SciMLBase.SDEFunction</code> struct constructor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/0af5a3d86d4fccdeca0acdc62f5fcecfe0faaf9e/src/problems/docs.jl#L340-L384">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SciMLBase.SDEProblem" href="#SciMLBase.SDEProblem"><code>SciMLBase.SDEProblem</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SciMLBase.SciMLBase.SDEProblem(sys::System, op, tspan::NTuple{2}; kwargs...)
SciMLBase.SciMLBase.SDEProblem{iip}(sys::System, op, tspan::NTuple{2}; kwargs...)
SciMLBase.SciMLBase.SDEProblem{iip, specialize}(sys::System, op, tspan::NTuple{2}; kwargs...)</code></pre><p>Build a <code>SciMLBase.SDEProblem</code> given a system <code>sys</code> and operating point <code>op</code>  and timespan <code>tspan</code>. <code>iip</code> is a boolean indicating whether the problem should be in-place. <code>specialization</code> is a <code>SciMLBase.AbstractSpecalize</code> subtype indicating the level of specialization of the SciMLBase.SDEFunction. The operating point should be an iterable collection of key-value pairs mapping variables/parameters in the system to the (initial) values they should take in <code>SciMLBase.SDEProblem</code>. Any values not provided will fallback to the corresponding default (if present).</p><p>ModelingToolkit will build an initialization problem where all initial values for unknowns or observables of <code>sys</code> (either explicitly provided or in defaults) will be constraints. To remove an initial condition in the defaults (without providing a replacement) give the corresponding variable a value of <code>nothing</code> in the operating point. The initialization problem will also run parameter initialization. See the <a href="../../tutorials/initialization/#initialization">Initialization</a> documentation for more information.</p><p><strong>Keyword arguments</strong></p><ul><li><p><code>eval_expression</code>: Whether to compile any functions via <code>eval</code> or <code>RuntimeGeneratedFunctions</code>.</p></li><li><p><code>eval_module</code>: If <code>eval_expression == true</code>, the module to <code>eval</code> into. Otherwise, the module in which to generate the <code>RuntimeGeneratedFunction</code>.</p></li><li><p><code>guesses</code>: The guesses for variables in the system, used as initial values for the initialization problem.</p></li><li><p><code>warn_initialize_determined</code>: Warn if the initialization system is under/over-determined.</p></li><li><p><code>initialization_eqs</code>: Extra equations to use in the initialization problem.</p></li><li><p><code>fully_determined</code>: Override whether the initialization system is fully determined.</p></li><li><p><code>use_scc</code>: Whether to use <code>SCCNonlinearProblem</code> for initialization if the system is fully determined.</p></li><li><p><code>check_initialization_units</code>: Enable or disable unit checks when constructing the initialization problem.</p></li><li><p><code>tofloat</code>: Passed to <a href="#ModelingToolkit.varmap_to_vars"><code>varmap_to_vars</code></a> when building the parameter vector of a non-split system.</p></li><li><p><code>u0_eltype</code>: The <code>eltype</code> of the <code>u0</code> vector. If <code>nothing</code>, finds the promoted floating point type from <code>op</code>.</p></li><li><p><code>u0_constructor</code>: A function to apply to the <code>u0</code> value returned from <a href="#ModelingToolkit.varmap_to_vars"><code>varmap_to_vars</code></a>. to construct the final <code>u0</code> value.</p></li><li><p><code>p_constructor</code>: A function to apply to each array buffer created when constructing the parameter object.</p></li><li><p><code>warn_cyclic_dependency</code>: Whether to emit a warning listing out cycles in initial conditions provided for unknowns and parameters.</p></li><li><p><code>circular_dependency_max_cycle_length</code>: Maximum length of cycle to check for. Only applicable if <code>warn_cyclic_dependency == true</code>.</p></li><li><p><code>circular_dependency_max_cycles</code>: Maximum number of cycles to check for. Only applicable if <code>warn_cyclic_dependency == true</code>.</p></li><li><p><code>substitution_limit</code>: The number times to substitute initial conditions into each other to attempt to arrive at a numeric value.</p></li><li><p><code>callback</code>: An extra callback or <code>CallbackSet</code> to add to the problem, in addition to the ones defined symbolically in the system.</p></li><li><p><code>check_compatibility</code>: Whether to check if the given system <code>sys</code> contains all the information necessary to create a <code>SciMLBase.SDEProblem</code> and no more. If disabled, assumes that <code>sys</code> at least contains the necessary information.</p></li><li><p><code>expression</code>: <code>Val{true}</code> to return an <code>Expr</code> that constructs the corresponding problem instead of the problem itself. <code>Val{false}</code> otherwise.  Constructing the expression does not support callbacks</p></li></ul><p>All other keyword arguments are forwarded to the SciMLBase.SDEFunction constructor.</p><p><strong>Extended docs</strong></p><p>The following API is internal and may change or be removed without notice. Its usage is highly discouraged.</p><ul><li><code>build_initializeprob</code>: If <code>false</code>, avoids building the initialization problem.</li><li><code>check_length</code>: Whether to check the number of equations along with number of unknowns and length of <code>u0</code> vector for consistency. If <code>false</code>, do not check with equations. This is forwarded to <code>check_eqs_u0</code>.</li><li><code>time_dependent_init</code>: Whether to build a time-dependent initialization for the problem. A time-dependent initialization solves for a consistent <code>u0</code>, whereas a time-independent one only runs parameter initialization.</li><li><code>algebraic_only</code>: Whether to build the initialization problem using only algebraic equations.</li><li><code>allow_incomplete</code>: Whether to allow incomplete initialization problems.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/0af5a3d86d4fccdeca0acdc62f5fcecfe0faaf9e/src/problems/docs.jl#L206-L295">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SciMLBase.DDEFunction" href="#SciMLBase.DDEFunction"><code>SciMLBase.DDEFunction</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SciMLBase.DDEFunction(sys::System; kwargs...)
SciMLBase.DDEFunction{iip}(sys::System; kwargs...)
SciMLBase.DDEFunction{iip, specialize}(sys::System; kwargs...)</code></pre><p>Create a <code>SciMLBase.DDEFunction</code> from the given <code>sys</code>. <code>iip</code> is a boolean indicating whether the function should be in-place. <code>specialization</code> is a <code>SciMLBase.AbstractSpecalize</code> subtype indicating the level of specialization of the SciMLBase.DDEFunction.</p><p><strong>Keyword arguments</strong></p><ul><li><p><code>u0</code>: The <code>u0</code> vector for the corresponding problem, if available. Can be obtained using <a href="#ModelingToolkit.get_u0"><code>ModelingToolkit.get_u0</code></a>.</p></li><li><p><code>p</code>: The parameter object for the corresponding problem, if available. Can be obtained using <a href="#ModelingToolkit.get_p"><code>ModelingToolkit.get_p</code></a>.</p></li><li><p><code>t</code>: The initial time for the corresponding problem, if available.</p></li><li><p><code>eval_expression</code>: Whether to compile any functions via <code>eval</code> or <code>RuntimeGeneratedFunctions</code>.</p></li><li><p><code>eval_module</code>: If <code>eval_expression == true</code>, the module to <code>eval</code> into. Otherwise, the module in which to generate the <code>RuntimeGeneratedFunction</code>.</p></li><li><p><code>checkbounds</code>: Whether to enable bounds checking in the generated code.</p></li><li><p><code>simplify</code>: Whether to <code>simplify</code> any symbolically computed jacobians/hessians/etc.</p></li><li><p><code>cse</code>: Whether to enable Common Subexpression Elimination (CSE) on the generated code. This typically improves performance of the generated code but reduces readability.</p></li><li><p><code>sparse</code>: Whether to generate jacobian/hessian/etc. functions that return/operate on sparse matrices. Also controls whether the mass matrix is sparse, wherever applicable.</p></li><li><p><code>check_compatibility</code>: Whether to check if the given system <code>sys</code> contains all the information necessary to create a <code>SciMLBase.DDEFunction</code> and no more. If disabled, assumes that <code>sys</code> at least contains the necessary information.</p></li><li><p><code>expression</code>: <code>Val{true}</code> to return an <code>Expr</code> that constructs the corresponding problem instead of the problem itself. <code>Val{false}</code> otherwise.  Constructing the expression does not support callbacks</p></li></ul><p>All other keyword arguments are forwarded to the <code>SciMLBase.DDEFunction</code> struct constructor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/0af5a3d86d4fccdeca0acdc62f5fcecfe0faaf9e/src/problems/docs.jl#L340-L378">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SciMLBase.DDEProblem" href="#SciMLBase.DDEProblem"><code>SciMLBase.DDEProblem</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SciMLBase.SciMLBase.DDEProblem(sys::System, op, tspan::NTuple{2}; kwargs...)
SciMLBase.SciMLBase.DDEProblem{iip}(sys::System, op, tspan::NTuple{2}; kwargs...)
SciMLBase.SciMLBase.DDEProblem{iip, specialize}(sys::System, op, tspan::NTuple{2}; kwargs...)</code></pre><p>Build a <code>SciMLBase.DDEProblem</code> given a system <code>sys</code> and operating point <code>op</code>  and timespan <code>tspan</code>. <code>iip</code> is a boolean indicating whether the problem should be in-place. <code>specialization</code> is a <code>SciMLBase.AbstractSpecalize</code> subtype indicating the level of specialization of the SciMLBase.DDEFunction. The operating point should be an iterable collection of key-value pairs mapping variables/parameters in the system to the (initial) values they should take in <code>SciMLBase.DDEProblem</code>. Any values not provided will fallback to the corresponding default (if present).</p><p>ModelingToolkit will build an initialization problem where all initial values for unknowns or observables of <code>sys</code> (either explicitly provided or in defaults) will be constraints. To remove an initial condition in the defaults (without providing a replacement) give the corresponding variable a value of <code>nothing</code> in the operating point. The initialization problem will also run parameter initialization. See the <a href="../../tutorials/initialization/#initialization">Initialization</a> documentation for more information.</p><p><strong>Keyword arguments</strong></p><ul><li><p><code>eval_expression</code>: Whether to compile any functions via <code>eval</code> or <code>RuntimeGeneratedFunctions</code>.</p></li><li><p><code>eval_module</code>: If <code>eval_expression == true</code>, the module to <code>eval</code> into. Otherwise, the module in which to generate the <code>RuntimeGeneratedFunction</code>.</p></li><li><p><code>guesses</code>: The guesses for variables in the system, used as initial values for the initialization problem.</p></li><li><p><code>warn_initialize_determined</code>: Warn if the initialization system is under/over-determined.</p></li><li><p><code>initialization_eqs</code>: Extra equations to use in the initialization problem.</p></li><li><p><code>fully_determined</code>: Override whether the initialization system is fully determined.</p></li><li><p><code>use_scc</code>: Whether to use <code>SCCNonlinearProblem</code> for initialization if the system is fully determined.</p></li><li><p><code>check_initialization_units</code>: Enable or disable unit checks when constructing the initialization problem.</p></li><li><p><code>tofloat</code>: Passed to <a href="#ModelingToolkit.varmap_to_vars"><code>varmap_to_vars</code></a> when building the parameter vector of a non-split system.</p></li><li><p><code>u0_eltype</code>: The <code>eltype</code> of the <code>u0</code> vector. If <code>nothing</code>, finds the promoted floating point type from <code>op</code>.</p></li><li><p><code>u0_constructor</code>: A function to apply to the <code>u0</code> value returned from <a href="#ModelingToolkit.varmap_to_vars"><code>varmap_to_vars</code></a>. to construct the final <code>u0</code> value.</p></li><li><p><code>p_constructor</code>: A function to apply to each array buffer created when constructing the parameter object.</p></li><li><p><code>warn_cyclic_dependency</code>: Whether to emit a warning listing out cycles in initial conditions provided for unknowns and parameters.</p></li><li><p><code>circular_dependency_max_cycle_length</code>: Maximum length of cycle to check for. Only applicable if <code>warn_cyclic_dependency == true</code>.</p></li><li><p><code>circular_dependency_max_cycles</code>: Maximum number of cycles to check for. Only applicable if <code>warn_cyclic_dependency == true</code>.</p></li><li><p><code>substitution_limit</code>: The number times to substitute initial conditions into each other to attempt to arrive at a numeric value.</p></li><li><p><code>callback</code>: An extra callback or <code>CallbackSet</code> to add to the problem, in addition to the ones defined symbolically in the system.</p></li><li><p><code>check_compatibility</code>: Whether to check if the given system <code>sys</code> contains all the information necessary to create a <code>SciMLBase.DDEProblem</code> and no more. If disabled, assumes that <code>sys</code> at least contains the necessary information.</p></li><li><p><code>expression</code>: <code>Val{true}</code> to return an <code>Expr</code> that constructs the corresponding problem instead of the problem itself. <code>Val{false}</code> otherwise.  Constructing the expression does not support callbacks</p></li></ul><p>All other keyword arguments are forwarded to the SciMLBase.DDEFunction constructor.</p><p><strong>Extended docs</strong></p><p>The following API is internal and may change or be removed without notice. Its usage is highly discouraged.</p><ul><li><code>build_initializeprob</code>: If <code>false</code>, avoids building the initialization problem.</li><li><code>check_length</code>: Whether to check the number of equations along with number of unknowns and length of <code>u0</code> vector for consistency. If <code>false</code>, do not check with equations. This is forwarded to <code>check_eqs_u0</code>.</li><li><code>time_dependent_init</code>: Whether to build a time-dependent initialization for the problem. A time-dependent initialization solves for a consistent <code>u0</code>, whereas a time-independent one only runs parameter initialization.</li><li><code>algebraic_only</code>: Whether to build the initialization problem using only algebraic equations.</li><li><code>allow_incomplete</code>: Whether to allow incomplete initialization problems.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/0af5a3d86d4fccdeca0acdc62f5fcecfe0faaf9e/src/problems/docs.jl#L206-L295">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SciMLBase.SDDEFunction" href="#SciMLBase.SDDEFunction"><code>SciMLBase.SDDEFunction</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SciMLBase.SDDEFunction(sys::System; kwargs...)
SciMLBase.SDDEFunction{iip}(sys::System; kwargs...)
SciMLBase.SDDEFunction{iip, specialize}(sys::System; kwargs...)</code></pre><p>Create a <code>SciMLBase.SDDEFunction</code> from the given <code>sys</code>. <code>iip</code> is a boolean indicating whether the function should be in-place. <code>specialization</code> is a <code>SciMLBase.AbstractSpecalize</code> subtype indicating the level of specialization of the SciMLBase.SDDEFunction.</p><p><strong>Keyword arguments</strong></p><ul><li><p><code>u0</code>: The <code>u0</code> vector for the corresponding problem, if available. Can be obtained using <a href="#ModelingToolkit.get_u0"><code>ModelingToolkit.get_u0</code></a>.</p></li><li><p><code>p</code>: The parameter object for the corresponding problem, if available. Can be obtained using <a href="#ModelingToolkit.get_p"><code>ModelingToolkit.get_p</code></a>.</p></li><li><p><code>t</code>: The initial time for the corresponding problem, if available.</p></li><li><p><code>eval_expression</code>: Whether to compile any functions via <code>eval</code> or <code>RuntimeGeneratedFunctions</code>.</p></li><li><p><code>eval_module</code>: If <code>eval_expression == true</code>, the module to <code>eval</code> into. Otherwise, the module in which to generate the <code>RuntimeGeneratedFunction</code>.</p></li><li><p><code>checkbounds</code>: Whether to enable bounds checking in the generated code.</p></li><li><p><code>simplify</code>: Whether to <code>simplify</code> any symbolically computed jacobians/hessians/etc.</p></li><li><p><code>cse</code>: Whether to enable Common Subexpression Elimination (CSE) on the generated code. This typically improves performance of the generated code but reduces readability.</p></li><li><p><code>sparse</code>: Whether to generate jacobian/hessian/etc. functions that return/operate on sparse matrices. Also controls whether the mass matrix is sparse, wherever applicable.</p></li><li><p><code>check_compatibility</code>: Whether to check if the given system <code>sys</code> contains all the information necessary to create a <code>SciMLBase.SDDEFunction</code> and no more. If disabled, assumes that <code>sys</code> at least contains the necessary information.</p></li><li><p><code>expression</code>: <code>Val{true}</code> to return an <code>Expr</code> that constructs the corresponding problem instead of the problem itself. <code>Val{false}</code> otherwise.  Constructing the expression does not support callbacks</p></li></ul><p>All other keyword arguments are forwarded to the <code>SciMLBase.SDDEFunction</code> struct constructor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/0af5a3d86d4fccdeca0acdc62f5fcecfe0faaf9e/src/problems/docs.jl#L340-L378">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SciMLBase.SDDEProblem" href="#SciMLBase.SDDEProblem"><code>SciMLBase.SDDEProblem</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SciMLBase.SciMLBase.SDDEProblem(sys::System, op, tspan::NTuple{2}; kwargs...)
SciMLBase.SciMLBase.SDDEProblem{iip}(sys::System, op, tspan::NTuple{2}; kwargs...)
SciMLBase.SciMLBase.SDDEProblem{iip, specialize}(sys::System, op, tspan::NTuple{2}; kwargs...)</code></pre><p>Build a <code>SciMLBase.SDDEProblem</code> given a system <code>sys</code> and operating point <code>op</code>  and timespan <code>tspan</code>. <code>iip</code> is a boolean indicating whether the problem should be in-place. <code>specialization</code> is a <code>SciMLBase.AbstractSpecalize</code> subtype indicating the level of specialization of the SciMLBase.SDDEFunction. The operating point should be an iterable collection of key-value pairs mapping variables/parameters in the system to the (initial) values they should take in <code>SciMLBase.SDDEProblem</code>. Any values not provided will fallback to the corresponding default (if present).</p><p>ModelingToolkit will build an initialization problem where all initial values for unknowns or observables of <code>sys</code> (either explicitly provided or in defaults) will be constraints. To remove an initial condition in the defaults (without providing a replacement) give the corresponding variable a value of <code>nothing</code> in the operating point. The initialization problem will also run parameter initialization. See the <a href="../../tutorials/initialization/#initialization">Initialization</a> documentation for more information.</p><p><strong>Keyword arguments</strong></p><ul><li><p><code>eval_expression</code>: Whether to compile any functions via <code>eval</code> or <code>RuntimeGeneratedFunctions</code>.</p></li><li><p><code>eval_module</code>: If <code>eval_expression == true</code>, the module to <code>eval</code> into. Otherwise, the module in which to generate the <code>RuntimeGeneratedFunction</code>.</p></li><li><p><code>guesses</code>: The guesses for variables in the system, used as initial values for the initialization problem.</p></li><li><p><code>warn_initialize_determined</code>: Warn if the initialization system is under/over-determined.</p></li><li><p><code>initialization_eqs</code>: Extra equations to use in the initialization problem.</p></li><li><p><code>fully_determined</code>: Override whether the initialization system is fully determined.</p></li><li><p><code>use_scc</code>: Whether to use <code>SCCNonlinearProblem</code> for initialization if the system is fully determined.</p></li><li><p><code>check_initialization_units</code>: Enable or disable unit checks when constructing the initialization problem.</p></li><li><p><code>tofloat</code>: Passed to <a href="#ModelingToolkit.varmap_to_vars"><code>varmap_to_vars</code></a> when building the parameter vector of a non-split system.</p></li><li><p><code>u0_eltype</code>: The <code>eltype</code> of the <code>u0</code> vector. If <code>nothing</code>, finds the promoted floating point type from <code>op</code>.</p></li><li><p><code>u0_constructor</code>: A function to apply to the <code>u0</code> value returned from <a href="#ModelingToolkit.varmap_to_vars"><code>varmap_to_vars</code></a>. to construct the final <code>u0</code> value.</p></li><li><p><code>p_constructor</code>: A function to apply to each array buffer created when constructing the parameter object.</p></li><li><p><code>warn_cyclic_dependency</code>: Whether to emit a warning listing out cycles in initial conditions provided for unknowns and parameters.</p></li><li><p><code>circular_dependency_max_cycle_length</code>: Maximum length of cycle to check for. Only applicable if <code>warn_cyclic_dependency == true</code>.</p></li><li><p><code>circular_dependency_max_cycles</code>: Maximum number of cycles to check for. Only applicable if <code>warn_cyclic_dependency == true</code>.</p></li><li><p><code>substitution_limit</code>: The number times to substitute initial conditions into each other to attempt to arrive at a numeric value.</p></li><li><p><code>callback</code>: An extra callback or <code>CallbackSet</code> to add to the problem, in addition to the ones defined symbolically in the system.</p></li><li><p><code>check_compatibility</code>: Whether to check if the given system <code>sys</code> contains all the information necessary to create a <code>SciMLBase.SDDEProblem</code> and no more. If disabled, assumes that <code>sys</code> at least contains the necessary information.</p></li><li><p><code>expression</code>: <code>Val{true}</code> to return an <code>Expr</code> that constructs the corresponding problem instead of the problem itself. <code>Val{false}</code> otherwise.  Constructing the expression does not support callbacks</p></li></ul><p>All other keyword arguments are forwarded to the SciMLBase.SDDEFunction constructor.</p><p><strong>Extended docs</strong></p><p>The following API is internal and may change or be removed without notice. Its usage is highly discouraged.</p><ul><li><code>build_initializeprob</code>: If <code>false</code>, avoids building the initialization problem.</li><li><code>check_length</code>: Whether to check the number of equations along with number of unknowns and length of <code>u0</code> vector for consistency. If <code>false</code>, do not check with equations. This is forwarded to <code>check_eqs_u0</code>.</li><li><code>time_dependent_init</code>: Whether to build a time-dependent initialization for the problem. A time-dependent initialization solves for a consistent <code>u0</code>, whereas a time-independent one only runs parameter initialization.</li><li><code>algebraic_only</code>: Whether to build the initialization problem using only algebraic equations.</li><li><code>allow_incomplete</code>: Whether to allow incomplete initialization problems.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/0af5a3d86d4fccdeca0acdc62f5fcecfe0faaf9e/src/problems/docs.jl#L206-L295">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JumpProcesses.JumpProblem" href="#JumpProcesses.JumpProblem"><code>JumpProcesses.JumpProblem</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SciMLBase.JumpProcesses.JumpProblem(sys::System, op, tspan::NTuple{2}; kwargs...)
SciMLBase.JumpProcesses.JumpProblem{iip}(sys::System, op, tspan::NTuple{2}; kwargs...)
SciMLBase.JumpProcesses.JumpProblem{iip, specialize}(sys::System, op, tspan::NTuple{2}; kwargs...)</code></pre><p>Build a <code>JumpProcesses.JumpProblem</code> given a system <code>sys</code> and operating point <code>op</code>  and timespan <code>tspan</code>. <code>iip</code> is a boolean indicating whether the problem should be in-place. <code>specialization</code> is a <code>SciMLBase.AbstractSpecalize</code> subtype indicating the level of specialization of the inner SciMLFunction. The operating point should be an iterable collection of key-value pairs mapping variables/parameters in the system to the (initial) values they should take in <code>JumpProcesses.JumpProblem</code>. Any values not provided will fallback to the corresponding default (if present).</p><p>ModelingToolkit will build an initialization problem where all initial values for unknowns or observables of <code>sys</code> (either explicitly provided or in defaults) will be constraints. To remove an initial condition in the defaults (without providing a replacement) give the corresponding variable a value of <code>nothing</code> in the operating point. The initialization problem will also run parameter initialization. See the <a href="../../tutorials/initialization/#initialization">Initialization</a> documentation for more information.</p><p><strong>Keyword arguments</strong></p><ul><li><p><code>eval_expression</code>: Whether to compile any functions via <code>eval</code> or <code>RuntimeGeneratedFunctions</code>.</p></li><li><p><code>eval_module</code>: If <code>eval_expression == true</code>, the module to <code>eval</code> into. Otherwise, the module in which to generate the <code>RuntimeGeneratedFunction</code>.</p></li><li><p><code>guesses</code>: The guesses for variables in the system, used as initial values for the initialization problem.</p></li><li><p><code>warn_initialize_determined</code>: Warn if the initialization system is under/over-determined.</p></li><li><p><code>initialization_eqs</code>: Extra equations to use in the initialization problem.</p></li><li><p><code>fully_determined</code>: Override whether the initialization system is fully determined.</p></li><li><p><code>use_scc</code>: Whether to use <code>SCCNonlinearProblem</code> for initialization if the system is fully determined.</p></li><li><p><code>check_initialization_units</code>: Enable or disable unit checks when constructing the initialization problem.</p></li><li><p><code>tofloat</code>: Passed to <a href="#ModelingToolkit.varmap_to_vars"><code>varmap_to_vars</code></a> when building the parameter vector of a non-split system.</p></li><li><p><code>u0_eltype</code>: The <code>eltype</code> of the <code>u0</code> vector. If <code>nothing</code>, finds the promoted floating point type from <code>op</code>.</p></li><li><p><code>u0_constructor</code>: A function to apply to the <code>u0</code> value returned from <a href="#ModelingToolkit.varmap_to_vars"><code>varmap_to_vars</code></a>. to construct the final <code>u0</code> value.</p></li><li><p><code>p_constructor</code>: A function to apply to each array buffer created when constructing the parameter object.</p></li><li><p><code>warn_cyclic_dependency</code>: Whether to emit a warning listing out cycles in initial conditions provided for unknowns and parameters.</p></li><li><p><code>circular_dependency_max_cycle_length</code>: Maximum length of cycle to check for. Only applicable if <code>warn_cyclic_dependency == true</code>.</p></li><li><p><code>circular_dependency_max_cycles</code>: Maximum number of cycles to check for. Only applicable if <code>warn_cyclic_dependency == true</code>.</p></li><li><p><code>substitution_limit</code>: The number times to substitute initial conditions into each other to attempt to arrive at a numeric value.</p></li><li><p><code>callback</code>: An extra callback or <code>CallbackSet</code> to add to the problem, in addition to the ones defined symbolically in the system.</p></li><li><p><code>check_compatibility</code>: Whether to check if the given system <code>sys</code> contains all the information necessary to create a <code>JumpProcesses.JumpProblem</code> and no more. If disabled, assumes that <code>sys</code> at least contains the necessary information.</p></li><li><p><code>expression</code>: <code>Val{true}</code> to return an <code>Expr</code> that constructs the corresponding problem instead of the problem itself. <code>Val{false}</code> otherwise.  Constructing the expression does not support callbacks</p></li></ul><p>All other keyword arguments are forwarded to the inner SciMLFunction constructor.</p><p><strong>Extended docs</strong></p><p>The following API is internal and may change or be removed without notice. Its usage is highly discouraged.</p><ul><li><code>build_initializeprob</code>: If <code>false</code>, avoids building the initialization problem.</li><li><code>check_length</code>: Whether to check the number of equations along with number of unknowns and length of <code>u0</code> vector for consistency. If <code>false</code>, do not check with equations. This is forwarded to <code>check_eqs_u0</code>.</li><li><code>time_dependent_init</code>: Whether to build a time-dependent initialization for the problem. A time-dependent initialization solves for a consistent <code>u0</code>, whereas a time-independent one only runs parameter initialization.</li><li><code>algebraic_only</code>: Whether to build the initialization problem using only algebraic equations.</li><li><code>allow_incomplete</code>: Whether to allow incomplete initialization problems.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/0af5a3d86d4fccdeca0acdc62f5fcecfe0faaf9e/src/problems/docs.jl#L206-L295">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SciMLBase.BVProblem" href="#SciMLBase.BVProblem"><code>SciMLBase.BVProblem</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SciMLBase.SciMLBase.BVProblem(sys::System, op, tspan::NTuple{2}; kwargs...)
SciMLBase.SciMLBase.BVProblem{iip}(sys::System, op, tspan::NTuple{2}; kwargs...)
SciMLBase.SciMLBase.BVProblem{iip, specialize}(sys::System, op, tspan::NTuple{2}; kwargs...)</code></pre><p>Build a <code>SciMLBase.BVProblem</code> given a system <code>sys</code> and operating point <code>op</code>  and timespan <code>tspan</code>. <code>iip</code> is a boolean indicating whether the problem should be in-place. <code>specialization</code> is a <code>SciMLBase.AbstractSpecalize</code> subtype indicating the level of specialization of the SciMLBase.ODEFunction. The operating point should be an iterable collection of key-value pairs mapping variables/parameters in the system to the (initial) values they should take in <code>SciMLBase.BVProblem</code>. Any values not provided will fallback to the corresponding default (if present).</p><p>ModelingToolkit will build an initialization problem where all initial values for unknowns or observables of <code>sys</code> (either explicitly provided or in defaults) will be constraints. To remove an initial condition in the defaults (without providing a replacement) give the corresponding variable a value of <code>nothing</code> in the operating point. The initialization problem will also run parameter initialization. See the <a href="../../tutorials/initialization/#initialization">Initialization</a> documentation for more information.</p><p><strong>Keyword arguments</strong></p><ul><li><p><code>eval_expression</code>: Whether to compile any functions via <code>eval</code> or <code>RuntimeGeneratedFunctions</code>.</p></li><li><p><code>eval_module</code>: If <code>eval_expression == true</code>, the module to <code>eval</code> into. Otherwise, the module in which to generate the <code>RuntimeGeneratedFunction</code>.</p></li><li><p><code>guesses</code>: The guesses for variables in the system, used as initial values for the initialization problem.</p></li><li><p><code>warn_initialize_determined</code>: Warn if the initialization system is under/over-determined.</p></li><li><p><code>initialization_eqs</code>: Extra equations to use in the initialization problem.</p></li><li><p><code>fully_determined</code>: Override whether the initialization system is fully determined.</p></li><li><p><code>use_scc</code>: Whether to use <code>SCCNonlinearProblem</code> for initialization if the system is fully determined.</p></li><li><p><code>check_initialization_units</code>: Enable or disable unit checks when constructing the initialization problem.</p></li><li><p><code>tofloat</code>: Passed to <a href="#ModelingToolkit.varmap_to_vars"><code>varmap_to_vars</code></a> when building the parameter vector of a non-split system.</p></li><li><p><code>u0_eltype</code>: The <code>eltype</code> of the <code>u0</code> vector. If <code>nothing</code>, finds the promoted floating point type from <code>op</code>.</p></li><li><p><code>u0_constructor</code>: A function to apply to the <code>u0</code> value returned from <a href="#ModelingToolkit.varmap_to_vars"><code>varmap_to_vars</code></a>. to construct the final <code>u0</code> value.</p></li><li><p><code>p_constructor</code>: A function to apply to each array buffer created when constructing the parameter object.</p></li><li><p><code>warn_cyclic_dependency</code>: Whether to emit a warning listing out cycles in initial conditions provided for unknowns and parameters.</p></li><li><p><code>circular_dependency_max_cycle_length</code>: Maximum length of cycle to check for. Only applicable if <code>warn_cyclic_dependency == true</code>.</p></li><li><p><code>circular_dependency_max_cycles</code>: Maximum number of cycles to check for. Only applicable if <code>warn_cyclic_dependency == true</code>.</p></li><li><p><code>substitution_limit</code>: The number times to substitute initial conditions into each other to attempt to arrive at a numeric value.</p></li><li><p><code>callback</code>: An extra callback or <code>CallbackSet</code> to add to the problem, in addition to the ones defined symbolically in the system.</p></li><li><p><code>check_compatibility</code>: Whether to check if the given system <code>sys</code> contains all the information necessary to create a <code>SciMLBase.BVProblem</code> and no more. If disabled, assumes that <code>sys</code> at least contains the necessary information.</p></li><li><p><code>expression</code>: <code>Val{true}</code> to return an <code>Expr</code> that constructs the corresponding problem instead of the problem itself. <code>Val{false}</code> otherwise.  Constructing the expression does not support callbacks</p></li></ul><p>All other keyword arguments are forwarded to the SciMLBase.ODEFunction constructor.</p><p><strong>Extended docs</strong></p><p>The following API is internal and may change or be removed without notice. Its usage is highly discouraged.</p><ul><li><code>build_initializeprob</code>: If <code>false</code>, avoids building the initialization problem.</li><li><code>check_length</code>: Whether to check the number of equations along with number of unknowns and length of <code>u0</code> vector for consistency. If <code>false</code>, do not check with equations. This is forwarded to <code>check_eqs_u0</code>.</li><li><code>time_dependent_init</code>: Whether to build a time-dependent initialization for the problem. A time-dependent initialization solves for a consistent <code>u0</code>, whereas a time-independent one only runs parameter initialization.</li><li><code>algebraic_only</code>: Whether to build the initialization problem using only algebraic equations.</li><li><code>allow_incomplete</code>: Whether to allow incomplete initialization problems.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/0af5a3d86d4fccdeca0acdc62f5fcecfe0faaf9e/src/problems/docs.jl#L206-L295">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SciMLBase.DiscreteProblem" href="#SciMLBase.DiscreteProblem"><code>SciMLBase.DiscreteProblem</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SciMLBase.SciMLBase.DiscreteProblem(sys::System, op, tspan::NTuple{2}; kwargs...)
SciMLBase.SciMLBase.DiscreteProblem{iip}(sys::System, op, tspan::NTuple{2}; kwargs...)
SciMLBase.SciMLBase.DiscreteProblem{iip, specialize}(sys::System, op, tspan::NTuple{2}; kwargs...)</code></pre><p>Build a <code>SciMLBase.DiscreteProblem</code> given a system <code>sys</code> and operating point <code>op</code>  and timespan <code>tspan</code>. <code>iip</code> is a boolean indicating whether the problem should be in-place. <code>specialization</code> is a <code>SciMLBase.AbstractSpecalize</code> subtype indicating the level of specialization of the SciMLBase.DiscreteFunction. The operating point should be an iterable collection of key-value pairs mapping variables/parameters in the system to the (initial) values they should take in <code>SciMLBase.DiscreteProblem</code>. Any values not provided will fallback to the corresponding default (if present).</p><p>ModelingToolkit will build an initialization problem where all initial values for unknowns or observables of <code>sys</code> (either explicitly provided or in defaults) will be constraints. To remove an initial condition in the defaults (without providing a replacement) give the corresponding variable a value of <code>nothing</code> in the operating point. The initialization problem will also run parameter initialization. See the <a href="../../tutorials/initialization/#initialization">Initialization</a> documentation for more information.</p><p><strong>Keyword arguments</strong></p><ul><li><p><code>eval_expression</code>: Whether to compile any functions via <code>eval</code> or <code>RuntimeGeneratedFunctions</code>.</p></li><li><p><code>eval_module</code>: If <code>eval_expression == true</code>, the module to <code>eval</code> into. Otherwise, the module in which to generate the <code>RuntimeGeneratedFunction</code>.</p></li><li><p><code>guesses</code>: The guesses for variables in the system, used as initial values for the initialization problem.</p></li><li><p><code>warn_initialize_determined</code>: Warn if the initialization system is under/over-determined.</p></li><li><p><code>initialization_eqs</code>: Extra equations to use in the initialization problem.</p></li><li><p><code>fully_determined</code>: Override whether the initialization system is fully determined.</p></li><li><p><code>use_scc</code>: Whether to use <code>SCCNonlinearProblem</code> for initialization if the system is fully determined.</p></li><li><p><code>check_initialization_units</code>: Enable or disable unit checks when constructing the initialization problem.</p></li><li><p><code>tofloat</code>: Passed to <a href="#ModelingToolkit.varmap_to_vars"><code>varmap_to_vars</code></a> when building the parameter vector of a non-split system.</p></li><li><p><code>u0_eltype</code>: The <code>eltype</code> of the <code>u0</code> vector. If <code>nothing</code>, finds the promoted floating point type from <code>op</code>.</p></li><li><p><code>u0_constructor</code>: A function to apply to the <code>u0</code> value returned from <a href="#ModelingToolkit.varmap_to_vars"><code>varmap_to_vars</code></a>. to construct the final <code>u0</code> value.</p></li><li><p><code>p_constructor</code>: A function to apply to each array buffer created when constructing the parameter object.</p></li><li><p><code>warn_cyclic_dependency</code>: Whether to emit a warning listing out cycles in initial conditions provided for unknowns and parameters.</p></li><li><p><code>circular_dependency_max_cycle_length</code>: Maximum length of cycle to check for. Only applicable if <code>warn_cyclic_dependency == true</code>.</p></li><li><p><code>circular_dependency_max_cycles</code>: Maximum number of cycles to check for. Only applicable if <code>warn_cyclic_dependency == true</code>.</p></li><li><p><code>substitution_limit</code>: The number times to substitute initial conditions into each other to attempt to arrive at a numeric value.</p></li><li><p><code>callback</code>: An extra callback or <code>CallbackSet</code> to add to the problem, in addition to the ones defined symbolically in the system.</p></li><li><p><code>check_compatibility</code>: Whether to check if the given system <code>sys</code> contains all the information necessary to create a <code>SciMLBase.DiscreteProblem</code> and no more. If disabled, assumes that <code>sys</code> at least contains the necessary information.</p></li><li><p><code>expression</code>: <code>Val{true}</code> to return an <code>Expr</code> that constructs the corresponding problem instead of the problem itself. <code>Val{false}</code> otherwise.  Constructing the expression does not support callbacks</p></li></ul><p>All other keyword arguments are forwarded to the SciMLBase.DiscreteFunction constructor.</p><p><strong>Extended docs</strong></p><p>The following API is internal and may change or be removed without notice. Its usage is highly discouraged.</p><ul><li><code>build_initializeprob</code>: If <code>false</code>, avoids building the initialization problem.</li><li><code>check_length</code>: Whether to check the number of equations along with number of unknowns and length of <code>u0</code> vector for consistency. If <code>false</code>, do not check with equations. This is forwarded to <code>check_eqs_u0</code>.</li><li><code>time_dependent_init</code>: Whether to build a time-dependent initialization for the problem. A time-dependent initialization solves for a consistent <code>u0</code>, whereas a time-independent one only runs parameter initialization.</li><li><code>algebraic_only</code>: Whether to build the initialization problem using only algebraic equations.</li><li><code>allow_incomplete</code>: Whether to allow incomplete initialization problems.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/0af5a3d86d4fccdeca0acdc62f5fcecfe0faaf9e/src/problems/docs.jl#L206-L295">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SciMLBase.ImplicitDiscreteProblem" href="#SciMLBase.ImplicitDiscreteProblem"><code>SciMLBase.ImplicitDiscreteProblem</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SciMLBase.SciMLBase.ImplicitDiscreteProblem(sys::System, op, tspan::NTuple{2}; kwargs...)
SciMLBase.SciMLBase.ImplicitDiscreteProblem{iip}(sys::System, op, tspan::NTuple{2}; kwargs...)
SciMLBase.SciMLBase.ImplicitDiscreteProblem{iip, specialize}(sys::System, op, tspan::NTuple{2}; kwargs...)</code></pre><p>Build a <code>SciMLBase.ImplicitDiscreteProblem</code> given a system <code>sys</code> and operating point <code>op</code>  and timespan <code>tspan</code>. <code>iip</code> is a boolean indicating whether the problem should be in-place. <code>specialization</code> is a <code>SciMLBase.AbstractSpecalize</code> subtype indicating the level of specialization of the SciMLBase.ImplicitDiscreteFunction. The operating point should be an iterable collection of key-value pairs mapping variables/parameters in the system to the (initial) values they should take in <code>SciMLBase.ImplicitDiscreteProblem</code>. Any values not provided will fallback to the corresponding default (if present).</p><p>ModelingToolkit will build an initialization problem where all initial values for unknowns or observables of <code>sys</code> (either explicitly provided or in defaults) will be constraints. To remove an initial condition in the defaults (without providing a replacement) give the corresponding variable a value of <code>nothing</code> in the operating point. The initialization problem will also run parameter initialization. See the <a href="../../tutorials/initialization/#initialization">Initialization</a> documentation for more information.</p><p><strong>Keyword arguments</strong></p><ul><li><p><code>eval_expression</code>: Whether to compile any functions via <code>eval</code> or <code>RuntimeGeneratedFunctions</code>.</p></li><li><p><code>eval_module</code>: If <code>eval_expression == true</code>, the module to <code>eval</code> into. Otherwise, the module in which to generate the <code>RuntimeGeneratedFunction</code>.</p></li><li><p><code>guesses</code>: The guesses for variables in the system, used as initial values for the initialization problem.</p></li><li><p><code>warn_initialize_determined</code>: Warn if the initialization system is under/over-determined.</p></li><li><p><code>initialization_eqs</code>: Extra equations to use in the initialization problem.</p></li><li><p><code>fully_determined</code>: Override whether the initialization system is fully determined.</p></li><li><p><code>use_scc</code>: Whether to use <code>SCCNonlinearProblem</code> for initialization if the system is fully determined.</p></li><li><p><code>check_initialization_units</code>: Enable or disable unit checks when constructing the initialization problem.</p></li><li><p><code>tofloat</code>: Passed to <a href="#ModelingToolkit.varmap_to_vars"><code>varmap_to_vars</code></a> when building the parameter vector of a non-split system.</p></li><li><p><code>u0_eltype</code>: The <code>eltype</code> of the <code>u0</code> vector. If <code>nothing</code>, finds the promoted floating point type from <code>op</code>.</p></li><li><p><code>u0_constructor</code>: A function to apply to the <code>u0</code> value returned from <a href="#ModelingToolkit.varmap_to_vars"><code>varmap_to_vars</code></a>. to construct the final <code>u0</code> value.</p></li><li><p><code>p_constructor</code>: A function to apply to each array buffer created when constructing the parameter object.</p></li><li><p><code>warn_cyclic_dependency</code>: Whether to emit a warning listing out cycles in initial conditions provided for unknowns and parameters.</p></li><li><p><code>circular_dependency_max_cycle_length</code>: Maximum length of cycle to check for. Only applicable if <code>warn_cyclic_dependency == true</code>.</p></li><li><p><code>circular_dependency_max_cycles</code>: Maximum number of cycles to check for. Only applicable if <code>warn_cyclic_dependency == true</code>.</p></li><li><p><code>substitution_limit</code>: The number times to substitute initial conditions into each other to attempt to arrive at a numeric value.</p></li><li><p><code>callback</code>: An extra callback or <code>CallbackSet</code> to add to the problem, in addition to the ones defined symbolically in the system.</p></li><li><p><code>check_compatibility</code>: Whether to check if the given system <code>sys</code> contains all the information necessary to create a <code>SciMLBase.ImplicitDiscreteProblem</code> and no more. If disabled, assumes that <code>sys</code> at least contains the necessary information.</p></li><li><p><code>expression</code>: <code>Val{true}</code> to return an <code>Expr</code> that constructs the corresponding problem instead of the problem itself. <code>Val{false}</code> otherwise.  Constructing the expression does not support callbacks</p></li></ul><p>All other keyword arguments are forwarded to the SciMLBase.ImplicitDiscreteFunction constructor.</p><p><strong>Extended docs</strong></p><p>The following API is internal and may change or be removed without notice. Its usage is highly discouraged.</p><ul><li><code>build_initializeprob</code>: If <code>false</code>, avoids building the initialization problem.</li><li><code>check_length</code>: Whether to check the number of equations along with number of unknowns and length of <code>u0</code> vector for consistency. If <code>false</code>, do not check with equations. This is forwarded to <code>check_eqs_u0</code>.</li><li><code>time_dependent_init</code>: Whether to build a time-dependent initialization for the problem. A time-dependent initialization solves for a consistent <code>u0</code>, whereas a time-independent one only runs parameter initialization.</li><li><code>algebraic_only</code>: Whether to build the initialization problem using only algebraic equations.</li><li><code>allow_incomplete</code>: Whether to allow incomplete initialization problems.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/0af5a3d86d4fccdeca0acdc62f5fcecfe0faaf9e/src/problems/docs.jl#L206-L295">source</a></section></article><h2 id="Linear-and-Nonlinear-systems"><a class="docs-heading-anchor" href="#Linear-and-Nonlinear-systems">Linear and Nonlinear systems</a><a id="Linear-and-Nonlinear-systems-1"></a><a class="docs-heading-anchor-permalink" href="#Linear-and-Nonlinear-systems" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SciMLBase.NonlinearFunction" href="#SciMLBase.NonlinearFunction"><code>SciMLBase.NonlinearFunction</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SciMLBase.NonlinearFunction(sys::System; kwargs...)
SciMLBase.NonlinearFunction{iip}(sys::System; kwargs...)
SciMLBase.NonlinearFunction{iip, specialize}(sys::System; kwargs...)</code></pre><p>Create a <code>SciMLBase.NonlinearFunction</code> from the given <code>sys</code>. <code>iip</code> is a boolean indicating whether the function should be in-place. <code>specialization</code> is a <code>SciMLBase.AbstractSpecalize</code> subtype indicating the level of specialization of the SciMLBase.NonlinearFunction.</p><p><strong>Keyword arguments</strong></p><ul><li><p><code>u0</code>: The <code>u0</code> vector for the corresponding problem, if available. Can be obtained using <a href="#ModelingToolkit.get_u0"><code>ModelingToolkit.get_u0</code></a>.</p></li><li><p><code>p</code>: The parameter object for the corresponding problem, if available. Can be obtained using <a href="#ModelingToolkit.get_p"><code>ModelingToolkit.get_p</code></a>.</p></li><li><p><code>eval_expression</code>: Whether to compile any functions via <code>eval</code> or <code>RuntimeGeneratedFunctions</code>.</p></li><li><p><code>eval_module</code>: If <code>eval_expression == true</code>, the module to <code>eval</code> into. Otherwise, the module in which to generate the <code>RuntimeGeneratedFunction</code>.</p></li><li><p><code>checkbounds</code>: Whether to enable bounds checking in the generated code.</p></li><li><p><code>simplify</code>: Whether to <code>simplify</code> any symbolically computed jacobians/hessians/etc.</p></li><li><p><code>cse</code>: Whether to enable Common Subexpression Elimination (CSE) on the generated code. This typically improves performance of the generated code but reduces readability.</p></li><li><p><code>sparse</code>: Whether to generate jacobian/hessian/etc. functions that return/operate on sparse matrices. Also controls whether the mass matrix is sparse, wherever applicable.</p></li><li><p><code>check_compatibility</code>: Whether to check if the given system <code>sys</code> contains all the information necessary to create a <code>SciMLBase.NonlinearFunction</code> and no more. If disabled, assumes that <code>sys</code> at least contains the necessary information.</p></li><li><p><code>expression</code>: <code>Val{true}</code> to return an <code>Expr</code> that constructs the corresponding problem instead of the problem itself. <code>Val{false}</code> otherwise.</p></li><li><p><code>resid_prototype</code>: The prototype of the residual function <code>f</code> for a problem involving a nonlinear solve where the residual and <code>u0</code> have different sizes.</p></li><li><p><code>jac</code>: Whether to symbolically compute and generate code for the jacobian function.</p></li><li><p><code>sparsity</code>: Whether to provide symbolically compute and provide sparsity patterns for the jacobian/hessian/etc.</p></li></ul><p>All other keyword arguments are forwarded to the <code>SciMLBase.NonlinearFunction</code> struct constructor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/0af5a3d86d4fccdeca0acdc62f5fcecfe0faaf9e/src/problems/docs.jl#L340-L384">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SciMLBase.NonlinearProblem" href="#SciMLBase.NonlinearProblem"><code>SciMLBase.NonlinearProblem</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SciMLBase.SciMLBase.NonlinearProblem(sys::System, op; kwargs...)
SciMLBase.SciMLBase.NonlinearProblem{iip}(sys::System, op; kwargs...)
SciMLBase.SciMLBase.NonlinearProblem{iip, specialize}(sys::System, op; kwargs...)</code></pre><p>Build a <code>SciMLBase.NonlinearProblem</code> given a system <code>sys</code> and operating point <code>op</code> . <code>iip</code> is a boolean indicating whether the problem should be in-place. <code>specialization</code> is a <code>SciMLBase.AbstractSpecalize</code> subtype indicating the level of specialization of the SciMLBase.NonlinearFunction. The operating point should be an iterable collection of key-value pairs mapping variables/parameters in the system to the (initial) values they should take in <code>SciMLBase.NonlinearProblem</code>. Any values not provided will fallback to the corresponding default (if present).</p><p>ModelingToolkit will build an initialization problem that will run parameter initialization. Since it does not solve for initial values of unknowns, observed equations will not be initialization constraints. If an initialization equation of the system must involve the initial value of an unknown <code>x</code>, it must be used as <code>Initial(x)</code> in the equation. For example, an equation to be used to solve for parameter <code>p</code> in terms of unknowns <code>x</code> and <code>y</code> must be provided as <code>Initial(x) + Initial(y) ~ p</code> instead of <code>x + y ~ p</code>. See the <a href="../../tutorials/initialization/#initialization">Initialization</a> documentation for more information.</p><p><strong>Keyword arguments</strong></p><ul><li><p><code>eval_expression</code>: Whether to compile any functions via <code>eval</code> or <code>RuntimeGeneratedFunctions</code>.</p></li><li><p><code>eval_module</code>: If <code>eval_expression == true</code>, the module to <code>eval</code> into. Otherwise, the module in which to generate the <code>RuntimeGeneratedFunction</code>.</p></li><li><p><code>guesses</code>: The guesses for variables in the system, used as initial values for the initialization problem.</p></li><li><p><code>warn_initialize_determined</code>: Warn if the initialization system is under/over-determined.</p></li><li><p><code>initialization_eqs</code>: Extra equations to use in the initialization problem.</p></li><li><p><code>fully_determined</code>: Override whether the initialization system is fully determined.</p></li><li><p><code>use_scc</code>: Whether to use <code>SCCNonlinearProblem</code> for initialization if the system is fully determined.</p></li><li><p><code>check_initialization_units</code>: Enable or disable unit checks when constructing the initialization problem.</p></li><li><p><code>tofloat</code>: Passed to <a href="#ModelingToolkit.varmap_to_vars"><code>varmap_to_vars</code></a> when building the parameter vector of a non-split system.</p></li><li><p><code>u0_eltype</code>: The <code>eltype</code> of the <code>u0</code> vector. If <code>nothing</code>, finds the promoted floating point type from <code>op</code>.</p></li><li><p><code>u0_constructor</code>: A function to apply to the <code>u0</code> value returned from <a href="#ModelingToolkit.varmap_to_vars"><code>varmap_to_vars</code></a>. to construct the final <code>u0</code> value.</p></li><li><p><code>p_constructor</code>: A function to apply to each array buffer created when constructing the parameter object.</p></li><li><p><code>warn_cyclic_dependency</code>: Whether to emit a warning listing out cycles in initial conditions provided for unknowns and parameters.</p></li><li><p><code>circular_dependency_max_cycle_length</code>: Maximum length of cycle to check for. Only applicable if <code>warn_cyclic_dependency == true</code>.</p></li><li><p><code>circular_dependency_max_cycles</code>: Maximum number of cycles to check for. Only applicable if <code>warn_cyclic_dependency == true</code>.</p></li><li><p><code>substitution_limit</code>: The number times to substitute initial conditions into each other to attempt to arrive at a numeric value.</p></li></ul><ul><li><code>check_compatibility</code>: Whether to check if the given system <code>sys</code> contains all the information necessary to create a <code>SciMLBase.NonlinearProblem</code> and no more. If disabled, assumes that <code>sys</code> at least contains the necessary information.</li><li><code>expression</code>: <code>Val{true}</code> to return an <code>Expr</code> that constructs the corresponding problem instead of the problem itself. <code>Val{false}</code> otherwise.</li></ul><p>All other keyword arguments are forwarded to the SciMLBase.NonlinearFunction constructor.</p><p><strong>Extended docs</strong></p><p>The following API is internal and may change or be removed without notice. Its usage is highly discouraged.</p><ul><li><code>build_initializeprob</code>: If <code>false</code>, avoids building the initialization problem.</li><li><code>check_length</code>: Whether to check the number of equations along with number of unknowns and length of <code>u0</code> vector for consistency. If <code>false</code>, do not check with equations. This is forwarded to <code>check_eqs_u0</code>.</li><li><code>time_dependent_init</code>: Whether to build a time-dependent initialization for the problem. A time-dependent initialization solves for a consistent <code>u0</code>, whereas a time-independent one only runs parameter initialization.</li><li><code>algebraic_only</code>: Whether to build the initialization problem using only algebraic equations.</li><li><code>allow_incomplete</code>: Whether to allow incomplete initialization problems.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/0af5a3d86d4fccdeca0acdc62f5fcecfe0faaf9e/src/problems/docs.jl#L206-L295">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SciMLBase.SCCNonlinearProblem" href="#SciMLBase.SCCNonlinearProblem"><code>SciMLBase.SCCNonlinearProblem</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SciMLBase.SciMLBase.SCCNonlinearProblem(sys::System, op; kwargs...)
SciMLBase.SciMLBase.SCCNonlinearProblem{iip}(sys::System, op; kwargs...)
SciMLBase.SciMLBase.SCCNonlinearProblem{iip, specialize}(sys::System, op; kwargs...)</code></pre><p>Build a <code>SciMLBase.SCCNonlinearProblem</code> given a system <code>sys</code> and operating point <code>op</code> . <code>iip</code> is a boolean indicating whether the problem should be in-place. <code>specialization</code> is a <code>SciMLBase.AbstractSpecalize</code> subtype indicating the level of specialization of the SciMLBase.NonlinearFunction. The operating point should be an iterable collection of key-value pairs mapping variables/parameters in the system to the (initial) values they should take in <code>SciMLBase.SCCNonlinearProblem</code>. Any values not provided will fallback to the corresponding default (if present).</p><p>ModelingToolkit will build an initialization problem that will run parameter initialization. Since it does not solve for initial values of unknowns, observed equations will not be initialization constraints. If an initialization equation of the system must involve the initial value of an unknown <code>x</code>, it must be used as <code>Initial(x)</code> in the equation. For example, an equation to be used to solve for parameter <code>p</code> in terms of unknowns <code>x</code> and <code>y</code> must be provided as <code>Initial(x) + Initial(y) ~ p</code> instead of <code>x + y ~ p</code>. See the <a href="../../tutorials/initialization/#initialization">Initialization</a> documentation for more information.</p><p><strong>Keyword arguments</strong></p><ul><li><p><code>eval_expression</code>: Whether to compile any functions via <code>eval</code> or <code>RuntimeGeneratedFunctions</code>.</p></li><li><p><code>eval_module</code>: If <code>eval_expression == true</code>, the module to <code>eval</code> into. Otherwise, the module in which to generate the <code>RuntimeGeneratedFunction</code>.</p></li><li><p><code>guesses</code>: The guesses for variables in the system, used as initial values for the initialization problem.</p></li><li><p><code>warn_initialize_determined</code>: Warn if the initialization system is under/over-determined.</p></li><li><p><code>initialization_eqs</code>: Extra equations to use in the initialization problem.</p></li><li><p><code>fully_determined</code>: Override whether the initialization system is fully determined.</p></li><li><p><code>use_scc</code>: Whether to use <code>SCCNonlinearProblem</code> for initialization if the system is fully determined.</p></li><li><p><code>check_initialization_units</code>: Enable or disable unit checks when constructing the initialization problem.</p></li><li><p><code>tofloat</code>: Passed to <a href="#ModelingToolkit.varmap_to_vars"><code>varmap_to_vars</code></a> when building the parameter vector of a non-split system.</p></li><li><p><code>u0_eltype</code>: The <code>eltype</code> of the <code>u0</code> vector. If <code>nothing</code>, finds the promoted floating point type from <code>op</code>.</p></li><li><p><code>u0_constructor</code>: A function to apply to the <code>u0</code> value returned from <a href="#ModelingToolkit.varmap_to_vars"><code>varmap_to_vars</code></a>. to construct the final <code>u0</code> value.</p></li><li><p><code>p_constructor</code>: A function to apply to each array buffer created when constructing the parameter object.</p></li><li><p><code>warn_cyclic_dependency</code>: Whether to emit a warning listing out cycles in initial conditions provided for unknowns and parameters.</p></li><li><p><code>circular_dependency_max_cycle_length</code>: Maximum length of cycle to check for. Only applicable if <code>warn_cyclic_dependency == true</code>.</p></li><li><p><code>circular_dependency_max_cycles</code>: Maximum number of cycles to check for. Only applicable if <code>warn_cyclic_dependency == true</code>.</p></li><li><p><code>substitution_limit</code>: The number times to substitute initial conditions into each other to attempt to arrive at a numeric value.</p></li></ul><ul><li><code>check_compatibility</code>: Whether to check if the given system <code>sys</code> contains all the information necessary to create a <code>SciMLBase.SCCNonlinearProblem</code> and no more. If disabled, assumes that <code>sys</code> at least contains the necessary information.</li><li><code>expression</code>: <code>Val{true}</code> to return an <code>Expr</code> that constructs the corresponding problem instead of the problem itself. <code>Val{false}</code> otherwise.</li></ul><p>All other keyword arguments are forwarded to the SciMLBase.NonlinearFunction constructor.</p><p><strong>Extended docs</strong></p><p>The following API is internal and may change or be removed without notice. Its usage is highly discouraged.</p><ul><li><code>build_initializeprob</code>: If <code>false</code>, avoids building the initialization problem.</li><li><code>check_length</code>: Whether to check the number of equations along with number of unknowns and length of <code>u0</code> vector for consistency. If <code>false</code>, do not check with equations. This is forwarded to <code>check_eqs_u0</code>.</li><li><code>time_dependent_init</code>: Whether to build a time-dependent initialization for the problem. A time-dependent initialization solves for a consistent <code>u0</code>, whereas a time-independent one only runs parameter initialization.</li><li><code>algebraic_only</code>: Whether to build the initialization problem using only algebraic equations.</li><li><code>allow_incomplete</code>: Whether to allow incomplete initialization problems.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/0af5a3d86d4fccdeca0acdc62f5fcecfe0faaf9e/src/problems/docs.jl#L206-L295">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SciMLBase.NonlinearLeastSquaresProblem" href="#SciMLBase.NonlinearLeastSquaresProblem"><code>SciMLBase.NonlinearLeastSquaresProblem</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SciMLBase.SciMLBase.NonlinearLeastSquaresProblem(sys::System, op; kwargs...)
SciMLBase.SciMLBase.NonlinearLeastSquaresProblem{iip}(sys::System, op; kwargs...)
SciMLBase.SciMLBase.NonlinearLeastSquaresProblem{iip, specialize}(sys::System, op; kwargs...)</code></pre><p>Build a <code>SciMLBase.NonlinearLeastSquaresProblem</code> given a system <code>sys</code> and operating point <code>op</code> . <code>iip</code> is a boolean indicating whether the problem should be in-place. <code>specialization</code> is a <code>SciMLBase.AbstractSpecalize</code> subtype indicating the level of specialization of the SciMLBase.NonlinearFunction. The operating point should be an iterable collection of key-value pairs mapping variables/parameters in the system to the (initial) values they should take in <code>SciMLBase.NonlinearLeastSquaresProblem</code>. Any values not provided will fallback to the corresponding default (if present).</p><p>ModelingToolkit will build an initialization problem that will run parameter initialization. Since it does not solve for initial values of unknowns, observed equations will not be initialization constraints. If an initialization equation of the system must involve the initial value of an unknown <code>x</code>, it must be used as <code>Initial(x)</code> in the equation. For example, an equation to be used to solve for parameter <code>p</code> in terms of unknowns <code>x</code> and <code>y</code> must be provided as <code>Initial(x) + Initial(y) ~ p</code> instead of <code>x + y ~ p</code>. See the <a href="../../tutorials/initialization/#initialization">Initialization</a> documentation for more information.</p><p><strong>Keyword arguments</strong></p><ul><li><p><code>eval_expression</code>: Whether to compile any functions via <code>eval</code> or <code>RuntimeGeneratedFunctions</code>.</p></li><li><p><code>eval_module</code>: If <code>eval_expression == true</code>, the module to <code>eval</code> into. Otherwise, the module in which to generate the <code>RuntimeGeneratedFunction</code>.</p></li><li><p><code>guesses</code>: The guesses for variables in the system, used as initial values for the initialization problem.</p></li><li><p><code>warn_initialize_determined</code>: Warn if the initialization system is under/over-determined.</p></li><li><p><code>initialization_eqs</code>: Extra equations to use in the initialization problem.</p></li><li><p><code>fully_determined</code>: Override whether the initialization system is fully determined.</p></li><li><p><code>use_scc</code>: Whether to use <code>SCCNonlinearProblem</code> for initialization if the system is fully determined.</p></li><li><p><code>check_initialization_units</code>: Enable or disable unit checks when constructing the initialization problem.</p></li><li><p><code>tofloat</code>: Passed to <a href="#ModelingToolkit.varmap_to_vars"><code>varmap_to_vars</code></a> when building the parameter vector of a non-split system.</p></li><li><p><code>u0_eltype</code>: The <code>eltype</code> of the <code>u0</code> vector. If <code>nothing</code>, finds the promoted floating point type from <code>op</code>.</p></li><li><p><code>u0_constructor</code>: A function to apply to the <code>u0</code> value returned from <a href="#ModelingToolkit.varmap_to_vars"><code>varmap_to_vars</code></a>. to construct the final <code>u0</code> value.</p></li><li><p><code>p_constructor</code>: A function to apply to each array buffer created when constructing the parameter object.</p></li><li><p><code>warn_cyclic_dependency</code>: Whether to emit a warning listing out cycles in initial conditions provided for unknowns and parameters.</p></li><li><p><code>circular_dependency_max_cycle_length</code>: Maximum length of cycle to check for. Only applicable if <code>warn_cyclic_dependency == true</code>.</p></li><li><p><code>circular_dependency_max_cycles</code>: Maximum number of cycles to check for. Only applicable if <code>warn_cyclic_dependency == true</code>.</p></li><li><p><code>substitution_limit</code>: The number times to substitute initial conditions into each other to attempt to arrive at a numeric value.</p></li></ul><ul><li><code>check_compatibility</code>: Whether to check if the given system <code>sys</code> contains all the information necessary to create a <code>SciMLBase.NonlinearLeastSquaresProblem</code> and no more. If disabled, assumes that <code>sys</code> at least contains the necessary information.</li><li><code>expression</code>: <code>Val{true}</code> to return an <code>Expr</code> that constructs the corresponding problem instead of the problem itself. <code>Val{false}</code> otherwise.</li></ul><p>All other keyword arguments are forwarded to the SciMLBase.NonlinearFunction constructor.</p><p><strong>Extended docs</strong></p><p>The following API is internal and may change or be removed without notice. Its usage is highly discouraged.</p><ul><li><code>build_initializeprob</code>: If <code>false</code>, avoids building the initialization problem.</li><li><code>check_length</code>: Whether to check the number of equations along with number of unknowns and length of <code>u0</code> vector for consistency. If <code>false</code>, do not check with equations. This is forwarded to <code>check_eqs_u0</code>.</li><li><code>time_dependent_init</code>: Whether to build a time-dependent initialization for the problem. A time-dependent initialization solves for a consistent <code>u0</code>, whereas a time-independent one only runs parameter initialization.</li><li><code>algebraic_only</code>: Whether to build the initialization problem using only algebraic equations.</li><li><code>allow_incomplete</code>: Whether to allow incomplete initialization problems.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/0af5a3d86d4fccdeca0acdc62f5fcecfe0faaf9e/src/problems/docs.jl#L206-L295">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SciMLBase.SteadyStateProblem" href="#SciMLBase.SteadyStateProblem"><code>SciMLBase.SteadyStateProblem</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SciMLBase.SciMLBase.SteadyStateProblem(sys::System, op; kwargs...)
SciMLBase.SciMLBase.SteadyStateProblem{iip}(sys::System, op; kwargs...)
SciMLBase.SciMLBase.SteadyStateProblem{iip, specialize}(sys::System, op; kwargs...)</code></pre><p>Build a <code>SciMLBase.SteadyStateProblem</code> given a system <code>sys</code> and operating point <code>op</code> . <code>iip</code> is a boolean indicating whether the problem should be in-place. <code>specialization</code> is a <code>SciMLBase.AbstractSpecalize</code> subtype indicating the level of specialization of the SciMLBase.ODEFunction. The operating point should be an iterable collection of key-value pairs mapping variables/parameters in the system to the (initial) values they should take in <code>SciMLBase.SteadyStateProblem</code>. Any values not provided will fallback to the corresponding default (if present).</p><p>ModelingToolkit will build an initialization problem that will run parameter initialization. Since it does not solve for initial values of unknowns, observed equations will not be initialization constraints. If an initialization equation of the system must involve the initial value of an unknown <code>x</code>, it must be used as <code>Initial(x)</code> in the equation. For example, an equation to be used to solve for parameter <code>p</code> in terms of unknowns <code>x</code> and <code>y</code> must be provided as <code>Initial(x) + Initial(y) ~ p</code> instead of <code>x + y ~ p</code>. See the <a href="../../tutorials/initialization/#initialization">Initialization</a> documentation for more information.</p><p><strong>Keyword arguments</strong></p><ul><li><p><code>eval_expression</code>: Whether to compile any functions via <code>eval</code> or <code>RuntimeGeneratedFunctions</code>.</p></li><li><p><code>eval_module</code>: If <code>eval_expression == true</code>, the module to <code>eval</code> into. Otherwise, the module in which to generate the <code>RuntimeGeneratedFunction</code>.</p></li><li><p><code>guesses</code>: The guesses for variables in the system, used as initial values for the initialization problem.</p></li><li><p><code>warn_initialize_determined</code>: Warn if the initialization system is under/over-determined.</p></li><li><p><code>initialization_eqs</code>: Extra equations to use in the initialization problem.</p></li><li><p><code>fully_determined</code>: Override whether the initialization system is fully determined.</p></li><li><p><code>use_scc</code>: Whether to use <code>SCCNonlinearProblem</code> for initialization if the system is fully determined.</p></li><li><p><code>check_initialization_units</code>: Enable or disable unit checks when constructing the initialization problem.</p></li><li><p><code>tofloat</code>: Passed to <a href="#ModelingToolkit.varmap_to_vars"><code>varmap_to_vars</code></a> when building the parameter vector of a non-split system.</p></li><li><p><code>u0_eltype</code>: The <code>eltype</code> of the <code>u0</code> vector. If <code>nothing</code>, finds the promoted floating point type from <code>op</code>.</p></li><li><p><code>u0_constructor</code>: A function to apply to the <code>u0</code> value returned from <a href="#ModelingToolkit.varmap_to_vars"><code>varmap_to_vars</code></a>. to construct the final <code>u0</code> value.</p></li><li><p><code>p_constructor</code>: A function to apply to each array buffer created when constructing the parameter object.</p></li><li><p><code>warn_cyclic_dependency</code>: Whether to emit a warning listing out cycles in initial conditions provided for unknowns and parameters.</p></li><li><p><code>circular_dependency_max_cycle_length</code>: Maximum length of cycle to check for. Only applicable if <code>warn_cyclic_dependency == true</code>.</p></li><li><p><code>circular_dependency_max_cycles</code>: Maximum number of cycles to check for. Only applicable if <code>warn_cyclic_dependency == true</code>.</p></li><li><p><code>substitution_limit</code>: The number times to substitute initial conditions into each other to attempt to arrive at a numeric value.</p></li></ul><ul><li><code>check_compatibility</code>: Whether to check if the given system <code>sys</code> contains all the information necessary to create a <code>SciMLBase.SteadyStateProblem</code> and no more. If disabled, assumes that <code>sys</code> at least contains the necessary information.</li><li><code>expression</code>: <code>Val{true}</code> to return an <code>Expr</code> that constructs the corresponding problem instead of the problem itself. <code>Val{false}</code> otherwise.</li></ul><p>All other keyword arguments are forwarded to the SciMLBase.ODEFunction constructor.</p><p><strong>Extended docs</strong></p><p>The following API is internal and may change or be removed without notice. Its usage is highly discouraged.</p><ul><li><code>build_initializeprob</code>: If <code>false</code>, avoids building the initialization problem.</li><li><code>check_length</code>: Whether to check the number of equations along with number of unknowns and length of <code>u0</code> vector for consistency. If <code>false</code>, do not check with equations. This is forwarded to <code>check_eqs_u0</code>.</li><li><code>time_dependent_init</code>: Whether to build a time-dependent initialization for the problem. A time-dependent initialization solves for a consistent <code>u0</code>, whereas a time-independent one only runs parameter initialization.</li><li><code>algebraic_only</code>: Whether to build the initialization problem using only algebraic equations.</li><li><code>allow_incomplete</code>: Whether to allow incomplete initialization problems.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/0af5a3d86d4fccdeca0acdc62f5fcecfe0faaf9e/src/problems/docs.jl#L206-L295">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SciMLBase.IntervalNonlinearFunction" href="#SciMLBase.IntervalNonlinearFunction"><code>SciMLBase.IntervalNonlinearFunction</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SciMLBase.IntervalNonlinearFunction(sys::System; kwargs...)
SciMLBase.IntervalNonlinearFunction{iip}(sys::System; kwargs...)
SciMLBase.IntervalNonlinearFunction{iip, specialize}(sys::System; kwargs...)</code></pre><p>Create a <code>SciMLBase.IntervalNonlinearFunction</code> from the given <code>sys</code>. <code>iip</code> is a boolean indicating whether the function should be in-place. <code>specialization</code> is a <code>SciMLBase.AbstractSpecalize</code> subtype indicating the level of specialization of the SciMLBase.IntervalNonlinearFunction.</p><p><strong>Keyword arguments</strong></p><ul><li><p><code>u0</code>: The <code>u0</code> vector for the corresponding problem, if available. Can be obtained using <a href="#ModelingToolkit.get_u0"><code>ModelingToolkit.get_u0</code></a>.</p></li><li><p><code>p</code>: The parameter object for the corresponding problem, if available. Can be obtained using <a href="#ModelingToolkit.get_p"><code>ModelingToolkit.get_p</code></a>.</p></li><li><p><code>eval_expression</code>: Whether to compile any functions via <code>eval</code> or <code>RuntimeGeneratedFunctions</code>.</p></li><li><p><code>eval_module</code>: If <code>eval_expression == true</code>, the module to <code>eval</code> into. Otherwise, the module in which to generate the <code>RuntimeGeneratedFunction</code>.</p></li><li><p><code>checkbounds</code>: Whether to enable bounds checking in the generated code.</p></li><li><p><code>simplify</code>: Whether to <code>simplify</code> any symbolically computed jacobians/hessians/etc.</p></li><li><p><code>cse</code>: Whether to enable Common Subexpression Elimination (CSE) on the generated code. This typically improves performance of the generated code but reduces readability.</p></li><li><p><code>sparse</code>: Whether to generate jacobian/hessian/etc. functions that return/operate on sparse matrices. Also controls whether the mass matrix is sparse, wherever applicable.</p></li><li><p><code>check_compatibility</code>: Whether to check if the given system <code>sys</code> contains all the information necessary to create a <code>SciMLBase.IntervalNonlinearFunction</code> and no more. If disabled, assumes that <code>sys</code> at least contains the necessary information.</p></li><li><p><code>expression</code>: <code>Val{true}</code> to return an <code>Expr</code> that constructs the corresponding problem instead of the problem itself. <code>Val{false}</code> otherwise.</p></li></ul><p>All other keyword arguments are forwarded to the <code>SciMLBase.IntervalNonlinearFunction</code> struct constructor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/0af5a3d86d4fccdeca0acdc62f5fcecfe0faaf9e/src/problems/docs.jl#L340-L377">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SciMLBase.IntervalNonlinearProblem" href="#SciMLBase.IntervalNonlinearProblem"><code>SciMLBase.IntervalNonlinearProblem</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SciMLBase.IntervalNonlinearProblem(sys::System, uspan::NTuple{2}, parammap = SciMLBase.NullParameters(); kwargs...)</code></pre><p>Create an <code>IntervalNonlinearProblem</code> from the given <code>sys</code>. This is only valid for a system of nonlinear equations with a single equation and unknown. <code>uspan</code> is the interval in which the root is to be found, and <code>parammap</code> is an iterable collection of key-value pairs providing values for the parameters in the system.</p><p>ModelingToolkit will build an initialization problem that will run parameter initialization. Since it does not solve for initial values of unknowns, observed equations will not be initialization constraints. If an initialization equation of the system must involve the initial value of an unknown <code>x</code>, it must be used as <code>Initial(x)</code> in the equation. For example, an equation to be used to solve for parameter <code>p</code> in terms of unknowns <code>x</code> and <code>y</code> must be provided as <code>Initial(x) + Initial(y) ~ p</code> instead of <code>x + y ~ p</code>. See the <a href="../../tutorials/initialization/#initialization">Initialization</a> documentation for more information.</p><p><strong>Keyword arguments</strong></p><ul><li><p><code>eval_expression</code>: Whether to compile any functions via <code>eval</code> or <code>RuntimeGeneratedFunctions</code>.</p></li><li><p><code>eval_module</code>: If <code>eval_expression == true</code>, the module to <code>eval</code> into. Otherwise, the module in which to generate the <code>RuntimeGeneratedFunction</code>.</p></li><li><p><code>guesses</code>: The guesses for variables in the system, used as initial values for the initialization problem.</p></li><li><p><code>warn_initialize_determined</code>: Warn if the initialization system is under/over-determined.</p></li><li><p><code>initialization_eqs</code>: Extra equations to use in the initialization problem.</p></li><li><p><code>fully_determined</code>: Override whether the initialization system is fully determined.</p></li><li><p><code>use_scc</code>: Whether to use <code>SCCNonlinearProblem</code> for initialization if the system is fully determined.</p></li><li><p><code>check_initialization_units</code>: Enable or disable unit checks when constructing the initialization problem.</p></li><li><p><code>tofloat</code>: Passed to <a href="#ModelingToolkit.varmap_to_vars"><code>varmap_to_vars</code></a> when building the parameter vector of a non-split system.</p></li><li><p><code>u0_eltype</code>: The <code>eltype</code> of the <code>u0</code> vector. If <code>nothing</code>, finds the promoted floating point type from <code>op</code>.</p></li><li><p><code>u0_constructor</code>: A function to apply to the <code>u0</code> value returned from <a href="#ModelingToolkit.varmap_to_vars"><code>varmap_to_vars</code></a>. to construct the final <code>u0</code> value.</p></li><li><p><code>p_constructor</code>: A function to apply to each array buffer created when constructing the parameter object.</p></li><li><p><code>warn_cyclic_dependency</code>: Whether to emit a warning listing out cycles in initial conditions provided for unknowns and parameters.</p></li><li><p><code>circular_dependency_max_cycle_length</code>: Maximum length of cycle to check for. Only applicable if <code>warn_cyclic_dependency == true</code>.</p></li><li><p><code>circular_dependency_max_cycles</code>: Maximum number of cycles to check for. Only applicable if <code>warn_cyclic_dependency == true</code>.</p></li><li><p><code>substitution_limit</code>: The number times to substitute initial conditions into each other to attempt to arrive at a numeric value.</p></li><li><p><code>check_compatibility</code>: Whether to check if the given system <code>sys</code> contains all the information necessary to create a <code>SciMLBase.IntervalNonlinearProblem</code> and no more. If disabled, assumes that <code>sys</code> at least contains the necessary information.</p></li><li><p><code>expression</code>: <code>Val{true}</code> to return an <code>Expr</code> that constructs the corresponding problem instead of the problem itself. <code>Val{false}</code> otherwise.</p></li></ul><p>All other keyword arguments are forwarded to the <code>IntervalNonlinearFunction</code> constructor.</p><p><strong>Extended docs</strong></p><p>The following API is internal and may change or be removed without notice. Its usage is highly discouraged.</p><ul><li><code>build_initializeprob</code>: If <code>false</code>, avoids building the initialization problem.</li><li><code>check_length</code>: Whether to check the number of equations along with number of unknowns and length of <code>u0</code> vector for consistency. If <code>false</code>, do not check with equations. This is forwarded to <code>check_eqs_u0</code>.</li><li><code>time_dependent_init</code>: Whether to build a time-dependent initialization for the problem. A time-dependent initialization solves for a consistent <code>u0</code>, whereas a time-independent one only runs parameter initialization.</li><li><code>algebraic_only</code>: Whether to build the initialization problem using only algebraic equations.</li><li><code>allow_incomplete</code>: Whether to allow incomplete initialization problems.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/0af5a3d86d4fccdeca0acdc62f5fcecfe0faaf9e/src/problems/docs.jl#L373-L393">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.HomotopyContinuationProblem" href="#ModelingToolkit.HomotopyContinuationProblem"><code>ModelingToolkit.HomotopyContinuationProblem</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SciMLBase.ModelingToolkit.HomotopyContinuationProblem(sys::System, op; kwargs...)
SciMLBase.ModelingToolkit.HomotopyContinuationProblem{iip}(sys::System, op; kwargs...)
SciMLBase.ModelingToolkit.HomotopyContinuationProblem{iip, specialize}(sys::System, op; kwargs...)</code></pre><p>Build a <code>ModelingToolkit.HomotopyContinuationProblem</code> given a system <code>sys</code> and operating point <code>op</code> . <code>iip</code> is a boolean indicating whether the problem should be in-place. <code>specialization</code> is a <code>SciMLBase.AbstractSpecalize</code> subtype indicating the level of specialization of the SciMLBase.HomotopyNonlinearFunction. The operating point should be an iterable collection of key-value pairs mapping variables/parameters in the system to the (initial) values they should take in <code>ModelingToolkit.HomotopyContinuationProblem</code>. Any values not provided will fallback to the corresponding default (if present).</p><p><strong>Keyword arguments</strong></p><ul><li><p><code>eval_expression</code>: Whether to compile any functions via <code>eval</code> or <code>RuntimeGeneratedFunctions</code>.</p></li><li><p><code>eval_module</code>: If <code>eval_expression == true</code>, the module to <code>eval</code> into. Otherwise, the module in which to generate the <code>RuntimeGeneratedFunction</code>.</p></li><li><p><code>guesses</code>: The guesses for variables in the system, used as initial values for the initialization problem.</p></li><li><p><code>warn_initialize_determined</code>: Warn if the initialization system is under/over-determined.</p></li><li><p><code>initialization_eqs</code>: Extra equations to use in the initialization problem.</p></li><li><p><code>fully_determined</code>: Override whether the initialization system is fully determined.</p></li><li><p><code>use_scc</code>: Whether to use <code>SCCNonlinearProblem</code> for initialization if the system is fully determined.</p></li><li><p><code>check_initialization_units</code>: Enable or disable unit checks when constructing the initialization problem.</p></li><li><p><code>tofloat</code>: Passed to <a href="#ModelingToolkit.varmap_to_vars"><code>varmap_to_vars</code></a> when building the parameter vector of a non-split system.</p></li><li><p><code>u0_eltype</code>: The <code>eltype</code> of the <code>u0</code> vector. If <code>nothing</code>, finds the promoted floating point type from <code>op</code>.</p></li><li><p><code>u0_constructor</code>: A function to apply to the <code>u0</code> value returned from <a href="#ModelingToolkit.varmap_to_vars"><code>varmap_to_vars</code></a>. to construct the final <code>u0</code> value.</p></li><li><p><code>p_constructor</code>: A function to apply to each array buffer created when constructing the parameter object.</p></li><li><p><code>warn_cyclic_dependency</code>: Whether to emit a warning listing out cycles in initial conditions provided for unknowns and parameters.</p></li><li><p><code>circular_dependency_max_cycle_length</code>: Maximum length of cycle to check for. Only applicable if <code>warn_cyclic_dependency == true</code>.</p></li><li><p><code>circular_dependency_max_cycles</code>: Maximum number of cycles to check for. Only applicable if <code>warn_cyclic_dependency == true</code>.</p></li><li><p><code>substitution_limit</code>: The number times to substitute initial conditions into each other to attempt to arrive at a numeric value.</p></li></ul><ul><li><code>check_compatibility</code>: Whether to check if the given system <code>sys</code> contains all the information necessary to create a <code>ModelingToolkit.HomotopyContinuationProblem</code> and no more. If disabled, assumes that <code>sys</code> at least contains the necessary information.</li><li><code>expression</code>: <code>Val{true}</code> to return an <code>Expr</code> that constructs the corresponding problem instead of the problem itself. <code>Val{false}</code> otherwise.</li></ul><p>All other keyword arguments are forwarded to the SciMLBase.HomotopyNonlinearFunction constructor.</p><p><strong>Extended docs</strong></p><p>The following API is internal and may change or be removed without notice. Its usage is highly discouraged.</p><ul><li><code>build_initializeprob</code>: If <code>false</code>, avoids building the initialization problem.</li><li><code>check_length</code>: Whether to check the number of equations along with number of unknowns and length of <code>u0</code> vector for consistency. If <code>false</code>, do not check with equations. This is forwarded to <code>check_eqs_u0</code>.</li><li><code>time_dependent_init</code>: Whether to build a time-dependent initialization for the problem. A time-dependent initialization solves for a consistent <code>u0</code>, whereas a time-independent one only runs parameter initialization.</li><li><code>algebraic_only</code>: Whether to build the initialization problem using only algebraic equations.</li><li><code>allow_incomplete</code>: Whether to allow incomplete initialization problems.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/0af5a3d86d4fccdeca0acdc62f5fcecfe0faaf9e/src/systems/nonlinear/homotopy_continuation.jl#L517-L598">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SciMLBase.HomotopyNonlinearFunction" href="#SciMLBase.HomotopyNonlinearFunction"><code>SciMLBase.HomotopyNonlinearFunction</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SciMLBase.HomotopyNonlinearFunction(sys::System; kwargs...)
SciMLBase.HomotopyNonlinearFunction{iip}(sys::System; kwargs...)
SciMLBase.HomotopyNonlinearFunction{iip, specialize}(sys::System; kwargs...)</code></pre><p>Create a <code>HomotopyNonlinearFunction</code> from the given <code>sys</code>. <code>iip</code> is a boolean indicating whether the function should be in-place. <code>specialization</code> is a <code>SciMLBase.AbstractSpecalize</code> subtype indicating the level of specialization of the func.</p><p><strong>Keyword arguments</strong></p><ul><li><p><code>u0</code>: The <code>u0</code> vector for the corresponding problem, if available. Can be obtained using <a href="#ModelingToolkit.get_u0"><code>ModelingToolkit.get_u0</code></a>.</p></li><li><p><code>p</code>: The parameter object for the corresponding problem, if available. Can be obtained using <a href="#ModelingToolkit.get_p"><code>ModelingToolkit.get_p</code></a>.</p></li><li><p><code>eval_expression</code>: Whether to compile any functions via <code>eval</code> or <code>RuntimeGeneratedFunctions</code>.</p></li><li><p><code>eval_module</code>: If <code>eval_expression == true</code>, the module to <code>eval</code> into. Otherwise, the module in which to generate the <code>RuntimeGeneratedFunction</code>.</p></li><li><p><code>checkbounds</code>: Whether to enable bounds checking in the generated code.</p></li><li><p><code>simplify</code>: Whether to <code>simplify</code> any symbolically computed jacobians/hessians/etc.</p></li><li><p><code>cse</code>: Whether to enable Common Subexpression Elimination (CSE) on the generated code. This typically improves performance of the generated code but reduces readability.</p></li><li><p><code>fraction_cancel_fn</code>: The function to use to simplify fractions in the polynomial expression. A more powerful function can increase processing time but be able to eliminate more rational functions, thus improving solve time. Should be a function that takes a symbolic expression containing zero or more fraction expressions and returns the simplified expression. While this defaults to <code>SymbolicUtils.simplify_fractions</code>, a viable alternative is <code>SymbolicUtils.quick_cancel</code></p></li></ul><p>All keyword arguments are forwarded to the wrapped <code>NonlinearFunction</code> constructor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/0af5a3d86d4fccdeca0acdc62f5fcecfe0faaf9e/src/problems/docs.jl#L343-L371">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SciMLBase.LinearProblem" href="#SciMLBase.LinearProblem"><code>SciMLBase.LinearProblem</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SciMLBase.LinearProblem(sys::System, op; kwargs...)
SciMLBase.LinearProblem{iip}(sys::System, op; kwargs...)</code></pre><p>Build a <code>LinearProblem</code> given a system <code>sys</code> and operating point <code>op</code>. <code>iip</code> is a boolean indicating whether the problem should be in-place. The operating point should be an iterable collection of key-value pairs mapping variables/parameters in the system to the (initial) values they should take in <code>LinearProblem</code>. Any values not provided will fallback to the corresponding default (if present).</p><p>Note that since <code>u0</code> is optional for <code>LinearProblem</code>, values of unknowns do not need to be specified in <code>op</code> to create a <code>LinearProblem</code>. In such a case, <code>prob.u0</code> will be <code>nothing</code> and attempting to symbolically index the problem with an unknown, observable, or expression depending on unknowns/observables will error.</p><p>Updating the parameters automatically updates the <code>A</code> and <code>b</code> arrays.</p><p><strong>Keyword arguments</strong></p><ul><li><p><code>eval_expression</code>: Whether to compile any functions via <code>eval</code> or <code>RuntimeGeneratedFunctions</code>.</p></li><li><p><code>eval_module</code>: If <code>eval_expression == true</code>, the module to <code>eval</code> into. Otherwise, the module in which to generate the <code>RuntimeGeneratedFunction</code>.</p></li><li><p><code>guesses</code>: The guesses for variables in the system, used as initial values for the initialization problem.</p></li><li><p><code>warn_initialize_determined</code>: Warn if the initialization system is under/over-determined.</p></li><li><p><code>initialization_eqs</code>: Extra equations to use in the initialization problem.</p></li><li><p><code>fully_determined</code>: Override whether the initialization system is fully determined.</p></li><li><p><code>use_scc</code>: Whether to use <code>SCCNonlinearProblem</code> for initialization if the system is fully determined.</p></li><li><p><code>check_initialization_units</code>: Enable or disable unit checks when constructing the initialization problem.</p></li><li><p><code>tofloat</code>: Passed to <a href="#ModelingToolkit.varmap_to_vars"><code>varmap_to_vars</code></a> when building the parameter vector of a non-split system.</p></li><li><p><code>u0_eltype</code>: The <code>eltype</code> of the <code>u0</code> vector. If <code>nothing</code>, finds the promoted floating point type from <code>op</code>.</p></li><li><p><code>u0_constructor</code>: A function to apply to the <code>u0</code> value returned from <a href="#ModelingToolkit.varmap_to_vars"><code>varmap_to_vars</code></a>. to construct the final <code>u0</code> value.</p></li><li><p><code>p_constructor</code>: A function to apply to each array buffer created when constructing the parameter object.</p></li><li><p><code>warn_cyclic_dependency</code>: Whether to emit a warning listing out cycles in initial conditions provided for unknowns and parameters.</p></li><li><p><code>circular_dependency_max_cycle_length</code>: Maximum length of cycle to check for. Only applicable if <code>warn_cyclic_dependency == true</code>.</p></li><li><p><code>circular_dependency_max_cycles</code>: Maximum number of cycles to check for. Only applicable if <code>warn_cyclic_dependency == true</code>.</p></li><li><p><code>substitution_limit</code>: The number times to substitute initial conditions into each other to attempt to arrive at a numeric value.</p></li><li><p><code>check_compatibility</code>: Whether to check if the given system <code>sys</code> contains all the information necessary to create a <code>SciMLBase.LinearProblem</code> and no more. If disabled, assumes that <code>sys</code> at least contains the necessary information.</p></li><li><p><code>expression</code>: <code>Val{true}</code> to return an <code>Expr</code> that constructs the corresponding problem instead of the problem itself. <code>Val{false}</code> otherwise.</p></li></ul><p>All other keyword arguments are forwarded to the func constructor.</p><p><strong>Extended docs</strong></p><p>The following API is internal and may change or be removed without notice. Its usage is highly discouraged.</p><ul><li><code>build_initializeprob</code>: If <code>false</code>, avoids building the initialization problem.</li><li><code>check_length</code>: Whether to check the number of equations along with number of unknowns and length of <code>u0</code> vector for consistency. If <code>false</code>, do not check with equations. This is forwarded to <code>check_eqs_u0</code>.</li><li><code>time_dependent_init</code>: Whether to build a time-dependent initialization for the problem. A time-dependent initialization solves for a consistent <code>u0</code>, whereas a time-independent one only runs parameter initialization.</li><li><code>algebraic_only</code>: Whether to build the initialization problem using only algebraic equations.</li><li><code>allow_incomplete</code>: Whether to allow incomplete initialization problems.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/0af5a3d86d4fccdeca0acdc62f5fcecfe0faaf9e/src/problems/docs.jl#L395-L422">source</a></section></article><h2 id="Optimization-and-optimal-control"><a class="docs-heading-anchor" href="#Optimization-and-optimal-control">Optimization and optimal control</a><a id="Optimization-and-optimal-control-1"></a><a class="docs-heading-anchor-permalink" href="#Optimization-and-optimal-control" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SciMLBase.OptimizationFunction" href="#SciMLBase.OptimizationFunction"><code>SciMLBase.OptimizationFunction</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SciMLBase.OptimizationFunction(sys::System; kwargs...)
SciMLBase.OptimizationFunction{iip}(sys::System; kwargs...)
SciMLBase.OptimizationFunction{iip, specialize}(sys::System; kwargs...)</code></pre><p>Create a <code>SciMLBase.OptimizationFunction</code> from the given <code>sys</code>. <code>iip</code> is a boolean indicating whether the function should be in-place. <code>specialization</code> is a <code>SciMLBase.AbstractSpecalize</code> subtype indicating the level of specialization of the SciMLBase.OptimizationFunction.</p><p><strong>Keyword arguments</strong></p><ul><li><p><code>u0</code>: The <code>u0</code> vector for the corresponding problem, if available. Can be obtained using <a href="#ModelingToolkit.get_u0"><code>ModelingToolkit.get_u0</code></a>.</p></li><li><p><code>p</code>: The parameter object for the corresponding problem, if available. Can be obtained using <a href="#ModelingToolkit.get_p"><code>ModelingToolkit.get_p</code></a>.</p></li><li><p><code>eval_expression</code>: Whether to compile any functions via <code>eval</code> or <code>RuntimeGeneratedFunctions</code>.</p></li><li><p><code>eval_module</code>: If <code>eval_expression == true</code>, the module to <code>eval</code> into. Otherwise, the module in which to generate the <code>RuntimeGeneratedFunction</code>.</p></li><li><p><code>checkbounds</code>: Whether to enable bounds checking in the generated code.</p></li><li><p><code>simplify</code>: Whether to <code>simplify</code> any symbolically computed jacobians/hessians/etc.</p></li><li><p><code>cse</code>: Whether to enable Common Subexpression Elimination (CSE) on the generated code. This typically improves performance of the generated code but reduces readability.</p></li><li><p><code>sparse</code>: Whether to generate jacobian/hessian/etc. functions that return/operate on sparse matrices. Also controls whether the mass matrix is sparse, wherever applicable.</p></li><li><p><code>check_compatibility</code>: Whether to check if the given system <code>sys</code> contains all the information necessary to create a <code>SciMLBase.OptimizationFunction</code> and no more. If disabled, assumes that <code>sys</code> at least contains the necessary information.</p></li><li><p><code>expression</code>: <code>Val{true}</code> to return an <code>Expr</code> that constructs the corresponding problem instead of the problem itself. <code>Val{false}</code> otherwise.</p></li><li><p><code>jac</code>: Whether to symbolically compute and generate code for the jacobian function.</p></li><li><p><code>grad</code>: Whether the symbolically compute and generate code for the gradient of the cost function with respect to unknowns.</p></li><li><p><code>hess</code>: Whether to symbolically compute and generate code for the hessian function.</p></li><li><p><code>cons_h</code>: Whether to symbolically compute and generate code for the hessian function of constraints. Since the constraint function is vector-valued, the hessian is a vector of hessian matrices.</p></li><li><p><code>cons_j</code>: Whether to symbolically compute and generate code for the jacobian function of constraints.</p></li><li><p><code>sparsity</code>: Whether to provide symbolically compute and provide sparsity patterns for the jacobian/hessian/etc.</p></li><li><p><code>cons_sparse</code>: Identical to the <code>sparse</code> keyword, but specifically for jacobian/hessian functions of the constraints.</p></li></ul><p>All other keyword arguments are forwarded to the <code>SciMLBase.OptimizationFunction</code> struct constructor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/0af5a3d86d4fccdeca0acdc62f5fcecfe0faaf9e/src/problems/docs.jl#L340-L396">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SciMLBase.OptimizationProblem" href="#SciMLBase.OptimizationProblem"><code>SciMLBase.OptimizationProblem</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SciMLBase.SciMLBase.OptimizationProblem(sys::System, op; kwargs...)
SciMLBase.SciMLBase.OptimizationProblem{iip}(sys::System, op; kwargs...)
SciMLBase.SciMLBase.OptimizationProblem{iip, specialize}(sys::System, op; kwargs...)</code></pre><p>Build a <code>SciMLBase.OptimizationProblem</code> given a system <code>sys</code> and operating point <code>op</code> . <code>iip</code> is a boolean indicating whether the problem should be in-place. <code>specialization</code> is a <code>SciMLBase.AbstractSpecalize</code> subtype indicating the level of specialization of the SciMLBase.OptimizationFunction. The operating point should be an iterable collection of key-value pairs mapping variables/parameters in the system to the (initial) values they should take in <code>SciMLBase.OptimizationProblem</code>. Any values not provided will fallback to the corresponding default (if present).</p><p>ModelingToolkit will build an initialization problem that will run parameter initialization. Since it does not solve for initial values of unknowns, observed equations will not be initialization constraints. If an initialization equation of the system must involve the initial value of an unknown <code>x</code>, it must be used as <code>Initial(x)</code> in the equation. For example, an equation to be used to solve for parameter <code>p</code> in terms of unknowns <code>x</code> and <code>y</code> must be provided as <code>Initial(x) + Initial(y) ~ p</code> instead of <code>x + y ~ p</code>. See the <a href="../../tutorials/initialization/#initialization">Initialization</a> documentation for more information.</p><p><strong>Keyword arguments</strong></p><ul><li><p><code>eval_expression</code>: Whether to compile any functions via <code>eval</code> or <code>RuntimeGeneratedFunctions</code>.</p></li><li><p><code>eval_module</code>: If <code>eval_expression == true</code>, the module to <code>eval</code> into. Otherwise, the module in which to generate the <code>RuntimeGeneratedFunction</code>.</p></li><li><p><code>guesses</code>: The guesses for variables in the system, used as initial values for the initialization problem.</p></li><li><p><code>warn_initialize_determined</code>: Warn if the initialization system is under/over-determined.</p></li><li><p><code>initialization_eqs</code>: Extra equations to use in the initialization problem.</p></li><li><p><code>fully_determined</code>: Override whether the initialization system is fully determined.</p></li><li><p><code>use_scc</code>: Whether to use <code>SCCNonlinearProblem</code> for initialization if the system is fully determined.</p></li><li><p><code>check_initialization_units</code>: Enable or disable unit checks when constructing the initialization problem.</p></li><li><p><code>tofloat</code>: Passed to <a href="#ModelingToolkit.varmap_to_vars"><code>varmap_to_vars</code></a> when building the parameter vector of a non-split system.</p></li><li><p><code>u0_eltype</code>: The <code>eltype</code> of the <code>u0</code> vector. If <code>nothing</code>, finds the promoted floating point type from <code>op</code>.</p></li><li><p><code>u0_constructor</code>: A function to apply to the <code>u0</code> value returned from <a href="#ModelingToolkit.varmap_to_vars"><code>varmap_to_vars</code></a>. to construct the final <code>u0</code> value.</p></li><li><p><code>p_constructor</code>: A function to apply to each array buffer created when constructing the parameter object.</p></li><li><p><code>warn_cyclic_dependency</code>: Whether to emit a warning listing out cycles in initial conditions provided for unknowns and parameters.</p></li><li><p><code>circular_dependency_max_cycle_length</code>: Maximum length of cycle to check for. Only applicable if <code>warn_cyclic_dependency == true</code>.</p></li><li><p><code>circular_dependency_max_cycles</code>: Maximum number of cycles to check for. Only applicable if <code>warn_cyclic_dependency == true</code>.</p></li><li><p><code>substitution_limit</code>: The number times to substitute initial conditions into each other to attempt to arrive at a numeric value.</p></li></ul><ul><li><code>check_compatibility</code>: Whether to check if the given system <code>sys</code> contains all the information necessary to create a <code>SciMLBase.OptimizationProblem</code> and no more. If disabled, assumes that <code>sys</code> at least contains the necessary information.</li><li><code>expression</code>: <code>Val{true}</code> to return an <code>Expr</code> that constructs the corresponding problem instead of the problem itself. <code>Val{false}</code> otherwise.</li></ul><p>All other keyword arguments are forwarded to the SciMLBase.OptimizationFunction constructor.</p><p><strong>Extended docs</strong></p><p>The following API is internal and may change or be removed without notice. Its usage is highly discouraged.</p><ul><li><code>build_initializeprob</code>: If <code>false</code>, avoids building the initialization problem.</li><li><code>check_length</code>: Whether to check the number of equations along with number of unknowns and length of <code>u0</code> vector for consistency. If <code>false</code>, do not check with equations. This is forwarded to <code>check_eqs_u0</code>.</li><li><code>time_dependent_init</code>: Whether to build a time-dependent initialization for the problem. A time-dependent initialization solves for a consistent <code>u0</code>, whereas a time-independent one only runs parameter initialization.</li><li><code>algebraic_only</code>: Whether to build the initialization problem using only algebraic equations.</li><li><code>allow_incomplete</code>: Whether to allow incomplete initialization problems.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/0af5a3d86d4fccdeca0acdc62f5fcecfe0faaf9e/src/problems/docs.jl#L206-L295">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SciMLBase.ODEInputFunction" href="#SciMLBase.ODEInputFunction"><code>SciMLBase.ODEInputFunction</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SciMLBase.ODEInputFunction(sys::System; kwargs...)
SciMLBase.ODEInputFunction{iip}(sys::System; kwargs...)
SciMLBase.ODEInputFunction{iip, specialize}(sys::System; kwargs...)</code></pre><p>Create a <code>SciMLBase.ODEInputFunction</code> from the given <code>sys</code>. <code>iip</code> is a boolean indicating whether the function should be in-place. <code>specialization</code> is a <code>SciMLBase.AbstractSpecalize</code> subtype indicating the level of specialization of the SciMLBase.ODEInputFunction.</p><p><strong>Keyword arguments</strong></p><ul><li><p><code>u0</code>: The <code>u0</code> vector for the corresponding problem, if available. Can be obtained using <a href="#ModelingToolkit.get_u0"><code>ModelingToolkit.get_u0</code></a>.</p></li><li><p><code>p</code>: The parameter object for the corresponding problem, if available. Can be obtained using <a href="#ModelingToolkit.get_p"><code>ModelingToolkit.get_p</code></a>.</p></li><li><p><code>t</code>: The initial time for the corresponding problem, if available.</p></li><li><p><code>eval_expression</code>: Whether to compile any functions via <code>eval</code> or <code>RuntimeGeneratedFunctions</code>.</p></li><li><p><code>eval_module</code>: If <code>eval_expression == true</code>, the module to <code>eval</code> into. Otherwise, the module in which to generate the <code>RuntimeGeneratedFunction</code>.</p></li><li><p><code>checkbounds</code>: Whether to enable bounds checking in the generated code.</p></li><li><p><code>simplify</code>: Whether to <code>simplify</code> any symbolically computed jacobians/hessians/etc.</p></li><li><p><code>cse</code>: Whether to enable Common Subexpression Elimination (CSE) on the generated code. This typically improves performance of the generated code but reduces readability.</p></li><li><p><code>sparse</code>: Whether to generate jacobian/hessian/etc. functions that return/operate on sparse matrices. Also controls whether the mass matrix is sparse, wherever applicable.</p></li><li><p><code>check_compatibility</code>: Whether to check if the given system <code>sys</code> contains all the information necessary to create a <code>SciMLBase.ODEInputFunction</code> and no more. If disabled, assumes that <code>sys</code> at least contains the necessary information.</p></li><li><p><code>expression</code>: <code>Val{true}</code> to return an <code>Expr</code> that constructs the corresponding problem instead of the problem itself. <code>Val{false}</code> otherwise.  Constructing the expression does not support callbacks</p></li><li><p><code>inputs</code>: The variables in the input vector. The system must have been simplified using <code>mtkcompile</code> with these variables passed as <code>inputs</code>.</p></li><li><p><code>disturbance_inputs</code>: The disturbance input variables. The system must have been simplified using <code>mtkcompile</code> with these variables passed as <code>disturbance_inputs</code>.</p></li><li><p><code>jac</code>: Whether to symbolically compute and generate code for the jacobian function.</p></li><li><p><code>tgrad</code>: Whether to symbolically compute and generate code for the <code>tgrad</code> function.</p></li><li><p><code>controljac</code>: Whether to symbolically compute and generate code for the jacobian of the ODE with respect to the inputs.</p></li><li><p><code>sparsity</code>: Whether to provide symbolically compute and provide sparsity patterns for the jacobian/hessian/etc.</p></li></ul><p>All other keyword arguments are forwarded to the <code>SciMLBase.ODEInputFunction</code> struct constructor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/0af5a3d86d4fccdeca0acdc62f5fcecfe0faaf9e/src/problems/docs.jl#L340-L392">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.JuMPDynamicOptProblem" href="#ModelingToolkit.JuMPDynamicOptProblem"><code>ModelingToolkit.JuMPDynamicOptProblem</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">JuMPDynamicOptProblem(sys::System, op, tspan; dt, steps, guesses, kwargs...)</code></pre><p>Convert an System representing an optimal control system into a JuMP model for solving using optimization. Must provide either <code>dt</code>, the timestep between collocation  points (which, along with the timespan, determines the number of points), or directly  provide the number of points as <code>steps</code>.</p><p>To construct the problem, please load InfiniteOpt along with ModelingToolkit.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/0af5a3d86d4fccdeca0acdc62f5fcecfe0faaf9e/src/systems/optimal_control_interface.jl#L21-L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.InfiniteOptDynamicOptProblem" href="#ModelingToolkit.InfiniteOptDynamicOptProblem"><code>ModelingToolkit.InfiniteOptDynamicOptProblem</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">InfiniteOptDynamicOptProblem(sys::System, op, tspan; dt)</code></pre><p>Convert an System representing an optimal control system into a InfiniteOpt model for solving using optimization. Must provide <code>dt</code> for determining the length  of the interpolation arrays.</p><p>Related to <code>JuMPDynamicOptProblem</code>, but directly adds the differential equations of the system as derivative constraints, rather than using a solver tableau.</p><p>To construct the problem, please load InfiniteOpt along with ModelingToolkit.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/0af5a3d86d4fccdeca0acdc62f5fcecfe0faaf9e/src/systems/optimal_control_interface.jl#L32-L43">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.CasADiDynamicOptProblem" href="#ModelingToolkit.CasADiDynamicOptProblem"><code>ModelingToolkit.CasADiDynamicOptProblem</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CasADiDynamicOptProblem(sys::System, op, tspan; dt, steps, guesses, kwargs...)</code></pre><p>Convert an System representing an optimal control system into a CasADi model for solving using optimization. Must provide either <code>dt</code>, the timestep between collocation  points (which, along with the timespan, determines the number of points), or directly  provide the number of points as <code>steps</code>.</p><p>To construct the problem, please load CasADi along with ModelingToolkit.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/0af5a3d86d4fccdeca0acdc62f5fcecfe0faaf9e/src/systems/optimal_control_interface.jl#L45-L54">source</a></section></article><div class="admonition is-warning" id="Missing-docstring.-f5c225cdb1676557"><header class="admonition-header">Missing docstring.<a class="admonition-anchor" href="#Missing-docstring.-f5c225cdb1676557" title="Permalink"></a></header><div class="admonition-body"><p>Missing docstring for <code>ModelingToolkit.DynamicOptSolution</code>. Check Documenter&#39;s build log for details.</p></div></div><h2 id="The-state-vector-and-parameter-object"><a class="docs-heading-anchor" href="#The-state-vector-and-parameter-object">The state vector and parameter object</a><a id="The-state-vector-and-parameter-object-1"></a><a class="docs-heading-anchor-permalink" href="#The-state-vector-and-parameter-object" title="Permalink"></a></h2><p>Typically the unknowns of the system are present as a <code>Vector</code> of the appropriate length in the numerical problem. The state vector can also be constructed manually without building a problem.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.get_u0" href="#ModelingToolkit.get_u0"><code>ModelingToolkit.get_u0</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_u0(
    sys::ModelingToolkit.AbstractSystem,
    varmap;
    kwargs...
) -&gt; Any
</code></pre><p>Return the <code>u0</code> vector for the given system <code>sys</code> and variable-value mapping <code>varmap</code>. All keyword arguments are forwarded to <a href="#ModelingToolkit.varmap_to_vars"><code>varmap_to_vars</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/0af5a3d86d4fccdeca0acdc62f5fcecfe0faaf9e/src/systems/problem_utils.jl#L1728-L1733">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.varmap_to_vars" href="#ModelingToolkit.varmap_to_vars"><code>ModelingToolkit.varmap_to_vars</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">varmap_to_vars(
    varmap::AbstractDict,
    vars::Vector;
    tofloat,
    use_union,
    container_type,
    buffer_eltype,
    toterm,
    check,
    allow_symbolic,
    is_initializeprob,
    substitution_limit
) -&gt; Any
</code></pre><p>Return an array of values where the <code>i</code>th element corresponds to the value of <code>vars[i]</code> in <code>varmap</code>. Will mutate <code>varmap</code> by symbolically substituting it into itself.</p><p>Keyword arguments:</p><ul><li><code>container_type</code>: The type of the returned container.</li><li><code>allow_symbolic</code>: Whether the returned container of values can have symbolic expressions.</li><li><code>buffer_eltype</code>: The <code>eltype</code> of the returned container if <code>!allow_symbolic</code>. If <code>Nothing</code>, automatically promotes the values in the container to a common <code>eltype</code>.</li><li><code>tofloat</code>: Whether to promote values to floating point numbers if <code>buffer_eltype == Nothing</code>.</li><li><code>use_union</code>: Whether to allow using a <code>Union</code> as the <code>eltype</code> if <code>buffer_eltype == Nothing</code>.</li><li><code>toterm</code>: The <code>toterm</code> function for canonicalizing keys of <code>varmap</code>. A value of <code>nothing</code> disables this process.</li><li><code>check</code>: Whether to check if all of <code>vars</code> are keys of <code>varmap</code>.</li><li><code>is_initializeprob</code>: Whether an initialization problem is being constructed. Used for better error messages.</li><li><code>substitution_limit</code>: The maximum number of times to recursively substitute <code>varmap</code> into itself to get a numeric value for each variable in <code>vars</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/0af5a3d86d4fccdeca0acdc62f5fcecfe0faaf9e/src/systems/problem_utils.jl#L346-L368">source</a></section></article><p>By default, the parameters of the system are stored in a custom data structure called <code>MTKParameters</code>. The internals of this data structure are undocumented, and it should only be interacted with through defined public API. SymbolicIndexingInterface.jl contains functionality useful for this purpose.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.MTKParameters" href="#ModelingToolkit.MTKParameters"><code>ModelingToolkit.MTKParameters</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">function MTKParameters(sys::AbstractSystem, p, u0 = Dict(); t0 = nothing)</code></pre><p>Create an <code>MTKParameters</code> object for the system <code>sys</code>. <code>p</code> (<code>u0</code>) are symbolic maps from parameters (unknowns) to their values. The values can also be symbolic expressions, which are evaluated given the values of other parameters/unknowns. <code>u0</code> is only required if the values of parameters depend on the unknowns. <code>t0</code> is the initial time, for time- dependent systems. It is only required if the symbolic expressions also use the independent variable of the system.</p><p>This requires that <code>complete</code> has been called on the system (usually via <code>mtkcompile</code> or <code>@mtkcompile</code>) and the keyword <code>split = true</code> was passed (which is the default behavior).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/0af5a3d86d4fccdeca0acdc62f5fcecfe0faaf9e/src/systems/parameter_buffer.jl#L15-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.get_p" href="#ModelingToolkit.get_p"><code>ModelingToolkit.get_p</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_p(
    sys::ModelingToolkit.AbstractSystem,
    varmap;
    split,
    kwargs...
) -&gt; Any
</code></pre><p>Return the <code>p</code> object for the given system <code>sys</code> and variable-value mapping <code>varmap</code>. All keyword arguments are forwarded to <a href="#ModelingToolkit.MTKParameters"><code>MTKParameters</code></a> for split systems and <a href="#ModelingToolkit.varmap_to_vars"><code>varmap_to_vars</code></a> for non-split systems.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/0af5a3d86d4fccdeca0acdc62f5fcecfe0faaf9e/src/systems/problem_utils.jl#L1748-L1754">source</a></section></article><p>The following functions are useful when working with <code>MTKParameters</code> objects, and especially the <code>Tunables</code> portion. For more information about the &quot;portions&quot; of <code>MTKParameters</code>, refer to the <a href="https://docs.sciml.ai/SciMLStructures/stable/"><code>SciMLStructures.jl</code></a> documentation.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.reorder_dimension_by_tunables!" href="#ModelingToolkit.reorder_dimension_by_tunables!"><code>ModelingToolkit.reorder_dimension_by_tunables!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">reorder_dimension_by_tunables!(dest::AbstractArray, sys::AbstractSystem, arr::AbstractArray, syms; dim = 1)</code></pre><p>Assuming the order of values in dimension <code>dim</code> of <code>arr</code> correspond to the order of tunable parameters in the system, reorder them according to the order described in <code>syms</code>. <code>syms</code> must be a permutation of <code>tunable_parameters(sys)</code>. The result is written to <code>dest</code>. The <code>size</code> of <code>dest</code> and <code>arr</code> must be equal. Return <code>dest</code>.</p><p>See also: <a href="#ModelingToolkit.MTKParameters"><code>MTKParameters</code></a>, <a href="../System/#ModelingToolkit.tunable_parameters"><code>tunable_parameters</code></a>, <a href="#ModelingToolkit.reorder_dimension_by_tunables"><code>reorder_dimension_by_tunables</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/0af5a3d86d4fccdeca0acdc62f5fcecfe0faaf9e/src/systems/index_cache.jl#L643-L652">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.reorder_dimension_by_tunables" href="#ModelingToolkit.reorder_dimension_by_tunables"><code>ModelingToolkit.reorder_dimension_by_tunables</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">reorder_dimension_by_tunables(sys::AbstractSystem, arr::AbstractArray, syms; dim = 1)</code></pre><p>Out-of-place version of <a href="#ModelingToolkit.reorder_dimension_by_tunables!"><code>reorder_dimension_by_tunables!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/0af5a3d86d4fccdeca0acdc62f5fcecfe0faaf9e/src/systems/index_cache.jl#L683-L687">source</a></section></article><h2 id="Initialization"><a class="docs-heading-anchor" href="#Initialization">Initialization</a><a id="Initialization-1"></a><a class="docs-heading-anchor-permalink" href="#Initialization" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.generate_initializesystem" href="#ModelingToolkit.generate_initializesystem"><code>ModelingToolkit.generate_initializesystem</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">generate_initializesystem(
    sys::ModelingToolkit.AbstractSystem;
    time_dependent_init,
    kwargs...
) -&gt; System
</code></pre><p>Generate the initialization system for <code>sys</code>. The initialization system is a system of nonlinear equations that solve for the full set of initial conditions of <code>sys</code> given specified constraints.</p><p>The initialization system can be of two types: time-dependent and time-independent. Time-dependent initialization systems solve for the initial values of unknowns as well as the values of solvable parameters of the system. Time-independent initialization systems only solve for solvable parameters of the system.</p><p><strong>Keyword arguments</strong></p><ul><li><code>time_dependent_init</code>: Whether to create an initialization system for a time-dependent system. A time-dependent initialization requires a time-dependent <code>sys</code>, but a time- independent initialization can be created regardless.</li><li><code>op</code>: The operating point of user-specified initial conditions of variables in <code>sys</code>.</li><li><code>initialization_eqs</code>: Additional initialization equations to use apart from those in <code>initialization_equations(sys)</code>.</li><li><code>guesses</code>: Additional guesses to use apart from those in <code>guesses(sys)</code>.</li><li><code>default_dd_guess</code>: Default guess for dummy derivative variables in time-dependent initialization.</li><li><code>algebraic_only</code>: If <code>false</code>, does not use initialization equations (provided via the keyword or part of the system) to construct initialization.</li><li><code>check_defguess</code>: Whether to error when a variable does not have a default or guess despite ModelingToolkit expecting it to.</li><li><code>name</code>: The name of the initialization system.</li></ul><p>All other keyword arguments are forwarded to the <a href="../System/#ModelingToolkit.System"><code>System</code></a> constructor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/0af5a3d86d4fccdeca0acdc62f5fcecfe0faaf9e/src/systems/nonlinear/initializesystem.jl#L1-L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.InitializationProblem" href="#ModelingToolkit.InitializationProblem"><code>ModelingToolkit.InitializationProblem</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">InitializationProblem(sys::AbstractSystem, t, op = Dict(); kwargs...)
InitializationProblem{iip}(sys::AbstractSystem, t, op = Dict(); kwargs...)
InitializationProblem{iip, specialize}(sys::AbstractSystem, t, op = Dict(); kwargs...)</code></pre><p>Generate a <code>NonlinearProblem</code>, <code>SCCNonlinearProblem</code> or <code>NonlinearLeastSquaresProblem</code> to represent a consistent initialization of <code>sys</code> given the initial time <code>t</code> and operating point <code>op</code>. The initial time can be <code>nothing</code> for time-independent systems.</p><p><strong>Keyword arguments</strong></p><ul><li><p><code>guesses</code>: The guesses for variables in the system, used as initial values for the initialization problem.</p></li><li><p><code>warn_initialize_determined</code>: Warn if the initialization system is under/over-determined.</p></li><li><p><code>initialization_eqs</code>: Extra equations to use in the initialization problem.</p></li><li><p><code>fully_determined</code>: Override whether the initialization system is fully determined.</p></li><li><p><code>use_scc</code>: Whether to use <code>SCCNonlinearProblem</code> for initialization if the system is fully determined.</p></li><li><p><code>time_dependent_init</code>: Whether to build a time-dependent initialization for the problem. A time-dependent initialization solves for a consistent <code>u0</code>, whereas a time-independent one only runs parameter initialization.</p></li><li><p><code>algebraic_only</code>: Whether to build the initialization problem using only algebraic equations.</p></li><li><p><code>allow_incomplete</code>: Whether to allow incomplete initialization problems.</p></li></ul><p>All other keyword arguments are forwarded to the wrapped nonlinear problem constructor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/0af5a3d86d4fccdeca0acdc62f5fcecfe0faaf9e/src/problems/initializationproblem.jl#L3-L18">source</a></section></article><h2 id="Linear-analysis"><a class="docs-heading-anchor" href="#Linear-analysis">Linear analysis</a><a id="Linear-analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Linear-analysis" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.linearization_function" href="#ModelingToolkit.linearization_function"><code>ModelingToolkit.linearization_function</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lin_fun, simplified_sys = linearization_function(sys::AbstractSystem, inputs, outputs; simplify = false, initialize = true, initialization_solver_alg = TrustRegion(), kwargs...)</code></pre><p>Return a function that linearizes the system <code>sys</code>. The function <a href="#ModelingToolkit.linearize"><code>linearize</code></a> provides a higher-level and easier to use interface.</p><p><code>lin_fun</code> is a function <code>(variables, p, t) -&gt; (; f_x, f_z, g_x, g_z, f_u, g_u, h_x, h_z, h_u)</code>, i.e., it returns a NamedTuple with the Jacobians of <code>f,g,h</code> for the nonlinear <code>sys</code> (technically for <code>simplified_sys</code>) on the form</p><p class="math-container">\[\begin{aligned}
ẋ &amp;= f(x, z, u) \\
0 &amp;= g(x, z, u) \\
y &amp;= h(x, z, u)
\end{aligned}\]</p><p>where <code>x</code> are differential unknown variables, <code>z</code> algebraic variables, <code>u</code> inputs and <code>y</code> outputs. To obtain a linear statespace representation, see <a href="#ModelingToolkit.linearize"><code>linearize</code></a>. The input argument <code>variables</code> is a vector defining the operating point, corresponding to <code>unknowns(simplified_sys)</code> and <code>p</code> is a vector corresponding to the parameters of <code>simplified_sys</code>. Note: all variables in <code>inputs</code> have been converted to parameters in <code>simplified_sys</code>.</p><p>The <code>simplified_sys</code> has undergone <a href="../model_building/#ModelingToolkit.mtkcompile"><code>mtkcompile</code></a> and had any occurring input or output variables replaced with the variables provided in arguments <code>inputs</code> and <code>outputs</code>. The unknowns of this system also indicate the order of the unknowns that holds for the linearized matrices.</p><p><strong>Arguments:</strong></p><ul><li><code>sys</code>: A <a href="../System/#ModelingToolkit.System"><code>System</code></a> of ODEs. This function will automatically apply simplification passes on <code>sys</code> and return the resulting <code>simplified_sys</code>.</li><li><code>inputs</code>: A vector of variables that indicate the inputs of the linearized input-output model.</li><li><code>outputs</code>: A vector of variables that indicate the outputs of the linearized input-output model.</li><li><code>simplify</code>: Apply simplification in tearing.</li><li><code>initialize</code>: If true, a check is performed to ensure that the operating point is consistent (satisfies algebraic equations). If the op is not consistent, initialization is performed.</li><li><code>initialization_solver_alg</code>: A NonlinearSolve algorithm to use for solving for a feasible set of state and algebraic variables that satisfies the specified operating point.</li><li><code>autodiff</code>: An <code>ADType</code> supported by DifferentiationInterface.jl to use for calculating the necessary jacobians. Defaults to using <code>AutoForwardDiff()</code></li><li><code>kwargs</code>: Are passed on to <code>find_solvables!</code></li></ul><p>See also <a href="#ModelingToolkit.linearize"><code>linearize</code></a> which provides a higher-level interface.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/0af5a3d86d4fccdeca0acdc62f5fcecfe0faaf9e/src/linearization.jl#L1-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.LinearizationProblem" href="#ModelingToolkit.LinearizationProblem"><code>ModelingToolkit.LinearizationProblem</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mutable struct LinearizationProblem{F&lt;:ModelingToolkit.LinearizationFunction, T}</code></pre><p>A struct representing a linearization operation to be performed. Can be symbolically indexed to efficiently update the operating point for multiple linearizations in a loop. The value of the independent variable can be set by mutating the <code>.t</code> field of this struct.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/0af5a3d86d4fccdeca0acdc62f5fcecfe0faaf9e/src/linearization.jl#L380-L386">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.linearize" href="#ModelingToolkit.linearize"><code>ModelingToolkit.linearize</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">(; A, B, C, D), simplified_sys, extras = linearize(sys, inputs, outputs;    t=0.0, op = Dict(), allow_input_derivatives = false, zero_dummy_der=false, kwargs...)
(; A, B, C, D), extras                 = linearize(simplified_sys, lin_fun; t=0.0, op = Dict(), allow_input_derivatives = false, zero_dummy_der=false)</code></pre><p>Linearize <code>sys</code> between <code>inputs</code> and <code>outputs</code>, both vectors of variables. Return a NamedTuple with the matrices of a linear statespace representation on the form</p><p class="math-container">\[\begin{aligned}
ẋ &amp;= Ax + Bu\\
y &amp;= Cx + Du
\end{aligned}\]</p><p>The first signature automatically calls <a href="#ModelingToolkit.linearization_function"><code>linearization_function</code></a> internally, while the second signature expects the outputs of <a href="#ModelingToolkit.linearization_function"><code>linearization_function</code></a> as input.</p><p><code>op</code> denotes the operating point around which to linearize. If none is provided, the default values of <code>sys</code> are used.</p><p>If <code>allow_input_derivatives = false</code>, an error will be thrown if input derivatives (<span>$u̇$</span>) appear as inputs in the linearized equations. If input derivatives are allowed, the returned <code>B</code> matrix will be of double width, corresponding to the input <code>[u; u̇]</code>.</p><p><code>zero_dummy_der</code> can be set to automatically set the operating point to zero for all dummy derivatives.</p><p>The return value <code>extras</code> is a NamedTuple <code>(; x, p, t)</code> containing the result of the initialization problem that was solved to determine the operating point.</p><p>See also <a href="#ModelingToolkit.linearization_function"><code>linearization_function</code></a> which provides a lower-level interface, <a href="../../basics/Linearization/#ModelingToolkit.linearize_symbolic-basics-Linearization"><code>linearize_symbolic</code></a> and <a href="#ModelingToolkit.reorder_unknowns"><code>ModelingToolkit.reorder_unknowns</code></a>.</p><p>See extended help for an example.</p><p>The implementation and notation follows that of <a href="https://ep.liu.se/ecp/043/075/ecp09430097.pdf">&quot;Linear Analysis Approach for Modelica Models&quot;, Allain et al. 2009</a></p><p><strong>Extended help</strong></p><p>This example builds the following feedback interconnection and linearizes it from the input of <code>F</code> to the output of <code>P</code>.</p><pre><code class="nohighlight hljs">
  r ┌─────┐       ┌─────┐     ┌─────┐
───►│     ├──────►│     │  u  │     │
    │  F  │       │  C  ├────►│  P  │ y
    └─────┘     ┌►│     │     │     ├─┬─►
                │ └─────┘     └─────┘ │
                │                     │
                └─────────────────────┘</code></pre><pre><code class="language-julia hljs">using ModelingToolkit
using ModelingToolkit: t_nounits as t, D_nounits as D
function plant(; name)
    @variables x(t) = 1
    @variables u(t)=0 y(t)=0
    eqs = [D(x) ~ -x + u
           y ~ x]
    System(eqs, t; name = name)
end

function ref_filt(; name)
    @variables x(t)=0 y(t)=0
    @variables u(t)=0 [input = true]
    eqs = [D(x) ~ -2 * x + u
           y ~ x]
    System(eqs, t, name = name)
end

function controller(kp; name)
    @variables y(t)=0 r(t)=0 u(t)=0
    @parameters kp = kp
    eqs = [
        u ~ kp * (r - y),
    ]
    System(eqs, t; name = name)
end

@named f = ref_filt()
@named c = controller(1)
@named p = plant()

connections = [f.y ~ c.r # filtered reference to controller reference
               c.u ~ p.u # controller output to plant input
               p.y ~ c.y]

@named cl = System(connections, t, systems = [f, c, p])

lsys0, ssys = linearize(cl, [f.u], [p.x])
desired_order = [f.x, p.x]
lsys = ModelingToolkit.reorder_unknowns(lsys0, unknowns(ssys), desired_order)

@assert lsys.A == [-2 0; 1 -2]
@assert lsys.B == [1; 0;;]
@assert lsys.C == [0 1]
@assert lsys.D[] == 0

## Symbolic linearization
lsys_sym, _ = ModelingToolkit.linearize_symbolic(cl, [f.u], [p.x])

@assert substitute(lsys_sym.A, ModelingToolkit.defaults(cl)) == lsys.A</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/0af5a3d86d4fccdeca0acdc62f5fcecfe0faaf9e/src/linearization.jl#L624-L724">source</a></section></article><div class="admonition is-warning" id="Missing-docstring.-b67b9c2ede9daee5"><header class="admonition-header">Missing docstring.<a class="admonition-anchor" href="#Missing-docstring.-b67b9c2ede9daee5" title="Permalink"></a></header><div class="admonition-body"><p>Missing docstring for <code>CommonSolve.solve(::LinearizationProblem)</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning" id="Missing-docstring.-f012156e96150b70"><header class="admonition-header">Missing docstring.<a class="admonition-anchor" href="#Missing-docstring.-f012156e96150b70" title="Permalink"></a></header><div class="admonition-body"><p>Missing docstring for <code>linearize_symbolic</code>. Check Documenter&#39;s build log for details.</p></div></div><p>There are also utilities for manipulating the results of these analyses in a symbolic context.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.similarity_transform" href="#ModelingToolkit.similarity_transform"><code>ModelingToolkit.similarity_transform</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">(; Ã, B̃, C̃, D̃) = similarity_transform(sys, T; unitary=false)</code></pre><p>Perform a similarity transform <code>T : Tx̃ = x</code> on linear system represented by matrices in NamedTuple <code>sys</code> such that</p><pre><code class="nohighlight hljs">Ã = T⁻¹AT
B̃ = T⁻¹ B
C̃ = CT
D̃ = D</code></pre><p>If <code>unitary=true</code>, <code>T</code> is assumed unitary and the matrix adjoint is used instead of the inverse.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/0af5a3d86d4fccdeca0acdc62f5fcecfe0faaf9e/src/linearization.jl#L763-L776">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.reorder_unknowns" href="#ModelingToolkit.reorder_unknowns"><code>ModelingToolkit.reorder_unknowns</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">reorder_unknowns(sys::NamedTuple, old, new)</code></pre><p>Permute the state representation of <code>sys</code> obtained from <a href="#ModelingToolkit.linearize"><code>linearize</code></a> so that the state unknown is changed from <code>old</code> to <code>new</code> Example:</p><pre><code class="nohighlight hljs">lsys, ssys = linearize(pid, [reference.u, measurement.u], [ctr_output.u])
desired_order = [int.x, der.x] # Unknowns that are present in unknowns(ssys)
lsys = ModelingToolkit.reorder_unknowns(lsys, unknowns(ssys), desired_order)</code></pre><p>See also <a href="#ModelingToolkit.similarity_transform"><code>ModelingToolkit.similarity_transform</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/0af5a3d86d4fccdeca0acdc62f5fcecfe0faaf9e/src/linearization.jl#L791-L804">source</a></section></article><h3 id="Analysis-point-transformations"><a class="docs-heading-anchor" href="#Analysis-point-transformations">Analysis point transformations</a><a id="Analysis-point-transformations-1"></a><a class="docs-heading-anchor-permalink" href="#Analysis-point-transformations" title="Permalink"></a></h3><p>Linear analysis can also be done using analysis points to perform several common workflows.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.get_sensitivity_function" href="#ModelingToolkit.get_sensitivity_function"><code>ModelingToolkit.get_sensitivity_function</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_sensitivity_function(
    sys::ModelingToolkit.AbstractSystem,
    aps;
    kwargs...
) -&gt; Tuple{ModelingToolkit.LinearizationFunction{DI, AI, _A, P, _B, _C, J1, J2, J3, J4, IA, @NamedTuple{abstol::Float64, reltol::Float64, nlsolve_alg::NonlinearSolveFirstOrder.GeneralizedFirstOrderAlgorithm{Missing, NonlinearSolveFirstOrder.GenericTrustRegionScheme{NonlinearSolveFirstOrder.RadiusUpdateSchemes.__Simple, Rational{Int64}, Rational{Int64}, Rational{Int64}, Rational{Int64}, Rational{Int64}, Rational{Int64}, Rational{Int64}}, NonlinearSolveBase.Dogleg{NonlinearSolveBase.NewtonDescent{Nothing}, NonlinearSolveBase.SteepestDescent{Nothing}}, Nothing, Nothing, Nothing, Val{false}}}} where {DI&lt;:AbstractVector{Int64}, AI&lt;:AbstractVector{Int64}, _A, P&lt;:ODEProblem, _B, _C, J1&lt;:Union{Nothing, ModelingToolkit.PreparedJacobian{true, DifferentiationInterfaceForwardDiffExt.ForwardDiffTwoArgJacobianPrep{Nothing, C, Tuple{Nothing, Nothing}}, ModelingToolkit.var&quot;#uff#943&quot;{var&quot;#1461#fun&quot;}, _A, ADTypes.AutoForwardDiff{nothing, Nothing}} where {C&lt;:(ForwardDiff.JacobianConfig{T, _A, _B, &lt;:Tuple{Any, Any}} where {T&lt;:(ForwardDiff.Tag{F} where F&lt;:ModelingToolkit.var&quot;#uff#943&quot;), _A, _B}), var&quot;#1461#fun&quot;, _A}}, J2&lt;:Union{Nothing, ModelingToolkit.PreparedJacobian{true, DifferentiationInterfaceForwardDiffExt.ForwardDiffTwoArgJacobianPrep{Nothing, C, Tuple{Nothing, Nothing}}, _A, _B, ADTypes.AutoForwardDiff{nothing, Nothing}} where {C&lt;:ForwardDiff.JacobianConfig, _A, _B}}, J3&lt;:Union{Nothing, ModelingToolkit.PreparedJacobian{true, DifferentiationInterfaceForwardDiffExt.ForwardDiffTwoArgJacobianPrep{Nothing, C, Tuple{Nothing, Nothing, Nothing}}, ModelingToolkit.var&quot;#pff#944&quot;{var&quot;#1462#fun&quot;, var&quot;#1463#setter&quot;}, _A, ADTypes.AutoForwardDiff{nothing, Nothing}} where {C&lt;:(ForwardDiff.JacobianConfig{T, _A, _B, &lt;:Tuple{Any, Any}} where {T&lt;:(ForwardDiff.Tag{F} where F&lt;:ModelingToolkit.var&quot;#pff#944&quot;), _A, _B}), var&quot;#1462#fun&quot;, var&quot;#1463#setter&quot;, _A}}, J4&lt;:(ModelingToolkit.PreparedJacobian{true, DifferentiationInterfaceForwardDiffExt.ForwardDiffTwoArgJacobianPrep{Nothing, C, Tuple{Nothing, Nothing, Nothing}}, ModelingToolkit.var&quot;#hpf#942&quot;{fun, setter}, _A, ADTypes.AutoForwardDiff{nothing, Nothing}} where {C&lt;:(ForwardDiff.JacobianConfig{T, _A, _B, &lt;:Tuple{Any, Any}} where {T&lt;:(ForwardDiff.Tag{F} where F&lt;:ModelingToolkit.var&quot;#hpf#942&quot;), _A, _B}), fun, setter, _A}), IA&lt;:Union{SciMLBase.NoInit, SciMLBase.OverrideInit{Nothing, Nothing, Nothing}}}, Any}
</code></pre><p>Return the sensitivity function for the analysis point(s) <code>aps</code>, and the modified system simplified with the appropriate inputs and outputs.</p><p><strong>Keyword Arguments</strong></p><pre><code class="nohighlight hljs">- `loop_openings`: A list of analysis points whose connections should be removed and
  the outputs set to the input as a part of the linear analysis.

- `system_modifier`: A function taking the transformed system and applying any
  additional transformations, returning the modified system. The modified system
  is passed to `linearization_function`.</code></pre><p>All other keyword arguments are forwarded to <code>linearization_function</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/0af5a3d86d4fccdeca0acdc62f5fcecfe0faaf9e/src/systems/analysis_points.jl#L864-L876">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.get_sensitivity" href="#ModelingToolkit.get_sensitivity"><code>ModelingToolkit.get_sensitivity</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">    get_sensitivity(sys, ap::AnalysisPoint; kwargs)
    get_sensitivity(sys, ap_name::Symbol; kwargs)</code></pre><p>Compute the sensitivity function in analysis point <code>ap</code>. The sensitivity function is obtained by introducing an infinitesimal perturbation <code>d</code> at the input of <code>ap</code>, linearizing the system and computing the transfer function between <code>d</code> and the output of <code>ap</code>.</p><p><strong>Arguments:</strong></p><ul><li><code>kwargs</code>: Are sent to <code>ModelingToolkit.linearize</code></li></ul><p>See also <a href="#ModelingToolkit.get_comp_sensitivity"><code>get_comp_sensitivity</code></a>, <a href="#ModelingToolkit.get_looptransfer"><code>get_looptransfer</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/0af5a3d86d4fccdeca0acdc62f5fcecfe0faaf9e/src/systems/analysis_points.jl#L993-L1004">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.get_comp_sensitivity_function" href="#ModelingToolkit.get_comp_sensitivity_function"><code>ModelingToolkit.get_comp_sensitivity_function</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_comp_sensitivity_function(
    sys::ModelingToolkit.AbstractSystem,
    aps;
    kwargs...
) -&gt; Tuple{ModelingToolkit.LinearizationFunction{DI, AI, _A, P, _B, _C, J1, J2, J3, J4, IA, @NamedTuple{abstol::Float64, reltol::Float64, nlsolve_alg::NonlinearSolveFirstOrder.GeneralizedFirstOrderAlgorithm{Missing, NonlinearSolveFirstOrder.GenericTrustRegionScheme{NonlinearSolveFirstOrder.RadiusUpdateSchemes.__Simple, Rational{Int64}, Rational{Int64}, Rational{Int64}, Rational{Int64}, Rational{Int64}, Rational{Int64}, Rational{Int64}}, NonlinearSolveBase.Dogleg{NonlinearSolveBase.NewtonDescent{Nothing}, NonlinearSolveBase.SteepestDescent{Nothing}}, Nothing, Nothing, Nothing, Val{false}}}} where {DI&lt;:AbstractVector{Int64}, AI&lt;:AbstractVector{Int64}, _A, P&lt;:ODEProblem, _B, _C, J1&lt;:Union{Nothing, ModelingToolkit.PreparedJacobian{true, DifferentiationInterfaceForwardDiffExt.ForwardDiffTwoArgJacobianPrep{Nothing, C, Tuple{Nothing, Nothing}}, ModelingToolkit.var&quot;#uff#943&quot;{var&quot;#1461#fun&quot;}, _A, ADTypes.AutoForwardDiff{nothing, Nothing}} where {C&lt;:(ForwardDiff.JacobianConfig{T, _A, _B, &lt;:Tuple{Any, Any}} where {T&lt;:(ForwardDiff.Tag{F} where F&lt;:ModelingToolkit.var&quot;#uff#943&quot;), _A, _B}), var&quot;#1461#fun&quot;, _A}}, J2&lt;:Union{Nothing, ModelingToolkit.PreparedJacobian{true, DifferentiationInterfaceForwardDiffExt.ForwardDiffTwoArgJacobianPrep{Nothing, C, Tuple{Nothing, Nothing}}, _A, _B, ADTypes.AutoForwardDiff{nothing, Nothing}} where {C&lt;:ForwardDiff.JacobianConfig, _A, _B}}, J3&lt;:Union{Nothing, ModelingToolkit.PreparedJacobian{true, DifferentiationInterfaceForwardDiffExt.ForwardDiffTwoArgJacobianPrep{Nothing, C, Tuple{Nothing, Nothing, Nothing}}, ModelingToolkit.var&quot;#pff#944&quot;{var&quot;#1462#fun&quot;, var&quot;#1463#setter&quot;}, _A, ADTypes.AutoForwardDiff{nothing, Nothing}} where {C&lt;:(ForwardDiff.JacobianConfig{T, _A, _B, &lt;:Tuple{Any, Any}} where {T&lt;:(ForwardDiff.Tag{F} where F&lt;:ModelingToolkit.var&quot;#pff#944&quot;), _A, _B}), var&quot;#1462#fun&quot;, var&quot;#1463#setter&quot;, _A}}, J4&lt;:(ModelingToolkit.PreparedJacobian{true, DifferentiationInterfaceForwardDiffExt.ForwardDiffTwoArgJacobianPrep{Nothing, C, Tuple{Nothing, Nothing, Nothing}}, ModelingToolkit.var&quot;#hpf#942&quot;{fun, setter}, _A, ADTypes.AutoForwardDiff{nothing, Nothing}} where {C&lt;:(ForwardDiff.JacobianConfig{T, _A, _B, &lt;:Tuple{Any, Any}} where {T&lt;:(ForwardDiff.Tag{F} where F&lt;:ModelingToolkit.var&quot;#hpf#942&quot;), _A, _B}), fun, setter, _A}), IA&lt;:Union{SciMLBase.NoInit, SciMLBase.OverrideInit{Nothing, Nothing, Nothing}}}, Any}
</code></pre><p>Return the complementary sensitivity function for the analysis point(s) <code>aps</code>, and the modified system simplified with the appropriate inputs and outputs.</p><p><strong>Keyword Arguments</strong></p><pre><code class="nohighlight hljs">- `loop_openings`: A list of analysis points whose connections should be removed and
  the outputs set to the input as a part of the linear analysis.

- `system_modifier`: A function taking the transformed system and applying any
  additional transformations, returning the modified system. The modified system
  is passed to `linearization_function`.</code></pre><p>All other keyword arguments are forwarded to <code>linearization_function</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/0af5a3d86d4fccdeca0acdc62f5fcecfe0faaf9e/src/systems/analysis_points.jl#L881-L893">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.get_comp_sensitivity" href="#ModelingToolkit.get_comp_sensitivity"><code>ModelingToolkit.get_comp_sensitivity</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_comp_sensitivity(sys, ap::AnalysisPoint; kwargs)
get_comp_sensitivity(sys, ap_name::Symbol; kwargs)</code></pre><p>Compute the complementary sensitivity function in analysis point <code>ap</code>. The complementary sensitivity function is obtained by introducing an infinitesimal perturbation <code>d</code> at the output of <code>ap</code>, linearizing the system and computing the transfer function between <code>d</code> and the input of <code>ap</code>.</p><p><strong>Arguments:</strong></p><ul><li><code>kwargs</code>: Are sent to <code>ModelingToolkit.linearize</code></li></ul><p>See also <a href="#ModelingToolkit.get_sensitivity"><code>get_sensitivity</code></a>, <a href="#ModelingToolkit.get_looptransfer"><code>get_looptransfer</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/0af5a3d86d4fccdeca0acdc62f5fcecfe0faaf9e/src/systems/analysis_points.jl#L1006-L1017">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.get_looptransfer_function" href="#ModelingToolkit.get_looptransfer_function"><code>ModelingToolkit.get_looptransfer_function</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_looptransfer_function(
    sys::ModelingToolkit.AbstractSystem,
    aps;
    kwargs...
) -&gt; Tuple{ModelingToolkit.LinearizationFunction{DI, AI, _A, P, _B, _C, J1, J2, J3, J4, IA, @NamedTuple{abstol::Float64, reltol::Float64, nlsolve_alg::NonlinearSolveFirstOrder.GeneralizedFirstOrderAlgorithm{Missing, NonlinearSolveFirstOrder.GenericTrustRegionScheme{NonlinearSolveFirstOrder.RadiusUpdateSchemes.__Simple, Rational{Int64}, Rational{Int64}, Rational{Int64}, Rational{Int64}, Rational{Int64}, Rational{Int64}, Rational{Int64}}, NonlinearSolveBase.Dogleg{NonlinearSolveBase.NewtonDescent{Nothing}, NonlinearSolveBase.SteepestDescent{Nothing}}, Nothing, Nothing, Nothing, Val{false}}}} where {DI&lt;:AbstractVector{Int64}, AI&lt;:AbstractVector{Int64}, _A, P&lt;:ODEProblem, _B, _C, J1&lt;:Union{Nothing, ModelingToolkit.PreparedJacobian{true, DifferentiationInterfaceForwardDiffExt.ForwardDiffTwoArgJacobianPrep{Nothing, C, Tuple{Nothing, Nothing}}, ModelingToolkit.var&quot;#uff#943&quot;{var&quot;#1461#fun&quot;}, _A, ADTypes.AutoForwardDiff{nothing, Nothing}} where {C&lt;:(ForwardDiff.JacobianConfig{T, _A, _B, &lt;:Tuple{Any, Any}} where {T&lt;:(ForwardDiff.Tag{F} where F&lt;:ModelingToolkit.var&quot;#uff#943&quot;), _A, _B}), var&quot;#1461#fun&quot;, _A}}, J2&lt;:Union{Nothing, ModelingToolkit.PreparedJacobian{true, DifferentiationInterfaceForwardDiffExt.ForwardDiffTwoArgJacobianPrep{Nothing, C, Tuple{Nothing, Nothing}}, _A, _B, ADTypes.AutoForwardDiff{nothing, Nothing}} where {C&lt;:ForwardDiff.JacobianConfig, _A, _B}}, J3&lt;:Union{Nothing, ModelingToolkit.PreparedJacobian{true, DifferentiationInterfaceForwardDiffExt.ForwardDiffTwoArgJacobianPrep{Nothing, C, Tuple{Nothing, Nothing, Nothing}}, ModelingToolkit.var&quot;#pff#944&quot;{var&quot;#1462#fun&quot;, var&quot;#1463#setter&quot;}, _A, ADTypes.AutoForwardDiff{nothing, Nothing}} where {C&lt;:(ForwardDiff.JacobianConfig{T, _A, _B, &lt;:Tuple{Any, Any}} where {T&lt;:(ForwardDiff.Tag{F} where F&lt;:ModelingToolkit.var&quot;#pff#944&quot;), _A, _B}), var&quot;#1462#fun&quot;, var&quot;#1463#setter&quot;, _A}}, J4&lt;:(ModelingToolkit.PreparedJacobian{true, DifferentiationInterfaceForwardDiffExt.ForwardDiffTwoArgJacobianPrep{Nothing, C, Tuple{Nothing, Nothing, Nothing}}, ModelingToolkit.var&quot;#hpf#942&quot;{fun, setter}, _A, ADTypes.AutoForwardDiff{nothing, Nothing}} where {C&lt;:(ForwardDiff.JacobianConfig{T, _A, _B, &lt;:Tuple{Any, Any}} where {T&lt;:(ForwardDiff.Tag{F} where F&lt;:ModelingToolkit.var&quot;#hpf#942&quot;), _A, _B}), fun, setter, _A}), IA&lt;:Union{SciMLBase.NoInit, SciMLBase.OverrideInit{Nothing, Nothing, Nothing}}}, Any}
</code></pre><p>Return the loop-transfer function for the analysis point(s) <code>aps</code>, and the modified system simplified with the appropriate inputs and outputs.</p><p><strong>Keyword Arguments</strong></p><pre><code class="nohighlight hljs">- `loop_openings`: A list of analysis points whose connections should be removed and
  the outputs set to the input as a part of the linear analysis.

- `system_modifier`: A function taking the transformed system and applying any
  additional transformations, returning the modified system. The modified system
  is passed to `linearization_function`.</code></pre><p>All other keyword arguments are forwarded to <code>linearization_function</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/0af5a3d86d4fccdeca0acdc62f5fcecfe0faaf9e/src/systems/analysis_points.jl#L898-L910">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.get_looptransfer" href="#ModelingToolkit.get_looptransfer"><code>ModelingToolkit.get_looptransfer</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_looptransfer(sys, ap::AnalysisPoint; kwargs)
get_looptransfer(sys, ap_name::Symbol; kwargs)</code></pre><p>Compute the (linearized) loop-transfer function in analysis point <code>ap</code>, from <code>ap.out</code> to <code>ap.in</code>.</p><div class="admonition is-info" id="Negative-feedback-bdb37f4684a709de"><header class="admonition-header">Negative feedback<a class="admonition-anchor" href="#Negative-feedback-bdb37f4684a709de" title="Permalink"></a></header><div class="admonition-body"><p>Feedback loops often use negative feedback, and the computed loop-transfer function will in this case have the negative feedback included. Standard analysis tools often assume a loop-transfer function without the negative gain built in, and the result of this function may thus need negation before use.</p></div></div><p><strong>Arguments:</strong></p><ul><li><code>kwargs</code>: Are sent to <code>ModelingToolkit.linearize</code></li></ul><p>See also <a href="#ModelingToolkit.get_sensitivity"><code>get_sensitivity</code></a>, <a href="#ModelingToolkit.get_comp_sensitivity"><code>get_comp_sensitivity</code></a>, <a href="#ModelingToolkit.open_loop"><code>open_loop</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/0af5a3d86d4fccdeca0acdc62f5fcecfe0faaf9e/src/systems/analysis_points.jl#L1019-L1034">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelingToolkit.open_loop" href="#ModelingToolkit.open_loop"><code>ModelingToolkit.open_loop</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">open_loop(
    sys,
    ap::Union{Symbol, AnalysisPoint};
    system_modifier
) -&gt; Tuple{Any, Tuple{Any, Any}}
</code></pre><p>Apply <code>LoopTransferTransform</code> to the analysis point <code>ap</code> and return the result of <code>apply_transformation</code>.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>system_modifier</code>: a function which takes the modified system and returns a new system with any required further modifications performed.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/0af5a3d86d4fccdeca0acdc62f5fcecfe0faaf9e/src/systems/analysis_points.jl#L926-L936">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../model_building/">« Model building reference</a><a class="docs-footer-nextpage" href="../dynamic_opt/">Dynamic Optimization Solvers »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.12.0 on <span class="colophon-date" title="Thursday 19 June 2025 12:20">Thursday 19 June 2025</span>. Using Julia version 1.10.9.</p></section><footer class="modal-card-foot"></footer></div></div></div></body><div data-docstringscollapsed="true"></div></html>
