<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Disturbance and input modeling modeling · ModelingToolkit.jl</title><meta name="title" content="Disturbance and input modeling modeling · ModelingToolkit.jl"/><meta property="og:title" content="Disturbance and input modeling modeling · ModelingToolkit.jl"/><meta property="twitter:title" content="Disturbance and input modeling modeling · ModelingToolkit.jl"/><meta name="description" content="Documentation for ModelingToolkit.jl."/><meta property="og:description" content="Documentation for ModelingToolkit.jl."/><meta property="twitter:description" content="Documentation for ModelingToolkit.jl."/><meta property="og:url" content="https://docs.sciml.ai/ModelingToolkit/stable/tutorials/disturbance_modeling/"/><meta property="twitter:url" content="https://docs.sciml.ai/ModelingToolkit/stable/tutorials/disturbance_modeling/"/><link rel="canonical" href="https://docs.sciml.ai/ModelingToolkit/stable/tutorials/disturbance_modeling/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="ModelingToolkit.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">ModelingToolkit.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../ode_modeling/">Getting Started with ModelingToolkit.jl</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../acausal_components/">Acausal Component-Based Modeling</a></li><li><a class="tocitem" href="../nonlinear/">Modeling Nonlinear Systems</a></li><li><a class="tocitem" href="../initialization/">Initialization of Systems</a></li><li><a class="tocitem" href="../optimization/">Modeling Optimization Problems</a></li><li><a class="tocitem" href="../modelingtoolkitize/">Modelingtoolkitize: Automatically Translating Numerical to Symbolic Code</a></li><li><a class="tocitem" href="../programmatically_generating/">Programmatically Generating and Scripting Systems</a></li><li><a class="tocitem" href="../stochastic_diffeq/">Modeling with Stochasticity</a></li><li><a class="tocitem" href="../dynamic_optimization/">Solving Dynamic Optimization Problems</a></li><li><a class="tocitem" href="../discrete_system/">(Experimental) Modeling Discrete Systems</a></li><li><a class="tocitem" href="../parameter_identifiability/">Parameter Identifiability in ODE Models</a></li><li><a class="tocitem" href="../change_independent_variable/">Changing the independent variable of ODEs</a></li><li><a class="tocitem" href="../bifurcation_diagram_computation/">Bifurcation Diagrams</a></li><li><a class="tocitem" href="../attractors/">Multi- and Nonlocal- Continuation</a></li><li><a class="tocitem" href="../SampledData/">Clocks and Sampled-Data Systems</a></li><li><a class="tocitem" href="../domain_connections/">Domains</a></li><li><a class="tocitem" href="../callable_params/">Callable parameters and interpolating data</a></li><li><a class="tocitem" href="../linear_analysis/">Linear Analysis</a></li><li class="is-active"><a class="tocitem" href>Disturbance and input modeling modeling</a><ul class="internal"><li><a class="tocitem" href="#A-flexible-component-based-workflow"><span>A flexible component-based workflow</span></a></li><li><a class="tocitem" href="#Modeling-for-state-estimation"><span>Modeling for state estimation</span></a></li><li><a class="tocitem" href="#Input-signal-library"><span>Input signal library</span></a></li><li><a class="tocitem" href="#Disturbance-model-library"><span>Disturbance-model library</span></a></li><li><a class="tocitem" href="#Further-reading"><span>Further reading</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li><li><a class="tocitem" href="../fmi/">Importing FMUs</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><input class="collapse-toggle" id="menuitem-4-1" type="checkbox"/><label class="tocitem" for="menuitem-4-1"><span class="docs-label">Basic Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/higher_order/">Automatic Transformation of Nth Order ODEs to 1st Order ODEs</a></li><li><a class="tocitem" href="../../examples/spring_mass/">Component-Based Modeling of a Spring-Mass System</a></li><li><a class="tocitem" href="../../examples/modelingtoolkitize_index_reduction/">Automated Index Reduction of DAEs</a></li><li><a class="tocitem" href="../../examples/remake/">Optimizing through an ODE solve and re-creating MTK Problems</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-2" type="checkbox"/><label class="tocitem" for="menuitem-4-2"><span class="docs-label">Advanced Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/tearing_parallelism/">Exposing More Parallelism By Tearing Algebraic Equations in Systems</a></li><li><a class="tocitem" href="../../examples/sparse_jacobians/">Automated Sparse Analytical Jacobians</a></li><li><a class="tocitem" href="../../examples/perturbation/">Symbolic-Numeric Perturbation Theory for ODEs</a></li></ul></li></ul></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../../API/System/">The <code>System</code> type</a></li><li><a class="tocitem" href="../../API/variables/">Symbolic variables and variable metadata</a></li><li><a class="tocitem" href="../../API/model_building/">Model building reference</a></li><li><a class="tocitem" href="../../API/problems/">Building and solving numerical problems</a></li><li><a class="tocitem" href="../../API/dynamic_opt/">Dynamic Optimization Solvers</a></li><li><a class="tocitem" href="../../API/codegen/">Code generation utilities</a></li><li><a class="tocitem" href="../../API/PDESystem/">PDESystem</a></li></ul></li><li><span class="tocitem">Basics</span><ul><li><a class="tocitem" href="../../basics/Composition/">Composing Models and Building Reusable Components</a></li><li><a class="tocitem" href="../../basics/Events/">Event Handling and Callback Functions</a></li><li><a class="tocitem" href="../../basics/Linearization/">Linearization</a></li><li><a class="tocitem" href="../../basics/InputOutput/">Input output</a></li><li><a class="tocitem" href="../../basics/MTKLanguage/">ModelingToolkit Language: Modeling with <code>@mtkmodel</code>, <code>@connectors</code> and <code>@mtkcompile</code></a></li><li><a class="tocitem" href="../../basics/Validation/">Model Validation and Units</a></li><li><a class="tocitem" href="../../basics/Debugging/">Debugging</a></li><li><a class="tocitem" href="../../basics/DependencyGraphs/">Dependency Graphs</a></li><li><a class="tocitem" href="../../basics/Precompilation/">Working with Precompilation and Binary Building</a></li><li><a class="tocitem" href="../../basics/FAQ/">Frequently Asked Questions</a></li></ul></li><li><a class="tocitem" href="../../comparison/">Comparison of ModelingToolkit vs Equation-Based and Block Modeling Languages</a></li><li><span class="tocitem">Internal Details</span><ul><li><a class="tocitem" href="../../internals/">Internal Details</a></li><li><a class="tocitem" href="../../internals/structural_transformation/">Structural Transformation</a></li><li><a class="tocitem" href="../../internals/bipartite_graph/">Bipartite Graphs</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Disturbance and input modeling modeling</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Disturbance and input modeling modeling</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SciML/ModelingToolkit.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SciML/ModelingToolkit.jl/blob/master/docs/src/tutorials/disturbance_modeling.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Disturbance-and-input-modeling-modeling"><a class="docs-heading-anchor" href="#Disturbance-and-input-modeling-modeling">Disturbance and input modeling modeling</a><a id="Disturbance-and-input-modeling-modeling-1"></a><a class="docs-heading-anchor-permalink" href="#Disturbance-and-input-modeling-modeling" title="Permalink"></a></h1><p>Disturbances are often seen as external factors that influence a system. Modeling and simulation of such external influences is common in order to ensure that the plant and or control system can adequately handle or suppress these disturbances. Disturbance modeling is also integral to the problem of state estimation, indeed, modeling how disturbances affect the evolution of the state of the system is crucial in order to accurately estimate this state.</p><p>This tutorial will show how to model disturbances in ModelingToolkit as <em>disturbance inputs</em>. This involves demonstrating best practices that make it easy to use a single model to handle both disturbed and undisturbed systems, and making use of the model for both simulation and state estimation.</p><h2 id="A-flexible-component-based-workflow"><a class="docs-heading-anchor" href="#A-flexible-component-based-workflow">A flexible component-based workflow</a><a id="A-flexible-component-based-workflow-1"></a><a class="docs-heading-anchor-permalink" href="#A-flexible-component-based-workflow" title="Permalink"></a></h2><p>We will consider a simple system consisting of two inertias connected through a flexible shaft, such as a simple transmission system in a car. We start by modeling the plant <em>without any input signals</em>:</p><pre><code class="language-julia hljs">using ModelingToolkit, OrdinaryDiffEq, LinearAlgebra, Test
using ModelingToolkitStandardLibrary.Mechanical.Rotational
using ModelingToolkitStandardLibrary.Blocks
t = ModelingToolkit.t_nounits
D = ModelingToolkit.D_nounits

# Define the SystemModel component
function SystemModel(; name, m1 = 1, m2 = 1, k = 10, c = 3)
    @parameters begin
        m1 = m1
        m2 = m2
        k = k # Spring stiffness
        c = c # Damping coefficient
    end
    systems = @named begin
        inertia1 = Inertia(; J = m1, phi = 0, w = 0)
        inertia2 = Inertia(; J = m2, phi = 0, w = 0)
        spring = Spring(; c = k)
        damper = Damper(; d = c)
        torque = Torque(use_support = false)
    end

    eqs = [
        connect(torque.flange, inertia1.flange_a)
        connect(inertia1.flange_b, spring.flange_a, damper.flange_a)
        connect(inertia2.flange_a, spring.flange_b, damper.flange_b)
    ]

    System(eqs, t, [], [m1, m2, k, c];
        systems,
        name)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">SystemModel (generic function with 1 method)</code></pre><p>Here, we have added a <code>torque</code> component that allows us to add a torque input to drive the system, but we have not connected any signal to it yet. We have not yet made any attempts at modeling disturbances, and this is deliberate, we will handle this later in order to make the plant model as generically useful as possible.</p><p>In order to simulate this system in the presence of disturbances, we must 1. Reason about how disturbances may affect the system, and 2. attach <em>disturbance inputs</em> and <em>disturbance signals</em> to the model. We distinguish between an <em>input</em> and a <em>signal</em> here, where we by <em>input</em> mean an attachment point (connector) to which we may connect a <em>signal</em>, i.e., a time-varying function.</p><p>We create a new model that includes disturbance inputs and signals, and attach those to the already defined plant model. We assume that each of the two inertias can be affected by a disturbance torque, such as due to friction or an unknown load on the output inertia.</p><pre><code class="language-julia hljs"># Define a model with inputs
function ModelWithInputs(; name)
    systems = @named begin
        input_signal = Blocks.Sine(frequency = 1, amplitude = 1)
        disturbance_signal1 = Blocks.Step(height = -1, start_time = 2) # We add an input signal that equals zero by default so that it has no effect during normal simulation
        disturbance_signal2 = Blocks.Step(height = 2, start_time = 4)
        disturbance_torque1 = Torque(use_support = false)
        disturbance_torque2 = Torque(use_support = false)
        system_model = SystemModel()
    end

    eqs = [
        connect(input_signal.output, :u, system_model.torque.tau)
        connect(disturbance_signal1.output, :d1, disturbance_torque1.tau) # When we connect the input _signals_, we do so through an analysis point. This allows us to easily disconnect the input signals in situations when we do not need them.
        connect(disturbance_signal2.output, :d2, disturbance_torque2.tau)
        connect(disturbance_torque1.flange, system_model.inertia1.flange_b)
        connect(disturbance_torque2.flange, system_model.inertia2.flange_b)
    ]

    System(eqs, t;
        systems,
        name)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ModelWithInputs (generic function with 1 method)</code></pre><p>This outer model, <code>ModelWithInputs</code>, contains two disturbance inputs, both of type <code>Torque</code>. It also contains three signal specifications, one for the control input and two for the corresponding disturbance inputs. Note how we added the disturbance torque inputs at this level of the model, but the control input was added inside the system model. This is a design choice that is up to the modeler, here, we consider the driving torque to be a fundamental part of the model that is always required to make use of it, while the disturbance inputs may be of interest only in certain situations, and we thus add them when needed. Since we have added not only input connectors, but also connected input signals to them, this model is complete and ready for simulation, i.e., there are no <em>unbound inputs</em>.</p><pre><code class="language-julia hljs">@named model = ModelWithInputs() # Model with load disturbance
ssys = mtkcompile(model)
prob = ODEProblem(ssys, [], (0.0, 6.0))
sol = solve(prob, Tsit5())
using Plots
plot(sol)</code></pre><img src="53c977f4.svg" alt="Example block output"/><p>A thing to note in the specification of <code>ModelWithInputs</code> is the presence of three <a href="https://docs.sciml.ai/ModelingToolkit/dev/tutorials/linear_analysis/#ModelingToolkit.AnalysisPoint">analysis points</a>, <code>:u</code>, <code>:d1</code>, and <code>:d2</code>. When signals are connected through an analysis point, we may at any time linearize the model as if the signals were not connected, i.e., as if the corresponding inputs were unbound. We may also use this to generate a julia function for the dynamics on the form <span>$f(x,u,p,t,w)$</span> where the input <span>$u$</span> and disturbance <span>$w$</span> may be provided as separate function arguments, as if the corresponding input signals were not present in the model. More details regarding this will be presented further below, here, we just demonstrate how we could linearize this system model from the inputs to the angular velocity of the inertias</p><pre><code class="language-julia hljs">using ControlSystemsBase, ControlSystemsMTK # ControlSystemsMTK provides the high-level function named_ss and ControlSystemsBase provides the bodeplot function
P = named_ss(model, [ssys.u, ssys.d1, ssys.d2],
    [ssys.system_model.inertia1.w, ssys.system_model.inertia2.w])
bodeplot(P, plotphase = false)</code></pre><img src="1117afcc.svg" alt="Example block output"/><p>It&#39;s worth noting at this point that the fact that we could connect disturbance outputs from outside of the plant-model definition was enabled by the fact that we used a component-based workflow, where the plant model had the appropriate connectors available. If the plant model had modeled the system using direct equations without connectors, this would not have been possible and the model would thus be significantly less flexible.</p><p>We summarize the findings so far as a number of best practices:</p><div class="admonition is-success" id="Best-practices-15028e5dc35bdaa3"><header class="admonition-header">Best practices<a class="admonition-anchor" href="#Best-practices-15028e5dc35bdaa3" title="Permalink"></a></header><div class="admonition-body"><ul><li>Use a component-based workflow to model the plant</li><li>If possible, model the plant without explicit disturbance inputs to make it as generic as possible</li><li>When disturbance inputs are needed, create a new model that includes the plant model and the disturbance inputs</li><li>Only add input <em>signals</em> at the top level of the model, this applies to both control inputs and disturbance inputs.</li><li>Use analysis points to connect signals to inputs, this allows for easy disconnection of signals when needed, e.g., for linearization or function generation.</li></ul></div></div><h2 id="Modeling-for-state-estimation"><a class="docs-heading-anchor" href="#Modeling-for-state-estimation">Modeling for state estimation</a><a id="Modeling-for-state-estimation-1"></a><a class="docs-heading-anchor-permalink" href="#Modeling-for-state-estimation" title="Permalink"></a></h2><p>In the example above, we constructed a model for <em>simulation</em> of a disturbance affecting the system. When simulating, we connect an input signal of specified shape that simulates the disturbance, above, we used <code>Blocks.Step</code> as input signals. On the other hand, when performing state estimation, the exact shape of the disturbance is typically not known, we might only have some diffuse knowledge of the disturbance characteristics such as &quot;varies smoothly&quot;, &quot;makes sudden step changes&quot; or &quot;is approximately periodic with 24hr period&quot;. The encoding of such knowledge is commonly reasoned about in the frequency domain, where we specify a disturbance model as a dynamical system with a frequency response similar to the approximate spectrum of the disturbance. <a href="https://juliahub.com/pluto/editor.html?id=ad9ecbf9-bf83-45e7-bbe8-d2e5194f2240">For more details around this, see the in-depth tutorial notebook &quot;How to tune a Kalman filter&quot;</a>. Most algorithms for state estimation, such as a Kalman-filter like estimators, assume that disturbances are independent and identically distributed (i.i.d.). While seemingly restrictive at first glance, when combined with an appropriate disturbance models encoded as dynamical systems, this assumption still allows for a wide range of non i.i.d. disturbances to be modeled.</p><p>When modeling a system in MTK, we essentially (without considering algebraic equations for simplicity in exposition) construct a model of a dynamical system</p><p class="math-container">\[\begin{aligned}
\dot x &amp;= f(x, p, t) \\
y &amp;= g(x, p, t)
\end{aligned}\]</p><p>where <span>$x$</span> is the state, <span>$y$</span> are observed variables, <span>$p$</span> are parameters, and <span>$t$</span> is time. When using MTK, which variables constitute <span>$x$</span> and which are considered part of the output, <span>$y$</span>, is up to the tool rather than the user, this choice is made by MTK during the call to <code>mtkcompile</code>.</p><p>If we further consider external inputs to the system, such as controlled input signals <span>$u$</span> and disturbance inputs <span>$w$</span>, we can write the system as</p><p class="math-container">\[\begin{aligned}
\dot x &amp;= f(x, u, p, t, w) \\
y &amp;= g(x, u, p, t)
\end{aligned}\]</p><p>To make use of the model defined above for state estimation, we may want to generate a Julia function for the dynamics <span>$f$</span> and the output equations <span>$g$</span> that we can plug into, e.g., a nonlinear version of a Kalman filter or a particle filter, etc. MTK contains utilities to do this, namely, <a href="@ref"><code>ModelingToolkit.generate_control_function</code></a> and <a href="@ref"><code>ModelingToolkit.build_explicit_observed_function</code></a> (described in more details in <a href="../../basics/InputOutput/#inputoutput">&quot;Input output&quot;</a>).</p><p>These functions support two types of disturbance inputs:</p><ul><li><p><strong>Unknown disturbances</strong> (<code>disturbance_inputs</code>): Variables that are part of <span>$w$</span> but NOT added as function arguments to <span>$f$</span>. MTK assumes these variables are zero, but any dynamics associated with them (such as disturbance models) are included in the generated function. This allows a state estimator to estimate the state of the disturbance model, provided that this state is <a href="https://en.wikipedia.org/wiki/Observability">observable</a> from measured outputs.</p></li><li><p><strong>Known disturbances</strong> (<code>known_disturbance_inputs</code>): Variables that are part of <span>$w$</span> AND added as function arguments to <span>$f$</span>, resulting in <span>$f(x, u, p, t, w)$</span>. Use this when disturbances can be measured or are otherwise known.</p></li></ul><p>You can mix and match: some disturbances can be unknown while others are known. For example, <code>generate_control_function(sys, inputs; disturbance_inputs=[w1], known_disturbance_inputs=[w2, w3])</code> generates a function <code>f(x, u, p, t, [w2, w3])</code> where <code>w1</code> is set to zero but its dynamics are preserved, while <code>w2</code> and <code>w3</code> must be provided as arguments.</p><p>Below, we demonstrate</p><ol><li>How to add an integrating disturbance model</li><li>how to generate the functions <span>$f$</span> and <span>$g$</span> for a typical nonlinear state estimator with explicit disturbance inputs</li></ol><pre><code class="language-julia hljs"># Define an integrating disturbance model
function IntegratingDisturbance(; name)
    @variables x(t) = 0.0 w(t) = 0.0 [disturbance = true, input = true]
    systems = @named begin
        input = RealInput()
        output = RealOutput()
    end
    eqs = [
        D(x) ~ w
        w ~ input.u
        output.u ~ x
    ]
    System(eqs, t, [x, w], []; systems, name)
end

# Define a system model with disturbance model
function SystemModelWithDisturbanceModel(; name)
    systems = @named begin
        input_signal = Blocks.Sine(frequency = 1, amplitude = 1)
        disturbance_signal1 = Blocks.Constant(k = 0)
        disturbance_signal2 = Blocks.Constant(k = 0)
        disturbance_torque1 = Torque(use_support = false)
        disturbance_torque2 = Torque(use_support = false)
        disturbance_model = Blocks.Integrator()
        system_model = SystemModel()
    end

    eqs = [
        connect(input_signal.output, :u, system_model.torque.tau)
        connect(disturbance_signal1.output, :d1, disturbance_model.input)
        connect(disturbance_model.output, disturbance_torque1.tau)
        connect(disturbance_signal2.output, :d2, disturbance_torque2.tau)
        connect(disturbance_torque1.flange, system_model.inertia1.flange_b)
        connect(disturbance_torque2.flange, system_model.inertia2.flange_b)
    ]

    System(eqs, t;
        systems,
        name)
end

@named model_with_disturbance = SystemModelWithDisturbanceModel()</code></pre><p class="math-container">\[ \begin{equation}
\left[
\begin{array}{c}
AnalysisPoint\left( \mathtt{input\_signal.output.u}\left( t \right), u, \left[
\begin{array}{c}
\mathtt{system\_model.torque.tau.u}\left( t \right) \\
\end{array}
\right] \right) \\
AnalysisPoint\left( \mathtt{disturbance\_signal1.output.u}\left( t \right), d1, \left[
\begin{array}{c}
\mathtt{disturbance\_model.input.u}\left( t \right) \\
\end{array}
\right] \right) \\
\mathrm{connect}\left( disturbance_{model_{+}output}, disturbance_{torque1_{+}tau} \right) \\
AnalysisPoint\left( \mathtt{disturbance\_signal2.output.u}\left( t \right), d2, \left[
\begin{array}{c}
\mathtt{disturbance\_torque2.tau.u}\left( t \right) \\
\end{array}
\right] \right) \\
\mathrm{connect}\left( disturbance_{torque1_{+}flange}, system_{model_{+}inertia1_{+}flange\_b} \right) \\
\mathrm{connect}\left( disturbance_{torque2_{+}flange}, system_{model_{+}inertia2_{+}flange\_b} \right) \\
\mathrm{\mathtt{input}_{signal.output.u}}\left( t \right) = \mathtt{input_{signal.offset}} + \mathrm{ifelse}\left( t &lt; \mathtt{input_{signal.start\_time}}, 0, \mathtt{input_{signal.amplitude}} \cdot \sin\left( \mathtt{input_{signal.phase}} + 6.283185307179586 \cdot \mathtt{input_{signal.frequency}} \cdot \left(  - \mathtt{input_{signal.start\_time}} + t \right) \right) \right) \\
\mathrm{\mathtt{disturbance}_{signal1.output.u}}\left( t \right) = \mathtt{disturbance_{signal1.k}} \\
\mathrm{\mathtt{disturbance}_{signal2.output.u}}\left( t \right) = \mathtt{disturbance_{signal2.k}} \\
\mathrm{\mathtt{disturbance}_{torque1.phi\_support}}\left( t \right) = 0 \\
\mathrm{\mathtt{disturbance}_{torque1.flange.tau}}\left( t \right) =  - \mathrm{\mathtt{disturbance}_{torque1.tau.u}}\left( t \right) \\
\mathrm{\mathtt{disturbance}_{torque2.phi\_support}}\left( t \right) = 0 \\
\mathrm{\mathtt{disturbance}_{torque2.flange.tau}}\left( t \right) =  - \mathrm{\mathtt{disturbance}_{torque2.tau.u}}\left( t \right) \\
\mathrm{\mathtt{disturbance}_{model.u}}\left( t \right) = \mathrm{\mathtt{disturbance}_{model.input.u}}\left( t \right) \\
\mathrm{\mathtt{disturbance}_{model.y}}\left( t \right) = \mathrm{\mathtt{disturbance}_{model.output.u}}\left( t \right) \\
\frac{\mathrm{d} \cdot \mathrm{\mathtt{disturbance}_{model.x}}\left( t \right)}{\mathrm{d}t} = \mathtt{disturbance_{model.k}} \cdot \mathrm{\mathtt{disturbance}_{model.u}}\left( t \right) \\
\mathrm{\mathtt{disturbance}_{model.y}}\left( t \right) = \mathrm{\mathtt{disturbance}_{model.x}}\left( t \right) \\
\mathrm{connect}\left( torque_{+}flange, inertia1_{+}flange_{a} \right) \\
\mathrm{connect}\left( inertia1_{+}flange_{b}, spring_{+}flange_{a}, damper_{+}flange_{a} \right) \\
\mathrm{connect}\left( inertia2_{+}flange_{a}, spring_{+}flange_{b}, damper_{+}flange_{b} \right) \\
\mathrm{\mathtt{system}_{model.inertia1.phi}}\left( t \right) = \mathrm{\mathtt{system}_{model.inertia1.flange\_a.phi}}\left( t \right) \\
\mathrm{\mathtt{system}_{model.inertia1.phi}}\left( t \right) = \mathrm{\mathtt{system}_{model.inertia1.flange\_b.phi}}\left( t \right) \\
\frac{\mathrm{d} \cdot \mathrm{\mathtt{system}_{model.inertia1.phi}}\left( t \right)}{\mathrm{d}t} = \mathrm{\mathtt{system}_{model.inertia1.w}}\left( t \right) \\
\frac{\mathrm{d} \cdot \mathrm{\mathtt{system}_{model.inertia1.w}}\left( t \right)}{\mathrm{d}t} = \mathrm{\mathtt{system}_{model.inertia1.a}}\left( t \right) \\
\mathtt{system_{model.inertia1.J}} \cdot \mathrm{\mathtt{system}_{model.inertia1.a}}\left( t \right) = \mathrm{\mathtt{system}_{model.inertia1.flange\_a.tau}}\left( t \right) + \mathrm{\mathtt{system}_{model.inertia1.flange\_b.tau}}\left( t \right) \\
\mathrm{\mathtt{system}_{model.inertia2.phi}}\left( t \right) = \mathrm{\mathtt{system}_{model.inertia2.flange\_a.phi}}\left( t \right) \\
\mathrm{\mathtt{system}_{model.inertia2.phi}}\left( t \right) = \mathrm{\mathtt{system}_{model.inertia2.flange\_b.phi}}\left( t \right) \\
\frac{\mathrm{d} \cdot \mathrm{\mathtt{system}_{model.inertia2.phi}}\left( t \right)}{\mathrm{d}t} = \mathrm{\mathtt{system}_{model.inertia2.w}}\left( t \right) \\
\frac{\mathrm{d} \cdot \mathrm{\mathtt{system}_{model.inertia2.w}}\left( t \right)}{\mathrm{d}t} = \mathrm{\mathtt{system}_{model.inertia2.a}}\left( t \right) \\
\mathtt{system_{model.inertia2.J}} \cdot \mathrm{\mathtt{system}_{model.inertia2.a}}\left( t \right) = \mathrm{\mathtt{system}_{model.inertia2.flange\_a.tau}}\left( t \right) + \mathrm{\mathtt{system}_{model.inertia2.flange\_b.tau}}\left( t \right) \\
\mathrm{\mathtt{system}_{model.spring.phi\_rel}}\left( t \right) = \mathrm{\mathtt{system}_{model.spring.flange\_b.phi}}\left( t \right) - \mathrm{\mathtt{system}_{model.spring.flange\_a.phi}}\left( t \right) \\
\mathrm{\mathtt{system}_{model.spring.flange\_b.tau}}\left( t \right) = \mathrm{\mathtt{system}_{model.spring.tau}}\left( t \right) \\
\mathrm{\mathtt{system}_{model.spring.flange\_a.tau}}\left( t \right) =  - \mathrm{\mathtt{system}_{model.spring.tau}}\left( t \right) \\
\mathrm{\mathtt{system}_{model.spring.tau}}\left( t \right) = \mathtt{system_{model.spring.c}} \cdot \left(  - \mathtt{system_{model.spring.phi\_rel0}} + \mathrm{\mathtt{system}_{model.spring.phi\_rel}}\left( t \right) \right) \\
\mathrm{\mathtt{system}_{model.damper.phi\_rel}}\left( t \right) =  - \mathrm{\mathtt{system}_{model.damper.flange\_a.phi}}\left( t \right) + \mathrm{\mathtt{system}_{model.damper.flange\_b.phi}}\left( t \right) \\
\frac{\mathrm{d} \cdot \mathrm{\mathtt{system}_{model.damper.phi\_rel}}\left( t \right)}{\mathrm{d}t} = \mathrm{\mathtt{system}_{model.damper.w\_rel}}\left( t \right) \\
\frac{\mathrm{d} \cdot \mathrm{\mathtt{system}_{model.damper.w\_rel}}\left( t \right)}{\mathrm{d}t} = \mathrm{\mathtt{system}_{model.damper.a\_rel}}\left( t \right) \\
\mathrm{\mathtt{system}_{model.damper.flange\_b.tau}}\left( t \right) = \mathrm{\mathtt{system}_{model.damper.tau}}\left( t \right) \\
\mathrm{\mathtt{system}_{model.damper.flange\_a.tau}}\left( t \right) =  - \mathrm{\mathtt{system}_{model.damper.tau}}\left( t \right) \\
\mathrm{\mathtt{system}_{model.damper.tau}}\left( t \right) = \mathtt{system_{model.damper.d}} \cdot \mathrm{\mathtt{system}_{model.damper.w\_rel}}\left( t \right) \\
\mathrm{\mathtt{system}_{model.torque.phi\_support}}\left( t \right) = 0 \\
\mathrm{\mathtt{system}_{model.torque.flange.tau}}\left( t \right) =  - \mathrm{\mathtt{system}_{model.torque.tau.u}}\left( t \right) \\
\end{array}
\right]
\end{equation}
 \]</p><p>We demonstrate that this model is complete and can be simulated:</p><pre><code class="language-julia hljs">ssys = mtkcompile(model_with_disturbance)
prob = ODEProblem(ssys, [], (0.0, 10.0))
sol = solve(prob, Tsit5())
using Test
@test SciMLBase.successful_retcode(sol)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr32"><span class="sgr1">Test Passed</span></span></code></pre><p>but we may also generate the functions <span>$f$</span> and <span>$g$</span> for state estimation:</p><div class="admonition is-warning" id="Example-currently-disabled-44eb41b40a941bb1"><header class="admonition-header">Example currently disabled<a class="admonition-anchor" href="#Example-currently-disabled-44eb41b40a941bb1" title="Permalink"></a></header><div class="admonition-body"><p>This example is currently disabled due to compatibility issues with <code>generate_control_function</code> and analysis points in the current ModelingToolkit stack.</p></div></div><pre><code class="language-julia hljs">inputs = [ssys.u]
disturbance_inputs = [ssys.d1, ssys.d2]
P = ssys.system_model
outputs = [P.inertia1.phi, P.inertia2.phi, P.inertia1.w, P.inertia2.w]

(f_oop, f_ip), x_sym,
p_sym,
io_sys = ModelingToolkit.generate_control_function(
    model_with_disturbance, inputs; known_disturbance_inputs = disturbance_inputs)

g = ModelingToolkit.build_explicit_observed_function(
    io_sys, outputs; inputs)

op = ModelingToolkit.inputs(io_sys) .=&gt; 0
x0 = ModelingToolkit.get_u0(io_sys, op)
p = MTKParameters(io_sys, op)
u = zeros(1) # Control input
w = zeros(length(disturbance_inputs)) # Disturbance input (known disturbances are provided as arguments)
@test f_oop(x0, u, p, t, w) == zeros(5)
@test g(x0, u, p, 0.0) == [0, 0, 0, 0]

# Non-zero disturbance inputs should result in non-zero state derivatives. We call `sort` since we do not generally know the order of the state variables
w = [1.0, 2.0]
@test sort(f_oop(x0, u, p, t, w)) == [0, 0, 0, 1, 2]</code></pre><h2 id="Input-signal-library"><a class="docs-heading-anchor" href="#Input-signal-library">Input signal library</a><a id="Input-signal-library-1"></a><a class="docs-heading-anchor-permalink" href="#Input-signal-library" title="Permalink"></a></h2><p>The <a href="https://docs.sciml.ai/ModelingToolkitStandardLibrary/stable/API/blocks/"><code>Blocks</code> module in ModelingToolkitStandardLibrary</a> contains several predefined input signals, such as <code>Sine, Step, Ramp, Constant</code> etc., a few of which were used in the examples above. If you have an input signal represented as a sequence of samples, you may use an <a href="https://docs.sciml.ai/ModelingToolkitStandardLibrary/stable/tutorials/input_component/"><code>Interpolation</code> block</a>, e.g., as <code>src = Interpolation(ConstantInterpolation, data, timepoints)</code>, see the docstring for a complete example.</p><h2 id="Disturbance-model-library"><a class="docs-heading-anchor" href="#Disturbance-model-library">Disturbance-model library</a><a id="Disturbance-model-library-1"></a><a class="docs-heading-anchor-permalink" href="#Disturbance-model-library" title="Permalink"></a></h2><p>There is no library explicitly constructed for disturbance modeling. Standard blocks from the <a href="https://docs.sciml.ai/ModelingToolkitStandardLibrary/stable/API/blocks/"><code>Blocks</code> module in ModelingToolkitStandardLibrary</a>, such as <code>Integrator, TransferFunction, StateSpace</code>, can model any disturbance with rational spectrum. Examples of this includes disturbance models such as constants, piecewise constant, periodic, highpass, lowpass, and bandpass. For help with filter design, see <a href="https://juliacontrol.github.io/ControlSystems.jl/stable/man/creating_systems/#Filter-design">ControlSystems.jl: Filter-design</a> and the interface package <a href="https://juliacontrol.github.io/ControlSystemsMTK.jl/dev/">ControlSystemsMTK.jl</a>. In the example above, we made use of <code>Blocks.Integrator</code>, which is a disturbance model suitable for disturbances dominated by low-frequency components, such as piecewise constant signals or slowly drifting signals.</p><h2 id="Further-reading"><a class="docs-heading-anchor" href="#Further-reading">Further reading</a><a id="Further-reading-1"></a><a class="docs-heading-anchor-permalink" href="#Further-reading" title="Permalink"></a></h2><p>To see full examples that perform state estimation with ModelingToolkit models, see the following resources:</p><ul><li><a href="https://arxiv.org/abs/2502.01128">C codegen considered unnecessary: go directly to binary, do not pass C. Compilation of Julia code for deployment in model-based engineering</a></li><li><a href="https://github.com/baggepinnen/LowLevelParticleFiltersMTK.jl">LowLevelParticleFiltersMTK.jl</a></li></ul><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul></ul><article><details class="docstring" open="true"><summary id="ModelingToolkit.get_comp_sensitivity-tutorials-disturbance_modeling"><a class="docstring-binding" href="#ModelingToolkit.get_comp_sensitivity-tutorials-disturbance_modeling"><code>ModelingToolkit.get_comp_sensitivity</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">get_comp_sensitivity(sys, ap::AnalysisPoint; kwargs)
get_comp_sensitivity(sys, ap_name::Symbol; kwargs)</code></pre><p>Compute the complementary sensitivity function in analysis point <code>ap</code>. The complementary sensitivity function is obtained by introducing an infinitesimal perturbation <code>d</code> at the output of <code>ap</code>, linearizing the system and computing the transfer function between <code>d</code> and the input of <code>ap</code>.</p><p><strong>Arguments:</strong></p><ul><li><code>kwargs</code>: Are sent to <code>ModelingToolkit.linearize</code></li></ul><p>See also <a href="../../API/System/#ModelingToolkit.get_sensitivity"><code>get_sensitivity</code></a>, <a href="../../API/System/#ModelingToolkit.get_looptransfer"><code>get_looptransfer</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/c94a61cfc01a7d9e82e2bbcdde302d7698b04511/src/systems/analysis_points.jl#L207-L218">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ModelingToolkit.get_comp_sensitivity_function-Tuple{ModelingToolkitBase.AbstractSystem, Any}-tutorials-disturbance_modeling"><a class="docstring-binding" href="#ModelingToolkit.get_comp_sensitivity_function-Tuple{ModelingToolkitBase.AbstractSystem, Any}-tutorials-disturbance_modeling"><code>ModelingToolkit.get_comp_sensitivity_function</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_comp_sensitivity_function(
    sys::ModelingToolkitBase.AbstractSystem,
    aps;
    kwargs...
) -&gt; Tuple{ModelingToolkit.LinearizationFunction{DI, AI, _A, P, _B, _C, J1, J2, J3, J4, IA, @NamedTuple{abstol::Float64, reltol::Float64, nlsolve_alg::Nothing}} where {DI&lt;:AbstractVector{Int64}, AI&lt;:AbstractVector{Int64}, _A, P&lt;:ODEProblem, _B, _C, J1&lt;:Union{Nothing, ModelingToolkit.PreparedJacobian{true, DifferentiationInterfaceForwardDiffExt.ForwardDiffTwoArgJacobianPrep{Nothing, C, Tuple{Nothing, Nothing}}, ModelingToolkit.var&quot;#uff#12&quot;{var&quot;#64#fun&quot;}, _A, ADTypes.AutoForwardDiff{nothing, Nothing}} where {C&lt;:(ForwardDiff.JacobianConfig{T, _A, _B, &lt;:Tuple{Any, Any}} where {T&lt;:(ForwardDiff.Tag{F} where F&lt;:ModelingToolkit.var&quot;#uff#12&quot;), _A, _B}), var&quot;#64#fun&quot;, _A}}, J2&lt;:Union{Nothing, ModelingToolkit.PreparedJacobian{true, DifferentiationInterfaceForwardDiffExt.ForwardDiffTwoArgJacobianPrep{Nothing, C, Tuple{Nothing, Nothing}}, _A, _B, ADTypes.AutoForwardDiff{nothing, Nothing}} where {C&lt;:ForwardDiff.JacobianConfig, _A, _B}}, J3&lt;:Union{Nothing, ModelingToolkit.PreparedJacobian{true, DifferentiationInterfaceForwardDiffExt.ForwardDiffTwoArgJacobianPrep{Nothing, C, Tuple{Nothing, Nothing, Nothing}}, ModelingToolkit.var&quot;#pff#13&quot;{var&quot;#65#fun&quot;, var&quot;#66#setter&quot;}, _A, ADTypes.AutoForwardDiff{nothing, Nothing}} where {C&lt;:(ForwardDiff.JacobianConfig{T, _A, _B, &lt;:Tuple{Any, Any}} where {T&lt;:(ForwardDiff.Tag{F} where F&lt;:ModelingToolkit.var&quot;#pff#13&quot;), _A, _B}), var&quot;#65#fun&quot;, var&quot;#66#setter&quot;, _A}}, J4&lt;:(ModelingToolkit.PreparedJacobian{true, DifferentiationInterfaceForwardDiffExt.ForwardDiffTwoArgJacobianPrep{Nothing, C, Tuple{Nothing, Nothing, Nothing}}, ModelingToolkit.var&quot;#hpf#11&quot;{fun, setter}, _A, ADTypes.AutoForwardDiff{nothing, Nothing}} where {C&lt;:(ForwardDiff.JacobianConfig{T, _A, _B, &lt;:Tuple{Any, Any}} where {T&lt;:(ForwardDiff.Tag{F} where F&lt;:ModelingToolkit.var&quot;#hpf#11&quot;), _A, _B}), fun, setter, _A}), IA&lt;:Union{SciMLBase.NoInit, SciMLBase.OverrideInit{Nothing, Nothing, Nothing}}}, Any}
</code></pre><p>Return the complementary sensitivity function for the analysis point(s) <code>aps</code>, and the modified system simplified with the appropriate inputs and outputs.</p><p><strong>Keyword Arguments</strong></p><ul><li><p><code>loop_openings</code>: A list of analysis points whose connections should be removed and the outputs set to the input as a part of the linear analysis.</p></li><li><p><code>system_modifier</code>: A function taking the transformed system and applying any additional transformations, returning the modified system. The modified system is passed to <code>linearization_function</code>. </p></li></ul><p>All other keyword arguments are forwarded to <code>linearization_function</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/c94a61cfc01a7d9e82e2bbcdde302d7698b04511/src/systems/analysis_points.jl#L89-L101">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ModelingToolkit.get_looptransfer-tutorials-disturbance_modeling"><a class="docstring-binding" href="#ModelingToolkit.get_looptransfer-tutorials-disturbance_modeling"><code>ModelingToolkit.get_looptransfer</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">get_looptransfer(sys, ap::AnalysisPoint; kwargs)
get_looptransfer(sys, ap_name::Symbol; kwargs)</code></pre><p>Compute the (linearized) loop-transfer function in analysis point <code>ap</code>, from <code>ap.out</code> to <code>ap.in</code>.</p><div class="admonition is-info" id="Negative-feedback-a2934effc06e9aab"><header class="admonition-header">Negative feedback<a class="admonition-anchor" href="#Negative-feedback-a2934effc06e9aab" title="Permalink"></a></header><div class="admonition-body"><p>Feedback loops often use negative feedback, and the computed loop-transfer function will in this case have the negative feedback included. Standard analysis tools often assume a loop-transfer function without the negative gain built in, and the result of this function may thus need negation before use.</p></div></div><p><strong>Arguments:</strong></p><ul><li><code>kwargs</code>: Are sent to <code>ModelingToolkit.linearize</code></li></ul><p>See also <a href="../../API/System/#ModelingToolkit.get_sensitivity"><code>get_sensitivity</code></a>, <a href="../../API/System/#ModelingToolkit.get_comp_sensitivity"><code>get_comp_sensitivity</code></a>, <a href="@ref"><code>open_loop</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/c94a61cfc01a7d9e82e2bbcdde302d7698b04511/src/systems/analysis_points.jl#L220-L235">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ModelingToolkit.get_looptransfer_function-Tuple{ModelingToolkitBase.AbstractSystem, Any}-tutorials-disturbance_modeling"><a class="docstring-binding" href="#ModelingToolkit.get_looptransfer_function-Tuple{ModelingToolkitBase.AbstractSystem, Any}-tutorials-disturbance_modeling"><code>ModelingToolkit.get_looptransfer_function</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_looptransfer_function(
    sys::ModelingToolkitBase.AbstractSystem,
    aps;
    kwargs...
) -&gt; Tuple{ModelingToolkit.LinearizationFunction{DI, AI, _A, P, _B, _C, J1, J2, J3, J4, IA, @NamedTuple{abstol::Float64, reltol::Float64, nlsolve_alg::Nothing}} where {DI&lt;:AbstractVector{Int64}, AI&lt;:AbstractVector{Int64}, _A, P&lt;:ODEProblem, _B, _C, J1&lt;:Union{Nothing, ModelingToolkit.PreparedJacobian{true, DifferentiationInterfaceForwardDiffExt.ForwardDiffTwoArgJacobianPrep{Nothing, C, Tuple{Nothing, Nothing}}, ModelingToolkit.var&quot;#uff#12&quot;{var&quot;#64#fun&quot;}, _A, ADTypes.AutoForwardDiff{nothing, Nothing}} where {C&lt;:(ForwardDiff.JacobianConfig{T, _A, _B, &lt;:Tuple{Any, Any}} where {T&lt;:(ForwardDiff.Tag{F} where F&lt;:ModelingToolkit.var&quot;#uff#12&quot;), _A, _B}), var&quot;#64#fun&quot;, _A}}, J2&lt;:Union{Nothing, ModelingToolkit.PreparedJacobian{true, DifferentiationInterfaceForwardDiffExt.ForwardDiffTwoArgJacobianPrep{Nothing, C, Tuple{Nothing, Nothing}}, _A, _B, ADTypes.AutoForwardDiff{nothing, Nothing}} where {C&lt;:ForwardDiff.JacobianConfig, _A, _B}}, J3&lt;:Union{Nothing, ModelingToolkit.PreparedJacobian{true, DifferentiationInterfaceForwardDiffExt.ForwardDiffTwoArgJacobianPrep{Nothing, C, Tuple{Nothing, Nothing, Nothing}}, ModelingToolkit.var&quot;#pff#13&quot;{var&quot;#65#fun&quot;, var&quot;#66#setter&quot;}, _A, ADTypes.AutoForwardDiff{nothing, Nothing}} where {C&lt;:(ForwardDiff.JacobianConfig{T, _A, _B, &lt;:Tuple{Any, Any}} where {T&lt;:(ForwardDiff.Tag{F} where F&lt;:ModelingToolkit.var&quot;#pff#13&quot;), _A, _B}), var&quot;#65#fun&quot;, var&quot;#66#setter&quot;, _A}}, J4&lt;:(ModelingToolkit.PreparedJacobian{true, DifferentiationInterfaceForwardDiffExt.ForwardDiffTwoArgJacobianPrep{Nothing, C, Tuple{Nothing, Nothing, Nothing}}, ModelingToolkit.var&quot;#hpf#11&quot;{fun, setter}, _A, ADTypes.AutoForwardDiff{nothing, Nothing}} where {C&lt;:(ForwardDiff.JacobianConfig{T, _A, _B, &lt;:Tuple{Any, Any}} where {T&lt;:(ForwardDiff.Tag{F} where F&lt;:ModelingToolkit.var&quot;#hpf#11&quot;), _A, _B}), fun, setter, _A}), IA&lt;:Union{SciMLBase.NoInit, SciMLBase.OverrideInit{Nothing, Nothing, Nothing}}}, Any}
</code></pre><p>Return the loop-transfer function for the analysis point(s) <code>aps</code>, and the modified system simplified with the appropriate inputs and outputs.</p><p><strong>Keyword Arguments</strong></p><ul><li><p><code>loop_openings</code>: A list of analysis points whose connections should be removed and the outputs set to the input as a part of the linear analysis.</p></li><li><p><code>system_modifier</code>: A function taking the transformed system and applying any additional transformations, returning the modified system. The modified system is passed to <code>linearization_function</code>. </p></li></ul><p>All other keyword arguments are forwarded to <code>linearization_function</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/c94a61cfc01a7d9e82e2bbcdde302d7698b04511/src/systems/analysis_points.jl#L106-L118">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ModelingToolkit.get_sensitivity-tutorials-disturbance_modeling"><a class="docstring-binding" href="#ModelingToolkit.get_sensitivity-tutorials-disturbance_modeling"><code>ModelingToolkit.get_sensitivity</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">get_sensitivity(sys, ap::AnalysisPoint; kwargs)
get_sensitivity(sys, ap_name::Symbol; kwargs)</code></pre><p>Compute the sensitivity function in analysis point <code>ap</code>. The sensitivity function is obtained by introducing an infinitesimal perturbation <code>d</code> at the input of <code>ap</code>, linearizing the system and computing the transfer function between <code>d</code> and the output of <code>ap</code>.</p><p><strong>Arguments:</strong></p><ul><li><code>kwargs</code>: Are sent to <code>ModelingToolkit.linearize</code></li></ul><p>See also <a href="../../API/System/#ModelingToolkit.get_comp_sensitivity"><code>get_comp_sensitivity</code></a>, <a href="../../API/System/#ModelingToolkit.get_looptransfer"><code>get_looptransfer</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/c94a61cfc01a7d9e82e2bbcdde302d7698b04511/src/systems/analysis_points.jl#L194-L205">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ModelingToolkit.get_sensitivity_function-Tuple{ModelingToolkitBase.AbstractSystem, Any}-tutorials-disturbance_modeling"><a class="docstring-binding" href="#ModelingToolkit.get_sensitivity_function-Tuple{ModelingToolkitBase.AbstractSystem, Any}-tutorials-disturbance_modeling"><code>ModelingToolkit.get_sensitivity_function</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_sensitivity_function(
    sys::ModelingToolkitBase.AbstractSystem,
    aps;
    kwargs...
) -&gt; Tuple{ModelingToolkit.LinearizationFunction{DI, AI, _A, P, _B, _C, J1, J2, J3, J4, IA, @NamedTuple{abstol::Float64, reltol::Float64, nlsolve_alg::Nothing}} where {DI&lt;:AbstractVector{Int64}, AI&lt;:AbstractVector{Int64}, _A, P&lt;:ODEProblem, _B, _C, J1&lt;:Union{Nothing, ModelingToolkit.PreparedJacobian{true, DifferentiationInterfaceForwardDiffExt.ForwardDiffTwoArgJacobianPrep{Nothing, C, Tuple{Nothing, Nothing}}, ModelingToolkit.var&quot;#uff#12&quot;{var&quot;#64#fun&quot;}, _A, ADTypes.AutoForwardDiff{nothing, Nothing}} where {C&lt;:(ForwardDiff.JacobianConfig{T, _A, _B, &lt;:Tuple{Any, Any}} where {T&lt;:(ForwardDiff.Tag{F} where F&lt;:ModelingToolkit.var&quot;#uff#12&quot;), _A, _B}), var&quot;#64#fun&quot;, _A}}, J2&lt;:Union{Nothing, ModelingToolkit.PreparedJacobian{true, DifferentiationInterfaceForwardDiffExt.ForwardDiffTwoArgJacobianPrep{Nothing, C, Tuple{Nothing, Nothing}}, _A, _B, ADTypes.AutoForwardDiff{nothing, Nothing}} where {C&lt;:ForwardDiff.JacobianConfig, _A, _B}}, J3&lt;:Union{Nothing, ModelingToolkit.PreparedJacobian{true, DifferentiationInterfaceForwardDiffExt.ForwardDiffTwoArgJacobianPrep{Nothing, C, Tuple{Nothing, Nothing, Nothing}}, ModelingToolkit.var&quot;#pff#13&quot;{var&quot;#65#fun&quot;, var&quot;#66#setter&quot;}, _A, ADTypes.AutoForwardDiff{nothing, Nothing}} where {C&lt;:(ForwardDiff.JacobianConfig{T, _A, _B, &lt;:Tuple{Any, Any}} where {T&lt;:(ForwardDiff.Tag{F} where F&lt;:ModelingToolkit.var&quot;#pff#13&quot;), _A, _B}), var&quot;#65#fun&quot;, var&quot;#66#setter&quot;, _A}}, J4&lt;:(ModelingToolkit.PreparedJacobian{true, DifferentiationInterfaceForwardDiffExt.ForwardDiffTwoArgJacobianPrep{Nothing, C, Tuple{Nothing, Nothing, Nothing}}, ModelingToolkit.var&quot;#hpf#11&quot;{fun, setter}, _A, ADTypes.AutoForwardDiff{nothing, Nothing}} where {C&lt;:(ForwardDiff.JacobianConfig{T, _A, _B, &lt;:Tuple{Any, Any}} where {T&lt;:(ForwardDiff.Tag{F} where F&lt;:ModelingToolkit.var&quot;#hpf#11&quot;), _A, _B}), fun, setter, _A}), IA&lt;:Union{SciMLBase.NoInit, SciMLBase.OverrideInit{Nothing, Nothing, Nothing}}}, Any}
</code></pre><p>Return the sensitivity function for the analysis point(s) <code>aps</code>, and the modified system simplified with the appropriate inputs and outputs.</p><p><strong>Keyword Arguments</strong></p><ul><li><p><code>loop_openings</code>: A list of analysis points whose connections should be removed and the outputs set to the input as a part of the linear analysis.</p></li><li><p><code>system_modifier</code>: A function taking the transformed system and applying any additional transformations, returning the modified system. The modified system is passed to <code>linearization_function</code>. </p></li></ul><p>All other keyword arguments are forwarded to <code>linearization_function</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/c94a61cfc01a7d9e82e2bbcdde302d7698b04511/src/systems/analysis_points.jl#L72-L84">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ModelingToolkit.linearization_ap_transform-Tuple{Any, Union{Vector{Symbol}, Vector{AnalysisPoint}, Symbol, AnalysisPoint}, Any, Any}-tutorials-disturbance_modeling"><a class="docstring-binding" href="#ModelingToolkit.linearization_ap_transform-Tuple{Any, Union{Vector{Symbol}, Vector{AnalysisPoint}, Symbol, AnalysisPoint}, Any, Any}-tutorials-disturbance_modeling"><code>ModelingToolkit.linearization_ap_transform</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">sys, input_vars, output_vars =</code></pre><pre><code class="language-julia hljs">linearization_ap_transform(
    sys,
    inputs::Union{Vector{Symbol}, Vector{AnalysisPoint}, Symbol, AnalysisPoint},
    outputs,
    loop_openings
) -&gt; Tuple{Any, Vector{SymbolicUtils.BasicSymbolicImpl.var&quot;typeof(BasicSymbolicImpl)&quot;{SymReal}}, Vector{SymbolicUtils.BasicSymbolicImpl.var&quot;typeof(BasicSymbolicImpl)&quot;{SymReal}}}
</code></pre><p>Apply analysis-point transformations to prepare a system for linearization.</p><p>Returns</p><ul><li><code>sys</code>: The transformed system.</li><li><code>input_vars</code>: A vector of input variables corresponding to the input analysis points.</li><li><code>output_vars</code>: A vector of output variables corresponding to the output analysis points.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/ModelingToolkit.jl/blob/c94a61cfc01a7d9e82e2bbcdde302d7698b04511/src/systems/analysis_points.jl#L138-L147">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../linear_analysis/">« Linear Analysis</a><a class="docs-footer-nextpage" href="../fmi/">Importing FMUs »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Monday 9 February 2026 10:00">Monday 9 February 2026</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
